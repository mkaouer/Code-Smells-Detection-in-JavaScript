<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">

<title>C:/release/quickfix/src/C++/FieldConvertors.h Source File</title>

<link href="quickfix.css" rel="stylesheet" type="text/css">

<table cellspacing="0" cellpadding="0" border="0">

  <tr>

   <td><img src="images/outsideTopLeft.gif"></td>

   <td width="100%" class="outsideTop">&nbsp;</td>

   <td><img src="images/outsideTopRight.gif"></td>

  </tr>

  <tr>

   <td class="outsideLeft">&nbsp;</td>

   <td>

	<img src="images/QuickFIX.jpg" align="middle" border=0>

	&nbsp;&nbsp;

	<a href="index.html">Index</a>&nbsp;

	<a href="files.html">Source Files</a>&nbsp;

	<a href="annotated.html">Annotated Class List</a>&nbsp;

	<a href="classes.html">Alphabetical Class List</a>&nbsp;

	<a href="hierarchy.html">Class Hierarchy</a>&nbsp;

	<a href="inherits.html">Graphical Class Hierarchy</a>&nbsp;

   </td>

   <td class="outsideRight">&nbsp;</td>

  </tr>

  <tr>

   <td><img src="images/outsideBottomLeft.gif"></td>

   <td width=100% class="outsideBottom">&nbsp;</td>

   <td><img src="images/outsideBottomRight.gif"></td>

  </tr>

</table>

</head><body bgcolor="#ffffff">

<!-- Generated by Doxygen 1.2.17 -->
<h1>C:/release/quickfix/src/C++/FieldConvertors.h</h1><a href="_field_convertors_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/* -*- C++ -*- */</span>
00002 <span class="comment">/* ====================================================================</span>
00003 <span class="comment"> * The QuickFIX Software License, Version 1.0</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * Copyright (c) 2001 ThoughtWorks, Inc.  All rights</span>
00006 <span class="comment"> * reserved.</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
00009 <span class="comment"> * modification, are permitted provided that the following conditions</span>
00010 <span class="comment"> * are met:</span>
00011 <span class="comment"> *</span>
00012 <span class="comment"> * 1. Redistributions of source code must retain the above copyright</span>
00013 <span class="comment"> *    notice, this list of conditions and the following disclaimer.</span>
00014 <span class="comment"> *</span>
00015 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright</span>
00016 <span class="comment"> *    notice, this list of conditions and the following disclaimer in</span>
00017 <span class="comment"> *    the documentation and/or other materials provided with the</span>
00018 <span class="comment"> *    distribution.</span>
00019 <span class="comment"> *</span>
00020 <span class="comment"> * 3. The end-user documentation included with the redistribution,</span>
00021 <span class="comment"> *    if any, must include the following acknowledgment:</span>
00022 <span class="comment"> *       "This product includes software developed by</span>
00023 <span class="comment"> *        ThoughtWorks, Inc. (http://www.thoughtworks.com/)."</span>
00024 <span class="comment"> *    Alternately, this acknowledgment may appear in the software itself,</span>
00025 <span class="comment"> *    if and wherever such third-party acknowledgments normally appear.</span>
00026 <span class="comment"> *</span>
00027 <span class="comment"> * 4. The names "QuickFIX" and "ThoughtWorks, Inc." must</span>
00028 <span class="comment"> *    not be used to endorse or promote products derived from this</span>
00029 <span class="comment"> *    software without prior written permission. For written</span>
00030 <span class="comment"> *    permission, please contact quickfix-users@lists.sourceforge.net.</span>
00031 <span class="comment"> *</span>
00032 <span class="comment"> * 5. Products derived from this software may not be called "QuickFIX",</span>
00033 <span class="comment"> *    nor may "QuickFIX" appear in their name, without prior written</span>
00034 <span class="comment"> *    permission of ThoughtWorks, Inc.</span>
00035 <span class="comment"> *</span>
00036 <span class="comment"> * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED</span>
00037 <span class="comment"> * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</span>
00038 <span class="comment"> * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
00039 <span class="comment"> * DISCLAIMED.  IN NO EVENT SHALL THOUGHTWORKS INC OR</span>
00040 <span class="comment"> * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
00041 <span class="comment"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
00042 <span class="comment"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF</span>
00043 <span class="comment"> * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND</span>
00044 <span class="comment"> * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span>
00045 <span class="comment"> * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT</span>
00046 <span class="comment"> * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</span>
00047 <span class="comment"> * SUCH DAMAGE.</span>
00048 <span class="comment"> * ====================================================================</span>
00049 <span class="comment"> */</span>
00050 
00051 <span class="preprocessor">#ifndef FIX_FIELDCONVERTORS_H</span>
00052 <span class="preprocessor"></span><span class="preprocessor">#define FIX_FIELDCONVERTORS_H</span>
00053 <span class="preprocessor"></span>
00054 <span class="preprocessor">#include "<a class="code" href="_field_types_8h.html">FieldTypes.h</a>"</span>
00055 <span class="preprocessor">#include "<a class="code" href="_exceptions_8h.html">Exceptions.h</a>"</span>
00056 <span class="preprocessor">#include &lt;string&gt;</span>
00057 <span class="preprocessor">#include &lt;sstream&gt;</span>
00058 <span class="preprocessor">#include &lt;iomanip&gt;</span>
00059 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00060 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00061 
00062 <span class="keyword">namespace </span>FIX
00063 {
<a name="l00065"></a><a class="code" href="struct_f_i_x_1_1_empty_convertor.html">00065</a> <span class="keyword">struct </span><a class="code" href="struct_f_i_x_1_1_empty_convertor.html">EmptyConvertor</a>
00066 {
<a name="l00067"></a><a class="code" href="struct_f_i_x_1_1_empty_convertor.html#d0">00067</a>   <span class="keyword">static</span> <span class="keyword">const</span> std::string&amp; <a class="code" href="struct_f_i_x_1_1_empty_convertor.html#d0">convert</a>( <span class="keyword">const</span> std::string&amp; value )
00068   { <span class="keywordflow">return</span> value; }
00069 };
00070 
<a name="l00071"></a><a class="code" href="namespace_f_i_x.html#a13">00071</a> <span class="keyword">typedef</span> <a class="code" href="struct_f_i_x_1_1_empty_convertor.html">EmptyConvertor</a> <a class="code" href="struct_f_i_x_1_1_empty_convertor.html">StringConvertor</a>;
00072 
<a name="l00074"></a><a class="code" href="struct_f_i_x_1_1_int_convertor.html">00074</a> <span class="keyword">struct </span><a class="code" href="struct_f_i_x_1_1_int_convertor.html">IntConvertor</a>
00075 {
<a name="l00076"></a><a class="code" href="struct_f_i_x_1_1_int_convertor.html#d0">00076</a>   <span class="keyword">static</span> std::string <a class="code" href="struct_f_i_x_1_1_int_convertor.html#d0">convert</a>( <span class="keywordtype">long</span> value )
00077   {
00078     <span class="keywordtype">char</span> temp[ 12 ];
00079     memset( temp, 0, 12 * <span class="keyword">sizeof</span>( <span class="keywordtype">char</span> ) );
00080     sprintf( temp, <span class="stringliteral">"%d"</span>, ( <span class="keywordtype">int</span> ) value );
00081     <span class="keywordflow">return</span> temp;
00082   }
00083 
<a name="l00084"></a><a class="code" href="struct_f_i_x_1_1_int_convertor.html#d1">00084</a>   <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="struct_f_i_x_1_1_int_convertor.html#d0">convert</a>( <span class="keyword">const</span> std::string&amp; value, <span class="keywordtype">long</span>&amp; result )
00085   {
00086     <span class="keyword">const</span> <span class="keywordtype">char</span> * str = value.c_str();
00087     <span class="keywordflow">if</span> ( *str == <span class="charliteral">'-'</span> ) ++str;
00088     <span class="keywordflow">for</span> ( <span class="keyword">const</span> <span class="keywordtype">char</span> * p = str; *p != 0; ++p )
00089     {
00090       <span class="keywordflow">if</span> ( !isdigit( *p ) ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00091     }
00092     result = atol( value.c_str() );
00093     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00094   }
00095 
<a name="l00096"></a><a class="code" href="struct_f_i_x_1_1_int_convertor.html#d2">00096</a>   <span class="keyword">static</span> <span class="keywordtype">long</span> <a class="code" href="struct_f_i_x_1_1_int_convertor.html#d0">convert</a>( <span class="keyword">const</span> std::string&amp; value )
00097   <span class="keywordflow">throw</span>( <a class="code" href="struct_f_i_x_1_1_field_convert_error.html">FieldConvertError</a>&amp; )
00098   {
00099     <span class="keywordtype">long</span> result = 0;
00100     <span class="keywordflow">if</span> ( !<a class="code" href="struct_f_i_x_1_1_int_convertor.html#d0">convert</a>( value, result ) )
00101       <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_field_convert_error.html">FieldConvertError</a>();
00102     <span class="keywordflow">else</span>
00103       <span class="keywordflow">return</span> result;
00104   }
00105 };
00106 
<a name="l00107"></a><a class="code" href="struct_f_i_x_1_1_check_sum_convertor.html">00107</a> <span class="keyword">struct </span><a class="code" href="struct_f_i_x_1_1_check_sum_convertor.html">CheckSumConvertor</a>
00108 {
<a name="l00109"></a><a class="code" href="struct_f_i_x_1_1_check_sum_convertor.html#d0">00109</a>   <span class="keyword">static</span> std::string <a class="code" href="struct_f_i_x_1_1_check_sum_convertor.html#d0">convert</a>( <span class="keywordtype">long</span> value )
00110   <span class="keywordflow">throw</span>( <a class="code" href="struct_f_i_x_1_1_field_convert_error.html">FieldConvertError</a>&amp; )
00111   {
00112     <span class="keywordflow">if</span> ( value &gt; 255 || value &lt; 0 ) <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_field_convert_error.html">FieldConvertError</a>();
00113     std::stringstream stream;
00114     stream &lt;&lt; std::setw( 3 ) &lt;&lt; std::setfill( <span class="charliteral">'0'</span> ) &lt;&lt; value;
00115     <span class="keywordflow">return</span> stream.str();
00116   }
00117 
<a name="l00118"></a><a class="code" href="struct_f_i_x_1_1_check_sum_convertor.html#d1">00118</a>   <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="struct_f_i_x_1_1_check_sum_convertor.html#d0">convert</a>( <span class="keyword">const</span> std::string&amp; value, <span class="keywordtype">long</span>&amp; result )
00119   {
00120     <span class="keywordflow">return</span> IntConvertor::convert( value, result );
00121   }
00122 
<a name="l00123"></a><a class="code" href="struct_f_i_x_1_1_check_sum_convertor.html#d2">00123</a>   <span class="keyword">static</span> <span class="keywordtype">long</span> <a class="code" href="struct_f_i_x_1_1_check_sum_convertor.html#d0">convert</a>( <span class="keyword">const</span> std::string&amp; value )
00124   <span class="keywordflow">throw</span>( <a class="code" href="struct_f_i_x_1_1_field_convert_error.html">FieldConvertError</a>&amp; )
00125   {
00126     <span class="keywordflow">return</span> IntConvertor::convert( value );
00127   }
00128 };
00129 
<a name="l00131"></a><a class="code" href="struct_f_i_x_1_1_double_convertor.html">00131</a> <span class="keyword">struct </span><a class="code" href="struct_f_i_x_1_1_double_convertor.html">DoubleConvertor</a>
00132 {
<a name="l00133"></a><a class="code" href="struct_f_i_x_1_1_double_convertor.html#d0">00133</a>   <span class="keyword">static</span> std::string <a class="code" href="struct_f_i_x_1_1_double_convertor.html#d0">convert</a>( <span class="keywordtype">double</span> value )
00134   {
00135     <span class="keywordtype">char</span> result[ 32 ];
00136     memset( result, 0, 32 * <span class="keyword">sizeof</span>( <span class="keywordtype">char</span> ) );
00137     sprintf( result, <span class="stringliteral">"%.15g"</span>, value );
00138     <span class="keywordflow">return</span> result;
00139   }
00140 
<a name="l00141"></a><a class="code" href="struct_f_i_x_1_1_double_convertor.html#d1">00141</a>   <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="struct_f_i_x_1_1_double_convertor.html#d0">convert</a>( <span class="keyword">const</span> std::string&amp; value, <span class="keywordtype">double</span>&amp; result )
00142   {
00143     <span class="keywordflow">if</span> ( !value.size() ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00144     <span class="keywordflow">if</span> ( value == <span class="stringliteral">"."</span> ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00145 
00146     result = atof( const_cast &lt; char* &gt; ( value.c_str() ) );
00147     std::string stripped = value;
00148     <span class="keywordflow">if</span> ( *stripped.begin() == <span class="charliteral">'.'</span> ) stripped = <span class="charliteral">'0'</span> + stripped;
00149 
00150     <span class="keywordflow">if</span> ( stripped.find( <span class="charliteral">'.'</span> ) != std::string::npos )
00151     {
00152       std::string::reverse_iterator r = stripped.rbegin();
00153       <span class="keywordflow">while</span> ( r != stripped.rend() &amp;&amp; ( *r == <span class="charliteral">'0'</span> || *r == <span class="charliteral">'.'</span> ) )
00154       {
00155         <span class="keywordflow">if</span> ( *r == <span class="charliteral">'.'</span> ) { stripped.resize( stripped.size() - 1 ); <span class="keywordflow">break</span>; }
00156         stripped.resize( stripped.size() - 1 ); r++;
00157       }
00158     }
00159     <span class="keywordflow">if</span> ( *stripped.begin() == <span class="charliteral">'0'</span> )
00160     {
00161       std::string::size_type i = stripped.find_first_not_of( <span class="charliteral">'0'</span> );
00162       std::string::size_type dot = stripped.find( <span class="charliteral">'.'</span> );
00163       <span class="keywordflow">if</span> ( i != dot )
00164         stripped = stripped.substr( i );
00165     }
00166 
00167     std::string converted = <a class="code" href="struct_f_i_x_1_1_double_convertor.html#d0">convert</a>( result );
00168     <span class="keywordflow">if</span> ( stripped.size() != converted.size() ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00169 
00170     <span class="comment">// strcmp is being used because == operator is funky under linux</span>
00171     <span class="keywordflow">if</span> ( strcmp( stripped.c_str(), converted.c_str() ) != 0 )
00172       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00173     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00174   }
00175 
<a name="l00176"></a><a class="code" href="struct_f_i_x_1_1_double_convertor.html#d2">00176</a>   <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="struct_f_i_x_1_1_double_convertor.html#d0">convert</a>( <span class="keyword">const</span> std::string&amp; value )
00177   <span class="keywordflow">throw</span>( <a class="code" href="struct_f_i_x_1_1_field_convert_error.html">FieldConvertError</a>&amp; )
00178   {
00179     <span class="keywordtype">double</span> result = 0.0;
00180     <span class="keywordflow">if</span> ( !<a class="code" href="struct_f_i_x_1_1_double_convertor.html#d0">convert</a>( value, result ) )
00181       <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_field_convert_error.html">FieldConvertError</a>();
00182     <span class="keywordflow">else</span>
00183       <span class="keywordflow">return</span> result;
00184   }
00185 };
00186 
<a name="l00188"></a><a class="code" href="struct_f_i_x_1_1_char_convertor.html">00188</a> <span class="keyword">struct </span><a class="code" href="struct_f_i_x_1_1_char_convertor.html">CharConvertor</a>
00189 {
<a name="l00190"></a><a class="code" href="struct_f_i_x_1_1_char_convertor.html#d0">00190</a>   <span class="keyword">static</span> std::string <a class="code" href="struct_f_i_x_1_1_char_convertor.html#d0">convert</a>( <span class="keywordtype">char</span> value )
00191   {
00192     <span class="keywordtype">char</span> temp[ 2 ];
00193     temp[ 0 ] = value;
00194     temp[ 1 ] = <span class="charliteral">'\0'</span>;
00195     <span class="keywordflow">return</span> temp;
00196   }
00197 
<a name="l00198"></a><a class="code" href="struct_f_i_x_1_1_char_convertor.html#d1">00198</a>   <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="struct_f_i_x_1_1_char_convertor.html#d0">convert</a>( <span class="keyword">const</span> std::string&amp; value, <span class="keywordtype">char</span>&amp; result )
00199   {
00200     <span class="keywordflow">if</span> ( value.size() == 0 ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00201     result = *value.c_str();
00202     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00203   }
00204 
<a name="l00205"></a><a class="code" href="struct_f_i_x_1_1_char_convertor.html#d2">00205</a>   <span class="keyword">static</span> <span class="keywordtype">char</span> <a class="code" href="struct_f_i_x_1_1_char_convertor.html#d0">convert</a>( <span class="keyword">const</span> std::string&amp; value )
00206   <span class="keywordflow">throw</span>( <a class="code" href="struct_f_i_x_1_1_field_convert_error.html">FieldConvertError</a>&amp; )
00207   {
00208     <span class="keywordtype">char</span> result = <span class="charliteral">'\0'</span>;
00209     <span class="keywordflow">if</span> ( !<a class="code" href="struct_f_i_x_1_1_char_convertor.html#d0">convert</a>( value, result ) )
00210       <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_field_convert_error.html">FieldConvertError</a>();
00211     <span class="keywordflow">else</span>
00212       <span class="keywordflow">return</span> result;
00213   }
00214 };
00215 
<a name="l00217"></a><a class="code" href="struct_f_i_x_1_1_bool_convertor.html">00217</a> <span class="keyword">struct </span><a class="code" href="struct_f_i_x_1_1_bool_convertor.html">BoolConvertor</a>
00218 {
<a name="l00219"></a><a class="code" href="struct_f_i_x_1_1_bool_convertor.html#d0">00219</a>   <span class="keyword">static</span> std::string <a class="code" href="struct_f_i_x_1_1_bool_convertor.html#d0">convert</a>( <span class="keywordtype">bool</span> value )
00220   { <span class="keywordflow">return</span> value ? <span class="stringliteral">"Y"</span> : <span class="stringliteral">"N"</span>; }
00221 
<a name="l00222"></a><a class="code" href="struct_f_i_x_1_1_bool_convertor.html#d1">00222</a>   <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="struct_f_i_x_1_1_bool_convertor.html#d0">convert</a>( <span class="keyword">const</span> std::string&amp; value, <span class="keywordtype">bool</span>&amp; result )
00223   {
00224     <span class="keywordflow">if</span> ( value == <span class="stringliteral">"Y"</span> ) result = <span class="keyword">true</span>;
00225     <span class="keywordflow">else</span>
00226       <span class="keywordflow">if</span> ( value == <span class="stringliteral">"N"</span> ) result = <span class="keyword">false</span>;
00227       <span class="keywordflow">else</span>
00228         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00229     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00230   }
00231 
<a name="l00232"></a><a class="code" href="struct_f_i_x_1_1_bool_convertor.html#d2">00232</a>   <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="struct_f_i_x_1_1_bool_convertor.html#d0">convert</a>( <span class="keyword">const</span> std::string&amp; value )
00233   <span class="keywordflow">throw</span>( <a class="code" href="struct_f_i_x_1_1_field_convert_error.html">FieldConvertError</a>&amp; )
00234   {
00235     <span class="keywordtype">bool</span> result = <span class="keyword">false</span>;
00236     <span class="keywordflow">if</span> ( !<a class="code" href="struct_f_i_x_1_1_bool_convertor.html#d0">convert</a>( value, result ) )
00237       <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_field_convert_error.html">FieldConvertError</a>();
00238     <span class="keywordflow">else</span>
00239       <span class="keywordflow">return</span> result;
00240   }
00241 };
00242 
<a name="l00244"></a><a class="code" href="struct_f_i_x_1_1_utc_time_stamp_convertor.html">00244</a> <span class="keyword">struct </span><a class="code" href="struct_f_i_x_1_1_utc_time_stamp_convertor.html">UtcTimeStampConvertor</a>
00245 {
<a name="l00246"></a><a class="code" href="struct_f_i_x_1_1_utc_time_stamp_convertor.html#d0">00246</a>   <span class="keyword">static</span> std::string <a class="code" href="struct_f_i_x_1_1_utc_time_stamp_convertor.html#d0">convert</a>( <span class="keyword">const</span> <a class="code" href="class_f_i_x_1_1_utc_time_stamp.html">UtcTimeStamp</a>&amp; value )
00247   <span class="keywordflow">throw</span>( <a class="code" href="struct_f_i_x_1_1_field_convert_error.html">FieldConvertError</a>&amp; )
00248   {
00249     <span class="keywordtype">char</span> result[ 18 ];
00250     <span class="keywordtype">int</span> len = strftime( result, 18, <span class="stringliteral">"%Y%m%d-%H:%M:%S"</span>, value );
00251     <span class="keywordflow">if</span> ( len != 17 ) <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_field_convert_error.html">FieldConvertError</a>();
00252     <span class="keywordflow">return</span> result;
00253   }
00254 
<a name="l00255"></a><a class="code" href="struct_f_i_x_1_1_utc_time_stamp_convertor.html#d1">00255</a>   <span class="keyword">static</span> <a class="code" href="class_f_i_x_1_1_utc_time_stamp.html">UtcTimeStamp</a> <a class="code" href="struct_f_i_x_1_1_utc_time_stamp_convertor.html#d0">convert</a>( <span class="keyword">const</span> std::string&amp; value )
00256   <span class="keywordflow">throw</span>( <a class="code" href="struct_f_i_x_1_1_field_convert_error.html">FieldConvertError</a>&amp; )
00257   {
00258     <a class="code" href="class_f_i_x_1_1_utc_time_stamp.html">UtcTimeStamp</a> result;
00259     <span class="keyword">const</span> <span class="keywordtype">char</span>* val = value.c_str();
00260     <span class="keyword">const</span> <span class="keywordtype">char</span>* foo = strptime( val, <span class="stringliteral">"%Y%m%d-%H:%M:%S"</span>, result );
00261     <span class="keywordflow">if</span> ( foo - val != 17 ) <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_field_convert_error.html">FieldConvertError</a>();
00262     <span class="keywordflow">return</span> result;
00263   }
00264 };
00265 
<a name="l00267"></a><a class="code" href="struct_f_i_x_1_1_utc_time_only_convertor.html">00267</a> <span class="keyword">struct </span><a class="code" href="struct_f_i_x_1_1_utc_time_only_convertor.html">UtcTimeOnlyConvertor</a>
00268 {
<a name="l00269"></a><a class="code" href="struct_f_i_x_1_1_utc_time_only_convertor.html#d0">00269</a>   <span class="keyword">static</span> std::string <a class="code" href="struct_f_i_x_1_1_utc_time_only_convertor.html#d0">convert</a>( <span class="keyword">const</span> <a class="code" href="class_f_i_x_1_1_utc_time_only.html">UtcTimeOnly</a>&amp; value )
00270   <span class="keywordflow">throw</span>( <a class="code" href="struct_f_i_x_1_1_field_convert_error.html">FieldConvertError</a>&amp; )
00271   {
00272     <span class="keywordtype">char</span> result[ 9 ];
00273     <span class="keywordtype">int</span> len = strftime( result, 9, <span class="stringliteral">"%H:%M:%S"</span>, value );
00274     <span class="keywordflow">if</span> ( len != 8 ) <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_field_convert_error.html">FieldConvertError</a>();
00275     <span class="keywordflow">return</span> result;
00276   }
00277 
<a name="l00278"></a><a class="code" href="struct_f_i_x_1_1_utc_time_only_convertor.html#d1">00278</a>   <span class="keyword">static</span> <a class="code" href="class_f_i_x_1_1_utc_time_only.html">UtcTimeOnly</a> <a class="code" href="struct_f_i_x_1_1_utc_time_only_convertor.html#d0">convert</a>( <span class="keyword">const</span> std::string&amp; value )
00279   <span class="keywordflow">throw</span>( <a class="code" href="struct_f_i_x_1_1_field_convert_error.html">FieldConvertError</a>&amp; )
00280   {
00281     <a class="code" href="class_f_i_x_1_1_utc_time_only.html">UtcTimeOnly</a> result;
00282     <span class="keyword">const</span> <span class="keywordtype">char</span>* val = value.c_str();
00283     <span class="keyword">const</span> <span class="keywordtype">char</span>* foo = strptime( val, <span class="stringliteral">"%H:%M:%S"</span>, result );
00284     <span class="keywordflow">if</span> ( foo - val != 8 ) <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_field_convert_error.html">FieldConvertError</a>();
00285     <span class="keywordflow">return</span> result;
00286   }
00287 };
00288 
<a name="l00290"></a><a class="code" href="struct_f_i_x_1_1_utc_date_convertor.html">00290</a> <span class="keyword">struct </span><a class="code" href="struct_f_i_x_1_1_utc_date_convertor.html">UtcDateConvertor</a>
00291 {
<a name="l00292"></a><a class="code" href="struct_f_i_x_1_1_utc_date_convertor.html#d0">00292</a>   <span class="keyword">static</span> std::string <a class="code" href="struct_f_i_x_1_1_utc_date_convertor.html#d0">convert</a>( <span class="keyword">const</span> <a class="code" href="class_f_i_x_1_1_utc_date.html">UtcDate</a>&amp; value )
00293   <span class="keywordflow">throw</span>( <a class="code" href="struct_f_i_x_1_1_field_convert_error.html">FieldConvertError</a>&amp; )
00294   {
00295     <span class="keywordtype">char</span> result[ 9 ];
00296     <span class="keywordtype">int</span> len = strftime( result, 9, <span class="stringliteral">"%Y%m%d"</span>, value );
00297     <span class="keywordflow">if</span> ( len != 8 ) <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_field_convert_error.html">FieldConvertError</a>();
00298     <span class="keywordflow">return</span> result;
00299   }
00300 
<a name="l00301"></a><a class="code" href="struct_f_i_x_1_1_utc_date_convertor.html#d1">00301</a>   <span class="keyword">static</span> <a class="code" href="class_f_i_x_1_1_utc_date.html">UtcDate</a> <a class="code" href="struct_f_i_x_1_1_utc_date_convertor.html#d0">convert</a>( <span class="keyword">const</span> std::string&amp; value )
00302   <span class="keywordflow">throw</span>( <a class="code" href="struct_f_i_x_1_1_field_convert_error.html">FieldConvertError</a>&amp; )
00303   {
00304     <a class="code" href="class_f_i_x_1_1_utc_date.html">UtcDate</a> result;
00305     <span class="keyword">const</span> <span class="keywordtype">char</span>* val = value.c_str();
00306     <span class="keyword">const</span> <span class="keywordtype">char</span>* foo = strptime( val, <span class="stringliteral">"%Y%m%d"</span>, result );
00307     <span class="keywordflow">if</span> ( foo - val != 8 ) <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_field_convert_error.html">FieldConvertError</a>();
00308     <span class="keywordflow">return</span> result;
00309   }
00310 };
00311 
<a name="l00312"></a><a class="code" href="namespace_f_i_x.html#a14">00312</a> <span class="keyword">typedef</span> StringConvertor <a class="code" href="struct_f_i_x_1_1_empty_convertor.html">STRING_CONVERTOR</a>;
<a name="l00313"></a><a class="code" href="namespace_f_i_x.html#a15">00313</a> <span class="keyword">typedef</span> <a class="code" href="struct_f_i_x_1_1_char_convertor.html">CharConvertor</a> <a class="code" href="struct_f_i_x_1_1_char_convertor.html">CHAR_CONVERTOR</a>;
<a name="l00314"></a><a class="code" href="namespace_f_i_x.html#a16">00314</a> <span class="keyword">typedef</span> <a class="code" href="struct_f_i_x_1_1_double_convertor.html">DoubleConvertor</a> <a class="code" href="struct_f_i_x_1_1_double_convertor.html">PRICE_CONVERTOR</a>;
<a name="l00315"></a><a class="code" href="namespace_f_i_x.html#a17">00315</a> <span class="keyword">typedef</span> <a class="code" href="struct_f_i_x_1_1_int_convertor.html">IntConvertor</a> <a class="code" href="struct_f_i_x_1_1_int_convertor.html">INT_CONVERTOR</a>;
<a name="l00316"></a><a class="code" href="namespace_f_i_x.html#a18">00316</a> <span class="keyword">typedef</span> <a class="code" href="struct_f_i_x_1_1_double_convertor.html">DoubleConvertor</a> <a class="code" href="struct_f_i_x_1_1_double_convertor.html">AMT_CONVERTOR</a>;
<a name="l00317"></a><a class="code" href="namespace_f_i_x.html#a19">00317</a> <span class="keyword">typedef</span> <a class="code" href="struct_f_i_x_1_1_double_convertor.html">DoubleConvertor</a> <a class="code" href="struct_f_i_x_1_1_double_convertor.html">QTY_CONVERTOR</a>;
<a name="l00318"></a><a class="code" href="namespace_f_i_x.html#a20">00318</a> <span class="keyword">typedef</span> <a class="code" href="struct_f_i_x_1_1_char_convertor.html">CharConvertor</a> <a class="code" href="struct_f_i_x_1_1_char_convertor.html">CURRENCY_CONVERTOR</a>;
<a name="l00319"></a><a class="code" href="namespace_f_i_x.html#a21">00319</a> <span class="keyword">typedef</span> StringConvertor <a class="code" href="struct_f_i_x_1_1_empty_convertor.html">MULTIPLEVALUESTRING_CONVERTOR</a>;
<a name="l00320"></a><a class="code" href="namespace_f_i_x.html#a22">00320</a> <span class="keyword">typedef</span> StringConvertor <a class="code" href="struct_f_i_x_1_1_empty_convertor.html">EXCHANGE_CONVERTOR</a>;
<a name="l00321"></a><a class="code" href="namespace_f_i_x.html#a23">00321</a> <span class="keyword">typedef</span> <a class="code" href="struct_f_i_x_1_1_utc_time_stamp_convertor.html">UtcTimeStampConvertor</a> <a class="code" href="struct_f_i_x_1_1_utc_time_stamp_convertor.html">UTCTIMESTAMP_CONVERTOR</a>;
<a name="l00322"></a><a class="code" href="namespace_f_i_x.html#a24">00322</a> <span class="keyword">typedef</span> <a class="code" href="struct_f_i_x_1_1_bool_convertor.html">BoolConvertor</a> <a class="code" href="struct_f_i_x_1_1_bool_convertor.html">BOOLEAN_CONVERTOR</a>;
<a name="l00323"></a><a class="code" href="namespace_f_i_x.html#a25">00323</a> <span class="keyword">typedef</span> StringConvertor <a class="code" href="struct_f_i_x_1_1_empty_convertor.html">LOCALMKTDATE_CONVERTOR</a>;
<a name="l00324"></a><a class="code" href="namespace_f_i_x.html#a26">00324</a> <span class="keyword">typedef</span> StringConvertor <a class="code" href="struct_f_i_x_1_1_empty_convertor.html">DATA_CONVERTOR</a>;
<a name="l00325"></a><a class="code" href="namespace_f_i_x.html#a27">00325</a> <span class="keyword">typedef</span> <a class="code" href="struct_f_i_x_1_1_double_convertor.html">DoubleConvertor</a> <a class="code" href="struct_f_i_x_1_1_double_convertor.html">FLOAT_CONVERTOR</a>;
<a name="l00326"></a><a class="code" href="namespace_f_i_x.html#a28">00326</a> <span class="keyword">typedef</span> <a class="code" href="struct_f_i_x_1_1_double_convertor.html">DoubleConvertor</a> <a class="code" href="struct_f_i_x_1_1_double_convertor.html">PRICEOFFSET_CONVERTOR</a>;
<a name="l00327"></a><a class="code" href="namespace_f_i_x.html#a29">00327</a> <span class="keyword">typedef</span> StringConvertor <a class="code" href="struct_f_i_x_1_1_empty_convertor.html">MONTHYEAR_CONVERTOR</a>;
<a name="l00328"></a><a class="code" href="namespace_f_i_x.html#a30">00328</a> <span class="keyword">typedef</span> StringConvertor <a class="code" href="struct_f_i_x_1_1_empty_convertor.html">DAYOFMONTH_CONVERTOR</a>;
<a name="l00329"></a><a class="code" href="namespace_f_i_x.html#a31">00329</a> <span class="keyword">typedef</span> <a class="code" href="struct_f_i_x_1_1_utc_date_convertor.html">UtcDateConvertor</a> <a class="code" href="struct_f_i_x_1_1_utc_date_convertor.html">UTCDATE_CONVERTOR</a>;
<a name="l00330"></a><a class="code" href="namespace_f_i_x.html#a32">00330</a> <span class="keyword">typedef</span> <a class="code" href="struct_f_i_x_1_1_utc_time_only_convertor.html">UtcTimeOnlyConvertor</a> <a class="code" href="struct_f_i_x_1_1_utc_time_only_convertor.html">UTCTIMEONLY_CONVERTOR</a>;
<a name="l00331"></a><a class="code" href="namespace_f_i_x.html#a33">00331</a> <span class="keyword">typedef</span> <a class="code" href="struct_f_i_x_1_1_check_sum_convertor.html">CheckSumConvertor</a> <a class="code" href="struct_f_i_x_1_1_check_sum_convertor.html">CHECKSUM_CONVERTOR</a>;
00332 }
00333 
00334 <span class="preprocessor">#endif //FIX_FIELDCONVERTORS_H</span>
</pre></div><hr><address><small>

Generated on Wed Oct 30 21:17:52 2002 for QuickFIX by <a href="http://www.doxygen.org/index.html">

<img src="doxygen.gif" alt="doxygen" align="middle" border=0 width=110 height=53>

</a> 1.2.17 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,

 &copy;&nbsp;1997-2001</small></address>

</body>

</html>

