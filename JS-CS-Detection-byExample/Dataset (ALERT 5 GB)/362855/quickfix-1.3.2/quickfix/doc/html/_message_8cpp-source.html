<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">

<title>C:/release/quickfix/src/C++/Message.cpp Source File</title>

<link href="quickfix.css" rel="stylesheet" type="text/css">

<table cellspacing="0" cellpadding="0" border="0">

  <tr>

   <td><img src="images/outsideTopLeft.gif"></td>

   <td width="100%" class="outsideTop">&nbsp;</td>

   <td><img src="images/outsideTopRight.gif"></td>

  </tr>

  <tr>

   <td class="outsideLeft">&nbsp;</td>

   <td>

	<img src="images/QuickFIX.jpg" align="middle" border=0>

	&nbsp;&nbsp;

	<a href="index.html">Index</a>&nbsp;

	<a href="files.html">Source Files</a>&nbsp;

	<a href="annotated.html">Annotated Class List</a>&nbsp;

	<a href="classes.html">Alphabetical Class List</a>&nbsp;

	<a href="hierarchy.html">Class Hierarchy</a>&nbsp;

	<a href="inherits.html">Graphical Class Hierarchy</a>&nbsp;

   </td>

   <td class="outsideRight">&nbsp;</td>

  </tr>

  <tr>

   <td><img src="images/outsideBottomLeft.gif"></td>

   <td width=100% class="outsideBottom">&nbsp;</td>

   <td><img src="images/outsideBottomRight.gif"></td>

  </tr>

</table>

</head><body bgcolor="#ffffff">

<!-- Generated by Doxygen 1.2.17 -->
<h1>C:/release/quickfix/src/C++/Message.cpp</h1><a href="_message_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/* ====================================================================</span>
00002 <span class="comment">* The QuickFIX Software License, Version 1.0</span>
00003 <span class="comment">*</span>
00004 <span class="comment">* Copyright (c) 2001 ThoughtWorks, Inc.  All rights</span>
00005 <span class="comment">* reserved.</span>
00006 <span class="comment">*</span>
00007 <span class="comment">* Redistribution and use in source and binary forms, with or without</span>
00008 <span class="comment">* modification, are permitted provided that the following conditions</span>
00009 <span class="comment">* are met:</span>
00010 <span class="comment">*</span>
00011 <span class="comment">* 1. Redistributions of source code must retain the above copyright</span>
00012 <span class="comment">*    notice, this list of conditions and the following disclaimer.</span>
00013 <span class="comment">*</span>
00014 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright</span>
00015 <span class="comment">*    notice, this list of conditions and the following disclaimer in</span>
00016 <span class="comment">*    the documentation and/or other materials provided with the</span>
00017 <span class="comment">*    distribution.</span>
00018 <span class="comment">*</span>
00019 <span class="comment">* 3. The end-user documentation included with the redistribution,</span>
00020 <span class="comment">*    if any, must include the following acknowledgment:</span>
00021 <span class="comment">*       "This product includes software developed by</span>
00022 <span class="comment">*        ThoughtWorks, Inc. (http://www.thoughtworks.com/)."</span>
00023 <span class="comment">*    Alternately, this acknowledgment may appear in the software itself,</span>
00024 <span class="comment">*    if and wherever such third-party acknowledgments normally appear.</span>
00025 <span class="comment">*</span>
00026 <span class="comment">* 4. The names "QuickFIX" and "ThoughtWorks, Inc." must</span>
00027 <span class="comment">*    not be used to endorse or promote products derived from this</span>
00028 <span class="comment">*    software without prior written permission. For written</span>
00029 <span class="comment">*    permission, please contact quickfix-users@lists.sourceforge.net.</span>
00030 <span class="comment">*</span>
00031 <span class="comment">* 5. Products derived from this software may not be called "QuickFIX",</span>
00032 <span class="comment">*    nor may "QuickFIX" appear in their name, without prior written</span>
00033 <span class="comment">*    permission of ThoughtWorks, Inc.</span>
00034 <span class="comment">*</span>
00035 <span class="comment">* THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED</span>
00036 <span class="comment">* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</span>
00037 <span class="comment">* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
00038 <span class="comment">* DISCLAIMED.  IN NO EVENT SHALL THOUGHTWORKS INC OR</span>
00039 <span class="comment">* ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
00040 <span class="comment">* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
00041 <span class="comment">* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF</span>
00042 <span class="comment">* USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND</span>
00043 <span class="comment">* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span>
00044 <span class="comment">* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT</span>
00045 <span class="comment">* OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</span>
00046 <span class="comment">* SUCH DAMAGE.</span>
00047 <span class="comment">* ====================================================================</span>
00048 <span class="comment">*/</span>
00049 
00050 <span class="preprocessor">#ifdef _MSC_VER</span>
00051 <span class="preprocessor"></span><span class="preprocessor">#include "stdafx.h"</span>
00052 <span class="preprocessor">#else</span>
00053 <span class="preprocessor"></span><span class="preprocessor">#include "config.h"</span>
00054 <span class="preprocessor">#endif</span>
00055 <span class="preprocessor"></span>
00056 <span class="preprocessor">#include "<a class="code" href="_message_8h.html">Message.h</a>"</span>
00057 <span class="preprocessor">#include "<a class="code" href="_utility_8h.html">Utility.h</a>"</span>
00058 <span class="preprocessor">#include &lt;iomanip&gt;</span>
00059 
00060 <span class="keyword">namespace </span>FIX
00061 {
<a name="l00062"></a><a class="code" href="class_f_i_x_1_1_message.html#q0">00062</a> std::auto_ptr&lt;DataDictionary&gt; Message::s_dataDictionary;
00063 
<a name="l00064"></a><a class="code" href="class_f_i_x_1_1_message.html#a0">00064</a> Message::Message()
00065     : m_header( <a class="code" href="struct_f_i_x_1_1message__order.html">message_order</a>( <a class="code" href="struct_f_i_x_1_1message__order.html">message_order</a>::header ) ),
00066     m_trailer( <a class="code" href="struct_f_i_x_1_1message__order.html">message_order</a>( <a class="code" href="struct_f_i_x_1_1message__order.html">message_order</a>::trailer ) ),
00067 m_validStructure( true ) {}
00068 
<a name="l00069"></a><a class="code" href="class_f_i_x_1_1_message.html#a1">00069</a> Message::Message( <span class="keyword">const</span> std::string&amp; string, <span class="keywordtype">bool</span> validate )
00070 <span class="keywordflow">throw</span>( <a class="code" href="struct_f_i_x_1_1_invalid_message.html">InvalidMessage</a>&amp; )
00071     : m_header( <a class="code" href="struct_f_i_x_1_1message__order.html">message_order</a>( message_order::header ) ),
00072     m_trailer( <a class="code" href="struct_f_i_x_1_1message__order.html">message_order</a>( message_order::trailer ) ),
00073     m_validStructure( <span class="keyword">true</span> )
00074 {
00075   <span class="keywordflow">if</span> ( !setString( string, validate ) )
00076     <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_invalid_message.html">InvalidMessage</a>();
00077 }
00078 
<a name="l00079"></a><a class="code" href="class_f_i_x_1_1_message.html#a2">00079</a> Message::Message( <span class="keyword">const</span> std::string&amp; string, <span class="keyword">const</span> <a class="code" href="class_f_i_x_1_1_data_dictionary.html">DataDictionary</a>&amp; dataDictionary )
00080 <span class="keywordflow">throw</span>( <a class="code" href="struct_f_i_x_1_1_invalid_message.html">InvalidMessage</a>&amp; )
00081     : m_header( <a class="code" href="struct_f_i_x_1_1message__order.html">message_order</a>( message_order::header ) ),
00082     m_trailer( <a class="code" href="struct_f_i_x_1_1message__order.html">message_order</a>( message_order::trailer ) ),
00083     m_validStructure( <span class="keyword">true</span> )
00084 {
00085   <span class="keywordflow">if</span> ( !setString( string, <span class="keyword">true</span>, &amp;dataDictionary ) )
00086     <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_invalid_message.html">InvalidMessage</a>();
00087 }
00088 
<a name="l00089"></a><a class="code" href="class_f_i_x_1_1_message.html#d0">00089</a> <span class="keywordtype">bool</span> Message::InitializeXML( <span class="keyword">const</span> std::string&amp; url )
00090 {
00091   <span class="keywordflow">try</span>
00092   {
00093     std::auto_ptr&lt;DataDictionary&gt; p =
00094       std::auto_ptr&lt;DataDictionary&gt;(<span class="keyword">new</span> <a class="code" href="class_f_i_x_1_1_message.html#l0">DataDictionary</a>(url));
00095     <a class="code" href="class_f_i_x_1_1_message.html#q0">s_dataDictionary</a> = p;
00096     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00097   }
00098   <span class="keywordflow">catch</span>( <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a>&amp; )
00099   { <span class="keywordflow">return</span> <span class="keyword">false</span>; }
00100 }
00101 
<a name="l00102"></a><a class="code" href="class_f_i_x_1_1_message.html#a6">00102</a> std::string Message::toString()<span class="keyword"> const</span>
00103 <span class="keyword"></span>{
00104   <a class="code" href="class_f_i_x_1_1_message.html#n0">m_header</a>.<a class="code" href="class_f_i_x_1_1_field_map.html#a5">setField</a>( <a class="code" href="namespace_f_i_x_1_1_f_i_e_l_d.html#a413a13">BodyLength</a>( <a class="code" href="class_f_i_x_1_1_message.html#a17">bodyLength</a>() ) );
00105   <a class="code" href="class_f_i_x_1_1_message.html#n1">m_trailer</a>.<a class="code" href="class_f_i_x_1_1_field_map.html#a5">setField</a>( <a class="code" href="namespace_f_i_x_1_1_f_i_e_l_d.html#a413a14">CheckSum</a>( <a class="code" href="class_f_i_x_1_1_message.html#a18">checkSum</a>() ) );
00106 
00107   <span class="keywordflow">return</span>
00108     <a class="code" href="class_f_i_x_1_1_message.html#n0">m_header</a>.<a class="code" href="class_f_i_x_1_1_field_map.html#a18">calculateString</a>() +
00109     FieldMap::calculateString() +
00110     <a class="code" href="class_f_i_x_1_1_message.html#n1">m_trailer</a>.<a class="code" href="class_f_i_x_1_1_field_map.html#a18">calculateString</a>();
00111 }
00112 
<a name="l00113"></a><a class="code" href="class_f_i_x_1_1_message.html#a8">00113</a> std::string Message::toXML()<span class="keyword"> const</span>
00114 <span class="keyword"></span>{
00115   std::stringstream stream;
00116   stream &lt;&lt; <span class="stringliteral">"&lt;message&gt;"</span>                         &lt;&lt; EOL
00117          &lt;&lt; std::setw(2) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; <span class="stringliteral">"&lt;header&gt;"</span>   &lt;&lt; EOL  
00118          &lt;&lt; <a class="code" href="class_f_i_x_1_1_message.html#c3">toXMLFields</a>(<a class="code" href="class_f_i_x_1_1_message.html#a12">getHeader</a>(), 4)
00119          &lt;&lt; std::setw(2) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; <span class="stringliteral">"&lt;/header&gt;"</span>  &lt;&lt; EOL
00120          &lt;&lt; std::setw(2) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; <span class="stringliteral">"&lt;body&gt;"</span>     &lt;&lt; EOL
00121          &lt;&lt; <a class="code" href="class_f_i_x_1_1_message.html#c3">toXMLFields</a>(*<span class="keyword">this</span>, 4)
00122          &lt;&lt; std::setw(2) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; <span class="stringliteral">"&lt;/body&gt;"</span>    &lt;&lt; EOL
00123          &lt;&lt; std::setw(2) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; <span class="stringliteral">"&lt;trailer&gt;"</span>  &lt;&lt; EOL
00124          &lt;&lt; <a class="code" href="class_f_i_x_1_1_message.html#c3">toXMLFields</a>(<a class="code" href="class_f_i_x_1_1_message.html#a14">getTrailer</a>(), 4)
00125          &lt;&lt; std::setw(2) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; <span class="stringliteral">"&lt;/trailer&gt;"</span> &lt;&lt; EOL
00126          &lt;&lt; <span class="stringliteral">"&lt;/message&gt;"</span>;
00127 
00128   <span class="keywordflow">return</span> stream.str();
00129 }
00130 
<a name="l00131"></a><a class="code" href="class_f_i_x_1_1_message.html#c3">00131</a> std::string Message::toXMLFields(<span class="keyword">const</span> <a class="code" href="class_f_i_x_1_1_field_map.html">FieldMap</a>&amp; fields, <span class="keywordtype">int</span> space)<span class="keyword"> const</span>
00132 <span class="keyword"></span>{
00133   std::stringstream stream;
00134   FieldMap::iterator i;
00135   std::string name;
00136   <span class="keywordflow">for</span>(i = fields.<a class="code" href="class_f_i_x_1_1_field_map.html#a21">begin</a>(); i != fields.<a class="code" href="class_f_i_x_1_1_field_map.html#a22">end</a>(); ++i)
00137   {       
00138     <span class="keywordtype">int</span> field = i-&gt;first;
00139     std::string value = i-&gt;second.getString();
00140 
00141     stream &lt;&lt; std::setw(space) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; <span class="stringliteral">"&lt;field "</span>;
00142     <span class="keywordflow">if</span>(<a class="code" href="class_f_i_x_1_1_message.html#q0">s_dataDictionary</a>.get() &amp;&amp; <a class="code" href="class_f_i_x_1_1_message.html#q0">s_dataDictionary</a>-&gt;getFieldName(field, name))
00143       stream &lt;&lt; <span class="stringliteral">"name=\""</span> &lt;&lt; name &lt;&lt; <span class="stringliteral">"\" "</span>;
00144     stream &lt;&lt; <span class="stringliteral">"number=\""</span> &lt;&lt; field &lt;&lt; <span class="stringliteral">"\" value=\""</span> &lt;&lt; value &lt;&lt; <span class="stringliteral">"\""</span>;
00145     <span class="keywordflow">if</span>(<a class="code" href="class_f_i_x_1_1_message.html#q0">s_dataDictionary</a>.get() &amp;&amp; <a class="code" href="class_f_i_x_1_1_message.html#q0">s_dataDictionary</a>-&gt;getValueName(field, value, name))
00146       stream &lt;&lt; <span class="stringliteral">" enum=\""</span> &lt;&lt; name &lt;&lt; <span class="stringliteral">"\""</span>;
00147         stream &lt;&lt; <span class="stringliteral">"/&gt;"</span> &lt;&lt; EOL;
00148   }
00149 
00150   FieldMap::g_iterator j;
00151   <span class="keywordflow">for</span>(j = fields.<a class="code" href="class_f_i_x_1_1_field_map.html#a23">g_begin</a>(); j != fields.<a class="code" href="class_f_i_x_1_1_field_map.html#a24">g_end</a>(); ++j)
00152   {
00153     std::vector&lt;FieldMap*&gt;::const_iterator k;
00154     <span class="keywordflow">for</span>(k = j-&gt;second.begin(); k != j-&gt;second.end(); ++k)
00155     {
00156                 stream &lt;&lt; std::setw(space) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; <span class="stringliteral">"&lt;group&gt;"</span> &lt;&lt; EOL
00157              &lt;&lt; <a class="code" href="class_f_i_x_1_1_message.html#c3">toXMLFields</a>(*(*k), space+2)
00158                          &lt;&lt; std::setw(space) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; <span class="stringliteral">"&lt;/group&gt;"</span> &lt;&lt; EOL;
00159     }
00160   }
00161 
00162   <span class="keywordflow">return</span> stream.str();
00163 }
00164 
<a name="l00165"></a><a class="code" href="class_f_i_x_1_1_message.html#a9">00165</a> <span class="keywordtype">bool</span> Message::setString( <span class="keyword">const</span> std::string&amp; string,
00166                          <span class="keywordtype">bool</span> doValidation,
00167                          <span class="keyword">const</span> <a class="code" href="class_f_i_x_1_1_data_dictionary.html">DataDictionary</a>* pDataDictionary )
00168 {
00169   <a class="code" href="class_f_i_x_1_1_message.html#c1">clear</a>();
00170 
00171   std::string::size_type pos = 0;
00172   <span class="keywordtype">int</span> count = 0;
00173   std::string msg;
00174 
00175   <span class="keyword">static</span> FIELD::Field <span class="keyword">const</span> headerOrder[] =
00176     {
00177       FIELD::BeginString,
00178       FIELD::BodyLength,
00179       FIELD::MsgType
00180     };
00181 
00182   <a class="code" href="class_f_i_x_1_1_message.html#u3">field_type</a> type = <a class="code" href="class_f_i_x_1_1_message.html#u3u0">header</a>;
00183 
00184   <span class="keywordflow">try</span> {
00185     <span class="keywordflow">while</span> ( pos &lt; string.size() )
00186     {
00187       <a class="code" href="class_f_i_x_1_1_field_base.html">FieldBase</a> field = <a class="code" href="class_f_i_x_1_1_message.html#c0">extractField</a>( string, pos );
00188       <span class="keywordflow">if</span> ( count &lt; 3 &amp;&amp; headerOrder[ count++ ] != field.<a class="code" href="class_f_i_x_1_1_field_base.html#a1">getField</a>() )
00189         <span class="keywordflow">if</span> ( doValidation ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00190 
00191       <span class="keywordflow">if</span> ( <a class="code" href="class_f_i_x_1_1_message.html#d2">isHeaderField</a>( field, pDataDictionary ) )
00192       {
00193         <span class="keywordflow">if</span> ( type != <a class="code" href="class_f_i_x_1_1_message.html#u3u0">header</a> ) <a class="code" href="class_f_i_x_1_1_message.html#n2">m_validStructure</a> = <span class="keyword">false</span>;
00194         <span class="keywordflow">if</span> ( field.<a class="code" href="class_f_i_x_1_1_field_base.html#a1">getField</a>() == FIELD::MsgType )
00195           msg = field.<a class="code" href="class_f_i_x_1_1_field_base.html#a2">getString</a>();
00196         <a class="code" href="class_f_i_x_1_1_message.html#n0">m_header</a>.<a class="code" href="class_f_i_x_1_1_field_map.html#a5">setField</a>( field );
00197       }
00198       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="class_f_i_x_1_1_message.html#d4">isTrailerField</a>( field, pDataDictionary ) )
00199       {
00200         type = <a class="code" href="class_f_i_x_1_1_message.html#u3u2">trailer</a>;
00201         <a class="code" href="class_f_i_x_1_1_message.html#n1">m_trailer</a>.<a class="code" href="class_f_i_x_1_1_field_map.html#a5">setField</a>( field );
00202       }
00203       <span class="keywordflow">else</span>
00204       {
00205         <span class="keywordflow">if</span> ( type == <a class="code" href="class_f_i_x_1_1_message.html#u3u2">trailer</a> ) <a class="code" href="class_f_i_x_1_1_message.html#n2">m_validStructure</a> = <span class="keyword">false</span>;
00206         type = <a class="code" href="class_f_i_x_1_1_message.html#u3u1">body</a>;
00207         <a class="code" href="class_f_i_x_1_1_field_map.html#a5">setField</a>( field );
00208         <span class="keywordflow">if</span> ( pDataDictionary )
00209         {
00210           <a class="code" href="class_f_i_x_1_1_message.html#a10">setGroup</a>( msg, field, string, pos, *<span class="keyword">this</span>, *pDataDictionary );
00211         }
00212       }
00213     }
00214     <span class="keywordflow">if</span> ( doValidation ) <span class="keywordflow">return</span> <a class="code" href="class_f_i_x_1_1_message.html#c2">validate</a>();
00215     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00216   }
00217   <span class="keywordflow">catch</span>( <a class="code" href="struct_f_i_x_1_1_invalid_message.html">InvalidMessage</a>&amp; )
00218   {
00219     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00220   }
00221 }
00222 
<a name="l00223"></a><a class="code" href="class_f_i_x_1_1_message.html#a10">00223</a> <span class="keywordtype">void</span> Message::setGroup( <span class="keyword">const</span> std::string&amp; msg, <span class="keyword">const</span> <a class="code" href="class_f_i_x_1_1_field_base.html">FieldBase</a>&amp; field, <span class="keyword">const</span> std::string&amp; string,
00224                         std::string::size_type&amp; pos, <a class="code" href="class_f_i_x_1_1_field_map.html">FieldMap</a>&amp; map,
00225                         <span class="keyword">const</span> <a class="code" href="class_f_i_x_1_1_data_dictionary.html">DataDictionary</a>&amp; dataDictionary )
00226 {
00227   <span class="keywordtype">int</span> group = field.<a class="code" href="class_f_i_x_1_1_field_base.html#a1">getField</a>();
00228   <span class="keywordtype">int</span> delim;
00229   <span class="keyword">const</span> <a class="code" href="class_f_i_x_1_1_data_dictionary.html">DataDictionary</a>* pDD = 0;
00230   <span class="keywordflow">if</span> ( !dataDictionary.<a class="code" href="class_f_i_x_1_1_data_dictionary.html#a32">getGroup</a>( msg, group, delim, pDD ) ) <span class="keywordflow">return</span> ;
00231   <span class="keywordflow">if</span> ( IntConvertor::convert(field.<a class="code" href="class_f_i_x_1_1_field_base.html#a2">getString</a>() ) &lt;= 0 ) <span class="keywordflow">return</span> ;
00232   <a class="code" href="class_f_i_x_1_1_group.html">Group</a>* pGroup = 0;
00233 
00234   <span class="keywordflow">while</span> ( pos &lt; string.size() )
00235   {
00236     std::string::size_type oldPos = pos;
00237     <a class="code" href="class_f_i_x_1_1_field_base.html">FieldBase</a> field = <a class="code" href="class_f_i_x_1_1_message.html#c0">extractField</a>( string, pos );
00238     <span class="keywordflow">if</span> ( field.<a class="code" href="class_f_i_x_1_1_field_base.html#a1">getField</a>() == delim )
00239     {
00240       <span class="keywordflow">if</span> ( pGroup ) { map.<a class="code" href="class_f_i_x_1_1_field_map.html#a10">addGroup</a>( group, *pGroup ); <span class="keyword">delete</span> pGroup; }
00241       pGroup = <span class="keyword">new</span> <a class="code" href="class_f_i_x_1_1_group.html">Group</a>( field.<a class="code" href="class_f_i_x_1_1_field_base.html#a1">getField</a>(), delim );
00242     }
00243     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( !pDD-&gt;<a class="code" href="class_f_i_x_1_1_data_dictionary.html#a14">isField</a>( field.<a class="code" href="class_f_i_x_1_1_field_base.html#a1">getField</a>() ) )
00244     {
00245       map.<a class="code" href="class_f_i_x_1_1_field_map.html#a10">addGroup</a>( group, *pGroup ); <span class="keyword">delete</span> pGroup;
00246       pos = oldPos;
00247       <span class="keywordflow">return</span> ;
00248     }
00249 
00250     <span class="keywordflow">if</span> ( !pGroup ) <span class="keywordflow">return</span> ;
00251     pGroup-&gt;<a class="code" href="class_f_i_x_1_1_field_map.html#a5">setField</a>( field );
00252     <a class="code" href="class_f_i_x_1_1_message.html#a10">setGroup</a>( msg, field, string, pos, *pGroup, *pDD );
00253   }
00254 }
00255 
<a name="l00256"></a><a class="code" href="class_f_i_x_1_1_message.html#a11">00256</a> <span class="keywordtype">bool</span> Message::setStringHeader( <span class="keyword">const</span> std::string&amp; string )
00257 {
00258   <a class="code" href="class_f_i_x_1_1_message.html#c1">clear</a>();
00259 
00260   std::string::size_type pos = 0;
00261   <span class="keywordtype">int</span> count = 0;
00262 
00263   <span class="keywordflow">while</span> ( pos &lt; string.size() )
00264   {
00265     <a class="code" href="class_f_i_x_1_1_field_base.html">FieldBase</a> field = <a class="code" href="class_f_i_x_1_1_message.html#c0">extractField</a>( string, pos );
00266     <span class="keywordflow">if</span> ( count &lt; 3 &amp;&amp; headerOrder[ count++ ] != field.<a class="code" href="class_f_i_x_1_1_field_base.html#a1">getField</a>() )
00267       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00268 
00269     <span class="keywordflow">if</span> ( <a class="code" href="class_f_i_x_1_1_message.html#d2">isHeaderField</a>( field ) )
00270       <a class="code" href="class_f_i_x_1_1_message.html#n0">m_header</a>.<a class="code" href="class_f_i_x_1_1_field_map.html#a5">setField</a>( field );
00271     <span class="keywordflow">else</span> <span class="keywordflow">break</span>;
00272   }
00273   <span class="keywordflow">return</span> <span class="keyword">true</span>;
00274 }
00275 
00276 FieldBase Message::extractField
<a name="l00277"></a><a class="code" href="class_f_i_x_1_1_message.html#c0">00277</a> ( <span class="keyword">const</span> std::string&amp; string, std::string::size_type&amp; pos )
00278 {
00279   <span class="keywordtype">int</span> field;
00280   std::string fieldString;
00281   std::string valueString;
00282 
00283   std::string::size_type equalSign = string.find_first_of( <span class="charliteral">'='</span>, pos );
00284   fieldString = string.substr( pos, equalSign - pos );
00285 
00286   std::string::size_type soh =
00287     string.find_first_of( <span class="charliteral">'\001'</span>, equalSign + 1 );
00288   <span class="keywordflow">if</span> ( soh == std::string::npos ) <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_invalid_message.html">InvalidMessage</a>();
00289   valueString = string.substr( equalSign + 1, soh - ( equalSign + 1 ) );
00290 
00291   field = atol( fieldString.c_str() );
00292 
00293   pos = soh + 1;
00294   <span class="keywordflow">return</span> <a class="code" href="class_f_i_x_1_1_field_base.html">FieldBase</a>( field, valueString );
00295 }
00296 }
</pre></div><hr><address><small>

Generated on Wed Oct 30 21:17:53 2002 for QuickFIX by <a href="http://www.doxygen.org/index.html">

<img src="doxygen.gif" alt="doxygen" align="middle" border=0 width=110 height=53>

</a> 1.2.17 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,

 &copy;&nbsp;1997-2001</small></address>

</body>

</html>

