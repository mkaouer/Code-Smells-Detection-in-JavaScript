<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libDAI: dai::DAG::Neighbor Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespacedai.html">dai</a>::<a class="el" href="classdai_1_1DAG.html">DAG</a>::<a class="el" href="structdai_1_1DAG_1_1Neighbor.html">Neighbor</a>
  </div>
</div>
<div class="contents">
<h1>dai::DAG::Neighbor Struct Reference</h1><!-- doxytag: class="dai::DAG::Neighbor" -->
<p>Describes the parent/child relationship of two nodes in a <a class="el" href="classdai_1_1DAG.html" title="Represents the neighborhood structure of nodes in a directed cyclic graph.">DAG</a>.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="dag_8h_source.html">dai/dag.h</a>&gt;</code></p>

<p><a href="structdai_1_1DAG_1_1Neighbor-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1DAG_1_1Neighbor.html#af3f82b1ec371de7e989ab714d3bdff83">Neighbor</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor.  <a href="#af3f82b1ec371de7e989ab714d3bdff83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1DAG_1_1Neighbor.html#a24b55888e6bb0a894d78e1da67074016">Neighbor</a> (size_t <a class="el" href="structdai_1_1DAG_1_1Neighbor.html#a007f484718e8c4b65f2900cca9724f53">iter</a>, size_t <a class="el" href="structdai_1_1DAG_1_1Neighbor.html#a936a90f5679e2238c9acbf964bda6f41">node</a>, size_t <a class="el" href="structdai_1_1DAG_1_1Neighbor.html#aad51a78f6b97f5c4620fba2e777ff925">dual</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor that sets the <a class="el" href="structdai_1_1DAG_1_1Neighbor.html" title="Describes the parent/child relationship of two nodes in a DAG.">Neighbor</a> members according to the parameters.  <a href="#a24b55888e6bb0a894d78e1da67074016"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1DAG_1_1Neighbor.html#ab0da5aee82cc0c114a0ee9fa5b329e45">operator size_t</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to <code>size_t</code> returns <code>node</code> member.  <a href="#ab0da5aee82cc0c114a0ee9fa5b329e45"></a><br/></td></tr>
<tr><td colspan="2"><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1DAG_1_1Neighbor.html#a007f484718e8c4b65f2900cca9724f53">iter</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Corresponds to the index of this <a class="el" href="structdai_1_1DAG_1_1Neighbor.html" title="Describes the parent/child relationship of two nodes in a DAG.">Neighbor</a> entry in the vector of neighbors.  <a href="#a007f484718e8c4b65f2900cca9724f53"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1DAG_1_1Neighbor.html#a936a90f5679e2238c9acbf964bda6f41">node</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contains the number of the neighboring node.  <a href="#a936a90f5679e2238c9acbf964bda6f41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1DAG_1_1Neighbor.html#aad51a78f6b97f5c4620fba2e777ff925">dual</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contains the "dual" iter.  <a href="#aad51a78f6b97f5c4620fba2e777ff925"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Describes the parent/child relationship of two nodes in a <a class="el" href="classdai_1_1DAG.html" title="Represents the neighborhood structure of nodes in a directed cyclic graph.">DAG</a>. </p>
<p>Sometimes we want to do an action, such as sending a message, for all edges in a graph. However, most graphs will be sparse, so we need some way of storing a set of the neighbors of a node, which is both fast and memory-efficient. We also need to be able to go between viewing node <em>a</em> as a neighbor of node <em>b</em>, and node <em>b</em> as a neighbor of node <em>a</em>. The <a class="el" href="structdai_1_1DAG_1_1Neighbor.html" title="Describes the parent/child relationship of two nodes in a DAG.">Neighbor</a> struct solves both of these problems. Each node has two lists of neighbors (a list of parents and a list of children), stored as a std::vector&lt;<a class="el" href="structdai_1_1DAG_1_1Neighbor.html">Neighbor</a>&gt;, and extra information is included in the <a class="el" href="structdai_1_1DAG_1_1Neighbor.html" title="Describes the parent/child relationship of two nodes in a DAG.">Neighbor</a> struct which allows us to access a node as a neighbor of its neighbor (the <code>dual</code> member), i.e., as a child of its parent or as a parent of its child.</p>
<p>By convention, variable identifiers naming indices into a vector of neighbors are prefixed with an underscore ("_"). The neighbor list which they point into is then understood from context. For example, <code>pa(i,_j)</code> gives the <em>_j</em> 'th parent of node <em>i</em>, and <code>ch(k,_l)</code> gives the <em>_l</em> 'th child of node <em>k</em>. Here, <em>i</em> and <em>k</em> are "absolute" indexes of nodes <em>i</em> and <em>k</em>, but <em>_j</em> and <em>_k</em> are understood as "relative" indexes within the list <code>pa(i)</code> of parents of <em>i</em> and the list of children <code>ch(k)</code> of <em>k</em>. The absolute index of <em>_j</em>, which would be called <em>j</em>, can be recovered from the <code>node</code> member: <code>j = pa(i,_j).node</code>. Similarly, the absolute index of <em>_l</em>, which would be called <em>l</em>, can be recovered from the <code>node</code> member: <code>l = ch(k,_l).node</code>. The <code>iter</code> member gives the relative index <em>_j</em> or <em>_l</em>, and the <code>dual</code> member gives the "dual" relative index, i.e., the index of <em>i</em> in <em>j</em> 's children list or the index of <em>k</em> in <em>l</em> 's parent list.</p>
<div class="fragment"><pre class="fragment">  <a class="code" href="structdai_1_1DAG_1_1Neighbor.html#af3f82b1ec371de7e989ab714d3bdff83" title="Default constructor.">Neighbor</a> p = <a class="code" href="classdai_1_1DAG.html#a876bff9fff164bef3f4053b42c8bc782" title="Returns constant reference to the _p &amp;#39;th parent of node n.">pa</a>(i,_j);
  p.node == j &amp;&amp;
  p.iter == _j &amp;&amp;
  <a class="code" href="classdai_1_1DAG.html#a43d62aab21a307f9e908462022b13dcd" title="Returns constant reference to the _c &amp;#39;th child of node n.">ch</a>(p.node,p.dual).node == i

  <a class="code" href="structdai_1_1DAG_1_1Neighbor.html#af3f82b1ec371de7e989ab714d3bdff83" title="Default constructor.">Neighbor</a> c = <a class="code" href="classdai_1_1DAG.html#a43d62aab21a307f9e908462022b13dcd" title="Returns constant reference to the _c &amp;#39;th child of node n.">ch</a>(k,_l);
  c.node == l &amp;&amp;
  c.iter == _l &amp;&amp; 
  <a class="code" href="classdai_1_1DAG.html#a876bff9fff164bef3f4053b42c8bc782" title="Returns constant reference to the _p &amp;#39;th parent of node n.">pa</a>(c.node,c.dual).node == k
</pre></div><p>There is no cheap way to transform a pair of absolute node indices <em>i</em> and <em>j</em> into a <a class="el" href="structdai_1_1DAG_1_1Neighbor.html" title="Describes the parent/child relationship of two nodes in a DAG.">Neighbor</a> structure relative to one of the nodes. Such a feature has never yet been found to be necessary. Iteration over edges can always be accomplished using the <a class="el" href="structdai_1_1DAG_1_1Neighbor.html" title="Describes the parent/child relationship of two nodes in a DAG.">Neighbor</a> lists, and by writing functions that accept relative indices: </p>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code" href="classdai_1_1DAG.html#a5c79447b7a63268417ff87093e0f7472" title="Returns number of nodes.">nrNodes</a>(); ++i )
      <span class="keywordflow">foreach</span>( <span class="keyword">const</span> <a class="code" href="structdai_1_1DAG_1_1Neighbor.html#af3f82b1ec371de7e989ab714d3bdff83" title="Default constructor.">Neighbor</a> &amp;j, <a class="code" href="classdai_1_1DAG.html#a43d62aab21a307f9e908462022b13dcd" title="Returns constant reference to the _c &amp;#39;th child of node n.">ch</a>(i) )
          assert( <a class="code" href="classdai_1_1DAG.html#a04ec82dc6d59fab6a77c24dc560164ac" title="Returns true if the DAG contains an edge from node n1 and n2.">hasEdge</a>( i, j ) );
</pre></div> <hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af3f82b1ec371de7e989ab714d3bdff83"></a><!-- doxytag: member="dai::DAG::Neighbor::Neighbor" ref="af3f82b1ec371de7e989ab714d3bdff83" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dai::DAG::Neighbor::Neighbor </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a class="anchor" id="a24b55888e6bb0a894d78e1da67074016"></a><!-- doxytag: member="dai::DAG::Neighbor::Neighbor" ref="a24b55888e6bb0a894d78e1da67074016" args="(size_t iter, size_t node, size_t dual)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dai::DAG::Neighbor::Neighbor </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>dual</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor that sets the <a class="el" href="structdai_1_1DAG_1_1Neighbor.html" title="Describes the parent/child relationship of two nodes in a DAG.">Neighbor</a> members according to the parameters. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ab0da5aee82cc0c114a0ee9fa5b329e45"></a><!-- doxytag: member="dai::DAG::Neighbor::operator size_t" ref="ab0da5aee82cc0c114a0ee9fa5b329e45" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dai::DAG::Neighbor::operator size_t </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cast to <code>size_t</code> returns <code>node</code> member. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a007f484718e8c4b65f2900cca9724f53"></a><!-- doxytag: member="dai::DAG::Neighbor::iter" ref="a007f484718e8c4b65f2900cca9724f53" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="structdai_1_1DAG_1_1Neighbor.html#a007f484718e8c4b65f2900cca9724f53">dai::DAG::Neighbor::iter</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Corresponds to the index of this <a class="el" href="structdai_1_1DAG_1_1Neighbor.html" title="Describes the parent/child relationship of two nodes in a DAG.">Neighbor</a> entry in the vector of neighbors. </p>

</div>
</div>
<a class="anchor" id="a936a90f5679e2238c9acbf964bda6f41"></a><!-- doxytag: member="dai::DAG::Neighbor::node" ref="a936a90f5679e2238c9acbf964bda6f41" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="structdai_1_1DAG_1_1Neighbor.html#a936a90f5679e2238c9acbf964bda6f41">dai::DAG::Neighbor::node</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Contains the number of the neighboring node. </p>

</div>
</div>
<a class="anchor" id="aad51a78f6b97f5c4620fba2e777ff925"></a><!-- doxytag: member="dai::DAG::Neighbor::dual" ref="aad51a78f6b97f5c4620fba2e777ff925" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="structdai_1_1DAG_1_1Neighbor.html#aad51a78f6b97f5c4620fba2e777ff925">dai::DAG::Neighbor::dual</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Contains the "dual" iter. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/dai/<a class="el" href="dag_8h_source.html">dag.h</a></li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Sun May 9 16:51:33 2010 for libDAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
