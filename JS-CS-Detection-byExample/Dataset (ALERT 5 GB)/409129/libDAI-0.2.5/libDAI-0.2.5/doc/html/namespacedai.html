<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libDAI: dai Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>dai Namespace Reference</h1>
<p>Namespace for libDAI.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1BBPCostFunction.html">BBPCostFunction</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Predefined cost functions that can be used with <a class="el" href="classdai_1_1BBP.html" title="Implements BBP (Back-Belief-Propagation) [EaG09].">BBP</a>.  <a href="classdai_1_1BBPCostFunction.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1BBP.html">BBP</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implements <a class="el" href="classdai_1_1BBP.html" title="Implements BBP (Back-Belief-Propagation) [EaG09].">BBP</a> (Back-Belief-Propagation) [<a class="el" href="bibliography.html#EaG09">EaG09</a>].  <a href="classdai_1_1BBP.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1BipartiteGraph.html">BipartiteGraph</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents the neighborhood structure of nodes in an undirected, bipartite graph.  <a href="classdai_1_1BipartiteGraph.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1BP.html">BP</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Approximate inference algorithm "(Loopy) Belief Propagation".  <a href="classdai_1_1BP.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1BP__dual.html">BP_dual</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates both types of <a class="el" href="classdai_1_1BP.html" title="Approximate inference algorithm &quot;(Loopy) Belief Propagation&quot;.">BP</a> messages and their normalizers from an <a class="el" href="classdai_1_1InfAlg.html" title="InfAlg is an abstract base class, defining the common interface of all inference...">InfAlg</a>.  <a href="classdai_1_1BP__dual.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1CBP.html">CBP</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for <a class="el" href="classdai_1_1CBP.html" title="Class for CBP (Conditioned Belief Propagation) [EaG09].">CBP</a> (Conditioned Belief Propagation) [<a class="el" href="bibliography.html#EaG09">EaG09</a>].  <a href="classdai_1_1CBP.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1ClusterGraph.html">ClusterGraph</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <a class="el" href="classdai_1_1ClusterGraph.html" title="A ClusterGraph is a hypergraph with variables as nodes, and &quot;clusters&quot;...">ClusterGraph</a> is a hypergraph with variables as nodes, and "clusters" (sets of variables) as hyperedges.  <a href="classdai_1_1ClusterGraph.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1sequentialVariableElimination.html">sequentialVariableElimination</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper object for <a class="el" href="classdai_1_1ClusterGraph.html#ac8293f37286fc6b0c32ea29ee666eea8" title="Performs Variable Elimination, keeping track of the interactions that are created...">dai::ClusterGraph::VarElim()</a>.  <a href="classdai_1_1sequentialVariableElimination.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1greedyVariableElimination.html">greedyVariableElimination</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper object for <a class="el" href="classdai_1_1ClusterGraph.html#ac8293f37286fc6b0c32ea29ee666eea8" title="Performs Variable Elimination, keeping track of the interactions that are created...">dai::ClusterGraph::VarElim()</a>.  <a href="classdai_1_1greedyVariableElimination.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1DAG.html">DAG</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents the neighborhood structure of nodes in a directed cyclic graph.  <a href="classdai_1_1DAG.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1InfAlg.html">InfAlg</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classdai_1_1InfAlg.html" title="InfAlg is an abstract base class, defining the common interface of all inference...">InfAlg</a> is an abstract base class, defining the common interface of all inference algorithms in libDAI.  <a href="classdai_1_1InfAlg.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1DAIAlg.html">DAIAlg</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combines the abstract base class <a class="el" href="classdai_1_1InfAlg.html" title="InfAlg is an abstract base class, defining the common interface of all inference...">InfAlg</a> with a graphical model (e.g., a <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a> or <a class="el" href="classdai_1_1RegionGraph.html" title="A RegionGraph combines a bipartite graph consisting of outer regions (type FRegion)...">RegionGraph</a>).  <a href="classdai_1_1DAIAlg.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1ParameterEstimation.html">ParameterEstimation</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for parameter estimation methods.  <a href="classdai_1_1ParameterEstimation.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1CondProbEstimation.html">CondProbEstimation</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Estimates the parameters of a conditional probability table, using pseudocounts.  <a href="classdai_1_1CondProbEstimation.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1SharedParameters.html">SharedParameters</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a single factor or set of factors whose parameters should be estimated.  <a href="classdai_1_1SharedParameters.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1MaximizationStep.html">MaximizationStep</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <a class="el" href="classdai_1_1MaximizationStep.html" title="A MaximizationStep groups together several parameter estimation tasks (SharedParameters...">MaximizationStep</a> groups together several parameter estimation tasks (<a class="el" href="classdai_1_1SharedParameters.html" title="Represents a single factor or set of factors whose parameters should be estimated...">SharedParameters</a> objects) into a single unit.  <a href="classdai_1_1MaximizationStep.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1EMAlg.html">EMAlg</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classdai_1_1EMAlg.html" title="EMAlg performs Expectation Maximization to learn factor parameters.">EMAlg</a> performs Expectation Maximization to learn factor parameters.  <a href="classdai_1_1EMAlg.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1Evidence.html">Evidence</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stores a data set consisting of multiple samples, where each sample is the observed joint state of some variables.  <a href="classdai_1_1Evidence.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1ExactInf.html">ExactInf</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exact inference algorithm using brute force enumeration (mainly useful for testing purposes).  <a href="classdai_1_1ExactInf.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1Exception.html">Exception</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Error handling in libDAI is done by throwing an instance of the <a class="el" href="classdai_1_1Exception.html" title="Error handling in libDAI is done by throwing an instance of the Exception class.">Exception</a> class.  <a href="classdai_1_1Exception.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TFactor.html">TFactor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a (probability) factor.  <a href="classdai_1_1TFactor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a factor graph.  <a href="classdai_1_1FactorGraph.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1FBP.html">FBP</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Approximate inference algorithm "Fractional Belief Propagation" [<a class="el" href="bibliography.html#WiH03">WiH03</a>].  <a href="classdai_1_1FBP.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1Gibbs.html">Gibbs</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Approximate inference algorithm "Gibbs sampling".  <a href="classdai_1_1Gibbs.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents the neighborhood structure of nodes in an undirected graph.  <a href="classdai_1_1GraphAL.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1HAK.html">HAK</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Approximate inference algorithm: implementation of single-loop ("Generalized Belief Propagation") and double-loop algorithms by Heskes, Albers and Kappen [<a class="el" href="bibliography.html#HAK03">HAK03</a>].  <a href="classdai_1_1HAK.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1IndexFor.html">IndexFor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tool for looping over the states of several variables.  <a href="classdai_1_1IndexFor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1Permute.html">Permute</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tool for calculating permutations of linear indices of multi-dimensional arrays.  <a href="classdai_1_1Permute.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1multifor.html">multifor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">multifor makes it easy to perform a dynamic number of nested <code>for</code> loops.  <a href="classdai_1_1multifor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1State.html">State</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes it easy to iterate over all possible joint states of variables within a <a class="el" href="classdai_1_1VarSet.html" title="Represents a set of variables.">VarSet</a>.  <a href="classdai_1_1State.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1JTree.html">JTree</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exact inference algorithm using junction tree.  <a href="classdai_1_1JTree.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1LC.html">LC</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Approximate inference algorithm "Loop Corrected Belief Propagation" [<a class="el" href="bibliography.html#MoK07">MoK07</a>].  <a href="classdai_1_1LC.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1MF.html">MF</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Approximate inference algorithm "Mean Field".  <a href="classdai_1_1MF.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1MR.html">MR</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Approximate inference algorithm by Montanari and Rizzo [<a class="el" href="bibliography.html#MoR05">MoR05</a>].  <a href="classdai_1_1MR.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__id.html">fo_id</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function object that returns the value itself.  <a href="structdai_1_1fo__id.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__abs.html">fo_abs</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function object that takes the absolute value.  <a href="structdai_1_1fo__abs.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__exp.html">fo_exp</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function object that takes the exponent.  <a href="structdai_1_1fo__exp.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__log.html">fo_log</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function object that takes the logarithm.  <a href="structdai_1_1fo__log.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__log0.html">fo_log0</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function object that takes the logarithm, except that log(0) is defined to be 0.  <a href="structdai_1_1fo__log0.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__inv.html">fo_inv</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function object that takes the inverse.  <a href="structdai_1_1fo__inv.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__inv0.html">fo_inv0</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function object that takes the inverse, except that 1/0 is defined to be 0.  <a href="structdai_1_1fo__inv0.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__plog0p.html">fo_plog0p</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function object that returns p*log0(p).  <a href="structdai_1_1fo__plog0p.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__divides0.html">fo_divides0</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function object similar to std::divides(), but different in that dividing by zero results in zero.  <a href="structdai_1_1fo__divides0.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__KL.html">fo_KL</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function object useful for calculating the KL distance.  <a href="structdai_1_1fo__KL.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__Hellinger.html">fo_Hellinger</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function object useful for calculating the Hellinger distance.  <a href="structdai_1_1fo__Hellinger.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__pow.html">fo_pow</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function object that returns x to the power y.  <a href="structdai_1_1fo__pow.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__max.html">fo_max</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function object that returns the maximum of two values.  <a href="structdai_1_1fo__max.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__min.html">fo_min</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function object that returns the minimum of two values.  <a href="structdai_1_1fo__min.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__absdiff.html">fo_absdiff</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function object that returns the absolute difference of x and y.  <a href="structdai_1_1fo__absdiff.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html">TProb</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a vector with entries of type <em>T</em>.  <a href="classdai_1_1TProb.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1PropertySet.html">PropertySet</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a set of properties, mapping keys (of type PropertyKey) to values (of type PropertyValue).  <a href="classdai_1_1PropertySet.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1Region.html">Region</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <a class="el" href="classdai_1_1Region.html" title="A Region is a set of variables with a counting number.">Region</a> is a set of variables with a counting number.  <a href="classdai_1_1Region.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1FRegion.html">FRegion</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An <a class="el" href="classdai_1_1FRegion.html" title="An FRegion is a factor with a counting number.">FRegion</a> is a factor with a counting number.  <a href="classdai_1_1FRegion.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1RegionGraph.html">RegionGraph</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <a class="el" href="classdai_1_1RegionGraph.html" title="A RegionGraph combines a bipartite graph consisting of outer regions (type FRegion)...">RegionGraph</a> combines a bipartite graph consisting of outer regions (type <a class="el" href="classdai_1_1FRegion.html" title="An FRegion is a factor with a counting number.">FRegion</a>) and inner regions (type <a class="el" href="classdai_1_1Region.html" title="A Region is a set of variables with a counting number.">Region</a>) with a <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a>.  <a href="classdai_1_1RegionGraph.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1SmallSet.html">SmallSet</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a set; the implementation is optimized for a small number of elements.  <a href="classdai_1_1SmallSet.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TreeEP.html">TreeEP</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Approximate inference algorithm "Tree Expectation Propagation" [<a class="el" href="bibliography.html#MiQ04">MiQ04</a>].  <a href="classdai_1_1TreeEP.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TRWBP.html">TRWBP</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Approximate inference algorithm "Tree-Reweighted Belief Propagation" [<a class="el" href="bibliography.html#WJW03">WJW03</a>].  <a href="classdai_1_1TRWBP.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1hash__map.html">hash_map</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classdai_1_1hash__map.html" title="hash_map is an alias for std::tr1::unordered_map.">hash_map</a> is an alias for <code>std::tr1::unordered_map</code>.  <a href="classdai_1_1hash__map.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1Var.html">Var</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a discrete random variable.  <a href="classdai_1_1Var.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1VarSet.html">VarSet</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a set of variables.  <a href="classdai_1_1VarSet.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1DEdge.html">DEdge</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a directed edge.  <a href="classdai_1_1DEdge.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1UEdge.html">UEdge</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents an undirected edge.  <a href="classdai_1_1UEdge.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1GraphEL.html">GraphEL</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents an undirected graph, implemented as a std::set of undirected edges.  <a href="classdai_1_1GraphEL.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1WeightedGraph.html">WeightedGraph</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents an undirected weighted graph, with weights of type <em>T</em>, implemented as a std::map mapping undirected edges to weights.  <a href="classdai_1_1WeightedGraph.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1RootedTree.html">RootedTree</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a rooted tree, implemented as a vector of directed edges.  <a href="classdai_1_1RootedTree.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structdai_1_1BipartiteGraph_1_1Neighbor.html">BipartiteGraph::Neighbor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a31db26b11f9f932d51ac93ade4db5099">Neighbor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience typedef.  <a href="#a31db26b11f9f932d51ac93ade4db5099"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::minstd_rand&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ad2fa14208786f0746805efc9fbf3e56e">_rnd_gen_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of global random number generator.  <a href="#ad2fa14208786f0746805efc9fbf3e56e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classdai_1_1DAIAlg.html">DAIAlg</a>&lt; <a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a4d66d71f2b2c7ac4845bba057eb7cee5">DAIAlgFG</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for inference algorithms that operate on a <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a>.  <a href="#a4d66d71f2b2c7ac4845bba057eb7cee5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classdai_1_1DAIAlg.html">DAIAlg</a>&lt; <a class="el" href="classdai_1_1RegionGraph.html">RegionGraph</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a6b5cb6d79a324915d2c88ad368437e21">DAIAlgRG</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for inference algorithms that operate on a <a class="el" href="classdai_1_1RegionGraph.html" title="A RegionGraph combines a bipartite graph consisting of outer regions (type FRegion)...">RegionGraph</a>.  <a href="#a6b5cb6d79a324915d2c88ad368437e21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classdai_1_1TFactor.html">TFactor</a>&lt; <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a7515abf9952cd312e95a34ada0670e85">Factor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a factor with values of type <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf" title="Real number (alias for double, which could be changed to long double if necessary)...">dai::Real</a>.  <a href="#a7515abf9952cd312e95a34ada0670e85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classdai_1_1TProb.html">TProb</a>&lt; <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a90f06137ef74bb483e30ee2c7e31b2c8">Prob</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a vector with entries of type <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf" title="Real number (alias for double, which could be changed to long double if necessary)...">dai::Real</a>.  <a href="#a90f06137ef74bb483e30ee2c7e31b2c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#acc877a85f4f4dbb6a0d58c434bb2b996">PropertyKey</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of the key of a Property.  <a href="#acc877a85f4f4dbb6a0d58c434bb2b996"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::any&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#aeb056b768d73d02c5796c4012f4170c7">PropertyValue</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of the value of a Property.  <a href="#aeb056b768d73d02c5796c4012f4170c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; <a class="el" href="namespacedai.html#acc877a85f4f4dbb6a0d58c434bb2b996">PropertyKey</a>, <br class="typebreak"/>
<a class="el" href="namespacedai.html#aeb056b768d73d02c5796c4012f4170c7">PropertyValue</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#acbc670414e04eecf5c284e42d9d036e3">Property</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A Property is a pair of a key and a corresponding value.  <a href="#acbc670414e04eecf5c284e42d9d036e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Real number (alias for <code>double</code>, which could be changed to <code>long double</code> if necessary).  <a href="#ae7d0472fdc89a8635825d01940e91cbf"></a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ae0d0ef753bd0ba57586e556ab6312677">ProbNormType</a> { <b>NORMPROB</b>, 
<b>NORMLINF</b>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Enumerates different ways of normalizing a probability measure. </p>
 <a href="namespacedai.html#ae0d0ef753bd0ba57586e556ab6312677">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#aa2735a823696443089d2de23e8ee6ecb">ProbDistType</a> { <br/>
&nbsp;&nbsp;<b>DISTL1</b>, 
<b>DISTLINF</b>, 
<b>DISTTV</b>, 
<b>DISTKL</b>, 
<br/>
&nbsp;&nbsp;<b>DISTHEL</b>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Enumerates different distance measures between probability measures. </p>
 <a href="namespacedai.html#aa2735a823696443089d2de23e8ee6ecb">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a4b9e5254e7ec388e69aa68dfc54509e0">newInfAlg</a> (const std::string &amp;name, const <a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a> &amp;fg, const <a class="el" href="classdai_1_1PropertySet.html">PropertySet</a> &amp;opts)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a new inference algorithm.  <a href="#a4b9e5254e7ec388e69aa68dfc54509e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a246c23914fee45f8b7f01f9073bdd6fe">newInfAlgFromString</a> (const std::string &amp;nameOpts, const <a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a> &amp;fg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a new inference algorithm.  <a href="#a246c23914fee45f8b7f01f9073bdd6fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#af688c62fd7c8dff22e24835547cec7e7">newInfAlgFromString</a> (const std::string &amp;nameOpts, const <a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a> &amp;fg, const std::map&lt; std::string, std::string &gt; &amp;aliases)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a new inference algorithm.  <a href="#af688c62fd7c8dff22e24835547cec7e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, <br class="typebreak"/>
<a class="el" href="classdai_1_1PropertySet.html">PropertySet</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a8f6e164a012fff145d683d64ac4d7b7f">parseNameProperties</a> (const std::string &amp;s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extracts the name and property set from a string <em>s</em> in the format "name[key1=val1,key2=val2,...]" or "name".  <a href="#a8f6e164a012fff145d683d64ac4d7b7f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, <br class="typebreak"/>
<a class="el" href="classdai_1_1PropertySet.html">PropertySet</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a18ef8153f219f1cad48e4f1f1a00a2a6">parseNameProperties</a> (const std::string &amp;s, const std::map&lt; std::string, std::string &gt; &amp;aliases)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extracts the name and property set from a string <em>s</em> in the format "name[key1=val1,key2=val2,...]" or "name", performing alias substitution.  <a href="#a18ef8153f219f1cad48e4f1f1a00a2a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <br class="typebreak"/>
std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#afffceb04ae10c57ff54a9c57ac3bfc29">readAliasesFile</a> (const std::string &amp;filename)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads aliases from file named <em>filename</em>.  <a href="#afffceb04ae10c57ff54a9c57ac3bfc29"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#acfb030b9c48de7885795f4d03d7226ee">getFactorEntryForState</a> (const <a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a> &amp;fg, size_t I, const vector&lt; size_t &gt; &amp;state)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the entry of the I'th factor corresponding to a global state.  <a href="#acfb030b9c48de7885795f4d03d7226ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6154e193b6b0581b1552728a03b26f39"></a><!-- doxytag: member="dai::numericBBPTest" ref="a6154e193b6b0581b1552728a03b26f39" args="(const InfAlg &amp;bp, const std::vector&lt; size_t &gt; *state, const PropertySet &amp;bbp_props, const BBPCostFunction &amp;cfn, Real h)" -->
<a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>numericBBPTest</b> (const <a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> &amp;bp, const std::vector&lt; size_t &gt; *state, const <a class="el" href="classdai_1_1PropertySet.html">PropertySet</a> &amp;bbp_props, const <a class="el" href="classdai_1_1BBPCostFunction.html">BBPCostFunction</a> &amp;cfn, <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> h)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a7796e22fdea01e8fe5e4d51b85ae0548">complement</a> (vector&lt; size_t &gt; &amp;xis, size_t n_states)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a sorted vector of states <em>xis</em> and total state count <em>n_states</em>, return a vector of states not in <em>xis</em>.  <a href="#a7796e22fdea01e8fe5e4d51b85ae0548"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a1091a5da35d620692783a17dbf265158">unSoftMax</a> (<a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> a, <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$\frac{\exp(a)}{\exp(a)+\exp(b)}$" src="form_0.png"/>.  <a href="#a1091a5da35d620692783a17dbf265158"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a56e006b34155719d5ab9c0dbc9bd57f4">logSumExp</a> (<a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> a, <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes log of sum of exponents, i.e., <img class="formulaInl" alt="$\log\left(\exp(a) + \exp(b)\right)$" src="form_1.png"/>.  <a href="#a56e006b34155719d5ab9c0dbc9bd57f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#aee9a0cc9279a7add0849f964e3bdfbed">dist</a> (const vector&lt; <a class="el" href="classdai_1_1TFactor.html">Factor</a> &gt; &amp;b1, const vector&lt; <a class="el" href="classdai_1_1TFactor.html">Factor</a> &gt; &amp;b2, size_t nv)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute sum of pairwise L-infinity distances of the first <em>nv</em> factors in each vector.  <a href="#aee9a0cc9279a7add0849f964e3bdfbed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static vector&lt; <a class="el" href="classdai_1_1TFactor.html">Factor</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#aadf664acf42371b8f25ade335a805da1">mixBeliefs</a> (<a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> p, const vector&lt; <a class="el" href="classdai_1_1TFactor.html">Factor</a> &gt; &amp;b, const vector&lt; <a class="el" href="classdai_1_1TFactor.html">Factor</a> &gt; &amp;c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates a vector of mixtures p * b + (1-p) * c.  <a href="#aadf664acf42371b8f25ade335a805da1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab41645939efa15bb66b14e20d1641c8f"></a><!-- doxytag: member="dai::BBPFindClampVar" ref="ab41645939efa15bb66b14e20d1641c8f" args="(const InfAlg &amp;in_bp, bool clampingVar, const PropertySet &amp;bbp_props, const BBPCostFunction &amp;cfn, Real *maxVarOut)" -->
std::pair&lt; size_t, size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>BBPFindClampVar</b> (const <a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> &amp;in_bp, bool clampingVar, const <a class="el" href="classdai_1_1PropertySet.html">PropertySet</a> &amp;bbp_props, const <a class="el" href="classdai_1_1BBPCostFunction.html">BBPCostFunction</a> &amp;cfn, <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> *maxVarOut)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#abb00ff16fe071140d9eb4c555c43e5d3">eliminationCost_MinNeighbors</a> (const <a class="el" href="classdai_1_1ClusterGraph.html">ClusterGraph</a> &amp;cl, size_t i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates cost of eliminating the <em>i</em> 'th variable from cluster graph <em>cl</em> according to the "MinNeighbors" criterion.  <a href="#abb00ff16fe071140d9eb4c555c43e5d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a68ec048cdbefcf8a488469dd14938452">eliminationCost_MinWeight</a> (const <a class="el" href="classdai_1_1ClusterGraph.html">ClusterGraph</a> &amp;cl, size_t i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates cost of eliminating the <em>i</em> 'th variable from cluster graph <em>cl</em> according to the "MinWeight" criterion.  <a href="#a68ec048cdbefcf8a488469dd14938452"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ab6cfdf0bf047e72e324c04e96d310edb">eliminationCost_MinFill</a> (const <a class="el" href="classdai_1_1ClusterGraph.html">ClusterGraph</a> &amp;cl, size_t i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates cost of eliminating the <em>i</em> 'th variable from cluster graph <em>cl</em> according to the "MinFill" criterion.  <a href="#ab6cfdf0bf047e72e324c04e96d310edb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a990ea70014c5c6a90932d9cee11f393b">eliminationCost_WeightedMinFill</a> (const <a class="el" href="classdai_1_1ClusterGraph.html">ClusterGraph</a> &amp;cl, size_t i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates cost of eliminating the <em>i</em> 'th variable from cluster graph <em>cl</em> according to the "WeightedMinFill" criterion.  <a href="#a990ea70014c5c6a90932d9cee11f393b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TFactor.html">Factor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#aab8aabfe0fcfd4b4bd24757c101449d5">calcMarginal</a> (const <a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> &amp;obj, const <a class="el" href="classdai_1_1VarSet.html">VarSet</a> &amp;vs, bool reInit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates the marginal probability distribution for <em>vs</em> using inference algorithm <em>obj</em>.  <a href="#aab8aabfe0fcfd4b4bd24757c101449d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classdai_1_1TFactor.html">Factor</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a82e775a1e2908856f13fa1aa7c081d4c">calcPairBeliefs</a> (const <a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> &amp;obj, const <a class="el" href="classdai_1_1VarSet.html">VarSet</a> &amp;vs, bool reInit, bool accurate=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates beliefs for all pairs of variables in <em>vs</em> using inference algorithm <em>obj</em>.  <a href="#a82e775a1e2908856f13fa1aa7c081d4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TFactor.html">Factor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a7dd9cb2405e798802d8cbb9b879fdf90">createFactorIsing</a> (const <a class="el" href="classdai_1_1Var.html">Var</a> &amp;x, <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> h)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a binary unnormalized single-variable factor <img class="formulaInl" alt="$ \exp(hx) $" src="form_69.png"/> where <img class="formulaInl" alt="$ x = \pm 1 $" src="form_70.png"/>.  <a href="#a7dd9cb2405e798802d8cbb9b879fdf90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TFactor.html">Factor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ade7f623237328458325bce5322abe03e">createFactorIsing</a> (const <a class="el" href="classdai_1_1Var.html">Var</a> &amp;x1, const <a class="el" href="classdai_1_1Var.html">Var</a> &amp;x2, <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> J)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a binary unnormalized pairwise factor <img class="formulaInl" alt="$ \exp(J x_1 x_2) $" src="form_71.png"/> where <img class="formulaInl" alt="$ x_1, x_2 = \pm 1 $" src="form_72.png"/>.  <a href="#ade7f623237328458325bce5322abe03e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TFactor.html">Factor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a6715831e60e66582bce1c69518a40dd3">createFactorExpGauss</a> (const <a class="el" href="classdai_1_1VarSet.html">VarSet</a> &amp;vs, <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> beta)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a random factor on the variables <em>vs</em> with strength <em>beta</em>.  <a href="#a6715831e60e66582bce1c69518a40dd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TFactor.html">Factor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#aab6d25e30baf39ea06c57b5f71c61a4e">createFactorPotts</a> (const <a class="el" href="classdai_1_1Var.html">Var</a> &amp;x1, const <a class="el" href="classdai_1_1Var.html">Var</a> &amp;x2, <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> J)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pairwise Potts factor <img class="formulaInl" alt="$ \exp( J \delta_{x_1, x_2} ) $" src="form_73.png"/>.  <a href="#aab6d25e30baf39ea06c57b5f71c61a4e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TFactor.html">Factor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#adf624997c47362bc5db95242b76a66a4">createFactorDelta</a> (const <a class="el" href="classdai_1_1Var.html">Var</a> &amp;v, size_t state)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a Kronecker delta point mass.  <a href="#adf624997c47362bc5db95242b76a66a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a57fa52134afbd3da21c99975fbba7080">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a> &amp;fg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a> to an output stream.  <a href="#a57fa52134afbd3da21c99975fbba7080"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::istream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ab1b9d59848e415c32330d4a7cbb3269a">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a> &amp;fg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads a <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a> from an input stream.  <a href="#ab1b9d59848e415c32330d4a7cbb3269a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8a59103fe8bdd638f90c81ae1512177"></a><!-- doxytag: member="dai::getGibbsState" ref="ab8a59103fe8bdd638f90c81ae1512177" args="(const FactorGraph &amp;fg, size_t iters)" -->
std::vector&lt; size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>getGibbsState</b> (const <a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a> &amp;fg, size_t iters)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#aedbe32ae13acdd8b62050b18e81a53ea">createGraphFull</a> (size_t N)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a fully-connected graph with <em>N</em> nodes.  <a href="#aedbe32ae13acdd8b62050b18e81a53ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#aaeeffaf06b9cd2fecccaf2bf773baed7">createGraphGrid</a> (size_t N1, size_t N2, bool periodic)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a two-dimensional rectangular grid of <em>N1</em> by <em>N2</em> nodes, which can be <em>periodic</em>.  <a href="#aaeeffaf06b9cd2fecccaf2bf773baed7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a9950d08bd6190ea12f50b4be6f2584cf">createGraphGrid3D</a> (size_t N1, size_t N2, size_t N3, bool periodic)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a three-dimensional rectangular grid of <em>N1</em> by <em>N2</em> by <em>N3</em> nodes, which can be <em>periodic</em>.  <a href="#a9950d08bd6190ea12f50b4be6f2584cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a7f65fc1665a6fa04b1b6897a4551bccc">createGraphLoop</a> (size_t N)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a graph consisting of a single loop of <em>N</em> nodes.  <a href="#a7f65fc1665a6fa04b1b6897a4551bccc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ad3fbe55f9fdb020e7a2b04f1d2451d20">createGraphTree</a> (size_t N)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a random tree-structured graph of <em>N</em> nodes.  <a href="#ad3fbe55f9fdb020e7a2b04f1d2451d20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#abfd6bb3f4b6135a99a68b9b13bee8bae">createGraphRegular</a> (size_t N, size_t d)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a random regular graph of <em>N</em> nodes with uniform connectivity <em>d</em>.  <a href="#abfd6bb3f4b6135a99a68b9b13bee8bae"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TFactor.html">TFactor</a>&lt; T &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#a847e3cef4f6660bb027e9a3978277a2b">makePositive</a> (<a class="el" href="classdai_1_1TFactor.html">TFactor</a>&lt; T &gt; &amp;f, T epsilon)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets factor entries that lie between 0 and <em>epsilon</em> to <em>epsilon</em>.  <a href="#a847e3cef4f6660bb027e9a3978277a2b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TFactor.html">TFactor</a>&lt; T &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#a1c7d5fa66149e0e508711f68bac11b5f">makeZero</a> (<a class="el" href="classdai_1_1TFactor.html">TFactor</a>&lt; T &gt; &amp;f, T epsilon)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets factor entries that are smaller (in absolute value) than <em>epsilon</em> to 0.  <a href="#a1c7d5fa66149e0e508711f68bac11b5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34858e579c64924a7cd80309acb01f66"></a><!-- doxytag: member="dai::boundTreewidth" ref="a34858e579c64924a7cd80309acb01f66" args="(const FactorGraph &amp;fg, greedyVariableElimination::eliminationCostFunction fn)" -->
std::pair&lt; size_t, double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>boundTreewidth</b> (const <a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a> &amp;fg, <a class="el" href="classdai_1_1greedyVariableElimination.html#a367d3a2c003842d28e27f10d9c0ea3fb">greedyVariableElimination::eliminationCostFunction</a> fn)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ac63c2f1d67d01aeda5c3cdd95843ea86">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="namespacedai.html#acbc670414e04eecf5c284e42d9d036e3">Property</a> &amp;p)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a Property object (key-value pair) to an output stream.  <a href="#ac63c2f1d67d01aeda5c3cdd95843ea86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ab339baefa9f588de2fba07526d8df7ba">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdai_1_1PropertySet.html">PropertySet</a> &amp;ps)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a <a class="el" href="classdai_1_1PropertySet.html" title="Represents a set of properties, mapping keys (of type PropertyKey) to values (of...">PropertySet</a> object to an output stream.  <a href="#ab339baefa9f588de2fba07526d8df7ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::istream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#aab0479dd285fd4021ecaa80947d40da3">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classdai_1_1PropertySet.html">PropertySet</a> &amp;ps)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads a <a class="el" href="classdai_1_1PropertySet.html" title="Represents a set of properties, mapping keys (of type PropertyKey) to values (of...">PropertySet</a> object from an input stream, storing values as strings.  <a href="#aab0479dd285fd4021ecaa80947d40da3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a0e910ae9247869ee549df8eed173a6df">operator&lt;&lt;</a> (ostream &amp;os, const <a class="el" href="classdai_1_1RegionGraph.html">RegionGraph</a> &amp;rg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send <a class="el" href="classdai_1_1RegionGraph.html" title="A RegionGraph combines a bipartite graph consisting of outer regions (type FRegion)...">RegionGraph</a> to output stream.  <a href="#a0e910ae9247869ee549df8eed173a6df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ab27c0799ddef29bb3833477e32c53862">toc</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns wall clock time in seconds.  <a href="#ab27c0799ddef29bb3833477e32c53862"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedai.html#ad2fa14208786f0746805efc9fbf3e56e">_rnd_gen_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a8676cd0faacaec12b2acf0e0472e3280">_rnd_gen</a> (42U)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Global random number generator.  <a href="#a8676cd0faacaec12b2acf0e0472e3280"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boost::uniform_real&lt; <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a2cff7aad0084432ddcc7ef52618b74bd">_uni_dist</a> (0, 1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uniform distribution with values between 0 and 1 (0 inclusive, 1 exclusive).  <a href="#a2cff7aad0084432ddcc7ef52618b74bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boost::variate_generator<br class="typebreak"/>
&lt; <a class="el" href="namespacedai.html#ad2fa14208786f0746805efc9fbf3e56e">_rnd_gen_type</a> <br class="typebreak"/>
&amp;, boost::uniform_real&lt; <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a95e934001307cafa4576b31fb0569e2c">_uni_rnd</a> (_rnd_gen, _uni_dist)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Global uniform random random number.  <a href="#a95e934001307cafa4576b31fb0569e2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boost::variate_generator<br class="typebreak"/>
&lt; <a class="el" href="namespacedai.html#ad2fa14208786f0746805efc9fbf3e56e">_rnd_gen_type</a> <br class="typebreak"/>
&amp;, boost::normal_distribution<br class="typebreak"/>
&lt; <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a205aca5e7688c28a95ecc978b4f79879">_normal_rnd</a> (_rnd_gen, <a class="el" href="namespacedai.html#a72200157ce1fbccfe91f66a3f8416823">_normal_dist</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Global random number generator with standard normal distribution.  <a href="#a205aca5e7688c28a95ecc978b4f79879"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ae699eca7ca4d6e971b54c2b4a95942d4">rnd_seed</a> (size_t seed)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the random seed.  <a href="#ae699eca7ca4d6e971b54c2b4a95942d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a129f3a9c518c632c985d045a4f8c60f9">rnd_uniform</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a real number, distributed uniformly on [0,1).  <a href="#a129f3a9c518c632c985d045a4f8c60f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ac3f6d317ca42fbb4b643aa8c82692d74">rnd_stdnormal</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a real number from a standard-normal distribution.  <a href="#ac3f6d317ca42fbb4b643aa8c82692d74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ac02317b960b112637976333f90d1f937">rnd_int</a> (int min, int max)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a random integer in interval [<em>min</em>, <em>max</em>].  <a href="#ac02317b960b112637976333f90d1f937"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a98aff76f2fef44c6d8d240e52e0d4651">tokenizeString</a> (const std::string &amp;s, std::vector&lt; std::string &gt; &amp;outTokens, const std::string &amp;delim=&quot;\t\n&quot;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Split a string into tokens delimited by one of the characters in <em>delim</em>.  <a href="#a98aff76f2fef44c6d8d240e52e0d4651"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a750c3807e7375265c3fb410a1f1223fe">calcLinearState</a> (const <a class="el" href="classdai_1_1VarSet.html">VarSet</a> &amp;vs, const std::map&lt; <a class="el" href="classdai_1_1Var.html">Var</a>, size_t &gt; &amp;state)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates the linear index in the Cartesian product of the variables in <em>vs</em> that corresponds to a particular joint assignment of the variables, specified by <em>state</em>.  <a href="#a750c3807e7375265c3fb410a1f1223fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="classdai_1_1Var.html">Var</a>, size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#afcfc874f85b4a2944ec128ebd1dd19f1">calcState</a> (const <a class="el" href="classdai_1_1VarSet.html">VarSet</a> &amp;vs, size_t linearState)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates the joint assignment of the variables in <em>vs</em> corresponding to the linear index <em>linearState</em>.  <a href="#afcfc874f85b4a2944ec128ebd1dd19f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1GraphEL.html">GraphEL</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#af26283612a1f256c2c4fa1eaafc0b7ce">RandomDRegularGraph</a> (size_t N, size_t d)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a random undirected graph of <em>N</em> nodes, where each node has connectivity <em>d</em>.  <a href="#af26283612a1f256c2c4fa1eaafc0b7ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">mxArray *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ae62bf4dfaa6694edc2d180b71656d430">Factors2mx</a> (const std::vector&lt; <a class="el" href="classdai_1_1TFactor.html">Factor</a> &gt; &amp;Ps)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert vector&lt;Factor&gt; structure to a cell vector of CPTAB-like structs.  <a href="#ae62bf4dfaa6694edc2d180b71656d430"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classdai_1_1TFactor.html">Factor</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#abdd1a935e89ca8dc1d4e0c1cea371d44">mx2Factors</a> (const mxArray *psi, long verbose)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert cell vector of CPTAB-like structs to vector&lt;Factor&gt;  <a href="#abdd1a935e89ca8dc1d4e0c1cea371d44"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TFactor.html">Factor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a573a608f62779c1a08f8e10c3fa4e940">mx2Factor</a> (const mxArray *psi)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert CPTAB-like struct to Factor.  <a href="#a573a608f62779c1a08f8e10c3fa4e940"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#aef8d342ac50bdaed5d513df6349be31c">DAI_ENUM</a> (BBPCostFunctionBase, CFN_GIBBS_B, CFN_GIBBS_B2, CFN_GIBBS_EXP, CFN_GIBBS_B_FACTOR, CFN_GIBBS_B2_FACTOR, CFN_GIBBS_EXP_FACTOR, CFN_VAR_ENT, CFN_FACTOR_ENT, CFN_BETHE_ENT)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumeration of several cost functions that can be used with <a class="el" href="classdai_1_1BBP.html" title="Implements BBP (Back-Belief-Propagation) [EaG09].">BBP</a>.  <a href="#aef8d342ac50bdaed5d513df6349be31c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a934491ad55f57c9072271b4a32ea4919">log</a> (<a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns logarithm of <em>x</em>.  <a href="#a934491ad55f57c9072271b4a32ea4919"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a00375a4d7b55534c14f993c909b04c3c">log0</a> (<a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns logarithm of <em>x</em>, or 0 if <em>x</em> == 0.  <a href="#a00375a4d7b55534c14f993c909b04c3c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ac336ffb182b6e6fa3f7df13620aab012">exp</a> (<a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns exponent of <em>x</em>.  <a href="#ac336ffb182b6e6fa3f7df13620aab012"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a16465ce3d62a6456fd06e9a226c966f2">pow</a> (<a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> x, <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <em>to</em> the power <em>y</em>.  <a href="#a16465ce3d62a6456fd06e9a226c966f2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#abc859d9510bf6f58fc066c33ae8f7492">abs</a> (const T &amp;t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns absolute value of <em>t</em>.  <a href="#abc859d9510bf6f58fc066c33ae8f7492"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#affae7aacdd26b4a580fbb8790cbccc86">rnd</a> (int n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a random integer in the half-open interval [0, <em>n</em>).  <a href="#affae7aacdd26b4a580fbb8790cbccc86"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#a039689f5b5f4a2f34479fd1a8fd21b8a">toString</a> (const T &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a variable of type <em>T</em> to a <code>std::string</code> by using a <code>std::stringstream</code>.  <a href="#a039689f5b5f4a2f34479fd1a8fd21b8a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#a1a0b1c88c46fb8763c2c783cc3fe9a62">operator&lt;&lt;</a> (std::ostream &amp;os, const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a <code>std::vector&lt;&gt;</code> to a <code>std::ostream</code>.  <a href="#a1a0b1c88c46fb8763c2c783cc3fe9a62"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#a4f8ad5d0c47c7fdfe17e5d0f4c0a32d9">operator&lt;&lt;</a> (std::ostream &amp;os, const std::set&lt; T &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a <code>std::set&lt;&gt;</code> to a <code>std::ostream</code>.  <a href="#a4f8ad5d0c47c7fdfe17e5d0f4c0a32d9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#a5913957fb1c3c3d3fbd1f3102b8eb04c">operator&lt;&lt;</a> (std::ostream &amp;os, const std::map&lt; T1, T2 &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a <code>std::map&lt;&gt;</code> to a <code>std::ostream</code>.  <a href="#a5913957fb1c3c3d3fbd1f3102b8eb04c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#a575f6202aa88de6bf5146b85d8832eb5">operator&lt;&lt;</a> (std::ostream &amp;os, const std::pair&lt; T1, T2 &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a <code>std::pair&lt;&gt;</code> to a <code>std::ostream</code>.  <a href="#a575f6202aa88de6bf5146b85d8832eb5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#aae335872c5de8c4d1f21833cbe5c0020">concat</a> (const std::vector&lt; T &gt; &amp;u, const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concatenates two vectors.  <a href="#aae335872c5de8c4d1f21833cbe5c0020"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1RootedTree.html">RootedTree</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#a273d7118dd690f5b438fba18f6860eb6">MinSpanningTree</a> (const <a class="el" href="classdai_1_1WeightedGraph.html">WeightedGraph</a>&lt; T &gt; &amp;G, bool usePrim)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a minimum spanning tree from the (non-negatively) weighted graph <em>G</em>.  <a href="#a273d7118dd690f5b438fba18f6860eb6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1RootedTree.html">RootedTree</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#a1914ae414d452b1844e6cd72f70501b5">MaxSpanningTree</a> (const <a class="el" href="classdai_1_1WeightedGraph.html">WeightedGraph</a>&lt; T &gt; &amp;G, bool usePrim)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a minimum spanning tree from the (non-negatively) weighted graph <em>G</em>.  <a href="#a1914ae414d452b1844e6cd72f70501b5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1RootedTree.html">RootedTree</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#a673056614abf3f5e48558709a5c97904">MinSpanningTree</a> (const <a class="el" href="classdai_1_1WeightedGraph.html">WeightedGraph</a>&lt; T &gt; &amp;G)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a minimum spanning tree from the (non-negatively) weighted graph <em>G</em> using Prim's algorithm.  <a href="#a673056614abf3f5e48558709a5c97904"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1RootedTree.html">RootedTree</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#a23a213d552dc1025647b8c5661393ac4">MaxSpanningTree</a> (const <a class="el" href="classdai_1_1WeightedGraph.html">WeightedGraph</a>&lt; T &gt; &amp;G)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a minimum spanning tree from the (non-negatively) weighted graph <em>G</em> using Prim's algorithm.  <a href="#a23a213d552dc1025647b8c5661393ac4"></a><br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boost::normal_distribution&lt; <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a72200157ce1fbccfe91f66a3f8416823">_normal_dist</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normal distribution with mean 0 and standard deviation 1.  <a href="#a72200157ce1fbccfe91f66a3f8416823"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#afaf76457d5d1ad9cfd37feb44ae94669">DAINames</a> []</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contains the names of all inference algorithms compiled into libDAI.  <a href="#afaf76457d5d1ad9cfd37feb44ae94669"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Namespace for libDAI. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a31db26b11f9f932d51ac93ade4db5099"></a><!-- doxytag: member="dai::Neighbor" ref="a31db26b11f9f932d51ac93ade4db5099" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structdai_1_1BipartiteGraph_1_1Neighbor.html">BipartiteGraph::Neighbor</a> <a class="el" href="structdai_1_1BipartiteGraph_1_1Neighbor.html">dai::Neighbor</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience typedef. </p>

</div>
</div>
<a class="anchor" id="ad2fa14208786f0746805efc9fbf3e56e"></a><!-- doxytag: member="dai::_rnd_gen_type" ref="ad2fa14208786f0746805efc9fbf3e56e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::minstd_rand <a class="el" href="namespacedai.html#ad2fa14208786f0746805efc9fbf3e56e">dai::_rnd_gen_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of global random number generator. </p>

</div>
</div>
<a class="anchor" id="a4d66d71f2b2c7ac4845bba057eb7cee5"></a><!-- doxytag: member="dai::DAIAlgFG" ref="a4d66d71f2b2c7ac4845bba057eb7cee5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classdai_1_1DAIAlg.html">DAIAlg</a>&lt;<a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a>&gt; <a class="el" href="classdai_1_1DAIAlg.html">dai::DAIAlgFG</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Base class for inference algorithms that operate on a <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a>. </p>

</div>
</div>
<a class="anchor" id="a6b5cb6d79a324915d2c88ad368437e21"></a><!-- doxytag: member="dai::DAIAlgRG" ref="a6b5cb6d79a324915d2c88ad368437e21" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classdai_1_1DAIAlg.html">DAIAlg</a>&lt;<a class="el" href="classdai_1_1RegionGraph.html">RegionGraph</a>&gt; <a class="el" href="classdai_1_1DAIAlg.html">dai::DAIAlgRG</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Base class for inference algorithms that operate on a <a class="el" href="classdai_1_1RegionGraph.html" title="A RegionGraph combines a bipartite graph consisting of outer regions (type FRegion)...">RegionGraph</a>. </p>

</div>
</div>
<a class="anchor" id="a7515abf9952cd312e95a34ada0670e85"></a><!-- doxytag: member="dai::Factor" ref="a7515abf9952cd312e95a34ada0670e85" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classdai_1_1TFactor.html">TFactor</a>&lt;<a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&gt; <a class="el" href="classdai_1_1TFactor.html">dai::Factor</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Represents a factor with values of type <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf" title="Real number (alias for double, which could be changed to long double if necessary)...">dai::Real</a>. </p>

</div>
</div>
<a class="anchor" id="a90f06137ef74bb483e30ee2c7e31b2c8"></a><!-- doxytag: member="dai::Prob" ref="a90f06137ef74bb483e30ee2c7e31b2c8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classdai_1_1TProb.html">TProb</a>&lt;<a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&gt; <a class="el" href="classdai_1_1TProb.html">dai::Prob</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Represents a vector with entries of type <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf" title="Real number (alias for double, which could be changed to long double if necessary)...">dai::Real</a>. </p>

</div>
</div>
<a class="anchor" id="acc877a85f4f4dbb6a0d58c434bb2b996"></a><!-- doxytag: member="dai::PropertyKey" ref="acc877a85f4f4dbb6a0d58c434bb2b996" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::string <a class="el" href="namespacedai.html#acc877a85f4f4dbb6a0d58c434bb2b996">dai::PropertyKey</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of the key of a Property. </p>

</div>
</div>
<a class="anchor" id="aeb056b768d73d02c5796c4012f4170c7"></a><!-- doxytag: member="dai::PropertyValue" ref="aeb056b768d73d02c5796c4012f4170c7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::any <a class="el" href="namespacedai.html#aeb056b768d73d02c5796c4012f4170c7">dai::PropertyValue</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of the value of a Property. </p>

</div>
</div>
<a class="anchor" id="acbc670414e04eecf5c284e42d9d036e3"></a><!-- doxytag: member="dai::Property" ref="acbc670414e04eecf5c284e42d9d036e3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;<a class="el" href="namespacedai.html#acc877a85f4f4dbb6a0d58c434bb2b996">PropertyKey</a>, <a class="el" href="namespacedai.html#aeb056b768d73d02c5796c4012f4170c7">PropertyValue</a>&gt; <a class="el" href="namespacedai.html#acbc670414e04eecf5c284e42d9d036e3">dai::Property</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A Property is a pair of a key and a corresponding value. </p>

</div>
</div>
<a class="anchor" id="ae7d0472fdc89a8635825d01940e91cbf"></a><!-- doxytag: member="dai::Real" ref="ae7d0472fdc89a8635825d01940e91cbf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">dai::Real</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Real number (alias for <code>double</code>, which could be changed to <code>long double</code> if necessary). </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="example_8cpp-example.html#a0">example.cpp</a>, <a class="el" href="example__sprinkler_8cpp-example.html#a9">example_sprinkler.cpp</a>, and <a class="el" href="example__sprinkler__em_8cpp-example.html#a11">example_sprinkler_em.cpp</a>.</dd>
</dl>
</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ae0d0ef753bd0ba57586e556ab6312677"></a><!-- doxytag: member="dai::ProbNormType" ref="ae0d0ef753bd0ba57586e556ab6312677" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedai.html#ae0d0ef753bd0ba57586e556ab6312677">dai::ProbNormType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enumerates different ways of normalizing a probability measure. </p>
<ul>
<li>NORMPROB means that the sum of all entries should be 1;</li>
<li>NORMLINF means that the maximum absolute value of all entries should be 1. </li>
</ul>

</div>
</div>
<a class="anchor" id="aa2735a823696443089d2de23e8ee6ecb"></a><!-- doxytag: member="dai::ProbDistType" ref="aa2735a823696443089d2de23e8ee6ecb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedai.html#aa2735a823696443089d2de23e8ee6ecb">dai::ProbDistType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enumerates different distance measures between probability measures. </p>
<ul>
<li>DISTL1 is the <img class="formulaInl" alt="$\ell_1$" src="form_118.png"/> distance (sum of absolute values of pointwise difference);</li>
<li>DISTLINF is the <img class="formulaInl" alt="$\ell_\infty$" src="form_119.png"/> distance (maximum absolute value of pointwise difference);</li>
<li>DISTTV is the total variation distance (half of the <img class="formulaInl" alt="$\ell_1$" src="form_118.png"/> distance);</li>
<li>DISTKL is the Kullback-Leibler distance (<img class="formulaInl" alt="$\sum_i p_i (\log p_i - \log q_i)$" src="form_120.png"/>).</li>
<li>DISTHEL is the Hellinger distance (<img class="formulaInl" alt="$\frac{1}{2}\sum_i (\sqrt{p_i}-\sqrt{q_i})^2$" src="form_121.png"/>). </li>
</ul>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a4b9e5254e7ec388e69aa68dfc54509e0"></a><!-- doxytag: member="dai::newInfAlg" ref="a4b9e5254e7ec388e69aa68dfc54509e0" args="(const std::string &amp;name, const FactorGraph &amp;fg, const PropertySet &amp;opts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> * dai::newInfAlg </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FactorGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PropertySet &amp;&nbsp;</td>
          <td class="paramname"> <em>opts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a new inference algorithm. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of the inference algorithm (should be one of the names in DAINames). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fg</em>&nbsp;</td><td>The <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a> that the algorithm should be applied to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opts</em>&nbsp;</td><td>A <a class="el" href="classdai_1_1PropertySet.html" title="Represents a set of properties, mapping keys (of type PropertyKey) to values (of...">PropertySet</a> specifying the options for the algorithm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a pointer to the new <a class="el" href="classdai_1_1InfAlg.html" title="InfAlg is an abstract base class, defining the common interface of all inference...">InfAlg</a> object; it is the responsibility of the caller to delete it later. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>UNKNOWN_DAI_ALGORITHM</em>&nbsp;</td><td>if the requested name is not known/compiled in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a246c23914fee45f8b7f01f9073bdd6fe"></a><!-- doxytag: member="dai::newInfAlgFromString" ref="a246c23914fee45f8b7f01f9073bdd6fe" args="(const std::string &amp;nameOpts, const FactorGraph &amp;fg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> * dai::newInfAlgFromString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>nameOpts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FactorGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>fg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a new inference algorithm. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nameOpts</em>&nbsp;</td><td>The name and options of the inference algorithm (should be in the format "name[key1=val1,key2=val2,...,keyn=valn]"). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fg</em>&nbsp;</td><td>The <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a> that the algorithm should be applied to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a pointer to the new <a class="el" href="classdai_1_1InfAlg.html" title="InfAlg is an abstract base class, defining the common interface of all inference...">InfAlg</a> object; it is the responsibility of the caller to delete it later. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>UNKNOWN_DAI_ALGORITHM</em>&nbsp;</td><td>if the requested name is not known/compiled in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af688c62fd7c8dff22e24835547cec7e7"></a><!-- doxytag: member="dai::newInfAlgFromString" ref="af688c62fd7c8dff22e24835547cec7e7" args="(const std::string &amp;nameOpts, const FactorGraph &amp;fg, const std::map&lt; std::string, std::string &gt; &amp;aliases)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> * dai::newInfAlgFromString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>nameOpts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FactorGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aliases</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a new inference algorithm. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nameOpts</em>&nbsp;</td><td>The name and options of the inference algorithm (should be in the format "name[key1=val1,key2=val2,...,keyn=valn]"). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fg</em>&nbsp;</td><td>The <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a> that the algorithm should be applied to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aliases</em>&nbsp;</td><td>Maps names to strings in the format "name[key1=val1,key2=val2,...,keyn=valn]"; if not empty, alias substitution will be performed when parsing <em>nameOpts</em> by invoking <a class="el" href="namespacedai.html#a18ef8153f219f1cad48e4f1f1a00a2a6" title="Extracts the name and property set from a string s in the format &quot;name[key1=val1...">parseNameProperties(const std::string &amp;,const std::map&lt;std::string,std::string&gt; &amp;)</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespacedai.html#a246c23914fee45f8b7f01f9073bdd6fe" title="Constructs a new inference algorithm.">newInfAlgFromString(const std::string &amp;, const FactorGraph &amp;)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8f6e164a012fff145d683d64ac4d7b7f"></a><!-- doxytag: member="dai::parseNameProperties" ref="a8f6e164a012fff145d683d64ac4d7b7f" args="(const std::string &amp;s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, <a class="el" href="classdai_1_1PropertySet.html">PropertySet</a> &gt; dai::parseNameProperties </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts the name and property set from a string <em>s</em> in the format "name[key1=val1,key2=val2,...]" or "name". </p>

</div>
</div>
<a class="anchor" id="a18ef8153f219f1cad48e4f1f1a00a2a6"></a><!-- doxytag: member="dai::parseNameProperties" ref="a18ef8153f219f1cad48e4f1f1a00a2a6" args="(const std::string &amp;s, const std::map&lt; std::string, std::string &gt; &amp;aliases)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, <a class="el" href="classdai_1_1PropertySet.html">PropertySet</a> &gt; dai::parseNameProperties </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aliases</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts the name and property set from a string <em>s</em> in the format "name[key1=val1,key2=val2,...]" or "name", performing alias substitution. </p>
<p>Alias substitution is performed as follows: as long as name appears as a key in <em>aliases</em>, it is substituted by its value. Properties in <em>s</em> override those of the alias (in case of recursion, the "outer" properties override those of the "inner" aliases). </p>

</div>
</div>
<a class="anchor" id="afffceb04ae10c57ff54a9c57ac3bfc29"></a><!-- doxytag: member="dai::readAliasesFile" ref="afffceb04ae10c57ff54a9c57ac3bfc29" args="(const std::string &amp;filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, std::string &gt; dai::readAliasesFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>filename</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads aliases from file named <em>filename</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>Name of the alias file </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A map that maps aliases to the strings they should be substituted with. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="fileformats.html#fileformats-aliases">Aliases file format</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acfb030b9c48de7885795f4d03d7226ee"></a><!-- doxytag: member="dai::getFactorEntryForState" ref="acfb030b9c48de7885795f4d03d7226ee" args="(const FactorGraph &amp;fg, size_t I, const vector&lt; size_t &gt; &amp;state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dai::getFactorEntryForState </td>
          <td>(</td>
          <td class="paramtype">const FactorGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; size_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>state</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the entry of the I'th factor corresponding to a global state. </p>

</div>
</div>
<a class="anchor" id="a7796e22fdea01e8fe5e4d51b85ae0548"></a><!-- doxytag: member="dai::complement" ref="a7796e22fdea01e8fe5e4d51b85ae0548" args="(vector&lt; size_t &gt; &amp;xis, size_t n_states)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;size_t&gt; dai::complement </td>
          <td>(</td>
          <td class="paramtype">vector&lt; size_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>xis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n_states</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a sorted vector of states <em>xis</em> and total state count <em>n_states</em>, return a vector of states not in <em>xis</em>. </p>

</div>
</div>
<a class="anchor" id="a1091a5da35d620692783a17dbf265158"></a><!-- doxytag: member="dai::unSoftMax" ref="a1091a5da35d620692783a17dbf265158" args="(Real a, Real b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> dai::unSoftMax </td>
          <td>(</td>
          <td class="paramtype">Real&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes <img class="formulaInl" alt="$\frac{\exp(a)}{\exp(a)+\exp(b)}$" src="form_0.png"/>. </p>

</div>
</div>
<a class="anchor" id="a56e006b34155719d5ab9c0dbc9bd57f4"></a><!-- doxytag: member="dai::logSumExp" ref="a56e006b34155719d5ab9c0dbc9bd57f4" args="(Real a, Real b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> dai::logSumExp </td>
          <td>(</td>
          <td class="paramtype">Real&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes log of sum of exponents, i.e., <img class="formulaInl" alt="$\log\left(\exp(a) + \exp(b)\right)$" src="form_1.png"/>. </p>

</div>
</div>
<a class="anchor" id="aee9a0cc9279a7add0849f964e3bdfbed"></a><!-- doxytag: member="dai::dist" ref="aee9a0cc9279a7add0849f964e3bdfbed" args="(const vector&lt; Factor &gt; &amp;b1, const vector&lt; Factor &gt; &amp;b2, size_t nv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> dai::dist </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; Factor &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; Factor &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute sum of pairwise L-infinity distances of the first <em>nv</em> factors in each vector. </p>

</div>
</div>
<a class="anchor" id="aadf664acf42371b8f25ade335a805da1"></a><!-- doxytag: member="dai::mixBeliefs" ref="aadf664acf42371b8f25ade335a805da1" args="(Real p, const vector&lt; Factor &gt; &amp;b, const vector&lt; Factor &gt; &amp;c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static vector&lt;<a class="el" href="classdai_1_1TFactor.html">Factor</a>&gt; dai::mixBeliefs </td>
          <td>(</td>
          <td class="paramtype">Real&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; Factor &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; Factor &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates a vector of mixtures p * b + (1-p) * c. </p>

</div>
</div>
<a class="anchor" id="abb00ff16fe071140d9eb4c555c43e5d3"></a><!-- doxytag: member="dai::eliminationCost_MinNeighbors" ref="abb00ff16fe071140d9eb4c555c43e5d3" args="(const ClusterGraph &amp;cl, size_t i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dai::eliminationCost_MinNeighbors </td>
          <td>(</td>
          <td class="paramtype">const ClusterGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates cost of eliminating the <em>i</em> 'th variable from cluster graph <em>cl</em> according to the "MinNeighbors" criterion. </p>
<p>The cost is measured as "number of neigboring nodes in the current adjacency graph", where the adjacency graph has the variables as its nodes and connects nodes <em>i1</em> and <em>i2</em> iff <em>i1</em> and <em>i2</em> occur together in some common cluster. </p>

</div>
</div>
<a class="anchor" id="a68ec048cdbefcf8a488469dd14938452"></a><!-- doxytag: member="dai::eliminationCost_MinWeight" ref="a68ec048cdbefcf8a488469dd14938452" args="(const ClusterGraph &amp;cl, size_t i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dai::eliminationCost_MinWeight </td>
          <td>(</td>
          <td class="paramtype">const ClusterGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates cost of eliminating the <em>i</em> 'th variable from cluster graph <em>cl</em> according to the "MinWeight" criterion. </p>
<p>The cost is measured as "product of weights of neighboring nodes in the current adjacency graph", where the adjacency graph has the variables as its nodes and connects nodes <em>i1</em> and <em>i2</em> iff <em>i1</em> and <em>i2</em> occur together in some common cluster. The weight of a node is the number of states of the corresponding variable. </p>

</div>
</div>
<a class="anchor" id="ab6cfdf0bf047e72e324c04e96d310edb"></a><!-- doxytag: member="dai::eliminationCost_MinFill" ref="ab6cfdf0bf047e72e324c04e96d310edb" args="(const ClusterGraph &amp;cl, size_t i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dai::eliminationCost_MinFill </td>
          <td>(</td>
          <td class="paramtype">const ClusterGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates cost of eliminating the <em>i</em> 'th variable from cluster graph <em>cl</em> according to the "MinFill" criterion. </p>
<p>The cost is measured as "number of added edges in the adjacency graph", where the adjacency graph has the variables as its nodes and connects nodes <em>i1</em> and <em>i2</em> iff <em>i1</em> and <em>i2</em> occur together in some common cluster. </p>

</div>
</div>
<a class="anchor" id="a990ea70014c5c6a90932d9cee11f393b"></a><!-- doxytag: member="dai::eliminationCost_WeightedMinFill" ref="a990ea70014c5c6a90932d9cee11f393b" args="(const ClusterGraph &amp;cl, size_t i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dai::eliminationCost_WeightedMinFill </td>
          <td>(</td>
          <td class="paramtype">const ClusterGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates cost of eliminating the <em>i</em> 'th variable from cluster graph <em>cl</em> according to the "WeightedMinFill" criterion. </p>
<p>The cost is measured as "total weight of added edges in the adjacency graph", where the adjacency graph has the variables as its nodes and connects nodes <em>i1</em> and <em>i2</em> iff <em>i1</em> and <em>i2</em> occur together in some common cluster. The weight of an edge is the product of the number of states of the variables corresponding with its nodes. </p>

</div>
</div>
<a class="anchor" id="aab8aabfe0fcfd4b4bd24757c101449d5"></a><!-- doxytag: member="dai::calcMarginal" ref="aab8aabfe0fcfd4b4bd24757c101449d5" args="(const InfAlg &amp;obj, const VarSet &amp;vs, bool reInit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TFactor.html">Factor</a> dai::calcMarginal </td>
          <td>(</td>
          <td class="paramtype">const InfAlg &amp;&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VarSet &amp;&nbsp;</td>
          <td class="paramname"> <em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>reInit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the marginal probability distribution for <em>vs</em> using inference algorithm <em>obj</em>. </p>
<p><a class="el" href="namespacedai.html#aab8aabfe0fcfd4b4bd24757c101449d5" title="Calculates the marginal probability distribution for vs using inference algorithm...">calcMarginal()</a> works by clamping all variables in <em>vs</em> and calculating the partition sum for each clamped state. Therefore, it can be used in combination with any inference algorithm that can calculate/approximate partition sums. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>instance of inference algorithm to be used </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vs</em>&nbsp;</td><td>variables for which the marginal should be calculated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reInit</em>&nbsp;</td><td>should be set to <code>true</code> if at least one of the possible clamped states would be invalid (leading to a factor graph with zero partition sum). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a82e775a1e2908856f13fa1aa7c081d4c"></a><!-- doxytag: member="dai::calcPairBeliefs" ref="a82e775a1e2908856f13fa1aa7c081d4c" args="(const InfAlg &amp;obj, const VarSet &amp;vs, bool reInit, bool accurate=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classdai_1_1TFactor.html">Factor</a> &gt; dai::calcPairBeliefs </td>
          <td>(</td>
          <td class="paramtype">const InfAlg &amp;&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VarSet &amp;&nbsp;</td>
          <td class="paramname"> <em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>reInit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>accurate</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates beliefs for all pairs of variables in <em>vs</em> using inference algorithm <em>obj</em>. </p>
<p><a class="el" href="namespacedai.html#a82e775a1e2908856f13fa1aa7c081d4c" title="Calculates beliefs for all pairs of variables in vs using inference algorithm obj...">calcPairBeliefs()</a> works by</p>
<ul>
<li>clamping single variables in <em>vs</em> and calculating the partition sum and the single variable beliefs for each clamped state, if <em>accurate</em> == <code>false</code>;</li>
<li>clamping pairs of variables in <em>vs</em> and calculating the partition sum for each clamped state, if <em>accurate</em> == <code>true</code>.</li>
</ul>
<p>Therefore, it can be used in combination with any inference algorithm that can calculate/approximate partition sums (and single variable beliefs, if <em>accurate</em> == <code>true</code>). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>instance of inference algorithm to be used </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vs</em>&nbsp;</td><td>variables for which the pair beliefs should be calculated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reInit</em>&nbsp;</td><td>should be set to <code>true</code> if at least one of the possible clamped states would be invalid (leading to a factor graph with zero partition sum). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>accurate</em>&nbsp;</td><td>if <code>true</code>, uses a slower but more accurate approximation algorithm </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7dd9cb2405e798802d8cbb9b879fdf90"></a><!-- doxytag: member="dai::createFactorIsing" ref="a7dd9cb2405e798802d8cbb9b879fdf90" args="(const Var &amp;x, Real h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TFactor.html">Factor</a> dai::createFactorIsing </td>
          <td>(</td>
          <td class="paramtype">const Var &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&nbsp;</td>
          <td class="paramname"> <em>h</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a binary unnormalized single-variable factor <img class="formulaInl" alt="$ \exp(hx) $" src="form_69.png"/> where <img class="formulaInl" alt="$ x = \pm 1 $" src="form_70.png"/>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Variable (should be binary) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>Field strength </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade7f623237328458325bce5322abe03e"></a><!-- doxytag: member="dai::createFactorIsing" ref="ade7f623237328458325bce5322abe03e" args="(const Var &amp;x1, const Var &amp;x2, Real J)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TFactor.html">Factor</a> dai::createFactorIsing </td>
          <td>(</td>
          <td class="paramtype">const Var &amp;&nbsp;</td>
          <td class="paramname"> <em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Var &amp;&nbsp;</td>
          <td class="paramname"> <em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&nbsp;</td>
          <td class="paramname"> <em>J</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a binary unnormalized pairwise factor <img class="formulaInl" alt="$ \exp(J x_1 x_2) $" src="form_71.png"/> where <img class="formulaInl" alt="$ x_1, x_2 = \pm 1 $" src="form_72.png"/>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x1</em>&nbsp;</td><td>First variable (should be binary) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x2</em>&nbsp;</td><td>Second variable (should be binary) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>J</em>&nbsp;</td><td>Coupling strength </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6715831e60e66582bce1c69518a40dd3"></a><!-- doxytag: member="dai::createFactorExpGauss" ref="a6715831e60e66582bce1c69518a40dd3" args="(const VarSet &amp;vs, Real beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TFactor.html">Factor</a> dai::createFactorExpGauss </td>
          <td>(</td>
          <td class="paramtype">const VarSet &amp;&nbsp;</td>
          <td class="paramname"> <em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&nbsp;</td>
          <td class="paramname"> <em>beta</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a random factor on the variables <em>vs</em> with strength <em>beta</em>. </p>
<p>Each entry are set by drawing a normally distributed random with mean 0 and standard-deviation <em>beta</em>, and taking its exponent. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vs</em>&nbsp;</td><td>Variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>beta</em>&nbsp;</td><td>Factor strength (inverse temperature) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aab6d25e30baf39ea06c57b5f71c61a4e"></a><!-- doxytag: member="dai::createFactorPotts" ref="aab6d25e30baf39ea06c57b5f71c61a4e" args="(const Var &amp;x1, const Var &amp;x2, Real J)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TFactor.html">Factor</a> dai::createFactorPotts </td>
          <td>(</td>
          <td class="paramtype">const Var &amp;&nbsp;</td>
          <td class="paramname"> <em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Var &amp;&nbsp;</td>
          <td class="paramname"> <em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&nbsp;</td>
          <td class="paramname"> <em>J</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a pairwise Potts factor <img class="formulaInl" alt="$ \exp( J \delta_{x_1, x_2} ) $" src="form_73.png"/>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x1</em>&nbsp;</td><td>First variable </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x2</em>&nbsp;</td><td>Second variable (should have the same number of states as <em>x1</em>) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>J</em>&nbsp;</td><td>Factor strength </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf624997c47362bc5db95242b76a66a4"></a><!-- doxytag: member="dai::createFactorDelta" ref="adf624997c47362bc5db95242b76a66a4" args="(const Var &amp;v, size_t state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TFactor.html">Factor</a> dai::createFactorDelta </td>
          <td>(</td>
          <td class="paramtype">const Var &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>state</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a Kronecker delta point mass. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Variable </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>The state of <em>v</em> that should get value 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57fa52134afbd3da21c99975fbba7080"></a><!-- doxytag: member="dai::operator&lt;&lt;" ref="a57fa52134afbd3da21c99975fbba7080" args="(std::ostream &amp;os, const FactorGraph &amp;fg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; dai::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FactorGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>fg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a> to an output stream. </p>
<p>Writes a factor graph to an output stream.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="fileformats.html#fileformats-factorgraph">Factor graph (.fg) file format</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab1b9d59848e415c32330d4a7cbb3269a"></a><!-- doxytag: member="dai::operator&gt;&gt;" ref="ab1b9d59848e415c32330d4a7cbb3269a" args="(std::istream &amp;is, FactorGraph &amp;fg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; dai::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FactorGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>fg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads a <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a> from an input stream. </p>
<p>Reads a factor graph from an input stream.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="fileformats.html#fileformats-factorgraph">Factor graph (.fg) file format</a> </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>INVALID_FACTORGRAPH_FILE</em>&nbsp;</td><td>if the input stream is not valid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aedbe32ae13acdd8b62050b18e81a53ea"></a><!-- doxytag: member="dai::createGraphFull" ref="aedbe32ae13acdd8b62050b18e81a53ea" args="(size_t N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a> dai::createGraphFull </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>N</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a fully-connected graph with <em>N</em> nodes. </p>

</div>
</div>
<a class="anchor" id="aaeeffaf06b9cd2fecccaf2bf773baed7"></a><!-- doxytag: member="dai::createGraphGrid" ref="aaeeffaf06b9cd2fecccaf2bf773baed7" args="(size_t N1, size_t N2, bool periodic)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a> dai::createGraphGrid </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>N1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>N2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>periodic</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a two-dimensional rectangular grid of <em>N1</em> by <em>N2</em> nodes, which can be <em>periodic</em>. </p>

</div>
</div>
<a class="anchor" id="a9950d08bd6190ea12f50b4be6f2584cf"></a><!-- doxytag: member="dai::createGraphGrid3D" ref="a9950d08bd6190ea12f50b4be6f2584cf" args="(size_t N1, size_t N2, size_t N3, bool periodic)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a> dai::createGraphGrid3D </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>N1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>N2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>N3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>periodic</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a three-dimensional rectangular grid of <em>N1</em> by <em>N2</em> by <em>N3</em> nodes, which can be <em>periodic</em>. </p>

</div>
</div>
<a class="anchor" id="a7f65fc1665a6fa04b1b6897a4551bccc"></a><!-- doxytag: member="dai::createGraphLoop" ref="a7f65fc1665a6fa04b1b6897a4551bccc" args="(size_t N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a> dai::createGraphLoop </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>N</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a graph consisting of a single loop of <em>N</em> nodes. </p>

</div>
</div>
<a class="anchor" id="ad3fbe55f9fdb020e7a2b04f1d2451d20"></a><!-- doxytag: member="dai::createGraphTree" ref="ad3fbe55f9fdb020e7a2b04f1d2451d20" args="(size_t N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a> dai::createGraphTree </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>N</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a random tree-structured graph of <em>N</em> nodes. </p>

</div>
</div>
<a class="anchor" id="abfd6bb3f4b6135a99a68b9b13bee8bae"></a><!-- doxytag: member="dai::createGraphRegular" ref="abfd6bb3f4b6135a99a68b9b13bee8bae" args="(size_t N, size_t d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a> dai::createGraphRegular </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>d</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a random regular graph of <em>N</em> nodes with uniform connectivity <em>d</em>. </p>
<p>Algorithm 1 in [<a class="el" href="bibliography.html#StW99">StW99</a>]. Draws a random graph of size <em>N</em> and uniform degree <em>d</em> from an almost uniform probability distribution over these graphs (which becomes uniform in the limit that <em>d</em> is small and <em>N</em> goes to infinity). </p>

</div>
</div>
<a class="anchor" id="a847e3cef4f6660bb027e9a3978277a2b"></a><!-- doxytag: member="dai::makePositive" ref="a847e3cef4f6660bb027e9a3978277a2b" args="(TFactor&lt; T &gt; &amp;f, T epsilon)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TFactor.html">TFactor</a>&lt;T&gt;&amp; dai::makePositive </td>
          <td>(</td>
          <td class="paramtype">TFactor&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>epsilon</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets factor entries that lie between 0 and <em>epsilon</em> to <em>epsilon</em>. </p>

</div>
</div>
<a class="anchor" id="a1c7d5fa66149e0e508711f68bac11b5f"></a><!-- doxytag: member="dai::makeZero" ref="a1c7d5fa66149e0e508711f68bac11b5f" args="(TFactor&lt; T &gt; &amp;f, T epsilon)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TFactor.html">TFactor</a>&lt;T&gt;&amp; dai::makeZero </td>
          <td>(</td>
          <td class="paramtype">TFactor&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>epsilon</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets factor entries that are smaller (in absolute value) than <em>epsilon</em> to 0. </p>

</div>
</div>
<a class="anchor" id="ac63c2f1d67d01aeda5c3cdd95843ea86"></a><!-- doxytag: member="dai::operator&lt;&lt;" ref="ac63c2f1d67d01aeda5c3cdd95843ea86" args="(std::ostream &amp;os, const Property &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; dai::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Property &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a Property object (key-value pair) to an output stream. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Not all value types are automatically supported; if a type is unknown, an UNKNOWN_PROPERTY_TYPE exception is thrown. Adding support for a new type can be done by changing this function body. </dd></dl>

</div>
</div>
<a class="anchor" id="ab339baefa9f588de2fba07526d8df7ba"></a><!-- doxytag: member="dai::operator&lt;&lt;" ref="ab339baefa9f588de2fba07526d8df7ba" args="(std::ostream &amp;os, const PropertySet &amp;ps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; dai::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PropertySet &amp;&nbsp;</td>
          <td class="paramname"> <em>ps</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a <a class="el" href="classdai_1_1PropertySet.html" title="Represents a set of properties, mapping keys (of type PropertyKey) to values (of...">PropertySet</a> object to an output stream. </p>
<p>It uses the format <code>"[key1=val1,key2=val2,...,keyn=valn]"</code>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Only a subset of all possible types is supported (see the implementation of this function). Adding support for more types has to be done by hand. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>UNKNOWN_PROPERTY_TYPE</em>&nbsp;</td><td>if the type of a property value is not supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aab0479dd285fd4021ecaa80947d40da3"></a><!-- doxytag: member="dai::operator&gt;&gt;" ref="aab0479dd285fd4021ecaa80947d40da3" args="(std::istream &amp;is, PropertySet &amp;ps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; dai::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertySet &amp;&nbsp;</td>
          <td class="paramname"> <em>ps</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads a <a class="el" href="classdai_1_1PropertySet.html" title="Represents a set of properties, mapping keys (of type PropertyKey) to values (of...">PropertySet</a> object from an input stream, storing values as strings. </p>
<p>Reads a <a class="el" href="classdai_1_1PropertySet.html" title="Represents a set of properties, mapping keys (of type PropertyKey) to values (of...">PropertySet</a> object from an input stream.</p>
<p>It expects a string in the format <code>"[key1=val1,key2=val2,...,keyn=valn]"</code>. Values are stored as strings. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>MALFORMED_PROPERTY</em>&nbsp;</td><td>if the string is not in the expected format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e910ae9247869ee549df8eed173a6df"></a><!-- doxytag: member="dai::operator&lt;&lt;" ref="a0e910ae9247869ee549df8eed173a6df" args="(ostream &amp;os, const RegionGraph &amp;rg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; dai::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RegionGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>rg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send <a class="el" href="classdai_1_1RegionGraph.html" title="A RegionGraph combines a bipartite graph consisting of outer regions (type FRegion)...">RegionGraph</a> to output stream. </p>
<p>Writes a <a class="el" href="classdai_1_1RegionGraph.html" title="A RegionGraph combines a bipartite graph consisting of outer regions (type FRegion)...">RegionGraph</a> to an output stream. </p>

</div>
</div>
<a class="anchor" id="ab27c0799ddef29bb3833477e32c53862"></a><!-- doxytag: member="dai::toc" ref="ab27c0799ddef29bb3833477e32c53862" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dai::toc </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns wall clock time in seconds. </p>

</div>
</div>
<a class="anchor" id="a8676cd0faacaec12b2acf0e0472e3280"></a><!-- doxytag: member="dai::_rnd_gen" ref="a8676cd0faacaec12b2acf0e0472e3280" args="(42U)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#ad2fa14208786f0746805efc9fbf3e56e">_rnd_gen_type</a> dai::_rnd_gen </td>
          <td>(</td>
          <td class="paramtype">42U&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Global random number generator. </p>

</div>
</div>
<a class="anchor" id="a2cff7aad0084432ddcc7ef52618b74bd"></a><!-- doxytag: member="dai::_uni_dist" ref="a2cff7aad0084432ddcc7ef52618b74bd" args="(0, 1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::uniform_real&lt;<a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&gt; dai::_uni_dist </td>
          <td>(</td>
          <td class="paramtype">0&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uniform distribution with values between 0 and 1 (0 inclusive, 1 exclusive). </p>

</div>
</div>
<a class="anchor" id="a95e934001307cafa4576b31fb0569e2c"></a><!-- doxytag: member="dai::_uni_rnd" ref="a95e934001307cafa4576b31fb0569e2c" args="(_rnd_gen, _uni_dist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::variate_generator&lt;<a class="el" href="namespacedai.html#ad2fa14208786f0746805efc9fbf3e56e">_rnd_gen_type</a>&amp;, boost::uniform_real&lt;<a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&gt; &gt; dai::_uni_rnd </td>
          <td>(</td>
          <td class="paramtype">_rnd_gen&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_uni_dist&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Global uniform random random number. </p>

</div>
</div>
<a class="anchor" id="a205aca5e7688c28a95ecc978b4f79879"></a><!-- doxytag: member="dai::_normal_rnd" ref="a205aca5e7688c28a95ecc978b4f79879" args="(_rnd_gen, _normal_dist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::variate_generator&lt;<a class="el" href="namespacedai.html#ad2fa14208786f0746805efc9fbf3e56e">_rnd_gen_type</a>&amp;, boost::normal_distribution&lt;<a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&gt; &gt; dai::_normal_rnd </td>
          <td>(</td>
          <td class="paramtype">_rnd_gen&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_normal_dist&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Global random number generator with standard normal distribution. </p>

</div>
</div>
<a class="anchor" id="ae699eca7ca4d6e971b54c2b4a95942d4"></a><!-- doxytag: member="dai::rnd_seed" ref="ae699eca7ca4d6e971b54c2b4a95942d4" args="(size_t seed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dai::rnd_seed </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>seed</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the random seed. </p>

</div>
</div>
<a class="anchor" id="a129f3a9c518c632c985d045a4f8c60f9"></a><!-- doxytag: member="dai::rnd_uniform" ref="a129f3a9c518c632c985d045a4f8c60f9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> dai::rnd_uniform </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a real number, distributed uniformly on [0,1). </p>

</div>
</div>
<a class="anchor" id="ac3f6d317ca42fbb4b643aa8c82692d74"></a><!-- doxytag: member="dai::rnd_stdnormal" ref="ac3f6d317ca42fbb4b643aa8c82692d74" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> dai::rnd_stdnormal </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a real number from a standard-normal distribution. </p>

</div>
</div>
<a class="anchor" id="ac02317b960b112637976333f90d1f937"></a><!-- doxytag: member="dai::rnd_int" ref="ac02317b960b112637976333f90d1f937" args="(int min, int max)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dai::rnd_int </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a random integer in interval [<em>min</em>, <em>max</em>]. </p>

</div>
</div>
<a class="anchor" id="a98aff76f2fef44c6d8d240e52e0d4651"></a><!-- doxytag: member="dai::tokenizeString" ref="a98aff76f2fef44c6d8d240e52e0d4651" args="(const std::string &amp;s, std::vector&lt; std::string &gt; &amp;outTokens, const std::string &amp;delim=&quot;\t\n&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dai::tokenizeString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>outTokens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>delim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Split a string into tokens delimited by one of the characters in <em>delim</em>. </p>

</div>
</div>
<a class="anchor" id="a750c3807e7375265c3fb410a1f1223fe"></a><!-- doxytag: member="dai::calcLinearState" ref="a750c3807e7375265c3fb410a1f1223fe" args="(const VarSet &amp;vs, const std::map&lt; Var, size_t &gt; &amp;state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dai::calcLinearState </td>
          <td>(</td>
          <td class="paramtype">const VarSet &amp;&nbsp;</td>
          <td class="paramname"> <em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; Var, size_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>state</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the linear index in the Cartesian product of the variables in <em>vs</em> that corresponds to a particular joint assignment of the variables, specified by <em>state</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vs</em>&nbsp;</td><td>Set of variables for which the linear state should be calculated; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>Specifies the states of some variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The linear index in the Cartesian product of the variables in <em>vs</em> corresponding with the joint assignment specified by <em>state</em>, where variables for which no state is specified are assumed to be in state 0.</dd></dl>
<p>The linear index is calculated as follows. The variables in <em>vs</em> are ordered according to their label (in ascending order); say <em>vs</em> corresponds with the set <img class="formulaInl" alt="$\{x_{l(0)},x_{l(1)},\dots,x_{l(n-1)}\}$" src="form_133.png"/> with <img class="formulaInl" alt="$l(0) < l(1) < \dots < l(n-1)$" src="form_134.png"/>, where variable <img class="formulaInl" alt="$x_l$" src="form_30.png"/> has label <em>l</em>. Denote by <img class="formulaInl" alt="$S_l$" src="form_32.png"/> the number of possible values ("states") of variable <img class="formulaInl" alt="$x_l$" src="form_30.png"/>. The argument <em>state</em> corresponds with a mapping <em>s</em> that assigns to each variable <img class="formulaInl" alt="$x_l$" src="form_30.png"/> a state <img class="formulaInl" alt="$s(x_l) \in \{0,1,\dots,S_l-1\}$" src="form_135.png"/>, where <img class="formulaInl" alt="$s(x_l)=0$" src="form_136.png"/> if <img class="formulaInl" alt="$x_l$" src="form_30.png"/> is not specified in <em>state</em>. The linear index <img class="formulaInl" alt="$S$" src="form_137.png"/> corresponding with <em>state</em> is now calculated by: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} S &amp;:=&amp; \sum_{i=0}^{n-1} s(x_{l(i)}) \prod_{j=0}^{i-1} S_{l(j)} \\ &amp;= &amp; s(x_{l(0)}) + s(x_{l(1)}) S_{l(0)} + s(x_{l(2)}) S_{l(0)} S_{l(1)} + \dots + s(x_{l(n-1)}) S_{l(0)} \cdots S_{l(n-2)}. \end{eqnarray*}" src="form_138.png"/>
</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If <em>vs</em> corresponds with <img class="formulaInl" alt="$\{x_l\}_{l\in L}$" src="form_64.png"/>, and <em>state</em> specifies a state for each variable <img class="formulaInl" alt="$x_l$" src="form_30.png"/> for <img class="formulaInl" alt="$l\in L$" src="form_139.png"/>, <a class="el" href="namespacedai.html#a750c3807e7375265c3fb410a1f1223fe" title="Calculates the linear index in the Cartesian product of the variables in vs that...">calcLinearState()</a> induces a mapping <img class="formulaInl" alt="$\sigma : \prod_{l\in L} X_l \to \{0,1,\dots,\prod_{l\in L} S_l-1\}$" src="form_140.png"/> that maps a joint state to a linear index; this is the inverse of the mapping <img class="formulaInl" alt="$\sigma^{-1}$" src="form_141.png"/> induced by <a class="el" href="namespacedai.html#afcfc874f85b4a2944ec128ebd1dd19f1" title="Calculates the joint assignment of the variables in vs corresponding to the linear...">calcState()</a>.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespacedai.html#afcfc874f85b4a2944ec128ebd1dd19f1" title="Calculates the joint assignment of the variables in vs corresponding to the linear...">calcState()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afcfc874f85b4a2944ec128ebd1dd19f1"></a><!-- doxytag: member="dai::calcState" ref="afcfc874f85b4a2944ec128ebd1dd19f1" args="(const VarSet &amp;vs, size_t linearState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; <a class="el" href="classdai_1_1Var.html">Var</a>, size_t &gt; dai::calcState </td>
          <td>(</td>
          <td class="paramtype">const VarSet &amp;&nbsp;</td>
          <td class="paramname"> <em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>linearState</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the joint assignment of the variables in <em>vs</em> corresponding to the linear index <em>linearState</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vs</em>&nbsp;</td><td>Set of variables to which <em>linearState</em> refers </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>linearState</em>&nbsp;</td><td>should be smaller than vs.nrStates(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A mapping <img class="formulaInl" alt="$s$" src="form_84.png"/> that maps each <a class="el" href="classdai_1_1Var.html" title="Represents a discrete random variable.">Var</a> <img class="formulaInl" alt="$x_l$" src="form_30.png"/> in <em>vs</em> to its state <img class="formulaInl" alt="$s(x_l)$" src="form_142.png"/>, as specified by <em>linearState</em>.</dd></dl>
<p>The variables in <em>vs</em> are ordered according to their label (in ascending order); say <em>vs</em> corresponds with the set <img class="formulaInl" alt="$\{x_{l(0)},x_{l(1)},\dots,x_{l(n-1)}\}$" src="form_133.png"/> with <img class="formulaInl" alt="$l(0) < l(1) < \dots < l(n-1)$" src="form_134.png"/>, where variable <img class="formulaInl" alt="$x_l$" src="form_30.png"/> has label <em>l</em>. Denote by <img class="formulaInl" alt="$S_l$" src="form_32.png"/> the number of possible values ("states") of variable <img class="formulaInl" alt="$x_l$" src="form_30.png"/> with label <em>l</em>. The mapping <img class="formulaInl" alt="$s$" src="form_84.png"/> returned by this function is defined as: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} s(x_{l(i)}) = \left\lfloor\frac{S \mbox { mod } \prod_{j=0}^{i} S_{l(j)}}{\prod_{j=0}^{i-1} S_{l(j)}}\right\rfloor \qquad \mbox{for all $i=0,\dots,n-1$}. \end{eqnarray*}" src="form_143.png"/>
</p>
<p> where <img class="formulaInl" alt="$S$" src="form_137.png"/> denotes the value of <em>linearState</em>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If <em>vs</em> corresponds with <img class="formulaInl" alt="$\{x_l\}_{l\in L}$" src="form_64.png"/>, <a class="el" href="namespacedai.html#afcfc874f85b4a2944ec128ebd1dd19f1" title="Calculates the joint assignment of the variables in vs corresponding to the linear...">calcState()</a> induces a mapping <img class="formulaInl" alt="$\sigma^{-1} : \{0,1,\dots,\prod_{l\in L} S_l-1\} \to \prod_{l\in L} X_l$" src="form_144.png"/> that maps a linear index to a joint state; this is the inverse of the mapping <img class="formulaInl" alt="$\sigma$" src="form_68.png"/> induced by <a class="el" href="namespacedai.html#a750c3807e7375265c3fb410a1f1223fe" title="Calculates the linear index in the Cartesian product of the variables in vs that...">calcLinearState()</a>.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespacedai.html#a750c3807e7375265c3fb410a1f1223fe" title="Calculates the linear index in the Cartesian product of the variables in vs that...">calcLinearState()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af26283612a1f256c2c4fa1eaafc0b7ce"></a><!-- doxytag: member="dai::RandomDRegularGraph" ref="af26283612a1f256c2c4fa1eaafc0b7ce" args="(size_t N, size_t d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1GraphEL.html">GraphEL</a> dai::RandomDRegularGraph </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>d</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a random undirected graph of <em>N</em> nodes, where each node has connectivity <em>d</em>. </p>
<p>Algorithm 1 in [<a class="el" href="bibliography.html#StW99">StW99</a>]. Draws a random graph of size <em>N</em> and uniform degree <em>d</em> from an almost uniform probability distribution over these graphs (which becomes uniform in the limit that <em>d</em> is small and <em>N</em> goes to infinity). </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000029">Deprecated:</a></b></dt><dd>Please use <a class="el" href="namespacedai.html#abfd6bb3f4b6135a99a68b9b13bee8bae" title="Creates a random regular graph of N nodes with uniform connectivity d.">dai::createGraphRegular(size_t, size_t)</a> instead </dd></dl>

</div>
</div>
<a class="anchor" id="ae62bf4dfaa6694edc2d180b71656d430"></a><!-- doxytag: member="dai::Factors2mx" ref="ae62bf4dfaa6694edc2d180b71656d430" args="(const std::vector&lt; Factor &gt; &amp;Ps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mxArray * dai::Factors2mx </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; Factor &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Ps</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert vector&lt;Factor&gt; structure to a cell vector of CPTAB-like structs. </p>

</div>
</div>
<a class="anchor" id="abdd1a935e89ca8dc1d4e0c1cea371d44"></a><!-- doxytag: member="dai::mx2Factors" ref="abdd1a935e89ca8dc1d4e0c1cea371d44" args="(const mxArray *psi, long verbose)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classdai_1_1TFactor.html">Factor</a> &gt; dai::mx2Factors </td>
          <td>(</td>
          <td class="paramtype">const mxArray *&nbsp;</td>
          <td class="paramname"> <em>psi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>verbose</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert cell vector of CPTAB-like structs to vector&lt;Factor&gt; </p>

</div>
</div>
<a class="anchor" id="a573a608f62779c1a08f8e10c3fa4e940"></a><!-- doxytag: member="dai::mx2Factor" ref="a573a608f62779c1a08f8e10c3fa4e940" args="(const mxArray *psi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TFactor.html">Factor</a> dai::mx2Factor </td>
          <td>(</td>
          <td class="paramtype">const mxArray *&nbsp;</td>
          <td class="paramname"> <em>psi</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert CPTAB-like struct to Factor. </p>

</div>
</div>
<a class="anchor" id="aef8d342ac50bdaed5d513df6349be31c"></a><!-- doxytag: member="dai::DAI_ENUM" ref="aef8d342ac50bdaed5d513df6349be31c" args="(BBPCostFunctionBase, CFN_GIBBS_B, CFN_GIBBS_B2, CFN_GIBBS_EXP, CFN_GIBBS_B_FACTOR, CFN_GIBBS_B2_FACTOR, CFN_GIBBS_EXP_FACTOR, CFN_VAR_ENT, CFN_FACTOR_ENT, CFN_BETHE_ENT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dai::DAI_ENUM </td>
          <td>(</td>
          <td class="paramtype">BBPCostFunctionBase&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFN_GIBBS_B&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFN_GIBBS_B2&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFN_GIBBS_EXP&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFN_GIBBS_B_FACTOR&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFN_GIBBS_B2_FACTOR&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFN_GIBBS_EXP_FACTOR&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFN_VAR_ENT&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFN_FACTOR_ENT&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFN_BETHE_ENT&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enumeration of several cost functions that can be used with <a class="el" href="classdai_1_1BBP.html" title="Implements BBP (Back-Belief-Propagation) [EaG09].">BBP</a>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This class is meant as a base class for <a class="el" href="classdai_1_1BBPCostFunction.html" title="Predefined cost functions that can be used with BBP.">BBPCostFunction</a>, which provides additional functionality. </dd></dl>

</div>
</div>
<a class="anchor" id="a934491ad55f57c9072271b4a32ea4919"></a><!-- doxytag: member="dai::log" ref="a934491ad55f57c9072271b4a32ea4919" args="(Real x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> dai::log </td>
          <td>(</td>
          <td class="paramtype">Real&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns logarithm of <em>x</em>. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="example_8cpp-example.html#a4">example.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a00375a4d7b55534c14f993c909b04c3c"></a><!-- doxytag: member="dai::log0" ref="a00375a4d7b55534c14f993c909b04c3c" args="(Real x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> dai::log0 </td>
          <td>(</td>
          <td class="paramtype">Real&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns logarithm of <em>x</em>, or 0 if <em>x</em> == 0. </p>

</div>
</div>
<a class="anchor" id="ac336ffb182b6e6fa3f7df13620aab012"></a><!-- doxytag: member="dai::exp" ref="ac336ffb182b6e6fa3f7df13620aab012" args="(Real x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> dai::exp </td>
          <td>(</td>
          <td class="paramtype">Real&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns exponent of <em>x</em>. </p>

</div>
</div>
<a class="anchor" id="a16465ce3d62a6456fd06e9a226c966f2"></a><!-- doxytag: member="dai::pow" ref="a16465ce3d62a6456fd06e9a226c966f2" args="(Real x, Real y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> dai::pow </td>
          <td>(</td>
          <td class="paramtype">Real&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <em>to</em> the power <em>y</em>. </p>

</div>
</div>
<a class="anchor" id="abc859d9510bf6f58fc066c33ae8f7492"></a><!-- doxytag: member="dai::abs" ref="abc859d9510bf6f58fc066c33ae8f7492" args="(const T &amp;t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T dai::abs </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns absolute value of <em>t</em>. </p>

</div>
</div>
<a class="anchor" id="affae7aacdd26b4a580fbb8790cbccc86"></a><!-- doxytag: member="dai::rnd" ref="affae7aacdd26b4a580fbb8790cbccc86" args="(int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dai::rnd </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a random integer in the half-open interval [0, <em>n</em>). </p>

</div>
</div>
<a class="anchor" id="a039689f5b5f4a2f34479fd1a8fd21b8a"></a><!-- doxytag: member="dai::toString" ref="a039689f5b5f4a2f34479fd1a8fd21b8a" args="(const T &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string dai::toString </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a variable of type <em>T</em> to a <code>std::string</code> by using a <code>std::stringstream</code>. </p>

</div>
</div>
<a class="anchor" id="a1a0b1c88c46fb8763c2c783cc3fe9a62"></a><!-- doxytag: member="dai::operator&lt;&lt;" ref="a1a0b1c88c46fb8763c2c783cc3fe9a62" args="(std::ostream &amp;os, const std::vector&lt; T &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; dai::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a <code>std::vector&lt;&gt;</code> to a <code>std::ostream</code>. </p>

</div>
</div>
<a class="anchor" id="a4f8ad5d0c47c7fdfe17e5d0f4c0a32d9"></a><!-- doxytag: member="dai::operator&lt;&lt;" ref="a4f8ad5d0c47c7fdfe17e5d0f4c0a32d9" args="(std::ostream &amp;os, const std::set&lt; T &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; dai::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a <code>std::set&lt;&gt;</code> to a <code>std::ostream</code>. </p>

</div>
</div>
<a class="anchor" id="a5913957fb1c3c3d3fbd1f3102b8eb04c"></a><!-- doxytag: member="dai::operator&lt;&lt;" ref="a5913957fb1c3c3d3fbd1f3102b8eb04c" args="(std::ostream &amp;os, const std::map&lt; T1, T2 &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; dai::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; T1, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a <code>std::map&lt;&gt;</code> to a <code>std::ostream</code>. </p>

</div>
</div>
<a class="anchor" id="a575f6202aa88de6bf5146b85d8832eb5"></a><!-- doxytag: member="dai::operator&lt;&lt;" ref="a575f6202aa88de6bf5146b85d8832eb5" args="(std::ostream &amp;os, const std::pair&lt; T1, T2 &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; dai::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; T1, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a <code>std::pair&lt;&gt;</code> to a <code>std::ostream</code>. </p>

</div>
</div>
<a class="anchor" id="aae335872c5de8c4d1f21833cbe5c0020"></a><!-- doxytag: member="dai::concat" ref="aae335872c5de8c4d1f21833cbe5c0020" args="(const std::vector&lt; T &gt; &amp;u, const std::vector&lt; T &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; dai::concat </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Concatenates two vectors. </p>

</div>
</div>
<a class="anchor" id="a273d7118dd690f5b438fba18f6860eb6"></a><!-- doxytag: member="dai::MinSpanningTree" ref="a273d7118dd690f5b438fba18f6860eb6" args="(const WeightedGraph&lt; T &gt; &amp;G, bool usePrim)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1RootedTree.html">RootedTree</a> dai::MinSpanningTree </td>
          <td>(</td>
          <td class="paramtype">const WeightedGraph&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>usePrim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a minimum spanning tree from the (non-negatively) weighted graph <em>G</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>G</em>&nbsp;</td><td>Weighted graph that should have non-negative weights. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>usePrim</em>&nbsp;</td><td>If true, use Prim's algorithm (complexity O(E log(V))), otherwise, use Kruskal's algorithm (complexity O(E log(E))). </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Uses implementation from Boost Graph Library. </dd>
<dd>
The vertices of <em>G</em> must be in the range [0,N) where N is the number of vertices of <em>G</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a1914ae414d452b1844e6cd72f70501b5"></a><!-- doxytag: member="dai::MaxSpanningTree" ref="a1914ae414d452b1844e6cd72f70501b5" args="(const WeightedGraph&lt; T &gt; &amp;G, bool usePrim)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1RootedTree.html">RootedTree</a> dai::MaxSpanningTree </td>
          <td>(</td>
          <td class="paramtype">const WeightedGraph&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>usePrim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a minimum spanning tree from the (non-negatively) weighted graph <em>G</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>G</em>&nbsp;</td><td>Weighted graph that should have non-negative weights. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>usePrim</em>&nbsp;</td><td>If true, use Prim's algorithm (complexity O(E log(V))), otherwise, use Kruskal's algorithm (complexity O(E log(E))). </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Uses implementation from Boost Graph Library. </dd>
<dd>
The vertices of <em>G</em> must be in the range [0,N) where N is the number of vertices of <em>G</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a673056614abf3f5e48558709a5c97904"></a><!-- doxytag: member="dai::MinSpanningTree" ref="a673056614abf3f5e48558709a5c97904" args="(const WeightedGraph&lt; T &gt; &amp;G)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1RootedTree.html">RootedTree</a> dai::MinSpanningTree </td>
          <td>(</td>
          <td class="paramtype">const WeightedGraph&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>G</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a minimum spanning tree from the (non-negatively) weighted graph <em>G</em> using Prim's algorithm. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>G</em>&nbsp;</td><td>Weighted graph that should have non-negative weights. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Uses implementation from Boost Graph Library. </dd>
<dd>
The vertices of <em>G</em> must be in the range [0,N) where N is the number of vertices of <em>G</em>. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000027">Deprecated:</a></b></dt><dd>Please use <a class="el" href="namespacedai.html#a273d7118dd690f5b438fba18f6860eb6" title="Constructs a minimum spanning tree from the (non-negatively) weighted graph G.">dai::MinSpanningTree(const WeightedGraph&amp;, bool)</a> instead </dd></dl>

</div>
</div>
<a class="anchor" id="a23a213d552dc1025647b8c5661393ac4"></a><!-- doxytag: member="dai::MaxSpanningTree" ref="a23a213d552dc1025647b8c5661393ac4" args="(const WeightedGraph&lt; T &gt; &amp;G)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1RootedTree.html">RootedTree</a> dai::MaxSpanningTree </td>
          <td>(</td>
          <td class="paramtype">const WeightedGraph&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>G</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a minimum spanning tree from the (non-negatively) weighted graph <em>G</em> using Prim's algorithm. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>G</em>&nbsp;</td><td>Weighted graph that should have non-negative weights. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Uses implementation from Boost Graph Library. </dd>
<dd>
The vertices of <em>G</em> must be in the range [0,N) where N is the number of vertices of <em>G</em>. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000028">Deprecated:</a></b></dt><dd>Please use <a class="el" href="namespacedai.html#a273d7118dd690f5b438fba18f6860eb6" title="Constructs a minimum spanning tree from the (non-negatively) weighted graph G.">dai::MinSpanningTree(const WeightedGraph&amp;, bool)</a> instead </dd></dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a72200157ce1fbccfe91f66a3f8416823"></a><!-- doxytag: member="dai::_normal_dist" ref="a72200157ce1fbccfe91f66a3f8416823" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::normal_distribution&lt;<a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&gt; <a class="el" href="namespacedai.html#a72200157ce1fbccfe91f66a3f8416823">dai::_normal_dist</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normal distribution with mean 0 and standard deviation 1. </p>

</div>
</div>
<a class="anchor" id="afaf76457d5d1ad9cfd37feb44ae94669"></a><!-- doxytag: member="dai::DAINames" ref="afaf76457d5d1ad9cfd37feb44ae94669" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="namespacedai.html#afaf76457d5d1ad9cfd37feb44ae94669">dai::DAINames</a>[]<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Contains the names of all inference algorithms compiled into libDAI. </p>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Sun May 9 16:51:33 2010 for libDAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
