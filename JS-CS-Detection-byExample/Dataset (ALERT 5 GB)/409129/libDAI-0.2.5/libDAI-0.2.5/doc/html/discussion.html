<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libDAI: Ideas not worth exploring</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="discussion">Ideas not worth exploring </a></h1><h2><a class="anchor" id="discuss_extendedgraphs">
Extended factorgraphs/regiongraphs</a></h2>
<p>A FactorGraph and a RegionGraph are often equipped with additional properties for nodes and edges. The code to initialize those is often quite similar. Maybe one could abstract this, e.g.: </p>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Node1Properties, <span class="keyword">typename</span> Node2Properties, <span class="keyword">typename</span> EdgeProperties&gt;
  <span class="keyword">class </span>ExtFactorGraph : <span class="keyword">public</span> FactorGraph {
      <span class="keyword">public</span>:
          std::vector&lt;Node1Properties&gt;              node1Props;
          std::vector&lt;Node2Properties&gt;              node2Props;
          std::vector&lt;std::vector&lt;EdgeProperties&gt; &gt; edgeProps;
         <span class="comment">// ...</span>
  }
</pre></div><p>Advantages:</p>
<ul>
<li>Less code duplication.</li>
<li>Easier maintainability.</li>
<li>Easier to write new inference algorithms.</li>
</ul>
<p>Disadvantages:</p>
<ul>
<li>Cachability may be worse.</li>
<li>A problem is the case where there are no properties for either type of nodes or for edges. Maybe this can be solved using specializations, or using variadac template arguments? Another possible solution would be to define a "class Empty {}", and add some code that checks for the typeid, comparing it with Empty, and doing something special in that case (e.g., not allocating memory).</li>
<li>The main disadvantage of this approach seems to be that it leads to even more entanglement. Therefore this is probably a bad idea.</li>
</ul>
<h2><a class="anchor" id="discuss_templates">
Polymorphism by template parameterization</a></h2>
<p>Instead of polymorphism by inheritance, use polymorphism by template parameterization. For example, the real reason for introducing the complicated inheritance scheme of <a class="el" href="classdai_1_1InfAlg.html" title="InfAlg is an abstract base class, defining the common interface of all inference...">dai::InfAlg</a> was for functions like <a class="el" href="namespacedai.html#aab8aabfe0fcfd4b4bd24757c101449d5" title="Calculates the marginal probability distribution for vs using inference algorithm...">dai::calcMarginal</a>. Instead, one could use a template function: </p>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> InfAlg&gt;
  <a class="code" href="namespacedai.html#a7515abf9952cd312e95a34ada0670e85" title="Represents a factor with values of type dai::Real.">Factor</a> <a class="code" href="namespacedai.html#aab8aabfe0fcfd4b4bd24757c101449d5" title="Calculates the marginal probability distribution for vs using inference algorithm...">calcMarginal</a>( <span class="keyword">const</span> InfAlg &amp;obj, <span class="keyword">const</span> VarSet &amp;ns, <span class="keywordtype">bool</span> reInit );
</pre></div><p> This would assume that the type InfAlg supports certain methods. Ideally, one would use concepts to define different classes of inference algorithms with different capabilities, for example the ability to calculate logZ, the ability to calculate marginals, the ability to calculate bounds, the ability to calculate MAP states, etc. Then, one would use traits classes in order to be able to query the capabilities of the model. For example, one would be able to query whether the inference algorithm supports calculation of logZ. Unfortunately, this is compile-time polymorphism, whereas tests/testdai needs runtime polymorphism. Therefore this is probably a bad idea. </p>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Sun May 9 16:51:33 2010 for libDAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
