<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libDAI: dai::TProb&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespacedai.html">dai</a>::<a class="el" href="classdai_1_1TProb.html">TProb</a>
  </div>
</div>
<div class="contents">
<h1>dai::TProb&lt; T &gt; Class Template Reference</h1><!-- doxytag: class="dai::TProb" -->
<p>Represents a vector with entries of type <em>T</em>.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="prob_8h_source.html">dai/prob.h</a>&gt;</code></p>

<p><a href="classdai_1_1TProb-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a31d9206096f52574dbd24cbb2502080c">NormType</a> { <b>NORMPROB</b>, 
<b>NORMLINF</b>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Enumerates different ways of normalizing a probability measure. </p>
 <a href="classdai_1_1TProb.html#a31d9206096f52574dbd24cbb2502080c">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a492487fd71f6e87673853e5e2fda2f27">DistType</a> { <br/>
&nbsp;&nbsp;<b>DISTL1</b>, 
<b>DISTLINF</b>, 
<b>DISTTV</b>, 
<b>DISTKL</b>, 
<br/>
&nbsp;&nbsp;<b>DISTHEL</b>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Enumerates different distance measures between probability measures. </p>
 <a href="classdai_1_1TProb.html#a492487fd71f6e87673853e5e2fda2f27">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#ada85efb9bd3e5624cc559e74c9c20de9">container_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of data structure used for storing the values.  <a href="#ada85efb9bd3e5624cc559e74c9c20de9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classdai_1_1TProb.html">TProb</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a3fd857f47bad7e3917df607cb38aa2ae">this_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shorthand.  <a href="#a3fd857f47bad7e3917df607cb38aa2ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
container_type::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a576e88e240684174a6fd2804271bfbaa">const_iterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant iterator over the elements.  <a href="#a576e88e240684174a6fd2804271bfbaa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef container_type::iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#ac3ae154b6e88196962c65bb725361052">iterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator over the elements.  <a href="#ac3ae154b6e88196962c65bb725361052"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
container_type::const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a37fb7b49feae193b466d370b501385a5">const_reverse_iterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant reverse iterator over the elements.  <a href="#a37fb7b49feae193b466d370b501385a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
container_type::reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a7b755e30b8bfaccacbde4e71952753ac">reverse_iterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reverse iterator over the elements.  <a href="#a7b755e30b8bfaccacbde4e71952753ac"></a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename binOp1 , typename binOp2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a7d28e5829f9b006125acd83067f70153">innerProduct</a> (const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;q, T init, binOp1 binaryOp1, binOp2 binaryOp2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a generalized inner product, similar to std::inner_product.  <a href="#a7d28e5829f9b006125acd83067f70153"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and destructors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp03575be4ec424b9ebd10985a43cc582a"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a81f9393fa860a6bb005c8286bf9aceab">TProb</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor (constructs empty vector).  <a href="#a81f9393fa860a6bb005c8286bf9aceab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a851cd9b5be495df487fb177b0e06a1dd">TProb</a> (size_t n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct uniform probability distribution over <em>n</em> outcomes (i.e., a vector of length <em>n</em> with each entry set to <img class="formulaInl" alt="$1/n$" src="form_76.png"/>).  <a href="#a851cd9b5be495df487fb177b0e06a1dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#acf3b7ed6e5a0c276b1bcced58c3437dc">TProb</a> (size_t n, T p)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct vector of length <em>n</em> with each entry set to <em>p</em>.  <a href="#acf3b7ed6e5a0c276b1bcced58c3437dc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a65619b3015acb5b208db15640726ea7f">TProb</a> (TIterator begin, TIterator end, size_t sizeHint=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct vector from a range.  <a href="#a65619b3015acb5b208db15640726ea7f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#aa65f38bf3cc4212624adfb4725e1f8c1">TProb</a> (const std::vector&lt; S &gt; &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct vector from another vector.  <a href="#aa65f38bf3cc4212624adfb4725e1f8c1"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterator interface</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp2cadd2ed9268994662a9b13976c78595"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html#ac3ae154b6e88196962c65bb725361052">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a416477b179ecfc91299d07ecd66a473e">begin</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns iterator that points to the first element.  <a href="#a416477b179ecfc91299d07ecd66a473e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html#a576e88e240684174a6fd2804271bfbaa">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#ae05c654ec4b36f719ad122f57c80f8f6">begin</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns constant iterator that points to the first element.  <a href="#ae05c654ec4b36f719ad122f57c80f8f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html#ac3ae154b6e88196962c65bb725361052">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#af61408263bab9270d81f3f791a406e1f">end</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns iterator that points beyond the last element.  <a href="#af61408263bab9270d81f3f791a406e1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html#a576e88e240684174a6fd2804271bfbaa">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a8c97e23797c8e9d7236d6e8d229f9a5c">end</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns constant iterator that points beyond the last element.  <a href="#a8c97e23797c8e9d7236d6e8d229f9a5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html#a7b755e30b8bfaccacbde4e71952753ac">reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#afc07e604de573d743427d2b92fcd710a">rbegin</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns reverse iterator that points to the last element.  <a href="#afc07e604de573d743427d2b92fcd710a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html#a37fb7b49feae193b466d370b501385a5">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a0fab959dfd34104f127caa3cddad2ddd">rbegin</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns constant reverse iterator that points to the last element.  <a href="#a0fab959dfd34104f127caa3cddad2ddd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html#a7b755e30b8bfaccacbde4e71952753ac">reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a05318f090b80662cb13ccca1baa88f94">rend</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns reverse iterator that points beyond the first element.  <a href="#a05318f090b80662cb13ccca1baa88f94"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html#a37fb7b49feae193b466d370b501385a5">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a69d41c85b7ab47ef335b14c041f4f9d7">rend</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns constant reverse iterator that points beyond the first element.  <a href="#a69d41c85b7ab47ef335b14c041f4f9d7"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous operations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp72be07f6f0cdcee715b0301e44d8420f"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a142164d549c8a8e14e55f9cf74127e3d"></a><!-- doxytag: member="dai::TProb::resize" ref="a142164d549c8a8e14e55f9cf74127e3d" args="(size_t sz)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>resize</b> (size_t sz)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Get/set individual entries</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp129514edc216e202757f291747c533a1"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a6ae623febe192134f7011526cbef2b80">get</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets <em>i</em> 'th entry.  <a href="#a6ae623febe192134f7011526cbef2b80"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a3e2be310024be448dacd132e04c0ab01">set</a> (size_t i, T val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets <em>i</em> 'th entry to <em>val</em>.  <a href="#a3e2be310024be448dacd132e04c0ab01"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Queries</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpcf43137803fb51915f84cbc5c3068d34"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdai_1_1TProb.html#ada85efb9bd3e5624cc559e74c9c20de9">container_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a243cb9987f616aee014b8fc767fc61b1">p</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a const reference to the wrapped container.  <a href="#a243cb9987f616aee014b8fc767fc61b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html#ada85efb9bd3e5624cc559e74c9c20de9">container_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#ad5f87d2c6f72001d1c2c046540dc8c9d">p</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a reference to the wrapped container.  <a href="#ad5f87d2c6f72001d1c2c046540dc8c9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#aa349fd5cb6373a5268f7ad6caa41c03b">operator[]</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a copy of the <em>i</em> 'th entry.  <a href="#aa349fd5cb6373a5268f7ad6caa41c03b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#ae305a0821f4afacf5a324297cc6fdb99">operator[]</a> (size_t i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns reference to the <em>i</em> 'th entry.  <a href="#ae305a0821f4afacf5a324297cc6fdb99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a8bfc7de7f2a1ed95cb129d0467c7b88d">size</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns length of the vector (i.e., the number of entries).  <a href="#a8bfc7de7f2a1ed95cb129d0467c7b88d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename binOp , typename unOp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a3df01ebd570c4393628cf5e52965e0d2">accumulate</a> (T init, binOp op1, unOp op2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accumulate over all values, similar to std::accumulate.  <a href="#a3df01ebd570c4393628cf5e52965e0d2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename unOp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a5f16d6a4b80a69cee98f8900eb36ca7a">accumulateSum</a> (T init, unOp op) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accumulate all values (similar to std::accumulate) by summing.  <a href="#a5f16d6a4b80a69cee98f8900eb36ca7a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename unOp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a8306cc2dbbf78e1c821b14505e873eea">accumulateMax</a> (T init, unOp op, bool minimize) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accumulate all values (similar to std::accumulate) by maximization/minimization.  <a href="#a8306cc2dbbf78e1c821b14505e873eea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#ae259baa00d23dc230ee8a9c79ad4fefb">entropy</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the Shannon entropy of <code>*this</code>, <img class="formulaInl" alt="$-\sum_i p_i \log p_i$" src="form_75.png"/>.  <a href="#ae259baa00d23dc230ee8a9c79ad4fefb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#abb905776961ac0533a38e8a41ea7389e">max</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns maximum value of all entries.  <a href="#abb905776961ac0533a38e8a41ea7389e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a93e3f2147498dd27bbea8154d93e046e">min</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns minimum value of all entries.  <a href="#a93e3f2147498dd27bbea8154d93e046e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#af1ca4f76c136ffe0026d19248aca92a6">sum</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns sum of all entries.  <a href="#af1ca4f76c136ffe0026d19248aca92a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a0471f7df573d9f2b950bc53c16605a32">sumAbs</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return sum of absolute value of all entries.  <a href="#a0471f7df573d9f2b950bc53c16605a32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a55b056b8834e159f4551136728bdb36a">maxAbs</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns maximum absolute value of all entries.  <a href="#a55b056b8834e159f4551136728bdb36a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#ab6a4ee056d92a0d59aab7cc0e141fd68">hasNaNs</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if one or more entries are NaN.  <a href="#ab6a4ee056d92a0d59aab7cc0e141fd68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#aaeabc65b661d9aa8b1321c7fcece7da4">hasNegatives</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if one or more entries are negative.  <a href="#aaeabc65b661d9aa8b1321c7fcece7da4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; size_t, T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a20dfad851c74251faacb57e143713eff">argmax</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pair consisting of the index of the maximum value and the maximum value itself.  <a href="#a20dfad851c74251faacb57e143713eff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a450a77f9a7c4a8a49702cc2afbf2e40a">draw</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a random index, according to the (normalized) distribution described by *this.  <a href="#a450a77f9a7c4a8a49702cc2afbf2e40a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#ad973502d526f51f447d704fa41ac17dd">operator&lt;</a> (const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;q) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lexicographical comparison.  <a href="#ad973502d526f51f447d704fa41ac17dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#aab76d678deecbe23d367bd86e59656c1">operator==</a> (const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;q) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison.  <a href="#aab76d678deecbe23d367bd86e59656c1"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Unary transformations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp6d3c1562ce010b1e47aa74a6c0947c0e"></a> </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename unaryOp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#ab54f4cd66bf744b88f177bd9c45f0ae0">pwUnaryTr</a> (unaryOp op) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the result of applying operation <em>op</em> pointwise on <code>*this</code>.  <a href="#ab54f4cd66bf744b88f177bd9c45f0ae0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a0156c24d784c9404e685f57cb518e3f7">operator-</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns negative of <code>*this</code>.  <a href="#a0156c24d784c9404e685f57cb518e3f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a061ecd1892ac6ae57be80db580f29efe">abs</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns pointwise absolute value.  <a href="#a061ecd1892ac6ae57be80db580f29efe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a27158827f4792af74db4051f36d9ab08">exp</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns pointwise exponent.  <a href="#a27158827f4792af74db4051f36d9ab08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#ab1bc1560f41eb6058a2cd11173702bf1">log</a> (bool zero=false) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns pointwise logarithm.  <a href="#ab1bc1560f41eb6058a2cd11173702bf1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#afe0075daa9071ae8e847252ab162a8a1">inverse</a> (bool zero=true) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns pointwise inverse.  <a href="#afe0075daa9071ae8e847252ab162a8a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a2d46eaa02bcc8ff6a0a480302cdcd7c0">normalized</a> (<a class="el" href="namespacedai.html#ae0d0ef753bd0ba57586e556ab6312677">ProbNormType</a> norm=dai::NORMPROB) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns normalized copy of <code>*this</code>, using the specified norm.  <a href="#a2d46eaa02bcc8ff6a0a480302cdcd7c0"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Unary operations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpa425d370480e269b94155ccb20f15a81"></a> </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename unaryOp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a3dca5c7c4958a86943332f201d530646">pwUnaryOp</a> (unaryOp op)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies unary operation <em>op</em> pointwise.  <a href="#a3dca5c7c4958a86943332f201d530646"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a2aca727d782ce95d9dc38e9e1b7b6587">randomize</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws all entries i.i.d. from a uniform distribution on [0,1).  <a href="#a2aca727d782ce95d9dc38e9e1b7b6587"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#aa5534cc0a31cedd9d437bdd796c1ed83">setUniform</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets all entries to <img class="formulaInl" alt="$1/n$" src="form_76.png"/> where <em>n</em> is the length of the vector.  <a href="#aa5534cc0a31cedd9d437bdd796c1ed83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#ab504f9bb3ce566eb0cb562151cd08366">takeAbs</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies absolute value pointwise.  <a href="#ab504f9bb3ce566eb0cb562151cd08366"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#af854cbac63f9029639e3115cebe50d6c">takeExp</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies exponent pointwise.  <a href="#af854cbac63f9029639e3115cebe50d6c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#ab612dd263551e85c413a24ac063981e7">takeLog</a> (bool zero=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies logarithm pointwise.  <a href="#ab612dd263551e85c413a24ac063981e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#ab2414cf14329da58b0519adf8d783cb5">normalize</a> (<a class="el" href="namespacedai.html#ae0d0ef753bd0ba57586e556ab6312677">ProbNormType</a> norm=dai::NORMPROB)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalizes vector using the specified norm.  <a href="#ab2414cf14329da58b0519adf8d783cb5"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Operations with scalars</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp06ff33806998592997f32fc8c41bfb21"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a9522ab8fb17ee8a15b4bcd0f1619f1a1">fill</a> (T x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets all entries to <em>x</em>.  <a href="#a9522ab8fb17ee8a15b4bcd0f1619f1a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a3ac92817a198c48af4c338b6fa804242">operator+=</a> (T x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds scalar <em>x</em> to each entry.  <a href="#a3ac92817a198c48af4c338b6fa804242"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a52621da036bcfa1f8b1ceffdcd79dfb2">operator-=</a> (T x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtracts scalar <em>x</em> from each entry.  <a href="#a52621da036bcfa1f8b1ceffdcd79dfb2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#afd4b81e9c75d9cb9a321acfc4da8d958">operator*=</a> (T x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplies each entry with scalar <em>x</em>.  <a href="#afd4b81e9c75d9cb9a321acfc4da8d958"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a96db9160dee43c0ef83d127938d0a92f">operator/=</a> (T x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Divides each entry by scalar <em>x</em>, where division by 0 yields 0.  <a href="#a96db9160dee43c0ef83d127938d0a92f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a724b980ec2c8b4a69bbf765894749d66">operator^=</a> (T x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Raises entries to the power <em>x</em>.  <a href="#a724b980ec2c8b4a69bbf765894749d66"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Transformations with scalars</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp5b4ef96ca9ab725bb7f51275c0598aa3"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#ac01f57c34a4e73a37db076c010240767">operator+</a> (T x) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns sum of <code>*this</code> and scalar <em>x</em>.  <a href="#ac01f57c34a4e73a37db076c010240767"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a30b7ea3a6ad3d17e763e424b4f4fcc6f">operator-</a> (T x) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns difference of <code>*this</code> and scalar <em>x</em>.  <a href="#a30b7ea3a6ad3d17e763e424b4f4fcc6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#ab098ea2b20f7cd8a3bd9b6d0b0abf67c">operator*</a> (T x) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns product of <code>*this</code> with scalar <em>x</em>.  <a href="#ab098ea2b20f7cd8a3bd9b6d0b0abf67c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a6f0573f9e0dbe3ee49bd048b722d4cbf">operator/</a> (T x) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns quotient of <code>*this</code> and scalar <em>x</em>, where division by 0 yields 0.  <a href="#a6f0573f9e0dbe3ee49bd048b722d4cbf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a074098a39665316299268b3851812bb6">operator^</a> (T x) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>*this</code> raised to the power <em>x</em>.  <a href="#a074098a39665316299268b3851812bb6"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Operations with other equally-sized vectors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpefa7cf78bda3a4c66c7339c908e1dea1"></a> </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename binaryOp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a89ba3f154c5ee49e9b741c907f52e772">pwBinaryOp</a> (const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;q, binaryOp op)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies binary operation pointwise on two vectors.  <a href="#a89ba3f154c5ee49e9b741c907f52e772"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#ad4acfd3184f92a0418f42be88256b4ea">operator+=</a> (const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;q)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointwise addition with <em>q</em>.  <a href="#ad4acfd3184f92a0418f42be88256b4ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#af2af5b7cf99d958b867338e54734c45a">operator-=</a> (const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;q)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointwise subtraction of <em>q</em>.  <a href="#af2af5b7cf99d958b867338e54734c45a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#aa0e26d77620b8a3d07d1ec7843fa0c56">operator*=</a> (const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;q)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointwise multiplication with <em>q</em>.  <a href="#aa0e26d77620b8a3d07d1ec7843fa0c56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a5a141778b339e2cce742ca6f7a5a2eaa">operator/=</a> (const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;q)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointwise division by <em>q</em>, where division by 0 yields 0.  <a href="#a5a141778b339e2cce742ca6f7a5a2eaa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a3aafaddd7cfeb51b46606a4d77e99c41">divide</a> (const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;q)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointwise division by <em>q</em>, where division by 0 yields +Inf.  <a href="#a3aafaddd7cfeb51b46606a4d77e99c41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a61e35d41a5716685f8536f9ecbc655cd">operator^=</a> (const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;q)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointwise power.  <a href="#a61e35d41a5716685f8536f9ecbc655cd"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Transformations with other equally-sized vectors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp34c40deda7aceb2bc493d2d92e1cb748"></a> </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename binaryOp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a66410841d35d573ea54ebf2bd91150f0">pwBinaryTr</a> (const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;q, binaryOp op) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the result of applying binary operation <em>op</em> pointwise on <code>*this</code> and <em>q</em>.  <a href="#a66410841d35d573ea54ebf2bd91150f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#ad626a9026442276889c629217f10f04d">operator+</a> (const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;q) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns sum of <code>*this</code> and <em>q</em>.  <a href="#ad626a9026442276889c629217f10f04d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#abd29d7c5df8a54c8139edeaaddc61c81">operator-</a> (const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;q) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <code>*this</code> minus <em>q</em>.  <a href="#abd29d7c5df8a54c8139edeaaddc61c81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a882dd82ffb2b2d3cd709b07fede37a46">operator*</a> (const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;q) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return product of <code>*this</code> with <em>q</em>.  <a href="#a882dd82ffb2b2d3cd709b07fede37a46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#ae10251b3e36a146d92732e0df5ca3fc5">operator/</a> (const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;q) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns quotient of <code>*this</code> with <em>q</em>, where division by 0 yields 0.  <a href="#ae10251b3e36a146d92732e0df5ca3fc5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a22bcf17b9eb7d6680d163eafff62e325">divided_by</a> (const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;q) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointwise division by <em>q</em>, where division by 0 yields +Inf.  <a href="#a22bcf17b9eb7d6680d163eafff62e325"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">this_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a45912403206dece7aa792325378f9bcb">operator^</a> (const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;q) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>*this</code> to the power <em>q</em>.  <a href="#a45912403206dece7aa792325378f9bcb"></a><br/></td></tr>
<tr><td colspan="2"><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html#ada85efb9bd3e5624cc559e74c9c20de9">container_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a2affaa300fa1ebd563723d112bc6ee6d">_p</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The data structure that stores the values.  <a href="#a2affaa300fa1ebd563723d112bc6ee6d"></a><br/></td></tr>
<tr><td colspan="2"><h2>Related Functions</h2></td></tr>
<tr><td colspan="2"><p>(Note that these are not member functions.) </p>
<br/><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a483e0c43b6631630272bc110e8c427a3">dist</a> (const <a class="el" href="classdai_1_1TProb.html">TProb</a>&lt; T &gt; &amp;p, const <a class="el" href="classdai_1_1TProb.html">TProb</a>&lt; T &gt; &amp;q, <a class="el" href="namespacedai.html#aa2735a823696443089d2de23e8ee6ecb">ProbDistType</a> dt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns distance between <em>p</em> and <em>q</em>, measured using distance measure <em>dt</em>.  <a href="#a483e0c43b6631630272bc110e8c427a3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#af4fa6ae7b745e67117f0f692e9b89be9">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdai_1_1TProb.html">TProb</a>&lt; T &gt; &amp;p)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a TProb&lt;T&gt; to an output stream.  <a href="#af4fa6ae7b745e67117f0f692e9b89be9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">TProb</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#a66e3ac3f34c932779ea24d7b6630032f">min</a> (const <a class="el" href="classdai_1_1TProb.html">TProb</a>&lt; T &gt; &amp;a, const <a class="el" href="classdai_1_1TProb.html">TProb</a>&lt; T &gt; &amp;b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the pointwise minimum of <em>a</em> and <em>b</em>.  <a href="#a66e3ac3f34c932779ea24d7b6630032f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProb.html">TProb</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html#af32f17b0148c33d1573267d9f6fceb02">max</a> (const <a class="el" href="classdai_1_1TProb.html">TProb</a>&lt; T &gt; &amp;a, const <a class="el" href="classdai_1_1TProb.html">TProb</a>&lt; T &gt; &amp;b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the pointwise maximum of <em>a</em> and <em>b</em>.  <a href="#af32f17b0148c33d1573267d9f6fceb02"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename T&gt;<br/>
 class dai::TProb&lt; T &gt;</h3>

<p>Represents a vector with entries of type <em>T</em>. </p>
<p>It is simply a <code>std::vector</code>&lt;<em>T</em>&gt; with an interface designed for dealing with probability mass functions.</p>
<p>It is mainly used for representing measures on a finite outcome space, for example, the probability distribution of a discrete random variable. However, entries are not necessarily non-negative; it is also used to represent logarithms of probability mass functions.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>Should be a scalar that is castable from and to <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf" title="Real number (alias for double, which could be changed to long double if necessary)...">dai::Real</a> and should support elementary arithmetic operations. </td></tr>
  </table>
  </dd>
</dl>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="ada85efb9bd3e5624cc559e74c9c20de9"></a><!-- doxytag: member="dai::TProb::container_type" ref="ada85efb9bd3e5624cc559e74c9c20de9" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;T&gt; <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::<a class="el" href="classdai_1_1TProb.html#ada85efb9bd3e5624cc559e74c9c20de9">container_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of data structure used for storing the values. </p>

</div>
</div>
<a class="anchor" id="a3fd857f47bad7e3917df607cb38aa2ae"></a><!-- doxytag: member="dai::TProb::this_type" ref="a3fd857f47bad7e3917df607cb38aa2ae" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classdai_1_1TProb.html">TProb</a>&lt;T&gt; <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::<a class="el" href="classdai_1_1TProb.html">this_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shorthand. </p>

</div>
</div>
<a class="anchor" id="a576e88e240684174a6fd2804271bfbaa"></a><!-- doxytag: member="dai::TProb::const_iterator" ref="a576e88e240684174a6fd2804271bfbaa" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef container_type::const_iterator <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::<a class="el" href="classdai_1_1TProb.html#a576e88e240684174a6fd2804271bfbaa">const_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constant iterator over the elements. </p>

</div>
</div>
<a class="anchor" id="ac3ae154b6e88196962c65bb725361052"></a><!-- doxytag: member="dai::TProb::iterator" ref="ac3ae154b6e88196962c65bb725361052" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef container_type::iterator <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::<a class="el" href="classdai_1_1TProb.html#ac3ae154b6e88196962c65bb725361052">iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterator over the elements. </p>

</div>
</div>
<a class="anchor" id="a37fb7b49feae193b466d370b501385a5"></a><!-- doxytag: member="dai::TProb::const_reverse_iterator" ref="a37fb7b49feae193b466d370b501385a5" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef container_type::const_reverse_iterator <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::<a class="el" href="classdai_1_1TProb.html#a37fb7b49feae193b466d370b501385a5">const_reverse_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constant reverse iterator over the elements. </p>

</div>
</div>
<a class="anchor" id="a7b755e30b8bfaccacbde4e71952753ac"></a><!-- doxytag: member="dai::TProb::reverse_iterator" ref="a7b755e30b8bfaccacbde4e71952753ac" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef container_type::reverse_iterator <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::<a class="el" href="classdai_1_1TProb.html#a7b755e30b8bfaccacbde4e71952753ac">reverse_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reverse iterator over the elements. </p>

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a31d9206096f52574dbd24cbb2502080c"></a><!-- doxytag: member="dai::TProb::NormType" ref="a31d9206096f52574dbd24cbb2502080c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classdai_1_1TProb.html#a31d9206096f52574dbd24cbb2502080c">dai::TProb::NormType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enumerates different ways of normalizing a probability measure. </p>
<ul>
<li>NORMPROB means that the sum of all entries should be 1;</li>
<li>NORMLINF means that the maximum absolute value of all entries should be 1. <dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000013">Deprecated:</a></b></dt><dd>Please use <a class="el" href="namespacedai.html#ae0d0ef753bd0ba57586e556ab6312677" title="Enumerates different ways of normalizing a probability measure.">dai::ProbNormType</a> instead. </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a492487fd71f6e87673853e5e2fda2f27"></a><!-- doxytag: member="dai::TProb::DistType" ref="a492487fd71f6e87673853e5e2fda2f27" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classdai_1_1TProb.html#a492487fd71f6e87673853e5e2fda2f27">dai::TProb::DistType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enumerates different distance measures between probability measures. </p>
<ul>
<li>DISTL1 is the <img class="formulaInl" alt="$\ell_1$" src="form_118.png"/> distance (sum of absolute values of pointwise difference);</li>
<li>DISTLINF is the <img class="formulaInl" alt="$\ell_\infty$" src="form_119.png"/> distance (maximum absolute value of pointwise difference);</li>
<li>DISTTV is the total variation distance (half of the <img class="formulaInl" alt="$\ell_1$" src="form_118.png"/> distance);</li>
<li>DISTKL is the Kullback-Leibler distance (<img class="formulaInl" alt="$\sum_i p_i (\log p_i - \log q_i)$" src="form_120.png"/>).</li>
<li>DISTHEL is the Hellinger distance (<img class="formulaInl" alt="$\frac{1}{2}\sum_i (\sqrt{p_i}-\sqrt{q_i})^2$" src="form_121.png"/>). <dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000014">Deprecated:</a></b></dt><dd>Please use <a class="el" href="namespacedai.html#aa2735a823696443089d2de23e8ee6ecb" title="Enumerates different distance measures between probability measures.">dai::ProbDistType</a> instead. </dd></dl>
</li>
</ul>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a81f9393fa860a6bb005c8286bf9aceab"></a><!-- doxytag: member="dai::TProb::TProb" ref="a81f9393fa860a6bb005c8286bf9aceab" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::<a class="el" href="classdai_1_1TProb.html">TProb</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor (constructs empty vector). </p>

</div>
</div>
<a class="anchor" id="a851cd9b5be495df487fb177b0e06a1dd"></a><!-- doxytag: member="dai::TProb::TProb" ref="a851cd9b5be495df487fb177b0e06a1dd" args="(size_t n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::<a class="el" href="classdai_1_1TProb.html">TProb</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct uniform probability distribution over <em>n</em> outcomes (i.e., a vector of length <em>n</em> with each entry set to <img class="formulaInl" alt="$1/n$" src="form_76.png"/>). </p>

</div>
</div>
<a class="anchor" id="acf3b7ed6e5a0c276b1bcced58c3437dc"></a><!-- doxytag: member="dai::TProb::TProb" ref="acf3b7ed6e5a0c276b1bcced58c3437dc" args="(size_t n, T p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::<a class="el" href="classdai_1_1TProb.html">TProb</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct vector of length <em>n</em> with each entry set to <em>p</em>. </p>

</div>
</div>
<a class="anchor" id="a65619b3015acb5b208db15640726ea7f"></a><!-- doxytag: member="dai::TProb::TProb" ref="a65619b3015acb5b208db15640726ea7f" args="(TIterator begin, TIterator end, size_t sizeHint=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename TIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::<a class="el" href="classdai_1_1TProb.html">TProb</a> </td>
          <td>(</td>
          <td class="paramtype">TIterator&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sizeHint</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct vector from a range. </p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>TIterator</em>&nbsp;</td><td>Iterates over instances that can be cast to <em>T</em> </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>begin</em>&nbsp;</td><td>Points to first instance to be added. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>Points just beyond last instance to be added. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sizeHint</em>&nbsp;</td><td>For efficiency, the number of entries can be speficied by <em>sizeHint</em>; the value 0 can be given if the size is unknown, but this will result in a performance penalty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000015">Deprecated:</a></b></dt><dd>In future libDAI versions, the <em>sizeHint</em> argument will no longer default to 0. </dd></dl>

</div>
</div>
<a class="anchor" id="aa65f38bf3cc4212624adfb4725e1f8c1"></a><!-- doxytag: member="dai::TProb::TProb" ref="aa65f38bf3cc4212624adfb4725e1f8c1" args="(const std::vector&lt; S &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::<a class="el" href="classdai_1_1TProb.html">TProb</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; S &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct vector from another vector. </p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>S</em>&nbsp;</td><td>type of elements in <em>v</em> (should be castable to type <em>T</em>) </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>vector used for initialization. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a416477b179ecfc91299d07ecd66a473e"></a><!-- doxytag: member="dai::TProb::begin" ref="a416477b179ecfc91299d07ecd66a473e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html#ac3ae154b6e88196962c65bb725361052">iterator</a> <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns iterator that points to the first element. </p>

</div>
</div>
<a class="anchor" id="ae05c654ec4b36f719ad122f57c80f8f6"></a><!-- doxytag: member="dai::TProb::begin" ref="ae05c654ec4b36f719ad122f57c80f8f6" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html#a576e88e240684174a6fd2804271bfbaa">const_iterator</a> <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns constant iterator that points to the first element. </p>

</div>
</div>
<a class="anchor" id="af61408263bab9270d81f3f791a406e1f"></a><!-- doxytag: member="dai::TProb::end" ref="af61408263bab9270d81f3f791a406e1f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html#ac3ae154b6e88196962c65bb725361052">iterator</a> <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns iterator that points beyond the last element. </p>

</div>
</div>
<a class="anchor" id="a8c97e23797c8e9d7236d6e8d229f9a5c"></a><!-- doxytag: member="dai::TProb::end" ref="a8c97e23797c8e9d7236d6e8d229f9a5c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html#a576e88e240684174a6fd2804271bfbaa">const_iterator</a> <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns constant iterator that points beyond the last element. </p>

</div>
</div>
<a class="anchor" id="afc07e604de573d743427d2b92fcd710a"></a><!-- doxytag: member="dai::TProb::rbegin" ref="afc07e604de573d743427d2b92fcd710a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html#a7b755e30b8bfaccacbde4e71952753ac">reverse_iterator</a> <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns reverse iterator that points to the last element. </p>

</div>
</div>
<a class="anchor" id="a0fab959dfd34104f127caa3cddad2ddd"></a><!-- doxytag: member="dai::TProb::rbegin" ref="a0fab959dfd34104f127caa3cddad2ddd" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html#a37fb7b49feae193b466d370b501385a5">const_reverse_iterator</a> <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns constant reverse iterator that points to the last element. </p>

</div>
</div>
<a class="anchor" id="a05318f090b80662cb13ccca1baa88f94"></a><!-- doxytag: member="dai::TProb::rend" ref="a05318f090b80662cb13ccca1baa88f94" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html#a7b755e30b8bfaccacbde4e71952753ac">reverse_iterator</a> <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns reverse iterator that points beyond the first element. </p>

</div>
</div>
<a class="anchor" id="a69d41c85b7ab47ef335b14c041f4f9d7"></a><!-- doxytag: member="dai::TProb::rend" ref="a69d41c85b7ab47ef335b14c041f4f9d7" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html#a37fb7b49feae193b466d370b501385a5">const_reverse_iterator</a> <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns constant reverse iterator that points beyond the first element. </p>

</div>
</div>
<a class="anchor" id="a6ae623febe192134f7011526cbef2b80"></a><!-- doxytag: member="dai::TProb::get" ref="a6ae623febe192134f7011526cbef2b80" args="(size_t i) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets <em>i</em> 'th entry. </p>

</div>
</div>
<a class="anchor" id="a3e2be310024be448dacd132e04c0ab01"></a><!-- doxytag: member="dai::TProb::set" ref="a3e2be310024be448dacd132e04c0ab01" args="(size_t i, T val)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::set </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets <em>i</em> 'th entry to <em>val</em>. </p>

</div>
</div>
<a class="anchor" id="a243cb9987f616aee014b8fc767fc61b1"></a><!-- doxytag: member="dai::TProb::p" ref="a243cb9987f616aee014b8fc767fc61b1" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdai_1_1TProb.html#ada85efb9bd3e5624cc559e74c9c20de9">container_type</a>&amp; <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::p </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a const reference to the wrapped container. </p>

</div>
</div>
<a class="anchor" id="ad5f87d2c6f72001d1c2c046540dc8c9d"></a><!-- doxytag: member="dai::TProb::p" ref="ad5f87d2c6f72001d1c2c046540dc8c9d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html#ada85efb9bd3e5624cc559e74c9c20de9">container_type</a>&amp; <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::p </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a reference to the wrapped container. </p>

</div>
</div>
<a class="anchor" id="aa349fd5cb6373a5268f7ad6caa41c03b"></a><!-- doxytag: member="dai::TProb::operator[]" ref="aa349fd5cb6373a5268f7ad6caa41c03b" args="(size_t i) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a copy of the <em>i</em> 'th entry. </p>

</div>
</div>
<a class="anchor" id="ae305a0821f4afacf5a324297cc6fdb99"></a><!-- doxytag: member="dai::TProb::operator[]" ref="ae305a0821f4afacf5a324297cc6fdb99" args="(size_t i)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns reference to the <em>i</em> 'th entry. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated:</a></b></dt><dd>Please use <a class="el" href="classdai_1_1TProb.html#a3e2be310024be448dacd132e04c0ab01" title="Sets i &#39;th entry to val.">dai::TProb::set()</a> instead </dd></dl>

</div>
</div>
<a class="anchor" id="a8bfc7de7f2a1ed95cb129d0467c7b88d"></a><!-- doxytag: member="dai::TProb::size" ref="a8bfc7de7f2a1ed95cb129d0467c7b88d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns length of the vector (i.e., the number of entries). </p>

</div>
</div>
<a class="anchor" id="a3df01ebd570c4393628cf5e52965e0d2"></a><!-- doxytag: member="dai::TProb::accumulate" ref="a3df01ebd570c4393628cf5e52965e0d2" args="(T init, binOp op1, unOp op2) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename binOp , typename unOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::accumulate </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">binOp&nbsp;</td>
          <td class="paramname"> <em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unOp&nbsp;</td>
          <td class="paramname"> <em>op2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accumulate over all values, similar to std::accumulate. </p>
<p>The following calculation is done: </p>
<div class="fragment"><pre class="fragment">  T t = op2(init);
  <span class="keywordflow">for</span>( <a class="code" href="classdai_1_1TProb.html#a576e88e240684174a6fd2804271bfbaa" title="Constant iterator over the elements.">const_iterator</a> it = <a class="code" href="classdai_1_1TProb.html#a416477b179ecfc91299d07ecd66a473e" title="Returns iterator that points to the first element.">begin</a>(); it != <a class="code" href="classdai_1_1TProb.html#af61408263bab9270d81f3f791a406e1f" title="Returns iterator that points beyond the last element.">end</a>(); it++ )
      t = op1( t, op2(*it) );
  <span class="keywordflow">return</span> t;
</pre></div> <dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated:</a></b></dt><dd>Please use <a class="el" href="classdai_1_1TProb.html#a5f16d6a4b80a69cee98f8900eb36ca7a" title="Accumulate all values (similar to std::accumulate) by summing.">dai::TProb::accumulateSum</a> or <a class="el" href="classdai_1_1TProb.html#a8306cc2dbbf78e1c821b14505e873eea" title="Accumulate all values (similar to std::accumulate) by maximization/minimization.">dai::TProb::accumulateMax</a> instead </dd></dl>

</div>
</div>
<a class="anchor" id="a5f16d6a4b80a69cee98f8900eb36ca7a"></a><!-- doxytag: member="dai::TProb::accumulateSum" ref="a5f16d6a4b80a69cee98f8900eb36ca7a" args="(T init, unOp op) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename unOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::accumulateSum </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unOp&nbsp;</td>
          <td class="paramname"> <em>op</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accumulate all values (similar to std::accumulate) by summing. </p>
<p>The following calculation is done: </p>
<div class="fragment"><pre class="fragment">  T t = op(init);
  <span class="keywordflow">for</span>( <a class="code" href="classdai_1_1TProb.html#a576e88e240684174a6fd2804271bfbaa" title="Constant iterator over the elements.">const_iterator</a> it = <a class="code" href="classdai_1_1TProb.html#a416477b179ecfc91299d07ecd66a473e" title="Returns iterator that points to the first element.">begin</a>(); it != <a class="code" href="classdai_1_1TProb.html#af61408263bab9270d81f3f791a406e1f" title="Returns iterator that points beyond the last element.">end</a>(); it++ )
      t += op(*it);
  <span class="keywordflow">return</span> t;
</pre></div> 
</div>
</div>
<a class="anchor" id="a8306cc2dbbf78e1c821b14505e873eea"></a><!-- doxytag: member="dai::TProb::accumulateMax" ref="a8306cc2dbbf78e1c821b14505e873eea" args="(T init, unOp op, bool minimize) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename unOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::accumulateMax </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unOp&nbsp;</td>
          <td class="paramname"> <em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>minimize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accumulate all values (similar to std::accumulate) by maximization/minimization. </p>
<p>The following calculation is done (with "max" replaced by "min" if <em>minimize</em> == <code>true</code>): </p>
<div class="fragment"><pre class="fragment">  T t = op(init);
  <span class="keywordflow">for</span>( <a class="code" href="classdai_1_1TProb.html#a576e88e240684174a6fd2804271bfbaa" title="Constant iterator over the elements.">const_iterator</a> it = <a class="code" href="classdai_1_1TProb.html#a416477b179ecfc91299d07ecd66a473e" title="Returns iterator that points to the first element.">begin</a>(); it != <a class="code" href="classdai_1_1TProb.html#af61408263bab9270d81f3f791a406e1f" title="Returns iterator that points beyond the last element.">end</a>(); it++ )
      t = std::max( t, op(*it) );
  <span class="keywordflow">return</span> t;
</pre></div> 
</div>
</div>
<a class="anchor" id="ae259baa00d23dc230ee8a9c79ad4fefb"></a><!-- doxytag: member="dai::TProb::entropy" ref="ae259baa00d23dc230ee8a9c79ad4fefb" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::entropy </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the Shannon entropy of <code>*this</code>, <img class="formulaInl" alt="$-\sum_i p_i \log p_i$" src="form_75.png"/>. </p>

</div>
</div>
<a class="anchor" id="abb905776961ac0533a38e8a41ea7389e"></a><!-- doxytag: member="dai::TProb::max" ref="abb905776961ac0533a38e8a41ea7389e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::max </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns maximum value of all entries. </p>

</div>
</div>
<a class="anchor" id="a93e3f2147498dd27bbea8154d93e046e"></a><!-- doxytag: member="dai::TProb::min" ref="a93e3f2147498dd27bbea8154d93e046e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::min </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns minimum value of all entries. </p>

</div>
</div>
<a class="anchor" id="af1ca4f76c136ffe0026d19248aca92a6"></a><!-- doxytag: member="dai::TProb::sum" ref="af1ca4f76c136ffe0026d19248aca92a6" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::sum </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns sum of all entries. </p>

</div>
</div>
<a class="anchor" id="a0471f7df573d9f2b950bc53c16605a32"></a><!-- doxytag: member="dai::TProb::sumAbs" ref="a0471f7df573d9f2b950bc53c16605a32" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::sumAbs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return sum of absolute value of all entries. </p>

</div>
</div>
<a class="anchor" id="a55b056b8834e159f4551136728bdb36a"></a><!-- doxytag: member="dai::TProb::maxAbs" ref="a55b056b8834e159f4551136728bdb36a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::maxAbs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns maximum absolute value of all entries. </p>

</div>
</div>
<a class="anchor" id="ab6a4ee056d92a0d59aab7cc0e141fd68"></a><!-- doxytag: member="dai::TProb::hasNaNs" ref="ab6a4ee056d92a0d59aab7cc0e141fd68" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::hasNaNs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if one or more entries are NaN. </p>

</div>
</div>
<a class="anchor" id="aaeabc65b661d9aa8b1321c7fcece7da4"></a><!-- doxytag: member="dai::TProb::hasNegatives" ref="aaeabc65b661d9aa8b1321c7fcece7da4" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::hasNegatives </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if one or more entries are negative. </p>

</div>
</div>
<a class="anchor" id="a20dfad851c74251faacb57e143713eff"></a><!-- doxytag: member="dai::TProb::argmax" ref="a20dfad851c74251faacb57e143713eff" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;size_t,T&gt; <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::argmax </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a pair consisting of the index of the maximum value and the maximum value itself. </p>

</div>
</div>
<a class="anchor" id="a450a77f9a7c4a8a49702cc2afbf2e40a"></a><!-- doxytag: member="dai::TProb::draw" ref="a450a77f9a7c4a8a49702cc2afbf2e40a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::draw </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a random index, according to the (normalized) distribution described by *this. </p>

</div>
</div>
<a class="anchor" id="ad973502d526f51f447d704fa41ac17dd"></a><!-- doxytag: member="dai::TProb::operator&lt;" ref="ad973502d526f51f447d704fa41ac17dd" args="(const this_type &amp;q) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lexicographical comparison. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProb.html#a8bfc7de7f2a1ed95cb129d0467c7b88d" title="Returns length of the vector (i.e., the number of entries).">size()</a> == q.size()</code> </dd></dl>

</div>
</div>
<a class="anchor" id="aab76d678deecbe23d367bd86e59656c1"></a><!-- doxytag: member="dai::TProb::operator==" ref="aab76d678deecbe23d367bd86e59656c1" args="(const this_type &amp;q) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Comparison. </p>

</div>
</div>
<a class="anchor" id="ab54f4cd66bf744b88f177bd9c45f0ae0"></a><!-- doxytag: member="dai::TProb::pwUnaryTr" ref="ab54f4cd66bf744b88f177bd9c45f0ae0" args="(unaryOp op) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename unaryOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a> <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::pwUnaryTr </td>
          <td>(</td>
          <td class="paramtype">unaryOp&nbsp;</td>
          <td class="paramname"> <em>op</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the result of applying operation <em>op</em> pointwise on <code>*this</code>. </p>

</div>
</div>
<a class="anchor" id="a0156c24d784c9404e685f57cb518e3f7"></a><!-- doxytag: member="dai::TProb::operator&#45;" ref="a0156c24d784c9404e685f57cb518e3f7" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a> <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns negative of <code>*this</code>. </p>

</div>
</div>
<a class="anchor" id="a061ecd1892ac6ae57be80db580f29efe"></a><!-- doxytag: member="dai::TProb::abs" ref="a061ecd1892ac6ae57be80db580f29efe" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a> <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::abs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns pointwise absolute value. </p>

</div>
</div>
<a class="anchor" id="a27158827f4792af74db4051f36d9ab08"></a><!-- doxytag: member="dai::TProb::exp" ref="a27158827f4792af74db4051f36d9ab08" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a> <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::exp </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns pointwise exponent. </p>

</div>
</div>
<a class="anchor" id="ab1bc1560f41eb6058a2cd11173702bf1"></a><!-- doxytag: member="dai::TProb::log" ref="ab1bc1560f41eb6058a2cd11173702bf1" args="(bool zero=false) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a> <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::log </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>zero</em> = <code>false</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns pointwise logarithm. </p>
<p>If <em>zero</em> == <code>true</code>, uses <code>log(0)==0</code>; otherwise, <code>log(0)==-Inf</code>. </p>

</div>
</div>
<a class="anchor" id="afe0075daa9071ae8e847252ab162a8a1"></a><!-- doxytag: member="dai::TProb::inverse" ref="afe0075daa9071ae8e847252ab162a8a1" args="(bool zero=true) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a> <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::inverse </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>zero</em> = <code>true</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns pointwise inverse. </p>
<p>If <em>zero</em> == <code>true</code>, uses <code>1/0==0</code>; otherwise, <code>1/0==Inf</code>. </p>

</div>
</div>
<a class="anchor" id="a2d46eaa02bcc8ff6a0a480302cdcd7c0"></a><!-- doxytag: member="dai::TProb::normalized" ref="a2d46eaa02bcc8ff6a0a480302cdcd7c0" args="(ProbNormType norm=dai::NORMPROB) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a> <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::normalized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedai.html#ae0d0ef753bd0ba57586e556ab6312677">ProbNormType</a>&nbsp;</td>
          <td class="paramname"> <em>norm</em> = <code>dai::NORMPROB</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns normalized copy of <code>*this</code>, using the specified norm. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NOT_NORMALIZABLE</em>&nbsp;</td><td>if the norm is zero </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3dca5c7c4958a86943332f201d530646"></a><!-- doxytag: member="dai::TProb::pwUnaryOp" ref="a3dca5c7c4958a86943332f201d530646" args="(unaryOp op)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename unaryOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::pwUnaryOp </td>
          <td>(</td>
          <td class="paramtype">unaryOp&nbsp;</td>
          <td class="paramname"> <em>op</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies unary operation <em>op</em> pointwise. </p>

</div>
</div>
<a class="anchor" id="a2aca727d782ce95d9dc38e9e1b7b6587"></a><!-- doxytag: member="dai::TProb::randomize" ref="a2aca727d782ce95d9dc38e9e1b7b6587" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::randomize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws all entries i.i.d. from a uniform distribution on [0,1). </p>

</div>
</div>
<a class="anchor" id="aa5534cc0a31cedd9d437bdd796c1ed83"></a><!-- doxytag: member="dai::TProb::setUniform" ref="aa5534cc0a31cedd9d437bdd796c1ed83" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::setUniform </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets all entries to <img class="formulaInl" alt="$1/n$" src="form_76.png"/> where <em>n</em> is the length of the vector. </p>

</div>
</div>
<a class="anchor" id="ab504f9bb3ce566eb0cb562151cd08366"></a><!-- doxytag: member="dai::TProb::takeAbs" ref="ab504f9bb3ce566eb0cb562151cd08366" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::takeAbs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies absolute value pointwise. </p>

</div>
</div>
<a class="anchor" id="af854cbac63f9029639e3115cebe50d6c"></a><!-- doxytag: member="dai::TProb::takeExp" ref="af854cbac63f9029639e3115cebe50d6c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::takeExp </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies exponent pointwise. </p>

</div>
</div>
<a class="anchor" id="ab612dd263551e85c413a24ac063981e7"></a><!-- doxytag: member="dai::TProb::takeLog" ref="ab612dd263551e85c413a24ac063981e7" args="(bool zero=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::takeLog </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>zero</em> = <code>false</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies logarithm pointwise. </p>
<p>If <em>zero</em> == <code>true</code>, uses <code>log(0)==0</code>; otherwise, <code>log(0)==-Inf</code>. </p>

</div>
</div>
<a class="anchor" id="ab2414cf14329da58b0519adf8d783cb5"></a><!-- doxytag: member="dai::TProb::normalize" ref="ab2414cf14329da58b0519adf8d783cb5" args="(ProbNormType norm=dai::NORMPROB)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::normalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedai.html#ae0d0ef753bd0ba57586e556ab6312677">ProbNormType</a>&nbsp;</td>
          <td class="paramname"> <em>norm</em> = <code>dai::NORMPROB</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normalizes vector using the specified norm. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NOT_NORMALIZABLE</em>&nbsp;</td><td>if the norm is zero </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9522ab8fb17ee8a15b4bcd0f1619f1a1"></a><!-- doxytag: member="dai::TProb::fill" ref="a9522ab8fb17ee8a15b4bcd0f1619f1a1" args="(T x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets all entries to <em>x</em>. </p>

</div>
</div>
<a class="anchor" id="a3ac92817a198c48af4c338b6fa804242"></a><!-- doxytag: member="dai::TProb::operator+=" ref="a3ac92817a198c48af4c338b6fa804242" args="(T x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds scalar <em>x</em> to each entry. </p>

</div>
</div>
<a class="anchor" id="a52621da036bcfa1f8b1ceffdcd79dfb2"></a><!-- doxytag: member="dai::TProb::operator&#45;=" ref="a52621da036bcfa1f8b1ceffdcd79dfb2" args="(T x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subtracts scalar <em>x</em> from each entry. </p>

</div>
</div>
<a class="anchor" id="afd4b81e9c75d9cb9a321acfc4da8d958"></a><!-- doxytag: member="dai::TProb::operator*=" ref="afd4b81e9c75d9cb9a321acfc4da8d958" args="(T x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiplies each entry with scalar <em>x</em>. </p>

</div>
</div>
<a class="anchor" id="a96db9160dee43c0ef83d127938d0a92f"></a><!-- doxytag: member="dai::TProb::operator/=" ref="a96db9160dee43c0ef83d127938d0a92f" args="(T x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Divides each entry by scalar <em>x</em>, where division by 0 yields 0. </p>

</div>
</div>
<a class="anchor" id="a724b980ec2c8b4a69bbf765894749d66"></a><!-- doxytag: member="dai::TProb::operator^=" ref="a724b980ec2c8b4a69bbf765894749d66" args="(T x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::operator^= </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Raises entries to the power <em>x</em>. </p>

</div>
</div>
<a class="anchor" id="ac01f57c34a4e73a37db076c010240767"></a><!-- doxytag: member="dai::TProb::operator+" ref="ac01f57c34a4e73a37db076c010240767" args="(T x) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a> <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns sum of <code>*this</code> and scalar <em>x</em>. </p>

</div>
</div>
<a class="anchor" id="a30b7ea3a6ad3d17e763e424b4f4fcc6f"></a><!-- doxytag: member="dai::TProb::operator&#45;" ref="a30b7ea3a6ad3d17e763e424b4f4fcc6f" args="(T x) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a> <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns difference of <code>*this</code> and scalar <em>x</em>. </p>

</div>
</div>
<a class="anchor" id="ab098ea2b20f7cd8a3bd9b6d0b0abf67c"></a><!-- doxytag: member="dai::TProb::operator*" ref="ab098ea2b20f7cd8a3bd9b6d0b0abf67c" args="(T x) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a> <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns product of <code>*this</code> with scalar <em>x</em>. </p>

</div>
</div>
<a class="anchor" id="a6f0573f9e0dbe3ee49bd048b722d4cbf"></a><!-- doxytag: member="dai::TProb::operator/" ref="a6f0573f9e0dbe3ee49bd048b722d4cbf" args="(T x) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a> <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns quotient of <code>*this</code> and scalar <em>x</em>, where division by 0 yields 0. </p>

</div>
</div>
<a class="anchor" id="a074098a39665316299268b3851812bb6"></a><!-- doxytag: member="dai::TProb::operator^" ref="a074098a39665316299268b3851812bb6" args="(T x) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a> <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::operator^ </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>*this</code> raised to the power <em>x</em>. </p>

</div>
</div>
<a class="anchor" id="a89ba3f154c5ee49e9b741c907f52e772"></a><!-- doxytag: member="dai::TProb::pwBinaryOp" ref="a89ba3f154c5ee49e9b741c907f52e772" args="(const this_type &amp;q, binaryOp op)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename binaryOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::pwBinaryOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">binaryOp&nbsp;</td>
          <td class="paramname"> <em>op</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies binary operation pointwise on two vectors. </p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>binaryOp</em>&nbsp;</td><td>Type of function object that accepts two arguments of type <em>T</em> and outputs a type <em>T</em> </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>Right operand </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>Operation of type <em>binaryOp</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad4acfd3184f92a0418f42be88256b4ea"></a><!-- doxytag: member="dai::TProb::operator+=" ref="ad4acfd3184f92a0418f42be88256b4ea" args="(const this_type &amp;q)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pointwise addition with <em>q</em>. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProb.html#a8bfc7de7f2a1ed95cb129d0467c7b88d" title="Returns length of the vector (i.e., the number of entries).">size()</a> == q.size()</code> </dd></dl>

</div>
</div>
<a class="anchor" id="af2af5b7cf99d958b867338e54734c45a"></a><!-- doxytag: member="dai::TProb::operator&#45;=" ref="af2af5b7cf99d958b867338e54734c45a" args="(const this_type &amp;q)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pointwise subtraction of <em>q</em>. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProb.html#a8bfc7de7f2a1ed95cb129d0467c7b88d" title="Returns length of the vector (i.e., the number of entries).">size()</a> == q.size()</code> </dd></dl>

</div>
</div>
<a class="anchor" id="aa0e26d77620b8a3d07d1ec7843fa0c56"></a><!-- doxytag: member="dai::TProb::operator*=" ref="aa0e26d77620b8a3d07d1ec7843fa0c56" args="(const this_type &amp;q)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pointwise multiplication with <em>q</em>. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProb.html#a8bfc7de7f2a1ed95cb129d0467c7b88d" title="Returns length of the vector (i.e., the number of entries).">size()</a> == q.size()</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a5a141778b339e2cce742ca6f7a5a2eaa"></a><!-- doxytag: member="dai::TProb::operator/=" ref="a5a141778b339e2cce742ca6f7a5a2eaa" args="(const this_type &amp;q)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pointwise division by <em>q</em>, where division by 0 yields 0. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProb.html#a8bfc7de7f2a1ed95cb129d0467c7b88d" title="Returns length of the vector (i.e., the number of entries).">size()</a> == q.size()</code> </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>divide(const TProb&lt;T&gt; &amp;) </dd></dl>

</div>
</div>
<a class="anchor" id="a3aafaddd7cfeb51b46606a4d77e99c41"></a><!-- doxytag: member="dai::TProb::divide" ref="a3aafaddd7cfeb51b46606a4d77e99c41" args="(const this_type &amp;q)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::divide </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pointwise division by <em>q</em>, where division by 0 yields +Inf. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProb.html#a8bfc7de7f2a1ed95cb129d0467c7b88d" title="Returns length of the vector (i.e., the number of entries).">size()</a> == q.size()</code> </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>operator/=(const TProb&lt;T&gt; &amp;) </dd></dl>

</div>
</div>
<a class="anchor" id="a61e35d41a5716685f8536f9ecbc655cd"></a><!-- doxytag: member="dai::TProb::operator^=" ref="a61e35d41a5716685f8536f9ecbc655cd" args="(const this_type &amp;q)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::operator^= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pointwise power. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProb.html#a8bfc7de7f2a1ed95cb129d0467c7b88d" title="Returns length of the vector (i.e., the number of entries).">size()</a> == q.size()</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a66410841d35d573ea54ebf2bd91150f0"></a><!-- doxytag: member="dai::TProb::pwBinaryTr" ref="a66410841d35d573ea54ebf2bd91150f0" args="(const this_type &amp;q, binaryOp op) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename binaryOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a> <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::pwBinaryTr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">binaryOp&nbsp;</td>
          <td class="paramname"> <em>op</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the result of applying binary operation <em>op</em> pointwise on <code>*this</code> and <em>q</em>. </p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>binaryOp</em>&nbsp;</td><td>Type of function object that accepts two arguments of type <em>T</em> and outputs a type <em>T</em> </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>Right operand </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>Operation of type <em>binaryOp</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad626a9026442276889c629217f10f04d"></a><!-- doxytag: member="dai::TProb::operator+" ref="ad626a9026442276889c629217f10f04d" args="(const this_type &amp;q) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a> <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns sum of <code>*this</code> and <em>q</em>. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProb.html#a8bfc7de7f2a1ed95cb129d0467c7b88d" title="Returns length of the vector (i.e., the number of entries).">size()</a> == q.size()</code> </dd></dl>

</div>
</div>
<a class="anchor" id="abd29d7c5df8a54c8139edeaaddc61c81"></a><!-- doxytag: member="dai::TProb::operator&#45;" ref="abd29d7c5df8a54c8139edeaaddc61c81" args="(const this_type &amp;q) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a> <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return <code>*this</code> minus <em>q</em>. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProb.html#a8bfc7de7f2a1ed95cb129d0467c7b88d" title="Returns length of the vector (i.e., the number of entries).">size()</a> == q.size()</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a882dd82ffb2b2d3cd709b07fede37a46"></a><!-- doxytag: member="dai::TProb::operator*" ref="a882dd82ffb2b2d3cd709b07fede37a46" args="(const this_type &amp;q) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a> <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return product of <code>*this</code> with <em>q</em>. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProb.html#a8bfc7de7f2a1ed95cb129d0467c7b88d" title="Returns length of the vector (i.e., the number of entries).">size()</a> == q.size()</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ae10251b3e36a146d92732e0df5ca3fc5"></a><!-- doxytag: member="dai::TProb::operator/" ref="ae10251b3e36a146d92732e0df5ca3fc5" args="(const this_type &amp;q) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a> <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns quotient of <code>*this</code> with <em>q</em>, where division by 0 yields 0. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProb.html#a8bfc7de7f2a1ed95cb129d0467c7b88d" title="Returns length of the vector (i.e., the number of entries).">size()</a> == q.size()</code> </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>divided_by(const TProb&lt;T&gt; &amp;) </dd></dl>

</div>
</div>
<a class="anchor" id="a22bcf17b9eb7d6680d163eafff62e325"></a><!-- doxytag: member="dai::TProb::divided_by" ref="a22bcf17b9eb7d6680d163eafff62e325" args="(const this_type &amp;q) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a> <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::divided_by </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pointwise division by <em>q</em>, where division by 0 yields +Inf. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProb.html#a8bfc7de7f2a1ed95cb129d0467c7b88d" title="Returns length of the vector (i.e., the number of entries).">size()</a> == q.size()</code> </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>operator/(const TProb&lt;T&gt; &amp;) </dd></dl>

</div>
</div>
<a class="anchor" id="a45912403206dece7aa792325378f9bcb"></a><!-- doxytag: member="dai::TProb::operator^" ref="a45912403206dece7aa792325378f9bcb" args="(const this_type &amp;q) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">this_type</a> <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::operator^ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>*this</code> to the power <em>q</em>. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProb.html#a8bfc7de7f2a1ed95cb129d0467c7b88d" title="Returns length of the vector (i.e., the number of entries).">size()</a> == q.size()</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a7d28e5829f9b006125acd83067f70153"></a><!-- doxytag: member="dai::TProb::innerProduct" ref="a7d28e5829f9b006125acd83067f70153" args="(const this_type &amp;q, T init, binOp1 binaryOp1, binOp2 binaryOp2) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename binOp1 , typename binOp2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::innerProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProb.html">this_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">binOp1&nbsp;</td>
          <td class="paramname"> <em>binaryOp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">binOp2&nbsp;</td>
          <td class="paramname"> <em>binaryOp2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a generalized inner product, similar to std::inner_product. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProb.html#a8bfc7de7f2a1ed95cb129d0467c7b88d" title="Returns length of the vector (i.e., the number of entries).">size()</a> == q.size()</code> </dd></dl>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a483e0c43b6631630272bc110e8c427a3"></a><!-- doxytag: member="dai::TProb::dist" ref="a483e0c43b6631630272bc110e8c427a3" args="(const TProb&lt; T &gt; &amp;p, const TProb&lt; T &gt; &amp;q, ProbDistType dt)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T dist </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProb.html">TProb</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProb.html">TProb</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedai.html#aa2735a823696443089d2de23e8ee6ecb">ProbDistType</a>&nbsp;</td>
          <td class="paramname"> <em>dt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns distance between <em>p</em> and <em>q</em>, measured using distance measure <em>dt</em>. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProb.html#a8bfc7de7f2a1ed95cb129d0467c7b88d" title="Returns length of the vector (i.e., the number of entries).">size()</a> == q.size()</code> </dd></dl>

</div>
</div>
<a class="anchor" id="af4fa6ae7b745e67117f0f692e9b89be9"></a><!-- doxytag: member="dai::TProb::operator&lt;&lt;" ref="af4fa6ae7b745e67117f0f692e9b89be9" args="(std::ostream &amp;os, const TProb&lt; T &gt; &amp;p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProb.html">TProb</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a TProb&lt;T&gt; to an output stream. </p>

</div>
</div>
<a class="anchor" id="a66e3ac3f34c932779ea24d7b6630032f"></a><!-- doxytag: member="dai::TProb::min" ref="a66e3ac3f34c932779ea24d7b6630032f" args="(const TProb&lt; T &gt; &amp;a, const TProb&lt; T &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">TProb</a>&lt; T &gt; min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProb.html">TProb</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProb.html">TProb</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the pointwise minimum of <em>a</em> and <em>b</em>. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProb.html#a8bfc7de7f2a1ed95cb129d0467c7b88d" title="Returns length of the vector (i.e., the number of entries).">size()</a> == q.size()</code> </dd></dl>

</div>
</div>
<a class="anchor" id="af32f17b0148c33d1573267d9f6fceb02"></a><!-- doxytag: member="dai::TProb::max" ref="af32f17b0148c33d1573267d9f6fceb02" args="(const TProb&lt; T &gt; &amp;a, const TProb&lt; T &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html">TProb</a>&lt; T &gt; max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProb.html">TProb</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProb.html">TProb</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the pointwise maximum of <em>a</em> and <em>b</em>. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProb.html#a8bfc7de7f2a1ed95cb129d0467c7b88d" title="Returns length of the vector (i.e., the number of entries).">size()</a> == q.size()</code> </dd></dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a2affaa300fa1ebd563723d112bc6ee6d"></a><!-- doxytag: member="dai::TProb::_p" ref="a2affaa300fa1ebd563723d112bc6ee6d" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProb.html#ada85efb9bd3e5624cc559e74c9c20de9">container_type</a> <a class="el" href="classdai_1_1TProb.html">dai::TProb</a>&lt; T &gt;::<a class="el" href="classdai_1_1TProb.html#a2affaa300fa1ebd563723d112bc6ee6d">_p</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The data structure that stores the values. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/dai/<a class="el" href="prob_8h_source.html">prob.h</a></li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Sun May 9 16:51:37 2010 for libDAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
