<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>libDAI: dai Namespace Reference</title>
<link href="customdoxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>dai Namespace Reference</h1>Namespace for libDAI.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1BBPCostFunction.html">BBPCostFunction</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Predefined cost functions that can be used with <a class="el" href="classdai_1_1BBP.html" title="Implements BBP (Back-Belief-Propagation) [EaG09].">BBP</a>.  <a href="classdai_1_1BBPCostFunction.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1BBP.html">BBP</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implements <a class="el" href="classdai_1_1BBP.html" title="Implements BBP (Back-Belief-Propagation) [EaG09].">BBP</a> (Back-Belief-Propagation) [<a class="el" href="bibliography.html#EaG09">EaG09</a>].  <a href="classdai_1_1BBP.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1BipartiteGraph.html">BipartiteGraph</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents the neighborhood structure of nodes in an undirected, bipartite graph.  <a href="classdai_1_1BipartiteGraph.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1BP.html">BP</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Approximate inference algorithm "(Loopy) Belief Propagation".  <a href="classdai_1_1BP.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1BP__dual.html">BP_dual</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates both types of <a class="el" href="classdai_1_1BP.html" title="Approximate inference algorithm &quot;(Loopy) Belief Propagation&quot;.">BP</a> <a class="el" href="structdai_1_1BP__dual_1_1messages.html" title="Groups together the data structures for storing the two types of messages and their...">messages</a> and their normalizers from an <a class="el" href="classdai_1_1InfAlg.html" title="InfAlg is an abstract base class, defining the common interface of all inference...">InfAlg</a>.  <a href="classdai_1_1BP__dual.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1CBP.html">CBP</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for <a class="el" href="classdai_1_1CBP.html" title="Class for CBP (Conditioned Belief Propagation) [EaG09].">CBP</a> (Conditioned Belief Propagation) [<a class="el" href="bibliography.html#EaG09">EaG09</a>].  <a href="classdai_1_1CBP.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1ClusterGraph.html">ClusterGraph</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <a class="el" href="classdai_1_1ClusterGraph.html" title="A ClusterGraph is a hypergraph with variables as nodes, and &quot;clusters&quot;...">ClusterGraph</a> is a hypergraph with variables as nodes, and "clusters" (sets of variables) as hyperedges.  <a href="classdai_1_1ClusterGraph.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1sequentialVariableElimination.html">sequentialVariableElimination</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper object for <a class="el" href="classdai_1_1ClusterGraph.html#9704c1b117a43897858554e57bee58b6" title="Performs Variable Elimination, keeping track of the interactions that are created...">dai::ClusterGraph::VarElim()</a>.  <a href="classdai_1_1sequentialVariableElimination.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1greedyVariableElimination.html">greedyVariableElimination</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper object for <a class="el" href="classdai_1_1ClusterGraph.html#9704c1b117a43897858554e57bee58b6" title="Performs Variable Elimination, keeping track of the interactions that are created...">dai::ClusterGraph::VarElim()</a>.  <a href="classdai_1_1greedyVariableElimination.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1DAG.html">DAG</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents the neighborhood structure of nodes in a directed cyclic graph.  <a href="classdai_1_1DAG.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1InfAlg.html">InfAlg</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classdai_1_1InfAlg.html" title="InfAlg is an abstract base class, defining the common interface of all inference...">InfAlg</a> is an abstract base class, defining the common interface of all inference algorithms in libDAI.  <a href="classdai_1_1InfAlg.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1DAIAlg.html">DAIAlg</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combines the abstract base class <a class="el" href="classdai_1_1InfAlg.html" title="InfAlg is an abstract base class, defining the common interface of all inference...">InfAlg</a> with a graphical model (e.g., a <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a> or <a class="el" href="classdai_1_1RegionGraph.html" title="A RegionGraph combines a bipartite graph consisting of outer regions (type FRegion)...">RegionGraph</a>).  <a href="classdai_1_1DAIAlg.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1DecMAP.html">DecMAP</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Approximate inference algorithm <a class="el" href="classdai_1_1DecMAP.html" title="Approximate inference algorithm DecMAP, which constructs a MAP state by decimation...">DecMAP</a>, which constructs a MAP state by decimation.  <a href="classdai_1_1DecMAP.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1ParameterEstimation.html">ParameterEstimation</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for parameter estimation methods.  <a href="classdai_1_1ParameterEstimation.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1CondProbEstimation.html">CondProbEstimation</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Estimates the parameters of a conditional probability table, using pseudocounts.  <a href="classdai_1_1CondProbEstimation.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1SharedParameters.html">SharedParameters</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a single factor or set of factors whose parameters should be estimated.  <a href="classdai_1_1SharedParameters.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1MaximizationStep.html">MaximizationStep</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <a class="el" href="classdai_1_1MaximizationStep.html" title="A MaximizationStep groups together several parameter estimation tasks (SharedParameters...">MaximizationStep</a> groups together several parameter estimation tasks (<a class="el" href="classdai_1_1SharedParameters.html" title="Represents a single factor or set of factors whose parameters should be estimated...">SharedParameters</a> objects) into a single unit.  <a href="classdai_1_1MaximizationStep.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1EMAlg.html">EMAlg</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classdai_1_1EMAlg.html" title="EMAlg performs Expectation Maximization to learn factor parameters.">EMAlg</a> performs Expectation Maximization to learn factor parameters.  <a href="classdai_1_1EMAlg.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1Evidence.html">Evidence</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stores a data set consisting of multiple samples, where each sample is the observed joint state of some variables.  <a href="classdai_1_1Evidence.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1ExactInf.html">ExactInf</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exact inference algorithm using brute force enumeration (mainly useful for testing purposes).  <a href="classdai_1_1ExactInf.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1Exception.html">Exception</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Error handling in libDAI is done by throwing an instance of the <a class="el" href="classdai_1_1Exception.html" title="Error handling in libDAI is done by throwing an instance of the Exception class.">Exception</a> class.  <a href="classdai_1_1Exception.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TFactor.html">TFactor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a (probability) factor.  <a href="classdai_1_1TFactor.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a factor graph.  <a href="classdai_1_1FactorGraph.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1FBP.html">FBP</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Approximate inference algorithm "Fractional Belief Propagation" [<a class="el" href="bibliography.html#WiH03">WiH03</a>].  <a href="classdai_1_1FBP.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1Gibbs.html">Gibbs</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Approximate inference algorithm "Gibbs sampling".  <a href="classdai_1_1Gibbs.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1Neighbor.html">Neighbor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Describes the neighbor relationship of two nodes in a graph.  <a href="structdai_1_1Neighbor.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents the neighborhood structure of nodes in an undirected graph.  <a href="classdai_1_1GraphAL.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1HAK.html">HAK</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Approximate inference algorithm: implementation of single-loop ("Generalized Belief Propagation") and double-loop algorithms by Heskes, Albers and Kappen [<a class="el" href="bibliography.html#HAK03">HAK03</a>].  <a href="classdai_1_1HAK.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1IndexFor.html">IndexFor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tool for looping over the states of several variables.  <a href="classdai_1_1IndexFor.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1Permute.html">Permute</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tool for calculating permutations of linear indices of multi-dimensional arrays.  <a href="classdai_1_1Permute.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1multifor.html">multifor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classdai_1_1multifor.html" title="multifor makes it easy to perform a dynamic number of nested for loops.">multifor</a> makes it easy to perform a dynamic number of nested <code>for</code> loops.  <a href="classdai_1_1multifor.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1State.html">State</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes it easy to iterate over all possible joint states of variables within a <a class="el" href="classdai_1_1VarSet.html" title="Represents a set of variables.">VarSet</a>.  <a href="classdai_1_1State.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1JTree.html">JTree</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exact inference algorithm using junction tree.  <a href="classdai_1_1JTree.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1LC.html">LC</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Approximate inference algorithm "Loop Corrected Belief Propagation" [<a class="el" href="bibliography.html#MoK07">MoK07</a>].  <a href="classdai_1_1LC.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1MF.html">MF</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Approximate inference algorithm "Mean Field".  <a href="classdai_1_1MF.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1MR.html">MR</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Approximate inference algorithm by Montanari and Rizzo [<a class="el" href="bibliography.html#MoR05">MoR05</a>].  <a href="classdai_1_1MR.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__id.html">fo_id</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function object that returns the value itself.  <a href="structdai_1_1fo__id.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__abs.html">fo_abs</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function object that takes the absolute value.  <a href="structdai_1_1fo__abs.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__exp.html">fo_exp</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function object that takes the exponent.  <a href="structdai_1_1fo__exp.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__log.html">fo_log</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function object that takes the logarithm.  <a href="structdai_1_1fo__log.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__log0.html">fo_log0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function object that takes the logarithm, except that log(0) is defined to be 0.  <a href="structdai_1_1fo__log0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__inv.html">fo_inv</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function object that takes the inverse.  <a href="structdai_1_1fo__inv.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__inv0.html">fo_inv0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function object that takes the inverse, except that 1/0 is defined to be 0.  <a href="structdai_1_1fo__inv0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__plog0p.html">fo_plog0p</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function object that returns p*log0(p).  <a href="structdai_1_1fo__plog0p.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__divides0.html">fo_divides0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function object similar to std::divides(), but different in that dividing by zero results in zero.  <a href="structdai_1_1fo__divides0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__KL.html">fo_KL</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function object useful for calculating the KL distance.  <a href="structdai_1_1fo__KL.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__Hellinger.html">fo_Hellinger</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function object useful for calculating the Hellinger distance.  <a href="structdai_1_1fo__Hellinger.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__pow.html">fo_pow</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function object that returns x to the power y.  <a href="structdai_1_1fo__pow.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__max.html">fo_max</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function object that returns the maximum of two values.  <a href="structdai_1_1fo__max.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__min.html">fo_min</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function object that returns the minimum of two values.  <a href="structdai_1_1fo__min.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__absdiff.html">fo_absdiff</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function object that returns the absolute difference of x and y.  <a href="structdai_1_1fo__absdiff.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html">TProb</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a vector with entries of type <em>T</em>.  <a href="classdai_1_1TProb.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1PropertySet.html">PropertySet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a set of properties, mapping keys (of type PropertyKey) to values (of type PropertyValue).  <a href="classdai_1_1PropertySet.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1Region.html">Region</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <a class="el" href="classdai_1_1Region.html" title="A Region is a set of variables with a counting number.">Region</a> is a set of variables with a counting number.  <a href="classdai_1_1Region.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1FRegion.html">FRegion</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An <a class="el" href="classdai_1_1FRegion.html" title="An FRegion is a factor with a counting number.">FRegion</a> is a factor with a counting number.  <a href="classdai_1_1FRegion.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1RegionGraph.html">RegionGraph</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <a class="el" href="classdai_1_1RegionGraph.html" title="A RegionGraph combines a bipartite graph consisting of outer regions (type FRegion)...">RegionGraph</a> combines a bipartite graph consisting of outer regions (type <a class="el" href="classdai_1_1FRegion.html" title="An FRegion is a factor with a counting number.">FRegion</a>) and inner regions (type <a class="el" href="classdai_1_1Region.html" title="A Region is a set of variables with a counting number.">Region</a>) with a <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a>.  <a href="classdai_1_1RegionGraph.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1SmallSet.html">SmallSet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a set; the implementation is optimized for a small number of elements.  <a href="classdai_1_1SmallSet.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TreeEP.html">TreeEP</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Approximate inference algorithm "Tree Expectation Propagation" [<a class="el" href="bibliography.html#MiQ04">MiQ04</a>].  <a href="classdai_1_1TreeEP.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TRWBP.html">TRWBP</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Approximate inference algorithm "Tree-Reweighted Belief Propagation" [<a class="el" href="bibliography.html#WJW03">WJW03</a>].  <a href="classdai_1_1TRWBP.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1hash__map.html">hash_map</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classdai_1_1hash__map.html" title="hash_map is an alias for std::tr1::unordered_map.">hash_map</a> is an alias for <code>std::tr1::unordered_map</code>.  <a href="classdai_1_1hash__map.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1Var.html">Var</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a discrete random variable.  <a href="classdai_1_1Var.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1VarSet.html">VarSet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a set of variables.  <a href="classdai_1_1VarSet.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1DEdge.html">DEdge</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a directed edge.  <a href="classdai_1_1DEdge.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1UEdge.html">UEdge</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents an undirected edge.  <a href="classdai_1_1UEdge.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1GraphEL.html">GraphEL</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents an undirected graph, implemented as a std::set of undirected edges.  <a href="classdai_1_1GraphEL.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1WeightedGraph.html">WeightedGraph</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents an undirected weighted graph, with weights of type <em>T</em>, implemented as a std::map mapping undirected edges to weights.  <a href="classdai_1_1WeightedGraph.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1RootedTree.html">RootedTree</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a rooted tree, implemented as a vector of directed edges.  <a href="classdai_1_1RootedTree.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef boost::minstd_rand&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#d2fa14208786f0746805efc9fbf3e56e">_rnd_gen_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of global random number generator.  <a href="#d2fa14208786f0746805efc9fbf3e56e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classdai_1_1DAIAlg.html">DAIAlg</a>&lt; <a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#4d66d71f2b2c7ac4845bba057eb7cee5">DAIAlgFG</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for inference algorithms that operate on a <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a>.  <a href="#4d66d71f2b2c7ac4845bba057eb7cee5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classdai_1_1DAIAlg.html">DAIAlg</a>&lt; <a class="el" href="classdai_1_1RegionGraph.html">RegionGraph</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#6b5cb6d79a324915d2c88ad368437e21">DAIAlgRG</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for inference algorithms that operate on a <a class="el" href="classdai_1_1RegionGraph.html" title="A RegionGraph combines a bipartite graph consisting of outer regions (type FRegion)...">RegionGraph</a>.  <a href="#6b5cb6d79a324915d2c88ad368437e21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classdai_1_1TFactor.html">TFactor</a>&lt; <a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#7515abf9952cd312e95a34ada0670e85">Factor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a factor with values of type <a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf" title="Real number (alias for double, which could be changed to long double if necessary)...">dai::Real</a>.  <a href="#7515abf9952cd312e95a34ada0670e85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::vector&lt; <a class="el" href="structdai_1_1Neighbor.html">Neighbor</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#14c563f2e5f6acf255903cae5c3b415c">Neighbors</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Describes the set of neighbors of some node in a graph.  <a href="#14c563f2e5f6acf255903cae5c3b415c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::pair&lt; size_t, size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ca51f13415f708db9eabda981b107a14">Edge</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents an edge in a graph: an Edge(<em>i</em>,<em>j</em>) corresponds to the edge between node <em>i</em> and node <em>j</em>.  <a href="#ca51f13415f708db9eabda981b107a14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classdai_1_1TProb.html">TProb</a>&lt; <a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#90f06137ef74bb483e30ee2c7e31b2c8">Prob</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a vector with entries of type <a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf" title="Real number (alias for double, which could be changed to long double if necessary)...">dai::Real</a>.  <a href="#90f06137ef74bb483e30ee2c7e31b2c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#cc877a85f4f4dbb6a0d58c434bb2b996">PropertyKey</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of the key of a Property.  <a href="#cc877a85f4f4dbb6a0d58c434bb2b996"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef boost::any&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#eb056b768d73d02c5796c4012f4170c7">PropertyValue</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of the value of a Property.  <a href="#eb056b768d73d02c5796c4012f4170c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::pair&lt; <a class="el" href="namespacedai.html#cc877a85f4f4dbb6a0d58c434bb2b996">PropertyKey</a>, <br>
<a class="el" href="namespacedai.html#eb056b768d73d02c5796c4012f4170c7">PropertyValue</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#cbc670414e04eecf5c284e42d9d036e3">Property</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A Property is a pair of a key and a corresponding value.  <a href="#cbc670414e04eecf5c284e42d9d036e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Real number (alias for <code>double</code>, which could be changed to <code>long double</code> if necessary).  <a href="#e7d0472fdc89a8635825d01940e91cbf"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#e0d0ef753bd0ba57586e556ab6312677">ProbNormType</a> { <b>NORMPROB</b>, 
<b>NORMLINF</b>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumerates different ways of normalizing a probability measure.  <a href="namespacedai.html#e0d0ef753bd0ba57586e556ab6312677">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a2735a823696443089d2de23e8ee6ecb">ProbDistType</a> { <br>
&nbsp;&nbsp;<b>DISTL1</b>, 
<b>DISTLINF</b>, 
<b>DISTTV</b>, 
<b>DISTKL</b>, 
<br>
&nbsp;&nbsp;<b>DISTHEL</b>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumerates different distance measures between probability measures.  <a href="namespacedai.html#a2735a823696443089d2de23e8ee6ecb">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#4b9e5254e7ec388e69aa68dfc54509e0">newInfAlg</a> (const std::string &amp;name, const <a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a> &amp;fg, const <a class="el" href="classdai_1_1PropertySet.html">PropertySet</a> &amp;opts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a new inference algorithm.  <a href="#4b9e5254e7ec388e69aa68dfc54509e0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#246c23914fee45f8b7f01f9073bdd6fe">newInfAlgFromString</a> (const std::string &amp;nameOpts, const <a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a> &amp;fg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a new inference algorithm.  <a href="#246c23914fee45f8b7f01f9073bdd6fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#f688c62fd7c8dff22e24835547cec7e7">newInfAlgFromString</a> (const std::string &amp;nameOpts, const <a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a> &amp;fg, const std::map&lt; std::string, std::string &gt; &amp;aliases)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a new inference algorithm.  <a href="#f688c62fd7c8dff22e24835547cec7e7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::pair&lt; std::string, <br>
<a class="el" href="classdai_1_1PropertySet.html">PropertySet</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#8f6e164a012fff145d683d64ac4d7b7f">parseNameProperties</a> (const std::string &amp;s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extracts the name and property set from a string <em>s</em> in the format "name[key1=val1,key2=val2,...]" or "name".  <a href="#8f6e164a012fff145d683d64ac4d7b7f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::pair&lt; std::string, <br>
<a class="el" href="classdai_1_1PropertySet.html">PropertySet</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#18ef8153f219f1cad48e4f1f1a00a2a6">parseNameProperties</a> (const std::string &amp;s, const std::map&lt; std::string, std::string &gt; &amp;aliases)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extracts the name and property set from a string <em>s</em> in the format "name[key1=val1,key2=val2,...]" or "name", performing alias substitution.  <a href="#18ef8153f219f1cad48e4f1f1a00a2a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::map&lt; std::string, <br>
std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#fffceb04ae10c57ff54a9c57ac3bfc29">readAliasesFile</a> (const std::string &amp;filename)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads aliases from file named <em>filename</em>.  <a href="#fffceb04ae10c57ff54a9c57ac3bfc29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#cfb030b9c48de7885795f4d03d7226ee">getFactorEntryForState</a> (const <a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a> &amp;fg, size_t I, const vector&lt; size_t &gt; &amp;state)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the entry of the I'th factor corresponding to a global state.  <a href="#cfb030b9c48de7885795f4d03d7226ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6154e193b6b0581b1552728a03b26f39"></a><!-- doxytag: member="dai::numericBBPTest" ref="6154e193b6b0581b1552728a03b26f39" args="(const InfAlg &amp;bp, const std::vector&lt; size_t &gt; *state, const PropertySet &amp;bbp_props, const BBPCostFunction &amp;cfn, Real h)" -->
<a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>numericBBPTest</b> (const <a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> &amp;bp, const std::vector&lt; size_t &gt; *state, const <a class="el" href="classdai_1_1PropertySet.html">PropertySet</a> &amp;bbp_props, const <a class="el" href="classdai_1_1BBPCostFunction.html">BBPCostFunction</a> &amp;cfn, <a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a> h)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">vector&lt; size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#7796e22fdea01e8fe5e4d51b85ae0548">complement</a> (vector&lt; size_t &gt; &amp;xis, size_t n_states)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a sorted vector of states <em>xis</em> and total state count <em>n_states</em>, return a vector of states not in <em>xis</em>.  <a href="#7796e22fdea01e8fe5e4d51b85ae0548"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#1091a5da35d620692783a17dbf265158">unSoftMax</a> (<a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a> a, <a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a> b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$\frac{\exp(a)}{\exp(a)+\exp(b)}$" src="form_0.png">.  <a href="#1091a5da35d620692783a17dbf265158"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#56e006b34155719d5ab9c0dbc9bd57f4">logSumExp</a> (<a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a> a, <a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a> b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes log of sum of exponents, i.e., <img class="formulaInl" alt="$\log\left(\exp(a) + \exp(b)\right)$" src="form_1.png">.  <a href="#56e006b34155719d5ab9c0dbc9bd57f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ee9a0cc9279a7add0849f964e3bdfbed">dist</a> (const vector&lt; <a class="el" href="namespacedai.html#7515abf9952cd312e95a34ada0670e85">Factor</a> &gt; &amp;b1, const vector&lt; <a class="el" href="namespacedai.html#7515abf9952cd312e95a34ada0670e85">Factor</a> &gt; &amp;b2, size_t nv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute sum of pairwise L-infinity distances of the first <em>nv</em> factors in each vector.  <a href="#ee9a0cc9279a7add0849f964e3bdfbed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static vector&lt; <a class="el" href="namespacedai.html#7515abf9952cd312e95a34ada0670e85">Factor</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#adf664acf42371b8f25ade335a805da1">mixBeliefs</a> (<a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a> p, const vector&lt; <a class="el" href="namespacedai.html#7515abf9952cd312e95a34ada0670e85">Factor</a> &gt; &amp;b, const vector&lt; <a class="el" href="namespacedai.html#7515abf9952cd312e95a34ada0670e85">Factor</a> &gt; &amp;c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates a vector of mixtures p * b + (1-p) * c.  <a href="#adf664acf42371b8f25ade335a805da1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b41645939efa15bb66b14e20d1641c8f"></a><!-- doxytag: member="dai::BBPFindClampVar" ref="b41645939efa15bb66b14e20d1641c8f" args="(const InfAlg &amp;in_bp, bool clampingVar, const PropertySet &amp;bbp_props, const BBPCostFunction &amp;cfn, Real *maxVarOut)" -->
std::pair&lt; size_t, size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>BBPFindClampVar</b> (const <a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> &amp;in_bp, bool clampingVar, const <a class="el" href="classdai_1_1PropertySet.html">PropertySet</a> &amp;bbp_props, const <a class="el" href="classdai_1_1BBPCostFunction.html">BBPCostFunction</a> &amp;cfn, <a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a> *maxVarOut)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#bb00ff16fe071140d9eb4c555c43e5d3">eliminationCost_MinNeighbors</a> (const <a class="el" href="classdai_1_1ClusterGraph.html">ClusterGraph</a> &amp;cl, size_t i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates cost of eliminating the <em>i</em> 'th variable from cluster graph <em>cl</em> according to the "MinNeighbors" criterion.  <a href="#bb00ff16fe071140d9eb4c555c43e5d3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#68ec048cdbefcf8a488469dd14938452">eliminationCost_MinWeight</a> (const <a class="el" href="classdai_1_1ClusterGraph.html">ClusterGraph</a> &amp;cl, size_t i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates cost of eliminating the <em>i</em> 'th variable from cluster graph <em>cl</em> according to the "MinWeight" criterion.  <a href="#68ec048cdbefcf8a488469dd14938452"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#b6cfdf0bf047e72e324c04e96d310edb">eliminationCost_MinFill</a> (const <a class="el" href="classdai_1_1ClusterGraph.html">ClusterGraph</a> &amp;cl, size_t i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates cost of eliminating the <em>i</em> 'th variable from cluster graph <em>cl</em> according to the "MinFill" criterion.  <a href="#b6cfdf0bf047e72e324c04e96d310edb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#990ea70014c5c6a90932d9cee11f393b">eliminationCost_WeightedMinFill</a> (const <a class="el" href="classdai_1_1ClusterGraph.html">ClusterGraph</a> &amp;cl, size_t i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates cost of eliminating the <em>i</em> 'th variable from cluster graph <em>cl</em> according to the "WeightedMinFill" criterion.  <a href="#990ea70014c5c6a90932d9cee11f393b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacedai.html#7515abf9952cd312e95a34ada0670e85">Factor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ab8aabfe0fcfd4b4bd24757c101449d5">calcMarginal</a> (const <a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> &amp;obj, const <a class="el" href="classdai_1_1VarSet.html">VarSet</a> &amp;vs, bool reInit)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates the marginal probability distribution for <em>vs</em> using inference algorithm <em>obj</em>.  <a href="#ab8aabfe0fcfd4b4bd24757c101449d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">vector&lt; <a class="el" href="namespacedai.html#7515abf9952cd312e95a34ada0670e85">Factor</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#82e775a1e2908856f13fa1aa7c081d4c">calcPairBeliefs</a> (const <a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> &amp;obj, const <a class="el" href="classdai_1_1VarSet.html">VarSet</a> &amp;vs, bool reInit, bool accurate=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates beliefs for all pairs of variables in <em>vs</em> using inference algorithm <em>obj</em>.  <a href="#82e775a1e2908856f13fa1aa7c081d4c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#e686384295f9909532d78328f87ae260">findMaximum</a> (const <a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> &amp;obj)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates the joint state of all variables that has maximum probability, according to the inference algorithm <em>obj</em>.  <a href="#e686384295f9909532d78328f87ae260"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacedai.html#7515abf9952cd312e95a34ada0670e85">Factor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#7dd9cb2405e798802d8cbb9b879fdf90">createFactorIsing</a> (const <a class="el" href="classdai_1_1Var.html">Var</a> &amp;x, <a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a> h)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a binary unnormalized single-variable factor <img class="formulaInl" alt="$ \exp(hx) $" src="form_69.png"> where <img class="formulaInl" alt="$ x = \pm 1 $" src="form_70.png">.  <a href="#7dd9cb2405e798802d8cbb9b879fdf90"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacedai.html#7515abf9952cd312e95a34ada0670e85">Factor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#de7f623237328458325bce5322abe03e">createFactorIsing</a> (const <a class="el" href="classdai_1_1Var.html">Var</a> &amp;x1, const <a class="el" href="classdai_1_1Var.html">Var</a> &amp;x2, <a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a> J)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a binary unnormalized pairwise factor <img class="formulaInl" alt="$ \exp(J x_1 x_2) $" src="form_71.png"> where <img class="formulaInl" alt="$ x_1, x_2 = \pm 1 $" src="form_72.png">.  <a href="#de7f623237328458325bce5322abe03e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacedai.html#7515abf9952cd312e95a34ada0670e85">Factor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#6715831e60e66582bce1c69518a40dd3">createFactorExpGauss</a> (const <a class="el" href="classdai_1_1VarSet.html">VarSet</a> &amp;vs, <a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a> beta)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a random factor on the variables <em>vs</em> with strength <em>beta</em>.  <a href="#6715831e60e66582bce1c69518a40dd3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacedai.html#7515abf9952cd312e95a34ada0670e85">Factor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ab6d25e30baf39ea06c57b5f71c61a4e">createFactorPotts</a> (const <a class="el" href="classdai_1_1Var.html">Var</a> &amp;x1, const <a class="el" href="classdai_1_1Var.html">Var</a> &amp;x2, <a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a> J)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pairwise Potts factor <img class="formulaInl" alt="$ \exp( J \delta_{x_1, x_2} ) $" src="form_73.png">.  <a href="#ab6d25e30baf39ea06c57b5f71c61a4e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacedai.html#7515abf9952cd312e95a34ada0670e85">Factor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#df624997c47362bc5db95242b76a66a4">createFactorDelta</a> (const <a class="el" href="classdai_1_1Var.html">Var</a> &amp;v, size_t state)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a Kronecker delta point mass.  <a href="#df624997c47362bc5db95242b76a66a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacedai.html#7515abf9952cd312e95a34ada0670e85">Factor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a9aa5a66a5df1ae48e29c4ad0965f3c6">createFactorDelta</a> (const <a class="el" href="classdai_1_1VarSet.html">VarSet</a> &amp;vs, size_t state)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a Kronecker delta point mass.  <a href="#a9aa5a66a5df1ae48e29c4ad0965f3c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#57fa52134afbd3da21c99975fbba7080">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a> &amp;fg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a> to an output stream.  <a href="#57fa52134afbd3da21c99975fbba7080"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::istream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#b1b9d59848e415c32330d4a7cbb3269a">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a> &amp;fg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads a <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a> from an input stream.  <a href="#b1b9d59848e415c32330d4a7cbb3269a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9fcdb2332486b1b9944a551040b8bcf6"></a><!-- doxytag: member="dai::getGibbsState" ref="9fcdb2332486b1b9944a551040b8bcf6" args="(const FactorGraph &amp;fg, size_t maxiter)" -->
std::vector&lt; size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>getGibbsState</b> (const <a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a> &amp;fg, size_t maxiter)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#edbe32ae13acdd8b62050b18e81a53ea">createGraphFull</a> (size_t N)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a fully-connected graph with <em>N</em> nodes.  <a href="#edbe32ae13acdd8b62050b18e81a53ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#aeeffaf06b9cd2fecccaf2bf773baed7">createGraphGrid</a> (size_t N1, size_t N2, bool periodic)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a two-dimensional rectangular grid of <em>N1</em> by <em>N2</em> nodes, which can be <em>periodic</em>.  <a href="#aeeffaf06b9cd2fecccaf2bf773baed7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#9950d08bd6190ea12f50b4be6f2584cf">createGraphGrid3D</a> (size_t N1, size_t N2, size_t N3, bool periodic)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a three-dimensional rectangular grid of <em>N1</em> by <em>N2</em> by <em>N3</em> nodes, which can be <em>periodic</em>.  <a href="#9950d08bd6190ea12f50b4be6f2584cf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#7f65fc1665a6fa04b1b6897a4551bccc">createGraphLoop</a> (size_t N)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a graph consisting of a single loop of <em>N</em> nodes.  <a href="#7f65fc1665a6fa04b1b6897a4551bccc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#d3fbe55f9fdb020e7a2b04f1d2451d20">createGraphTree</a> (size_t N)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a random tree-structured graph of <em>N</em> nodes.  <a href="#d3fbe55f9fdb020e7a2b04f1d2451d20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#bfd6bb3f4b6135a99a68b9b13bee8bae">createGraphRegular</a> (size_t N, size_t d)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a random regular graph of <em>N</em> nodes with uniform connectivity <em>d</em>.  <a href="#bfd6bb3f4b6135a99a68b9b13bee8bae"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classdai_1_1TFactor.html">TFactor</a>&lt; T &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#847e3cef4f6660bb027e9a3978277a2b">makePositive</a> (<a class="el" href="classdai_1_1TFactor.html">TFactor</a>&lt; T &gt; &amp;f, T epsilon)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets factor entries that lie between 0 and <em>epsilon</em> to <em>epsilon</em>.  <a href="#847e3cef4f6660bb027e9a3978277a2b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classdai_1_1TFactor.html">TFactor</a>&lt; T &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#1c7d5fa66149e0e508711f68bac11b5f">makeZero</a> (<a class="el" href="classdai_1_1TFactor.html">TFactor</a>&lt; T &gt; &amp;f, T epsilon)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets factor entries that are smaller (in absolute value) than <em>epsilon</em> to 0.  <a href="#1c7d5fa66149e0e508711f68bac11b5f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#fbde3d057ec404d5f4f962da46bccced">ReadUaiAieFactorGraphFile</a> (const char *filename, size_t verbose, std::vector&lt; <a class="el" href="classdai_1_1Var.html">Var</a> &gt; &amp;vars, std::vector&lt; <a class="el" href="namespacedai.html#7515abf9952cd312e95a34ada0670e85">Factor</a> &gt; &amp;factors, std::vector&lt; <a class="el" href="classdai_1_1Permute.html">Permute</a> &gt; &amp;permutations)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads factor graph (as a pair of a variable vector and factor vector) from a file in the UAI approximate inference challenge format.  <a href="#fbde3d057ec404d5f4f962da46bccced"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; std::map&lt; size_t, <br>
size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#b5cba3982dd0cd9d5fa3a06c05aef8b1">ReadUaiAieEvidenceFile</a> (const char *filename, size_t verbose)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads evidence (a mapping from observed variable labels to the observed values) from a file in the UAI approximate inference challenge format.  <a href="#b5cba3982dd0cd9d5fa3a06c05aef8b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e8d9ce7ede5f5eeb7eb989ab1e418eb4"></a><!-- doxytag: member="dai::boundTreewidth" ref="e8d9ce7ede5f5eeb7eb989ab1e418eb4" args="(const FactorGraph &amp;fg, greedyVariableElimination::eliminationCostFunction fn, size_t maxStates)" -->
std::pair&lt; size_t, long double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>boundTreewidth</b> (const <a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a> &amp;fg, <a class="el" href="classdai_1_1greedyVariableElimination.html#367d3a2c003842d28e27f10d9c0ea3fb">greedyVariableElimination::eliminationCostFunction</a> fn, size_t maxStates)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#c63c2f1d67d01aeda5c3cdd95843ea86">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="namespacedai.html#cbc670414e04eecf5c284e42d9d036e3">Property</a> &amp;p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a Property object (key-value pair) to an output stream.  <a href="#c63c2f1d67d01aeda5c3cdd95843ea86"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#b339baefa9f588de2fba07526d8df7ba">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdai_1_1PropertySet.html">PropertySet</a> &amp;ps)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a <a class="el" href="classdai_1_1PropertySet.html" title="Represents a set of properties, mapping keys (of type PropertyKey) to values (of...">PropertySet</a> object to an output stream.  <a href="#b339baefa9f588de2fba07526d8df7ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::istream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ab0479dd285fd4021ecaa80947d40da3">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classdai_1_1PropertySet.html">PropertySet</a> &amp;ps)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads a <a class="el" href="classdai_1_1PropertySet.html" title="Represents a set of properties, mapping keys (of type PropertyKey) to values (of...">PropertySet</a> object from an input stream, storing values as strings.  <a href="#ab0479dd285fd4021ecaa80947d40da3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#0e910ae9247869ee549df8eed173a6df">operator&lt;&lt;</a> (ostream &amp;os, const <a class="el" href="classdai_1_1RegionGraph.html">RegionGraph</a> &amp;rg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send <a class="el" href="classdai_1_1RegionGraph.html" title="A RegionGraph combines a bipartite graph consisting of outer regions (type FRegion)...">RegionGraph</a> to output stream.  <a href="#0e910ae9247869ee549df8eed173a6df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#9886ca4103eac52b3f82698e12e86672">isnan</a> (<a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a> x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if argument is NAN (Not A Number).  <a href="#9886ca4103eac52b3f82698e12e86672"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#b27c0799ddef29bb3833477e32c53862">toc</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns wall clock time in seconds.  <a href="#b27c0799ddef29bb3833477e32c53862"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacedai.html#d2fa14208786f0746805efc9fbf3e56e">_rnd_gen_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#8676cd0faacaec12b2acf0e0472e3280">_rnd_gen</a> (42U)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Global random number generator.  <a href="#8676cd0faacaec12b2acf0e0472e3280"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::uniform_real&lt; <a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#2cff7aad0084432ddcc7ef52618b74bd">_uni_dist</a> (0, 1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uniform distribution with values between 0 and 1 (0 inclusive, 1 exclusive).  <a href="#2cff7aad0084432ddcc7ef52618b74bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::variate_generator<br>
&lt; <a class="el" href="namespacedai.html#d2fa14208786f0746805efc9fbf3e56e">_rnd_gen_type</a> <br>
&amp;, boost::uniform_real&lt; <a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#95e934001307cafa4576b31fb0569e2c">_uni_rnd</a> (_rnd_gen, _uni_dist)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Global uniform random random number.  <a href="#95e934001307cafa4576b31fb0569e2c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::variate_generator<br>
&lt; <a class="el" href="namespacedai.html#d2fa14208786f0746805efc9fbf3e56e">_rnd_gen_type</a> <br>
&amp;, boost::normal_distribution<br>
&lt; <a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#205aca5e7688c28a95ecc978b4f79879">_normal_rnd</a> (_rnd_gen, <a class="el" href="namespacedai.html#72200157ce1fbccfe91f66a3f8416823">_normal_dist</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Global random number generator with standard normal distribution.  <a href="#205aca5e7688c28a95ecc978b4f79879"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#e699eca7ca4d6e971b54c2b4a95942d4">rnd_seed</a> (size_t seed)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the random seed.  <a href="#e699eca7ca4d6e971b54c2b4a95942d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#129f3a9c518c632c985d045a4f8c60f9">rnd_uniform</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a real number, distributed uniformly on [0,1).  <a href="#129f3a9c518c632c985d045a4f8c60f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#c3f6d317ca42fbb4b643aa8c82692d74">rnd_stdnormal</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a real number from a standard-normal distribution.  <a href="#c3f6d317ca42fbb4b643aa8c82692d74"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#c02317b960b112637976333f90d1f937">rnd_int</a> (int min, int max)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a random integer in interval [<em>min</em>, <em>max</em>].  <a href="#c02317b960b112637976333f90d1f937"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#87303da2767f4906ea37216bdc9278ca">tokenizeString</a> (const std::string &amp;s, bool singleDelim, const std::string &amp;delim=&quot;\t\n&quot;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Split a string into tokens delimited by one of the characters in <em>delim</em>.  <a href="#87303da2767f4906ea37216bdc9278ca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#750c3807e7375265c3fb410a1f1223fe">calcLinearState</a> (const <a class="el" href="classdai_1_1VarSet.html">VarSet</a> &amp;vs, const std::map&lt; <a class="el" href="classdai_1_1Var.html">Var</a>, size_t &gt; &amp;state)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates the linear index in the Cartesian product of the variables in <em>vs</em> that corresponds to a particular joint assignment of the variables, specified by <em>state</em>.  <a href="#750c3807e7375265c3fb410a1f1223fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::map&lt; <a class="el" href="classdai_1_1Var.html">Var</a>, size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#fcfc874f85b4a2944ec128ebd1dd19f1">calcState</a> (const <a class="el" href="classdai_1_1VarSet.html">VarSet</a> &amp;vs, size_t linearState)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates the joint assignment of the variables in <em>vs</em> corresponding to the linear index <em>linearState</em>.  <a href="#fcfc874f85b4a2944ec128ebd1dd19f1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">mxArray *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#e62bf4dfaa6694edc2d180b71656d430">Factors2mx</a> (const std::vector&lt; <a class="el" href="namespacedai.html#7515abf9952cd312e95a34ada0670e85">Factor</a> &gt; &amp;Ps)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert vector&lt;Factor&gt; structure to a cell vector of CPTAB-like structs.  <a href="#e62bf4dfaa6694edc2d180b71656d430"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">vector&lt; <a class="el" href="namespacedai.html#7515abf9952cd312e95a34ada0670e85">Factor</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#bdd1a935e89ca8dc1d4e0c1cea371d44">mx2Factors</a> (const mxArray *psi, long verbose)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert cell vector of CPTAB-like structs to vector&lt;Factor&gt;.  <a href="#bdd1a935e89ca8dc1d4e0c1cea371d44"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacedai.html#7515abf9952cd312e95a34ada0670e85">Factor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#573a608f62779c1a08f8e10c3fa4e940">mx2Factor</a> (const mxArray *psi)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert CPTAB-like struct to Factor.  <a href="#573a608f62779c1a08f8e10c3fa4e940"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ef8d342ac50bdaed5d513df6349be31c">DAI_ENUM</a> (BBPCostFunctionBase, CFN_GIBBS_B, CFN_GIBBS_B2, CFN_GIBBS_EXP, CFN_GIBBS_B_FACTOR, CFN_GIBBS_B2_FACTOR, CFN_GIBBS_EXP_FACTOR, CFN_VAR_ENT, CFN_FACTOR_ENT, CFN_BETHE_ENT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumeration of several cost functions that can be used with <a class="el" href="classdai_1_1BBP.html" title="Implements BBP (Back-Belief-Propagation) [EaG09].">BBP</a>.  <a href="#ef8d342ac50bdaed5d513df6349be31c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#934491ad55f57c9072271b4a32ea4919">log</a> (<a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a> x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns logarithm of <em>x</em>.  <a href="#934491ad55f57c9072271b4a32ea4919"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#00375a4d7b55534c14f993c909b04c3c">log0</a> (<a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a> x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns logarithm of <em>x</em>, or 0 if <em>x</em> == 0.  <a href="#00375a4d7b55534c14f993c909b04c3c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#c336ffb182b6e6fa3f7df13620aab012">exp</a> (<a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a> x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns exponent of <em>x</em>.  <a href="#c336ffb182b6e6fa3f7df13620aab012"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#16465ce3d62a6456fd06e9a226c966f2">pow</a> (<a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a> x, <a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a> y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <em>to</em> the power <em>y</em>.  <a href="#16465ce3d62a6456fd06e9a226c966f2"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#bc859d9510bf6f58fc066c33ae8f7492">abs</a> (const T &amp;t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns absolute value of <em>t</em>.  <a href="#bc859d9510bf6f58fc066c33ae8f7492"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ffae7aacdd26b4a580fbb8790cbccc86">rnd</a> (int n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a random integer in the half-open interval [0, <em>n</em>).  <a href="#ffae7aacdd26b4a580fbb8790cbccc86"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#039689f5b5f4a2f34479fd1a8fd21b8a">toString</a> (const T &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a variable of type <em>T</em> to a <code>std::string</code> by using a <code>boost::lexical_cast</code>.  <a href="#039689f5b5f4a2f34479fd1a8fd21b8a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#464325bef76b7bf68a4b3f3246380e93">fromString</a> (const std::string &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a variable of type std::string to <em>T</em> by using a <code>boost::lexical_cast</code>.  <a href="#464325bef76b7bf68a4b3f3246380e93"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#1a0b1c88c46fb8763c2c783cc3fe9a62">operator&lt;&lt;</a> (std::ostream &amp;os, const std::vector&lt; T &gt; &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a <code>std::vector&lt;&gt;</code> to a <code>std::ostream</code>.  <a href="#1a0b1c88c46fb8763c2c783cc3fe9a62"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#4f8ad5d0c47c7fdfe17e5d0f4c0a32d9">operator&lt;&lt;</a> (std::ostream &amp;os, const std::set&lt; T &gt; &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a <code>std::set&lt;&gt;</code> to a <code>std::ostream</code>.  <a href="#4f8ad5d0c47c7fdfe17e5d0f4c0a32d9"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T1, class T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#5913957fb1c3c3d3fbd1f3102b8eb04c">operator&lt;&lt;</a> (std::ostream &amp;os, const std::map&lt; T1, T2 &gt; &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a <code>std::map&lt;&gt;</code> to a <code>std::ostream</code>.  <a href="#5913957fb1c3c3d3fbd1f3102b8eb04c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T1, class T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#575f6202aa88de6bf5146b85d8832eb5">operator&lt;&lt;</a> (std::ostream &amp;os, const std::pair&lt; T1, T2 &gt; &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a <code>std::pair&lt;&gt;</code> to a <code>std::ostream</code>.  <a href="#575f6202aa88de6bf5146b85d8832eb5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::vector&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#ae335872c5de8c4d1f21833cbe5c0020">concat</a> (const std::vector&lt; T &gt; &amp;u, const std::vector&lt; T &gt; &amp;v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concatenates two vectors.  <a href="#ae335872c5de8c4d1f21833cbe5c0020"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classdai_1_1RootedTree.html">RootedTree</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#273d7118dd690f5b438fba18f6860eb6">MinSpanningTree</a> (const <a class="el" href="classdai_1_1WeightedGraph.html">WeightedGraph</a>&lt; T &gt; &amp;G, bool usePrim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a minimum spanning tree from the (non-negatively) weighted graph <em>G</em>.  <a href="#273d7118dd690f5b438fba18f6860eb6"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classdai_1_1RootedTree.html">RootedTree</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#1914ae414d452b1844e6cd72f70501b5">MaxSpanningTree</a> (const <a class="el" href="classdai_1_1WeightedGraph.html">WeightedGraph</a>&lt; T &gt; &amp;G, bool usePrim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a minimum spanning tree from the (non-negatively) weighted graph <em>G</em>.  <a href="#1914ae414d452b1844e6cd72f70501b5"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::normal_distribution&lt; <a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#72200157ce1fbccfe91f66a3f8416823">_normal_dist</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normal distribution with mean 0 and standard deviation 1.  <a href="#72200157ce1fbccfe91f66a3f8416823"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#faf76457d5d1ad9cfd37feb44ae94669">DAINames</a> []</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contains the names of all inference algorithms compiled into libDAI.  <a href="#faf76457d5d1ad9cfd37feb44ae94669"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Namespace for libDAI. <hr><h2>Typedef Documentation</h2>
<a class="anchor" name="d2fa14208786f0746805efc9fbf3e56e"></a><!-- doxytag: member="dai::_rnd_gen_type" ref="d2fa14208786f0746805efc9fbf3e56e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::minstd_rand <a class="el" href="namespacedai.html#d2fa14208786f0746805efc9fbf3e56e">dai::_rnd_gen_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of global random number generator. 
<p>

</div>
</div><p>
<a class="anchor" name="4d66d71f2b2c7ac4845bba057eb7cee5"></a><!-- doxytag: member="dai::DAIAlgFG" ref="4d66d71f2b2c7ac4845bba057eb7cee5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classdai_1_1DAIAlg.html">DAIAlg</a>&lt;<a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a>&gt; <a class="el" href="classdai_1_1DAIAlg.html">dai::DAIAlgFG</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Base class for inference algorithms that operate on a <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="6b5cb6d79a324915d2c88ad368437e21"></a><!-- doxytag: member="dai::DAIAlgRG" ref="6b5cb6d79a324915d2c88ad368437e21" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classdai_1_1DAIAlg.html">DAIAlg</a>&lt;<a class="el" href="classdai_1_1RegionGraph.html">RegionGraph</a>&gt; <a class="el" href="classdai_1_1DAIAlg.html">dai::DAIAlgRG</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Base class for inference algorithms that operate on a <a class="el" href="classdai_1_1RegionGraph.html" title="A RegionGraph combines a bipartite graph consisting of outer regions (type FRegion)...">RegionGraph</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="7515abf9952cd312e95a34ada0670e85"></a><!-- doxytag: member="dai::Factor" ref="7515abf9952cd312e95a34ada0670e85" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classdai_1_1TFactor.html">TFactor</a>&lt;<a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a>&gt; <a class="el" href="classdai_1_1TFactor.html">dai::Factor</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Represents a factor with values of type <a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf" title="Real number (alias for double, which could be changed to long double if necessary)...">dai::Real</a>. 
<p>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="example__sprinkler_8cpp-example.html#a1">example_sprinkler.cpp</a>, and <a class="el" href="uai2010-aie-solver_8cpp-example.html#a4">uai2010-aie-solver.cpp</a>.</dl>
</div>
</div><p>
<a class="anchor" name="14c563f2e5f6acf255903cae5c3b415c"></a><!-- doxytag: member="dai::Neighbors" ref="14c563f2e5f6acf255903cae5c3b415c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="structdai_1_1Neighbor.html">Neighbor</a>&gt; <a class="el" href="namespacedai.html#14c563f2e5f6acf255903cae5c3b415c">dai::Neighbors</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Describes the set of neighbors of some node in a graph. 
<p>

</div>
</div><p>
<a class="anchor" name="ca51f13415f708db9eabda981b107a14"></a><!-- doxytag: member="dai::Edge" ref="ca51f13415f708db9eabda981b107a14" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;size_t,size_t&gt; <a class="el" href="namespacedai.html#ca51f13415f708db9eabda981b107a14">dai::Edge</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Represents an edge in a graph: an Edge(<em>i</em>,<em>j</em>) corresponds to the edge between node <em>i</em> and node <em>j</em>. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the edge is interpreted as a directed edge, then it points from <em>i</em> to <em>j</em>. <p>
If the edge is part of a bipartite graph, <em>i</em> is understood to correspond to a node of type 1, and <em>j</em> to a node of type 2. </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="example__bipgraph_8cpp-example.html#a0">example_bipgraph.cpp</a>.</dl>
</div>
</div><p>
<a class="anchor" name="90f06137ef74bb483e30ee2c7e31b2c8"></a><!-- doxytag: member="dai::Prob" ref="90f06137ef74bb483e30ee2c7e31b2c8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classdai_1_1TProb.html">TProb</a>&lt;<a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a>&gt; <a class="el" href="classdai_1_1TProb.html">dai::Prob</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Represents a vector with entries of type <a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf" title="Real number (alias for double, which could be changed to long double if necessary)...">dai::Real</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="cc877a85f4f4dbb6a0d58c434bb2b996"></a><!-- doxytag: member="dai::PropertyKey" ref="cc877a85f4f4dbb6a0d58c434bb2b996" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::string <a class="el" href="namespacedai.html#cc877a85f4f4dbb6a0d58c434bb2b996">dai::PropertyKey</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of the key of a Property. 
<p>

</div>
</div><p>
<a class="anchor" name="eb056b768d73d02c5796c4012f4170c7"></a><!-- doxytag: member="dai::PropertyValue" ref="eb056b768d73d02c5796c4012f4170c7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::any <a class="el" href="namespacedai.html#eb056b768d73d02c5796c4012f4170c7">dai::PropertyValue</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of the value of a Property. 
<p>

</div>
</div><p>
<a class="anchor" name="cbc670414e04eecf5c284e42d9d036e3"></a><!-- doxytag: member="dai::Property" ref="cbc670414e04eecf5c284e42d9d036e3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;<a class="el" href="namespacedai.html#cc877a85f4f4dbb6a0d58c434bb2b996">PropertyKey</a>, <a class="el" href="namespacedai.html#eb056b768d73d02c5796c4012f4170c7">PropertyValue</a>&gt; <a class="el" href="namespacedai.html#cbc670414e04eecf5c284e42d9d036e3">dai::Property</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A Property is a pair of a key and a corresponding value. 
<p>

</div>
</div><p>
<a class="anchor" name="e7d0472fdc89a8635825d01940e91cbf"></a><!-- doxytag: member="dai::Real" ref="e7d0472fdc89a8635825d01940e91cbf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">dai::Real</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Real number (alias for <code>double</code>, which could be changed to <code>long double</code> if necessary). 
<p>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="example_8cpp-example.html#a2">example.cpp</a>, <a class="el" href="example__sprinkler_8cpp-example.html#a8">example_sprinkler.cpp</a>, <a class="el" href="example__sprinkler__em_8cpp-example.html#a11">example_sprinkler_em.cpp</a>, and <a class="el" href="uai2010-aie-solver_8cpp-example.html#a0">uai2010-aie-solver.cpp</a>.</dl>
</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="e0d0ef753bd0ba57586e556ab6312677"></a><!-- doxytag: member="dai::ProbNormType" ref="e0d0ef753bd0ba57586e556ab6312677" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedai.html#e0d0ef753bd0ba57586e556ab6312677">dai::ProbNormType</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enumerates different ways of normalizing a probability measure. 
<p>
<ul>
<li>NORMPROB means that the sum of all entries should be 1;</li><li>NORMLINF means that the maximum absolute value of all entries should be 1. </li></ul>

</div>
</div><p>
<a class="anchor" name="a2735a823696443089d2de23e8ee6ecb"></a><!-- doxytag: member="dai::ProbDistType" ref="a2735a823696443089d2de23e8ee6ecb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedai.html#a2735a823696443089d2de23e8ee6ecb">dai::ProbDistType</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enumerates different distance measures between probability measures. 
<p>
<ul>
<li>DISTL1 is the <img class="formulaInl" alt="$\ell_1$" src="form_129.png"> distance (sum of absolute values of pointwise difference);</li><li>DISTLINF is the <img class="formulaInl" alt="$\ell_\infty$" src="form_130.png"> distance (maximum absolute value of pointwise difference);</li><li>DISTTV is the total variation distance (half of the <img class="formulaInl" alt="$\ell_1$" src="form_129.png"> distance);</li><li>DISTKL is the Kullback-Leibler distance (<img class="formulaInl" alt="$\sum_i p_i (\log p_i - \log q_i)$" src="form_131.png">).</li><li>DISTHEL is the Hellinger distance (<img class="formulaInl" alt="$\frac{1}{2}\sum_i (\sqrt{p_i}-\sqrt{q_i})^2$" src="form_132.png">). </li></ul>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="4b9e5254e7ec388e69aa68dfc54509e0"></a><!-- doxytag: member="dai::newInfAlg" ref="4b9e5254e7ec388e69aa68dfc54509e0" args="(const std::string &amp;name, const FactorGraph &amp;fg, const PropertySet &amp;opts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> * dai::newInfAlg           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FactorGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PropertySet &amp;&nbsp;</td>
          <td class="paramname"> <em>opts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a new inference algorithm. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of the inference algorithm (should be one of the names in DAINames). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fg</em>&nbsp;</td><td>The <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a> that the algorithm should be applied to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opts</em>&nbsp;</td><td>A <a class="el" href="classdai_1_1PropertySet.html" title="Represents a set of properties, mapping keys (of type PropertyKey) to values (of...">PropertySet</a> specifying the options for the algorithm. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns a pointer to the new <a class="el" href="classdai_1_1InfAlg.html" title="InfAlg is an abstract base class, defining the common interface of all inference...">InfAlg</a> object; it is the responsibility of the caller to delete it later. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>UNKNOWN_DAI_ALGORITHM</em>&nbsp;</td><td>if the requested name is not known/compiled in. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="246c23914fee45f8b7f01f9073bdd6fe"></a><!-- doxytag: member="dai::newInfAlgFromString" ref="246c23914fee45f8b7f01f9073bdd6fe" args="(const std::string &amp;nameOpts, const FactorGraph &amp;fg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> * dai::newInfAlgFromString           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>nameOpts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FactorGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>fg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a new inference algorithm. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nameOpts</em>&nbsp;</td><td>The name and options of the inference algorithm (should be in the format "name[key1=val1,key2=val2,...,keyn=valn]"). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fg</em>&nbsp;</td><td>The <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a> that the algorithm should be applied to. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns a pointer to the new <a class="el" href="classdai_1_1InfAlg.html" title="InfAlg is an abstract base class, defining the common interface of all inference...">InfAlg</a> object; it is the responsibility of the caller to delete it later. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>UNKNOWN_DAI_ALGORITHM</em>&nbsp;</td><td>if the requested name is not known/compiled in. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f688c62fd7c8dff22e24835547cec7e7"></a><!-- doxytag: member="dai::newInfAlgFromString" ref="f688c62fd7c8dff22e24835547cec7e7" args="(const std::string &amp;nameOpts, const FactorGraph &amp;fg, const std::map&lt; std::string, std::string &gt; &amp;aliases)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> * dai::newInfAlgFromString           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>nameOpts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FactorGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aliases</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a new inference algorithm. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nameOpts</em>&nbsp;</td><td>The name and options of the inference algorithm (should be in the format "name[key1=val1,key2=val2,...,keyn=valn]"). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fg</em>&nbsp;</td><td>The <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a> that the algorithm should be applied to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aliases</em>&nbsp;</td><td>Maps names to strings in the format "name[key1=val1,key2=val2,...,keyn=valn]"; if not empty, alias substitution will be performed when parsing <em>nameOpts</em> by invoking <a class="el" href="namespacedai.html#18ef8153f219f1cad48e4f1f1a00a2a6" title="Extracts the name and property set from a string s in the format &quot;name[key1=val1...">parseNameProperties(const std::string &amp;,const std::map&lt;std::string,std::string&gt; &amp;)</a> </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="namespacedai.html#246c23914fee45f8b7f01f9073bdd6fe" title="Constructs a new inference algorithm.">newInfAlgFromString(const std::string &amp;, const FactorGraph &amp;)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="8f6e164a012fff145d683d64ac4d7b7f"></a><!-- doxytag: member="dai::parseNameProperties" ref="8f6e164a012fff145d683d64ac4d7b7f" args="(const std::string &amp;s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, <a class="el" href="classdai_1_1PropertySet.html">PropertySet</a> &gt; dai::parseNameProperties           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extracts the name and property set from a string <em>s</em> in the format "name[key1=val1,key2=val2,...]" or "name". 
<p>

</div>
</div><p>
<a class="anchor" name="18ef8153f219f1cad48e4f1f1a00a2a6"></a><!-- doxytag: member="dai::parseNameProperties" ref="18ef8153f219f1cad48e4f1f1a00a2a6" args="(const std::string &amp;s, const std::map&lt; std::string, std::string &gt; &amp;aliases)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, <a class="el" href="classdai_1_1PropertySet.html">PropertySet</a> &gt; dai::parseNameProperties           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aliases</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extracts the name and property set from a string <em>s</em> in the format "name[key1=val1,key2=val2,...]" or "name", performing alias substitution. 
<p>
Alias substitution is performed as follows: as long as name appears as a key in <em>aliases</em>, it is substituted by its value. Properties in <em>s</em> override those of the alias (in case of recursion, the "outer" properties override those of the "inner" aliases). 
</div>
</div><p>
<a class="anchor" name="fffceb04ae10c57ff54a9c57ac3bfc29"></a><!-- doxytag: member="dai::readAliasesFile" ref="fffceb04ae10c57ff54a9c57ac3bfc29" args="(const std::string &amp;filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, std::string &gt; dai::readAliasesFile           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>filename</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads aliases from file named <em>filename</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>Name of the alias file </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A map that maps aliases to the strings they should be substituted with. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="fileformats.html#fileformats-aliases">Aliases file format</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="cfb030b9c48de7885795f4d03d7226ee"></a><!-- doxytag: member="dai::getFactorEntryForState" ref="cfb030b9c48de7885795f4d03d7226ee" args="(const FactorGraph &amp;fg, size_t I, const vector&lt; size_t &gt; &amp;state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dai::getFactorEntryForState           </td>
          <td>(</td>
          <td class="paramtype">const FactorGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; size_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>state</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the entry of the I'th factor corresponding to a global state. 
<p>

</div>
</div><p>
<a class="anchor" name="7796e22fdea01e8fe5e4d51b85ae0548"></a><!-- doxytag: member="dai::complement" ref="7796e22fdea01e8fe5e4d51b85ae0548" args="(vector&lt; size_t &gt; &amp;xis, size_t n_states)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;size_t&gt; dai::complement           </td>
          <td>(</td>
          <td class="paramtype">vector&lt; size_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>xis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n_states</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a sorted vector of states <em>xis</em> and total state count <em>n_states</em>, return a vector of states not in <em>xis</em>. 
<p>

</div>
</div><p>
<a class="anchor" name="1091a5da35d620692783a17dbf265158"></a><!-- doxytag: member="dai::unSoftMax" ref="1091a5da35d620692783a17dbf265158" args="(Real a, Real b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a> dai::unSoftMax           </td>
          <td>(</td>
          <td class="paramtype">Real&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes <img class="formulaInl" alt="$\frac{\exp(a)}{\exp(a)+\exp(b)}$" src="form_0.png">. 
<p>

</div>
</div><p>
<a class="anchor" name="56e006b34155719d5ab9c0dbc9bd57f4"></a><!-- doxytag: member="dai::logSumExp" ref="56e006b34155719d5ab9c0dbc9bd57f4" args="(Real a, Real b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a> dai::logSumExp           </td>
          <td>(</td>
          <td class="paramtype">Real&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes log of sum of exponents, i.e., <img class="formulaInl" alt="$\log\left(\exp(a) + \exp(b)\right)$" src="form_1.png">. 
<p>

</div>
</div><p>
<a class="anchor" name="ee9a0cc9279a7add0849f964e3bdfbed"></a><!-- doxytag: member="dai::dist" ref="ee9a0cc9279a7add0849f964e3bdfbed" args="(const vector&lt; Factor &gt; &amp;b1, const vector&lt; Factor &gt; &amp;b2, size_t nv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a> dai::dist           </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; Factor &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; Factor &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute sum of pairwise L-infinity distances of the first <em>nv</em> factors in each vector. 
<p>

</div>
</div><p>
<a class="anchor" name="adf664acf42371b8f25ade335a805da1"></a><!-- doxytag: member="dai::mixBeliefs" ref="adf664acf42371b8f25ade335a805da1" args="(Real p, const vector&lt; Factor &gt; &amp;b, const vector&lt; Factor &gt; &amp;c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static vector&lt;<a class="el" href="namespacedai.html#7515abf9952cd312e95a34ada0670e85">Factor</a>&gt; dai::mixBeliefs           </td>
          <td>(</td>
          <td class="paramtype">Real&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; Factor &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; Factor &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculates a vector of mixtures p * b + (1-p) * c. 
<p>

</div>
</div><p>
<a class="anchor" name="bb00ff16fe071140d9eb4c555c43e5d3"></a><!-- doxytag: member="dai::eliminationCost_MinNeighbors" ref="bb00ff16fe071140d9eb4c555c43e5d3" args="(const ClusterGraph &amp;cl, size_t i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dai::eliminationCost_MinNeighbors           </td>
          <td>(</td>
          <td class="paramtype">const ClusterGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculates cost of eliminating the <em>i</em> 'th variable from cluster graph <em>cl</em> according to the "MinNeighbors" criterion. 
<p>
The cost is measured as "number of neigboring nodes in the current adjacency graph", where the adjacency graph has the variables as its nodes and connects nodes <em>i1</em> and <em>i2</em> iff <em>i1</em> and <em>i2</em> occur together in some common cluster. 
</div>
</div><p>
<a class="anchor" name="68ec048cdbefcf8a488469dd14938452"></a><!-- doxytag: member="dai::eliminationCost_MinWeight" ref="68ec048cdbefcf8a488469dd14938452" args="(const ClusterGraph &amp;cl, size_t i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dai::eliminationCost_MinWeight           </td>
          <td>(</td>
          <td class="paramtype">const ClusterGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculates cost of eliminating the <em>i</em> 'th variable from cluster graph <em>cl</em> according to the "MinWeight" criterion. 
<p>
The cost is measured as "product of weights of neighboring nodes in the current adjacency graph", where the adjacency graph has the variables as its nodes and connects nodes <em>i1</em> and <em>i2</em> iff <em>i1</em> and <em>i2</em> occur together in some common cluster. The weight of a node is the number of states of the corresponding variable. 
</div>
</div><p>
<a class="anchor" name="b6cfdf0bf047e72e324c04e96d310edb"></a><!-- doxytag: member="dai::eliminationCost_MinFill" ref="b6cfdf0bf047e72e324c04e96d310edb" args="(const ClusterGraph &amp;cl, size_t i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dai::eliminationCost_MinFill           </td>
          <td>(</td>
          <td class="paramtype">const ClusterGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculates cost of eliminating the <em>i</em> 'th variable from cluster graph <em>cl</em> according to the "MinFill" criterion. 
<p>
The cost is measured as "number of added edges in the adjacency graph", where the adjacency graph has the variables as its nodes and connects nodes <em>i1</em> and <em>i2</em> iff <em>i1</em> and <em>i2</em> occur together in some common cluster. 
</div>
</div><p>
<a class="anchor" name="990ea70014c5c6a90932d9cee11f393b"></a><!-- doxytag: member="dai::eliminationCost_WeightedMinFill" ref="990ea70014c5c6a90932d9cee11f393b" args="(const ClusterGraph &amp;cl, size_t i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dai::eliminationCost_WeightedMinFill           </td>
          <td>(</td>
          <td class="paramtype">const ClusterGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculates cost of eliminating the <em>i</em> 'th variable from cluster graph <em>cl</em> according to the "WeightedMinFill" criterion. 
<p>
The cost is measured as "total weight of added edges in the adjacency graph", where the adjacency graph has the variables as its nodes and connects nodes <em>i1</em> and <em>i2</em> iff <em>i1</em> and <em>i2</em> occur together in some common cluster. The weight of an edge is the product of the number of states of the variables corresponding with its nodes. 
</div>
</div><p>
<a class="anchor" name="ab8aabfe0fcfd4b4bd24757c101449d5"></a><!-- doxytag: member="dai::calcMarginal" ref="ab8aabfe0fcfd4b4bd24757c101449d5" args="(const InfAlg &amp;obj, const VarSet &amp;vs, bool reInit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#7515abf9952cd312e95a34ada0670e85">Factor</a> dai::calcMarginal           </td>
          <td>(</td>
          <td class="paramtype">const InfAlg &amp;&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VarSet &amp;&nbsp;</td>
          <td class="paramname"> <em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>reInit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculates the marginal probability distribution for <em>vs</em> using inference algorithm <em>obj</em>. 
<p>
<a class="el" href="namespacedai.html#ab8aabfe0fcfd4b4bd24757c101449d5" title="Calculates the marginal probability distribution for vs using inference algorithm...">calcMarginal()</a> works by clamping all variables in <em>vs</em> and calculating the partition sum for each clamped state. Therefore, it can be used in combination with any inference algorithm that can calculate/approximate partition sums. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>instance of inference algorithm to be used </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vs</em>&nbsp;</td><td>variables for which the marginal should be calculated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reInit</em>&nbsp;</td><td>should be set to <code>true</code> if at least one of the possible clamped states would be invalid (leading to a factor graph with zero partition sum). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="82e775a1e2908856f13fa1aa7c081d4c"></a><!-- doxytag: member="dai::calcPairBeliefs" ref="82e775a1e2908856f13fa1aa7c081d4c" args="(const InfAlg &amp;obj, const VarSet &amp;vs, bool reInit, bool accurate=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacedai.html#7515abf9952cd312e95a34ada0670e85">Factor</a> &gt; dai::calcPairBeliefs           </td>
          <td>(</td>
          <td class="paramtype">const InfAlg &amp;&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VarSet &amp;&nbsp;</td>
          <td class="paramname"> <em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>reInit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>accurate</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculates beliefs for all pairs of variables in <em>vs</em> using inference algorithm <em>obj</em>. 
<p>
<a class="el" href="namespacedai.html#82e775a1e2908856f13fa1aa7c081d4c" title="Calculates beliefs for all pairs of variables in vs using inference algorithm obj...">calcPairBeliefs()</a> works by<ul>
<li>clamping single variables in <em>vs</em> and calculating the partition sum and the single variable beliefs for each clamped state, if <em>accurate</em> == <code>false</code>;</li><li>clamping pairs of variables in <em>vs</em> and calculating the partition sum for each clamped state, if <em>accurate</em> == <code>true</code>.</li></ul>
<p>
Therefore, it can be used in combination with any inference algorithm that can calculate/approximate partition sums (and single variable beliefs, if <em>accurate</em> == <code>true</code>). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>instance of inference algorithm to be used </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vs</em>&nbsp;</td><td>variables for which the pair beliefs should be calculated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reInit</em>&nbsp;</td><td>should be set to <code>true</code> if at least one of the possible clamped states would be invalid (leading to a factor graph with zero partition sum). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>accurate</em>&nbsp;</td><td>if <code>true</code>, uses a slower but more accurate approximation algorithm </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e686384295f9909532d78328f87ae260"></a><!-- doxytag: member="dai::findMaximum" ref="e686384295f9909532d78328f87ae260" args="(const InfAlg &amp;obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; dai::findMaximum           </td>
          <td>(</td>
          <td class="paramtype">const InfAlg &amp;&nbsp;</td>
          <td class="paramname"> <em>obj</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculates the joint state of all variables that has maximum probability, according to the inference algorithm <em>obj</em>. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Before this method is called, obj.run() should have been called. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7dd9cb2405e798802d8cbb9b879fdf90"></a><!-- doxytag: member="dai::createFactorIsing" ref="7dd9cb2405e798802d8cbb9b879fdf90" args="(const Var &amp;x, Real h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#7515abf9952cd312e95a34ada0670e85">Factor</a> dai::createFactorIsing           </td>
          <td>(</td>
          <td class="paramtype">const Var &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&nbsp;</td>
          <td class="paramname"> <em>h</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a binary unnormalized single-variable factor <img class="formulaInl" alt="$ \exp(hx) $" src="form_69.png"> where <img class="formulaInl" alt="$ x = \pm 1 $" src="form_70.png">. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Variable (should be binary) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>Field strength </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="de7f623237328458325bce5322abe03e"></a><!-- doxytag: member="dai::createFactorIsing" ref="de7f623237328458325bce5322abe03e" args="(const Var &amp;x1, const Var &amp;x2, Real J)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#7515abf9952cd312e95a34ada0670e85">Factor</a> dai::createFactorIsing           </td>
          <td>(</td>
          <td class="paramtype">const Var &amp;&nbsp;</td>
          <td class="paramname"> <em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Var &amp;&nbsp;</td>
          <td class="paramname"> <em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&nbsp;</td>
          <td class="paramname"> <em>J</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a binary unnormalized pairwise factor <img class="formulaInl" alt="$ \exp(J x_1 x_2) $" src="form_71.png"> where <img class="formulaInl" alt="$ x_1, x_2 = \pm 1 $" src="form_72.png">. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x1</em>&nbsp;</td><td>First variable (should be binary) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x2</em>&nbsp;</td><td>Second variable (should be binary) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>J</em>&nbsp;</td><td>Coupling strength </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6715831e60e66582bce1c69518a40dd3"></a><!-- doxytag: member="dai::createFactorExpGauss" ref="6715831e60e66582bce1c69518a40dd3" args="(const VarSet &amp;vs, Real beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#7515abf9952cd312e95a34ada0670e85">Factor</a> dai::createFactorExpGauss           </td>
          <td>(</td>
          <td class="paramtype">const VarSet &amp;&nbsp;</td>
          <td class="paramname"> <em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&nbsp;</td>
          <td class="paramname"> <em>beta</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a random factor on the variables <em>vs</em> with strength <em>beta</em>. 
<p>
Each entry are set by drawing a normally distributed random with mean 0 and standard-deviation <em>beta</em>, and taking its exponent. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vs</em>&nbsp;</td><td>Variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>beta</em>&nbsp;</td><td>Factor strength (inverse temperature) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ab6d25e30baf39ea06c57b5f71c61a4e"></a><!-- doxytag: member="dai::createFactorPotts" ref="ab6d25e30baf39ea06c57b5f71c61a4e" args="(const Var &amp;x1, const Var &amp;x2, Real J)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#7515abf9952cd312e95a34ada0670e85">Factor</a> dai::createFactorPotts           </td>
          <td>(</td>
          <td class="paramtype">const Var &amp;&nbsp;</td>
          <td class="paramname"> <em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Var &amp;&nbsp;</td>
          <td class="paramname"> <em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&nbsp;</td>
          <td class="paramname"> <em>J</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a pairwise Potts factor <img class="formulaInl" alt="$ \exp( J \delta_{x_1, x_2} ) $" src="form_73.png">. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x1</em>&nbsp;</td><td>First variable </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x2</em>&nbsp;</td><td>Second variable (should have the same number of states as <em>x1</em>) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>J</em>&nbsp;</td><td>Factor strength </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="df624997c47362bc5db95242b76a66a4"></a><!-- doxytag: member="dai::createFactorDelta" ref="df624997c47362bc5db95242b76a66a4" args="(const Var &amp;v, size_t state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#7515abf9952cd312e95a34ada0670e85">Factor</a> dai::createFactorDelta           </td>
          <td>(</td>
          <td class="paramtype">const Var &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>state</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a Kronecker delta point mass. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Variable </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>The state of <em>v</em> that should get value 1 </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a9aa5a66a5df1ae48e29c4ad0965f3c6"></a><!-- doxytag: member="dai::createFactorDelta" ref="a9aa5a66a5df1ae48e29c4ad0965f3c6" args="(const VarSet &amp;vs, size_t state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#7515abf9952cd312e95a34ada0670e85">Factor</a> dai::createFactorDelta           </td>
          <td>(</td>
          <td class="paramtype">const VarSet &amp;&nbsp;</td>
          <td class="paramname"> <em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>state</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a Kronecker delta point mass. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vs</em>&nbsp;</td><td>Set of variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>The state of <em>vs</em> that should get value 1 </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="57fa52134afbd3da21c99975fbba7080"></a><!-- doxytag: member="dai::operator&lt;&lt;" ref="57fa52134afbd3da21c99975fbba7080" args="(std::ostream &amp;os, const FactorGraph &amp;fg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; dai::operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FactorGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>fg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes a <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a> to an output stream. 
<p>
Writes a factor graph to an output stream.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="fileformats.html#fileformats-factorgraph">Factor graph (.fg) file format</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b1b9d59848e415c32330d4a7cbb3269a"></a><!-- doxytag: member="dai::operator&gt;&gt;" ref="b1b9d59848e415c32330d4a7cbb3269a" args="(std::istream &amp;is, FactorGraph &amp;fg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; dai::operator&gt;&gt;           </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FactorGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>fg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads a <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a> from an input stream. 
<p>
Reads a factor graph from an input stream.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="fileformats.html#fileformats-factorgraph">Factor graph (.fg) file format</a> </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>INVALID_FACTORGRAPH_FILE</em>&nbsp;</td><td>if the input stream is not valid </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="edbe32ae13acdd8b62050b18e81a53ea"></a><!-- doxytag: member="dai::createGraphFull" ref="edbe32ae13acdd8b62050b18e81a53ea" args="(size_t N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a> dai::createGraphFull           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>N</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a fully-connected graph with <em>N</em> nodes. 
<p>

</div>
</div><p>
<a class="anchor" name="aeeffaf06b9cd2fecccaf2bf773baed7"></a><!-- doxytag: member="dai::createGraphGrid" ref="aeeffaf06b9cd2fecccaf2bf773baed7" args="(size_t N1, size_t N2, bool periodic)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a> dai::createGraphGrid           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>N1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>N2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>periodic</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a two-dimensional rectangular grid of <em>N1</em> by <em>N2</em> nodes, which can be <em>periodic</em>. 
<p>

</div>
</div><p>
<a class="anchor" name="9950d08bd6190ea12f50b4be6f2584cf"></a><!-- doxytag: member="dai::createGraphGrid3D" ref="9950d08bd6190ea12f50b4be6f2584cf" args="(size_t N1, size_t N2, size_t N3, bool periodic)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a> dai::createGraphGrid3D           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>N1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>N2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>N3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>periodic</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a three-dimensional rectangular grid of <em>N1</em> by <em>N2</em> by <em>N3</em> nodes, which can be <em>periodic</em>. 
<p>

</div>
</div><p>
<a class="anchor" name="7f65fc1665a6fa04b1b6897a4551bccc"></a><!-- doxytag: member="dai::createGraphLoop" ref="7f65fc1665a6fa04b1b6897a4551bccc" args="(size_t N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a> dai::createGraphLoop           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>N</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a graph consisting of a single loop of <em>N</em> nodes. 
<p>

</div>
</div><p>
<a class="anchor" name="d3fbe55f9fdb020e7a2b04f1d2451d20"></a><!-- doxytag: member="dai::createGraphTree" ref="d3fbe55f9fdb020e7a2b04f1d2451d20" args="(size_t N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a> dai::createGraphTree           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>N</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a random tree-structured graph of <em>N</em> nodes. 
<p>

</div>
</div><p>
<a class="anchor" name="bfd6bb3f4b6135a99a68b9b13bee8bae"></a><!-- doxytag: member="dai::createGraphRegular" ref="bfd6bb3f4b6135a99a68b9b13bee8bae" args="(size_t N, size_t d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a> dai::createGraphRegular           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>d</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a random regular graph of <em>N</em> nodes with uniform connectivity <em>d</em>. 
<p>
Algorithm 1 in [<a class="el" href="bibliography.html#StW99">StW99</a>]. Draws a random graph of size <em>N</em> and uniform degree <em>d</em> from an almost uniform probability distribution over these graphs (which becomes uniform in the limit that <em>d</em> is small and <em>N</em> goes to infinity). 
</div>
</div><p>
<a class="anchor" name="847e3cef4f6660bb027e9a3978277a2b"></a><!-- doxytag: member="dai::makePositive" ref="847e3cef4f6660bb027e9a3978277a2b" args="(TFactor&lt; T &gt; &amp;f, T epsilon)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TFactor.html">TFactor</a>&lt;T&gt;&amp; dai::makePositive           </td>
          <td>(</td>
          <td class="paramtype">TFactor&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>epsilon</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets factor entries that lie between 0 and <em>epsilon</em> to <em>epsilon</em>. 
<p>

</div>
</div><p>
<a class="anchor" name="1c7d5fa66149e0e508711f68bac11b5f"></a><!-- doxytag: member="dai::makeZero" ref="1c7d5fa66149e0e508711f68bac11b5f" args="(TFactor&lt; T &gt; &amp;f, T epsilon)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TFactor.html">TFactor</a>&lt;T&gt;&amp; dai::makeZero           </td>
          <td>(</td>
          <td class="paramtype">TFactor&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>epsilon</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets factor entries that are smaller (in absolute value) than <em>epsilon</em> to 0. 
<p>

</div>
</div><p>
<a class="anchor" name="fbde3d057ec404d5f4f962da46bccced"></a><!-- doxytag: member="dai::ReadUaiAieFactorGraphFile" ref="fbde3d057ec404d5f4f962da46bccced" args="(const char *filename, size_t verbose, std::vector&lt; Var &gt; &amp;vars, std::vector&lt; Factor &gt; &amp;factors, std::vector&lt; Permute &gt; &amp;permutations)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dai::ReadUaiAieFactorGraphFile           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Var &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Factor &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Permute &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>permutations</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads factor graph (as a pair of a variable vector and factor vector) from a file in the UAI approximate inference challenge format. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filename</em>&nbsp;</td><td>The filename (usually ends with ".uai") </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>verbose</em>&nbsp;</td><td>The amount of output sent to cout </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>vars</em>&nbsp;</td><td>Array of variables read from the file </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>factors</em>&nbsp;</td><td>Array of factors read from the file </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>permutations</em>&nbsp;</td><td>Array of permutations, which permute between libDAI canonical ordering and ordering specified by the file </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.cs.huji.ac.il/project/UAI10">http://www.cs.huji.ac.il/project/UAI10</a> and <a href="http://graphmod.ics.uci.edu/uai08">http://graphmod.ics.uci.edu/uai08</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b5cba3982dd0cd9d5fa3a06c05aef8b1"></a><!-- doxytag: member="dai::ReadUaiAieEvidenceFile" ref="b5cba3982dd0cd9d5fa3a06c05aef8b1" args="(const char *filename, size_t verbose)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::map&lt; size_t, size_t &gt; &gt; dai::ReadUaiAieEvidenceFile           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>verbose</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads evidence (a mapping from observed variable labels to the observed values) from a file in the UAI approximate inference challenge format. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filename</em>&nbsp;</td><td>The filename (usually ends with ".uai.evid") </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>verbose</em>&nbsp;</td><td>The amount of output sent to cout </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.cs.huji.ac.il/project/UAI10">http://www.cs.huji.ac.il/project/UAI10</a> and <a href="http://graphmod.ics.uci.edu/uai08">http://graphmod.ics.uci.edu/uai08</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c63c2f1d67d01aeda5c3cdd95843ea86"></a><!-- doxytag: member="dai::operator&lt;&lt;" ref="c63c2f1d67d01aeda5c3cdd95843ea86" args="(std::ostream &amp;os, const Property &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; dai::operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Property &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes a Property object (key-value pair) to an output stream. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Not all value types are automatically supported; if a type is unknown, an UNKNOWN_PROPERTY_TYPE exception is thrown. Adding support for a new type can be done by changing this function body. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b339baefa9f588de2fba07526d8df7ba"></a><!-- doxytag: member="dai::operator&lt;&lt;" ref="b339baefa9f588de2fba07526d8df7ba" args="(std::ostream &amp;os, const PropertySet &amp;ps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; dai::operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PropertySet &amp;&nbsp;</td>
          <td class="paramname"> <em>ps</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes a <a class="el" href="classdai_1_1PropertySet.html" title="Represents a set of properties, mapping keys (of type PropertyKey) to values (of...">PropertySet</a> object to an output stream. 
<p>
It uses the format <code>"[key1=val1,key2=val2,...,keyn=valn]"</code>. <dl class="note" compact><dt><b>Note:</b></dt><dd>Only a subset of all possible types is supported (see the implementation of this function). Adding support for more types has to be done by hand. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>UNKNOWN_PROPERTY_TYPE</em>&nbsp;</td><td>if the type of a property value is not supported. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ab0479dd285fd4021ecaa80947d40da3"></a><!-- doxytag: member="dai::operator&gt;&gt;" ref="ab0479dd285fd4021ecaa80947d40da3" args="(std::istream &amp;is, PropertySet &amp;ps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; dai::operator&gt;&gt;           </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertySet &amp;&nbsp;</td>
          <td class="paramname"> <em>ps</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads a <a class="el" href="classdai_1_1PropertySet.html" title="Represents a set of properties, mapping keys (of type PropertyKey) to values (of...">PropertySet</a> object from an input stream, storing values as strings. 
<p>
Reads a <a class="el" href="classdai_1_1PropertySet.html" title="Represents a set of properties, mapping keys (of type PropertyKey) to values (of...">PropertySet</a> object from an input stream.<p>
It expects a string in the format <code>"[key1=val1,key2=val2,...,keyn=valn]"</code>. Values are stored as strings. <dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>MALFORMED_PROPERTY</em>&nbsp;</td><td>if the string is not in the expected format </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0e910ae9247869ee549df8eed173a6df"></a><!-- doxytag: member="dai::operator&lt;&lt;" ref="0e910ae9247869ee549df8eed173a6df" args="(ostream &amp;os, const RegionGraph &amp;rg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; dai::operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RegionGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>rg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send <a class="el" href="classdai_1_1RegionGraph.html" title="A RegionGraph combines a bipartite graph consisting of outer regions (type FRegion)...">RegionGraph</a> to output stream. 
<p>

</div>
</div><p>
<a class="anchor" name="9886ca4103eac52b3f82698e12e86672"></a><!-- doxytag: member="dai::isnan" ref="9886ca4103eac52b3f82698e12e86672" args="(Real x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dai::isnan           </td>
          <td>(</td>
          <td class="paramtype">Real&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if argument is NAN (Not A Number). 
<p>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="uai2010-aie-solver_8cpp-example.html#a15">uai2010-aie-solver.cpp</a>.</dl>
</div>
</div><p>
<a class="anchor" name="b27c0799ddef29bb3833477e32c53862"></a><!-- doxytag: member="dai::toc" ref="b27c0799ddef29bb3833477e32c53862" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dai::toc           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns wall clock time in seconds. 
<p>

</div>
</div><p>
<a class="anchor" name="8676cd0faacaec12b2acf0e0472e3280"></a><!-- doxytag: member="dai::_rnd_gen" ref="8676cd0faacaec12b2acf0e0472e3280" args="(42U)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#d2fa14208786f0746805efc9fbf3e56e">_rnd_gen_type</a> dai::_rnd_gen           </td>
          <td>(</td>
          <td class="paramtype">42U&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Global random number generator. 
<p>

</div>
</div><p>
<a class="anchor" name="2cff7aad0084432ddcc7ef52618b74bd"></a><!-- doxytag: member="dai::_uni_dist" ref="2cff7aad0084432ddcc7ef52618b74bd" args="(0, 1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::uniform_real&lt;<a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a>&gt; dai::_uni_dist           </td>
          <td>(</td>
          <td class="paramtype">0&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Uniform distribution with values between 0 and 1 (0 inclusive, 1 exclusive). 
<p>

</div>
</div><p>
<a class="anchor" name="95e934001307cafa4576b31fb0569e2c"></a><!-- doxytag: member="dai::_uni_rnd" ref="95e934001307cafa4576b31fb0569e2c" args="(_rnd_gen, _uni_dist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::variate_generator&lt;<a class="el" href="namespacedai.html#d2fa14208786f0746805efc9fbf3e56e">_rnd_gen_type</a>&amp;, boost::uniform_real&lt;<a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a>&gt; &gt; dai::_uni_rnd           </td>
          <td>(</td>
          <td class="paramtype">_rnd_gen&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_uni_dist&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Global uniform random random number. 
<p>

</div>
</div><p>
<a class="anchor" name="205aca5e7688c28a95ecc978b4f79879"></a><!-- doxytag: member="dai::_normal_rnd" ref="205aca5e7688c28a95ecc978b4f79879" args="(_rnd_gen, _normal_dist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::variate_generator&lt;<a class="el" href="namespacedai.html#d2fa14208786f0746805efc9fbf3e56e">_rnd_gen_type</a>&amp;, boost::normal_distribution&lt;<a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a>&gt; &gt; dai::_normal_rnd           </td>
          <td>(</td>
          <td class="paramtype">_rnd_gen&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_normal_dist&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Global random number generator with standard normal distribution. 
<p>

</div>
</div><p>
<a class="anchor" name="e699eca7ca4d6e971b54c2b4a95942d4"></a><!-- doxytag: member="dai::rnd_seed" ref="e699eca7ca4d6e971b54c2b4a95942d4" args="(size_t seed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dai::rnd_seed           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>seed</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the random seed. 
<p>

</div>
</div><p>
<a class="anchor" name="129f3a9c518c632c985d045a4f8c60f9"></a><!-- doxytag: member="dai::rnd_uniform" ref="129f3a9c518c632c985d045a4f8c60f9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a> dai::rnd_uniform           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a real number, distributed uniformly on [0,1). 
<p>

</div>
</div><p>
<a class="anchor" name="c3f6d317ca42fbb4b643aa8c82692d74"></a><!-- doxytag: member="dai::rnd_stdnormal" ref="c3f6d317ca42fbb4b643aa8c82692d74" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a> dai::rnd_stdnormal           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a real number from a standard-normal distribution. 
<p>

</div>
</div><p>
<a class="anchor" name="c02317b960b112637976333f90d1f937"></a><!-- doxytag: member="dai::rnd_int" ref="c02317b960b112637976333f90d1f937" args="(int min, int max)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dai::rnd_int           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a random integer in interval [<em>min</em>, <em>max</em>]. 
<p>

</div>
</div><p>
<a class="anchor" name="87303da2767f4906ea37216bdc9278ca"></a><!-- doxytag: member="dai::tokenizeString" ref="87303da2767f4906ea37216bdc9278ca" args="(const std::string &amp;s, bool singleDelim, const std::string &amp;delim=&quot;\t\n&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; dai::tokenizeString           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>singleDelim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>delim</em> = <code>&quot;\t\n&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Split a string into tokens delimited by one of the characters in <em>delim</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>the string to be split into tokens </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>singleDelim</em>&nbsp;</td><td>if <code>true</code>, any single delimiter forms a boundary between two tokens; if <code>false</code>, a maximal group of consecutive delimiters forms a boundary between two tokens </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delim</em>&nbsp;</td><td>delimiter characters </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="750c3807e7375265c3fb410a1f1223fe"></a><!-- doxytag: member="dai::calcLinearState" ref="750c3807e7375265c3fb410a1f1223fe" args="(const VarSet &amp;vs, const std::map&lt; Var, size_t &gt; &amp;state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dai::calcLinearState           </td>
          <td>(</td>
          <td class="paramtype">const VarSet &amp;&nbsp;</td>
          <td class="paramname"> <em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; Var, size_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>state</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculates the linear index in the Cartesian product of the variables in <em>vs</em> that corresponds to a particular joint assignment of the variables, specified by <em>state</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vs</em>&nbsp;</td><td>Set of variables for which the linear state should be calculated; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>Specifies the states of some variables. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The linear index in the Cartesian product of the variables in <em>vs</em> corresponding with the joint assignment specified by <em>state</em>, where variables for which no state is specified are assumed to be in state 0.</dd></dl>
The linear index is calculated as follows. The variables in <em>vs</em> are ordered according to their label (in ascending order); say <em>vs</em> corresponds with the set <img class="formulaInl" alt="$\{x_{l(0)},x_{l(1)},\dots,x_{l(n-1)}\}$" src="form_133.png"> with <img class="formulaInl" alt="$l(0) < l(1) < \dots < l(n-1)$" src="form_134.png">, where variable <img class="formulaInl" alt="$x_l$" src="form_30.png"> has label <em>l</em>. Denote by <img class="formulaInl" alt="$S_l$" src="form_32.png"> the number of possible values ("states") of variable <img class="formulaInl" alt="$x_l$" src="form_30.png">. The argument <em>state</em> corresponds with a mapping <em>s</em> that assigns to each variable <img class="formulaInl" alt="$x_l$" src="form_30.png"> a state <img class="formulaInl" alt="$s(x_l) \in \{0,1,\dots,S_l-1\}$" src="form_135.png">, where <img class="formulaInl" alt="$s(x_l)=0$" src="form_136.png"> if <img class="formulaInl" alt="$x_l$" src="form_30.png"> is not specified in <em>state</em>. The linear index <img class="formulaInl" alt="$S$" src="form_137.png"> corresponding with <em>state</em> is now calculated by: <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} S &amp;:=&amp; \sum_{i=0}^{n-1} s(x_{l(i)}) \prod_{j=0}^{i-1} S_{l(j)} \\ &amp;= &amp; s(x_{l(0)}) + s(x_{l(1)}) S_{l(0)} + s(x_{l(2)}) S_{l(0)} S_{l(1)} + \dots + s(x_{l(n-1)}) S_{l(0)} \cdots S_{l(n-2)}. \end{eqnarray*}" src="form_138.png">
<p>
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If <em>vs</em> corresponds with <img class="formulaInl" alt="$\{x_l\}_{l\in L}$" src="form_64.png">, and <em>state</em> specifies a state for each variable <img class="formulaInl" alt="$x_l$" src="form_30.png"> for <img class="formulaInl" alt="$l\in L$" src="form_139.png">, <a class="el" href="namespacedai.html#750c3807e7375265c3fb410a1f1223fe" title="Calculates the linear index in the Cartesian product of the variables in vs that...">calcLinearState()</a> induces a mapping <img class="formulaInl" alt="$\sigma : \prod_{l\in L} X_l \to \{0,1,\dots,\prod_{l\in L} S_l-1\}$" src="form_140.png"> that maps a joint state to a linear index; this is the inverse of the mapping <img class="formulaInl" alt="$\sigma^{-1}$" src="form_141.png"> induced by <a class="el" href="namespacedai.html#fcfc874f85b4a2944ec128ebd1dd19f1" title="Calculates the joint assignment of the variables in vs corresponding to the linear...">calcState()</a>.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="namespacedai.html#fcfc874f85b4a2944ec128ebd1dd19f1" title="Calculates the joint assignment of the variables in vs corresponding to the linear...">calcState()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="fcfc874f85b4a2944ec128ebd1dd19f1"></a><!-- doxytag: member="dai::calcState" ref="fcfc874f85b4a2944ec128ebd1dd19f1" args="(const VarSet &amp;vs, size_t linearState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; <a class="el" href="classdai_1_1Var.html">Var</a>, size_t &gt; dai::calcState           </td>
          <td>(</td>
          <td class="paramtype">const VarSet &amp;&nbsp;</td>
          <td class="paramname"> <em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>linearState</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculates the joint assignment of the variables in <em>vs</em> corresponding to the linear index <em>linearState</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vs</em>&nbsp;</td><td>Set of variables to which <em>linearState</em> refers </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>linearState</em>&nbsp;</td><td>should be smaller than vs.nrStates(). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A mapping <img class="formulaInl" alt="$s$" src="form_84.png"> that maps each <a class="el" href="classdai_1_1Var.html" title="Represents a discrete random variable.">Var</a> <img class="formulaInl" alt="$x_l$" src="form_30.png"> in <em>vs</em> to its state <img class="formulaInl" alt="$s(x_l)$" src="form_142.png">, as specified by <em>linearState</em>.</dd></dl>
The variables in <em>vs</em> are ordered according to their label (in ascending order); say <em>vs</em> corresponds with the set <img class="formulaInl" alt="$\{x_{l(0)},x_{l(1)},\dots,x_{l(n-1)}\}$" src="form_133.png"> with <img class="formulaInl" alt="$l(0) < l(1) < \dots < l(n-1)$" src="form_134.png">, where variable <img class="formulaInl" alt="$x_l$" src="form_30.png"> has label <em>l</em>. Denote by <img class="formulaInl" alt="$S_l$" src="form_32.png"> the number of possible values ("states") of variable <img class="formulaInl" alt="$x_l$" src="form_30.png"> with label <em>l</em>. The mapping <img class="formulaInl" alt="$s$" src="form_84.png"> returned by this function is defined as: <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} s(x_{l(i)}) = \left\lfloor\frac{S \mbox { mod } \prod_{j=0}^{i} S_{l(j)}}{\prod_{j=0}^{i-1} S_{l(j)}}\right\rfloor \qquad \mbox{for all $i=0,\dots,n-1$}. \end{eqnarray*}" src="form_143.png">
<p>
 where <img class="formulaInl" alt="$S$" src="form_137.png"> denotes the value of <em>linearState</em>.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If <em>vs</em> corresponds with <img class="formulaInl" alt="$\{x_l\}_{l\in L}$" src="form_64.png">, <a class="el" href="namespacedai.html#fcfc874f85b4a2944ec128ebd1dd19f1" title="Calculates the joint assignment of the variables in vs corresponding to the linear...">calcState()</a> induces a mapping <img class="formulaInl" alt="$\sigma^{-1} : \{0,1,\dots,\prod_{l\in L} S_l-1\} \to \prod_{l\in L} X_l$" src="form_144.png"> that maps a linear index to a joint state; this is the inverse of the mapping <img class="formulaInl" alt="$\sigma$" src="form_68.png"> induced by <a class="el" href="namespacedai.html#750c3807e7375265c3fb410a1f1223fe" title="Calculates the linear index in the Cartesian product of the variables in vs that...">calcLinearState()</a>.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="namespacedai.html#750c3807e7375265c3fb410a1f1223fe" title="Calculates the linear index in the Cartesian product of the variables in vs that...">calcLinearState()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e62bf4dfaa6694edc2d180b71656d430"></a><!-- doxytag: member="dai::Factors2mx" ref="e62bf4dfaa6694edc2d180b71656d430" args="(const std::vector&lt; Factor &gt; &amp;Ps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mxArray * dai::Factors2mx           </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; Factor &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Ps</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert vector&lt;Factor&gt; structure to a cell vector of CPTAB-like structs. 
<p>

</div>
</div><p>
<a class="anchor" name="bdd1a935e89ca8dc1d4e0c1cea371d44"></a><!-- doxytag: member="dai::mx2Factors" ref="bdd1a935e89ca8dc1d4e0c1cea371d44" args="(const mxArray *psi, long verbose)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacedai.html#7515abf9952cd312e95a34ada0670e85">Factor</a> &gt; dai::mx2Factors           </td>
          <td>(</td>
          <td class="paramtype">const mxArray *&nbsp;</td>
          <td class="paramname"> <em>psi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>verbose</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert cell vector of CPTAB-like structs to vector&lt;Factor&gt;. 
<p>

</div>
</div><p>
<a class="anchor" name="573a608f62779c1a08f8e10c3fa4e940"></a><!-- doxytag: member="dai::mx2Factor" ref="573a608f62779c1a08f8e10c3fa4e940" args="(const mxArray *psi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#7515abf9952cd312e95a34ada0670e85">Factor</a> dai::mx2Factor           </td>
          <td>(</td>
          <td class="paramtype">const mxArray *&nbsp;</td>
          <td class="paramname"> <em>psi</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert CPTAB-like struct to Factor. 
<p>

</div>
</div><p>
<a class="anchor" name="ef8d342ac50bdaed5d513df6349be31c"></a><!-- doxytag: member="dai::DAI_ENUM" ref="ef8d342ac50bdaed5d513df6349be31c" args="(BBPCostFunctionBase, CFN_GIBBS_B, CFN_GIBBS_B2, CFN_GIBBS_EXP, CFN_GIBBS_B_FACTOR, CFN_GIBBS_B2_FACTOR, CFN_GIBBS_EXP_FACTOR, CFN_VAR_ENT, CFN_FACTOR_ENT, CFN_BETHE_ENT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dai::DAI_ENUM           </td>
          <td>(</td>
          <td class="paramtype">BBPCostFunctionBase&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFN_GIBBS_B&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFN_GIBBS_B2&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFN_GIBBS_EXP&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFN_GIBBS_B_FACTOR&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFN_GIBBS_B2_FACTOR&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFN_GIBBS_EXP_FACTOR&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFN_VAR_ENT&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFN_FACTOR_ENT&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFN_BETHE_ENT&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enumeration of several cost functions that can be used with <a class="el" href="classdai_1_1BBP.html" title="Implements BBP (Back-Belief-Propagation) [EaG09].">BBP</a>. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This class is meant as a base class for <a class="el" href="classdai_1_1BBPCostFunction.html" title="Predefined cost functions that can be used with BBP.">BBPCostFunction</a>, which provides additional functionality. </dd></dl>

</div>
</div><p>
<a class="anchor" name="934491ad55f57c9072271b4a32ea4919"></a><!-- doxytag: member="dai::log" ref="934491ad55f57c9072271b4a32ea4919" args="(Real x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a> dai::log           </td>
          <td>(</td>
          <td class="paramtype">Real&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns logarithm of <em>x</em>. 
<p>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="uai2010-aie-solver_8cpp-example.html#a3">uai2010-aie-solver.cpp</a>.</dl>
</div>
</div><p>
<a class="anchor" name="00375a4d7b55534c14f993c909b04c3c"></a><!-- doxytag: member="dai::log0" ref="00375a4d7b55534c14f993c909b04c3c" args="(Real x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a> dai::log0           </td>
          <td>(</td>
          <td class="paramtype">Real&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns logarithm of <em>x</em>, or 0 if <em>x</em> == 0. 
<p>

</div>
</div><p>
<a class="anchor" name="c336ffb182b6e6fa3f7df13620aab012"></a><!-- doxytag: member="dai::exp" ref="c336ffb182b6e6fa3f7df13620aab012" args="(Real x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a> dai::exp           </td>
          <td>(</td>
          <td class="paramtype">Real&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns exponent of <em>x</em>. 
<p>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="uai2010-aie-solver_8cpp-example.html#a6">uai2010-aie-solver.cpp</a>.</dl>
</div>
</div><p>
<a class="anchor" name="16465ce3d62a6456fd06e9a226c966f2"></a><!-- doxytag: member="dai::pow" ref="16465ce3d62a6456fd06e9a226c966f2" args="(Real x, Real y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a> dai::pow           </td>
          <td>(</td>
          <td class="paramtype">Real&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <em>to</em> the power <em>y</em>. 
<p>

</div>
</div><p>
<a class="anchor" name="bc859d9510bf6f58fc066c33ae8f7492"></a><!-- doxytag: member="dai::abs" ref="bc859d9510bf6f58fc066c33ae8f7492" args="(const T &amp;t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T dai::abs           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns absolute value of <em>t</em>. 
<p>

</div>
</div><p>
<a class="anchor" name="ffae7aacdd26b4a580fbb8790cbccc86"></a><!-- doxytag: member="dai::rnd" ref="ffae7aacdd26b4a580fbb8790cbccc86" args="(int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dai::rnd           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a random integer in the half-open interval [0, <em>n</em>). 
<p>

</div>
</div><p>
<a class="anchor" name="039689f5b5f4a2f34479fd1a8fd21b8a"></a><!-- doxytag: member="dai::toString" ref="039689f5b5f4a2f34479fd1a8fd21b8a" args="(const T &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string dai::toString           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a variable of type <em>T</em> to a <code>std::string</code> by using a <code>boost::lexical_cast</code>. 
<p>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="uai2010-aie-solver_8cpp-example.html#a8">uai2010-aie-solver.cpp</a>.</dl>
</div>
</div><p>
<a class="anchor" name="464325bef76b7bf68a4b3f3246380e93"></a><!-- doxytag: member="dai::fromString" ref="464325bef76b7bf68a4b3f3246380e93" args="(const std::string &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T dai::fromString           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a variable of type std::string to <em>T</em> by using a <code>boost::lexical_cast</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="1a0b1c88c46fb8763c2c783cc3fe9a62"></a><!-- doxytag: member="dai::operator&lt;&lt;" ref="1a0b1c88c46fb8763c2c783cc3fe9a62" args="(std::ostream &amp;os, const std::vector&lt; T &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; dai::operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes a <code>std::vector&lt;&gt;</code> to a <code>std::ostream</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="4f8ad5d0c47c7fdfe17e5d0f4c0a32d9"></a><!-- doxytag: member="dai::operator&lt;&lt;" ref="4f8ad5d0c47c7fdfe17e5d0f4c0a32d9" args="(std::ostream &amp;os, const std::set&lt; T &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; dai::operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes a <code>std::set&lt;&gt;</code> to a <code>std::ostream</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="5913957fb1c3c3d3fbd1f3102b8eb04c"></a><!-- doxytag: member="dai::operator&lt;&lt;" ref="5913957fb1c3c3d3fbd1f3102b8eb04c" args="(std::ostream &amp;os, const std::map&lt; T1, T2 &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; dai::operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; T1, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes a <code>std::map&lt;&gt;</code> to a <code>std::ostream</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="575f6202aa88de6bf5146b85d8832eb5"></a><!-- doxytag: member="dai::operator&lt;&lt;" ref="575f6202aa88de6bf5146b85d8832eb5" args="(std::ostream &amp;os, const std::pair&lt; T1, T2 &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; dai::operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; T1, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes a <code>std::pair&lt;&gt;</code> to a <code>std::ostream</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="ae335872c5de8c4d1f21833cbe5c0020"></a><!-- doxytag: member="dai::concat" ref="ae335872c5de8c4d1f21833cbe5c0020" args="(const std::vector&lt; T &gt; &amp;u, const std::vector&lt; T &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; dai::concat           </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Concatenates two vectors. 
<p>

</div>
</div><p>
<a class="anchor" name="273d7118dd690f5b438fba18f6860eb6"></a><!-- doxytag: member="dai::MinSpanningTree" ref="273d7118dd690f5b438fba18f6860eb6" args="(const WeightedGraph&lt; T &gt; &amp;G, bool usePrim)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1RootedTree.html">RootedTree</a> dai::MinSpanningTree           </td>
          <td>(</td>
          <td class="paramtype">const WeightedGraph&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>usePrim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a minimum spanning tree from the (non-negatively) weighted graph <em>G</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>G</em>&nbsp;</td><td>Weighted graph that should have non-negative weights. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>usePrim</em>&nbsp;</td><td>If true, use Prim's algorithm (complexity O(E log(V))), otherwise, use Kruskal's algorithm (complexity O(E log(E))). </td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Uses implementation from Boost Graph Library. <p>
The vertices of <em>G</em> must be in the range [0,N) where N is the number of vertices of <em>G</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1914ae414d452b1844e6cd72f70501b5"></a><!-- doxytag: member="dai::MaxSpanningTree" ref="1914ae414d452b1844e6cd72f70501b5" args="(const WeightedGraph&lt; T &gt; &amp;G, bool usePrim)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1RootedTree.html">RootedTree</a> dai::MaxSpanningTree           </td>
          <td>(</td>
          <td class="paramtype">const WeightedGraph&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>usePrim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a minimum spanning tree from the (non-negatively) weighted graph <em>G</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>G</em>&nbsp;</td><td>Weighted graph that should have non-negative weights. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>usePrim</em>&nbsp;</td><td>If true, use Prim's algorithm (complexity O(E log(V))), otherwise, use Kruskal's algorithm (complexity O(E log(E))). </td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Uses implementation from Boost Graph Library. <p>
The vertices of <em>G</em> must be in the range [0,N) where N is the number of vertices of <em>G</em>. </dd></dl>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="72200157ce1fbccfe91f66a3f8416823"></a><!-- doxytag: member="dai::_normal_dist" ref="72200157ce1fbccfe91f66a3f8416823" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::normal_distribution&lt;<a class="el" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf">Real</a>&gt; <a class="el" href="namespacedai.html#72200157ce1fbccfe91f66a3f8416823">dai::_normal_dist</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Normal distribution with mean 0 and standard deviation 1. 
<p>

</div>
</div><p>
<a class="anchor" name="faf76457d5d1ad9cfd37feb44ae94669"></a><!-- doxytag: member="dai::DAINames" ref="faf76457d5d1ad9cfd37feb44ae94669" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="namespacedai.html#faf76457d5d1ad9cfd37feb44ae94669">dai::DAINames</a>[]<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Contains the names of all inference algorithms compiled into libDAI. 
<p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Aug 19 13:58:11 2010 for libDAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
