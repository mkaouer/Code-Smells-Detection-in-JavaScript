<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>libDAI: example_imagesegmentation.cpp</title>
<link href="customdoxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>example_imagesegmentation.cpp</h1>This example shows how one can use approximate inference in factor graphs on a simple vision task: given two images, identify smooth regions where these two images differ more than some threshold. This can be used to seperate foreground from background if one image contains the background and the other one the combination of background and foreground.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>In order to build this example, a recent version of CImg needs to be installed.</dd></dl>
<div class="fragment"><pre class="fragment"><span class="comment">/*  This file is part of libDAI - http://www.libdai.org/</span>
<span class="comment"> *</span>
<span class="comment"> *  libDAI is licensed under the terms of the GNU General Public License version</span>
<span class="comment"> *  2, or (at your option) any later version. libDAI is distributed without any</span>
<span class="comment"> *  warranty. See the file COPYING for more details.</span>
<span class="comment"> *</span>
<span class="comment"> *  Copyright (C) 2006-2010  Joris Mooij  [joris dot mooij at libdai dot org]</span>
<span class="comment"> *  Copyright (C) 2006-2007  Radboud University Nijmegen, The Netherlands</span>
<span class="comment"> */</span>


<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="alldai_8h.html" title="Main libDAI header file. It #includes all other libDAI headers.">dai/alldai.h</a>&gt;</span>  <span class="comment">// Include main libDAI header file</span>
<span class="preprocessor">#include &lt;CImg.h&gt;</span>        <span class="comment">// This example needs CImg to be installed</span>


<span class="keyword">using namespace </span>dai;
<span class="keyword">using namespace </span>std;
<span class="keyword">using namespace </span>cimg_library;



<span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="_a0"></a><a class="code" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a> img2fg( <span class="keyword">const</span> CImg&lt;T&gt; &amp;img, <span class="keywordtype">double</span> J, <span class="keywordtype">double</span> th_min, <span class="keywordtype">double</span> th_max, <span class="keywordtype">double</span> scale, <span class="keywordtype">double</span> pbg, CImg&lt;unsigned char&gt; &amp;evidence ) {
    vector&lt;Var&gt; vars;
    vector&lt;Factor&gt; factors;

<span class="preprocessor">#ifndef NEW_CIMG</span>
<span class="preprocessor"></span>    <span class="keywordtype">size_t</span> dimx = img.width;   <span class="comment">// Width of the image in pixels</span>
    <span class="keywordtype">size_t</span> dimy = img.height;  <span class="comment">// Height of the image in pixels</span>
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>    <span class="keywordtype">size_t</span> dimx = img.width();   <span class="comment">// Width of the image in pixels</span>
    <span class="keywordtype">size_t</span> dimy = img.height();  <span class="comment">// Height of the image in pixels</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    <span class="keywordtype">size_t</span> N = dimx * dimy;      <span class="comment">// One variable for each pixel</span>

    <span class="comment">// Create variables</span>
    cout &lt;&lt; <span class="stringliteral">"  Image width:  "</span> &lt;&lt; dimx &lt;&lt; endl;
    cout &lt;&lt; <span class="stringliteral">"  Image height: "</span> &lt;&lt; dimy &lt;&lt; endl;
    cout &lt;&lt; <span class="stringliteral">"  Pairwise interaction strength:   "</span> &lt;&lt; J &lt;&lt; endl;
    cout &lt;&lt; <span class="stringliteral">"  Minimal local evidence strength: "</span> &lt;&lt; th_min &lt;&lt; endl;
    cout &lt;&lt; <span class="stringliteral">"  Maximal local evidence strength: "</span> &lt;&lt; th_max &lt;&lt; endl;
    cout &lt;&lt; <span class="stringliteral">"  Scale of pixel values:           "</span> &lt;&lt; scale &lt;&lt; endl;
    cout &lt;&lt; <span class="stringliteral">"  Percentage of background:        "</span> &lt;&lt; pbg &lt;&lt; endl;
    cout &lt;&lt; <span class="stringliteral">"  Creating "</span> &lt;&lt; N &lt;&lt; <span class="stringliteral">" variables..."</span> &lt;&lt; endl;
    <span class="comment">// Reserve memory for the variables</span>
    vars.reserve( N );
    <span class="comment">// Create a binary variable for each pixel</span>
    <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i = 0; i &lt; N; i++ )
        vars.push_back( <a name="_a1"></a><a class="code" href="classdai_1_1Var.html" title="Represents a discrete random variable.">Var</a>( i, 2 ) );

    <span class="comment">// Build image histogram</span>
    CImg&lt;float&gt; hist = img.get_channel( 0 ).get_histogram( 256, 0, 255 );
    <span class="keywordtype">size_t</span> cum_hist = 0;

    <span class="comment">// Find the critical level which corresponds with the seperation</span>
    <span class="comment">// between foreground and background, assuming that the percentage</span>
    <span class="comment">// of pixels in the image that belong to the background is pbg</span>
    <span class="keywordtype">size_t</span> level = 0;
    <span class="keywordflow">for</span>( level = 0; level &lt; 256; level++ ) {
        cum_hist += (size_t)hist(level);
        <span class="keywordflow">if</span>( cum_hist &gt; pbg * dimx * dimy / 100.0 )
            <span class="keywordflow">break</span>;
    }

    <span class="comment">// Create factors</span>
    cout &lt;&lt; <span class="stringliteral">"  Creating "</span> &lt;&lt; (3 * N - dimx - dimy) &lt;&lt; <span class="stringliteral">" factors..."</span> &lt;&lt; endl;
    <span class="comment">// Reserve memory for the factors</span>
    factors.reserve( 3 * N - dimx - dimy );
    <span class="comment">// th_avg is the local field strength that would correspond with pixel value level</span>
    <span class="comment">// th_width is the width of the local field strength range</span>
    <span class="keywordtype">double</span> th_avg = (th_min + th_max) / 2.0;
    <span class="keywordtype">double</span> th_width = (th_max - th_min) / 2.0;
    <span class="comment">// For each pixel</span>
    <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i = 0; i &lt; dimx; i++ )
        <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> j = 0; j &lt; dimy; j++ ) {
            <span class="comment">// Add a pairwise interaction with the left neighboring pixel</span>
            <span class="keywordflow">if</span>( i &gt;= 1 )
                factors.push_back( <a class="code" href="namespacedai.html#7dd9cb2405e798802d8cbb9b879fdf90" title="Returns a binary unnormalized single-variable factor  where .">createFactorIsing</a>( vars[i*dimy+j], vars[(i-1)*dimy+j], J ) );
            <span class="comment">// Add a pairwise interaction with the upper neighboring pixel</span>
            <span class="keywordflow">if</span>( j &gt;= 1 )
                factors.push_back( <a class="code" href="namespacedai.html#7dd9cb2405e798802d8cbb9b879fdf90" title="Returns a binary unnormalized single-variable factor  where .">createFactorIsing</a>( vars[i*dimy+j], vars[i*dimy+(j-1)], J ) );
            <span class="comment">// Get the pixel value</span>
            <span class="keywordtype">double</span> x = img(i,j);
            <span class="comment">// Apply the nonlinear transformation to get the local field strength</span>
            <span class="keywordtype">double</span> th = th_avg + th_width * tanh( (x - level) / scale );
            <span class="comment">// Add a single-variable interaction with strength th</span>
            factors.push_back( <a class="code" href="namespacedai.html#7dd9cb2405e798802d8cbb9b879fdf90" title="Returns a binary unnormalized single-variable factor  where .">createFactorIsing</a>( vars[i*dimy+j], th ) );

            <span class="comment">// For visualization, we calculate a grayscale level corresponding to the local field strength</span>
            <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> g = (<span class="keywordtype">unsigned</span> char)((tanh(th) + 1.0) / 2.0 * 255.0);
            <span class="comment">// and store it in the evidence image</span>
            <span class="keywordflow">if</span>( g &gt; 127 ) {
                evidence(i,j,0) = 255;
                evidence(i,j,1) = 2 * (g - 127);
                evidence(i,j,2) = 2 * (g - 127);
            } <span class="keywordflow">else</span> {
                evidence(i,j,0) = 0;
                evidence(i,j,1) = 0;
                evidence(i,j,2) = 2*g;
            }
        }

    <span class="comment">// Create the factor graph out of the variables and factors</span>
    cout &lt;&lt; <span class="stringliteral">"Creating the factor graph..."</span> &lt;&lt; endl;
    <span class="keywordflow">return</span> <a class="code" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a>( factors.begin(), factors.end(), vars.begin(), vars.end(), factors.size(), vars.size() );
}



<span class="keywordtype">double</span> doInference( <a class="code" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a>&amp; fg, <span class="keywordtype">string</span> algOpts, <span class="keywordtype">size_t</span> maxIter, <span class="keywordtype">double</span> tol, vector&lt;double&gt; &amp;m, <span class="keywordtype">size_t</span> dimx, <span class="keywordtype">size_t</span> dimy, CImgDisplay &amp;disp ) {
    <span class="comment">// Construct inference algorithm</span>
    cout &lt;&lt; <span class="stringliteral">"Inference algorithm: "</span> &lt;&lt; algOpts &lt;&lt; endl;
    cout &lt;&lt; <span class="stringliteral">"Constructing inference algorithm object..."</span> &lt;&lt; endl;
    <a name="_a2"></a><a class="code" href="classdai_1_1InfAlg.html" title="InfAlg is an abstract base class, defining the common interface of all inference...">InfAlg</a>* ia = <a class="code" href="namespacedai.html#246c23914fee45f8b7f01f9073bdd6fe" title="Constructs a new inference algorithm.">newInfAlgFromString</a>( algOpts, fg );

    <span class="comment">// Initialize inference algorithm</span>
    cout &lt;&lt; <span class="stringliteral">"Initializing inference algorithm..."</span> &lt;&lt; endl;
    ia-&gt;<a name="a3"></a><a class="code" href="classdai_1_1InfAlg.html#99dd53d1aaccf09a4b977a49a983cc85" title="Initializes all data structures of the approximate inference algorithm.">init</a>();

    <span class="comment">// Initialize vector for storing the magnetizations</span>
    m = vector&lt;double&gt;( fg.<a name="a4"></a><a class="code" href="classdai_1_1FactorGraph.html#107d707b4ef22d83f19c40989c227d5d" title="Returns number of variables.">nrVars</a>(), 0.0 );

    <span class="comment">// Construct an image that will hold the intermediate single-variable beliefs</span>
    CImg&lt;unsigned char&gt; image( dimx, dimy, 1, 3 );

    <span class="comment">// maxDiff stores the current convergence level</span>
    <span class="keywordtype">double</span> maxDiff = 1.0;
    
    <span class="comment">// Iterate while maximum number of iterations has not been</span>
    <span class="comment">// reached and requested convergence level has not been reached</span>
    cout &lt;&lt; <span class="stringliteral">"Starting inference algorithm..."</span> &lt;&lt; endl;
    <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> iter = 0; iter &lt; maxIter &amp;&amp; maxDiff &gt; tol; iter++ ) {
        <span class="comment">// Set magnetizations to beliefs</span>
        <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i = 0; i &lt; fg.<a class="code" href="classdai_1_1FactorGraph.html#107d707b4ef22d83f19c40989c227d5d" title="Returns number of variables.">nrVars</a>(); i++ )
            m[i] = ia-&gt;<a name="a5"></a><a class="code" href="classdai_1_1InfAlg.html#dcca5c7e5971d946198feb1a7c85db1c" title="Returns the (approximate) marginal probability distribution of the variable with...">beliefV</a>(i)[1] - ia-&gt;<a class="code" href="classdai_1_1InfAlg.html#dcca5c7e5971d946198feb1a7c85db1c" title="Returns the (approximate) marginal probability distribution of the variable with...">beliefV</a>(i)[0];

        <span class="comment">// For each pixel, calculate a color coded magnetization</span>
        <span class="comment">// and store it in the image for visualization</span>
        <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i = 0; i &lt; dimx; i++ )
            <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> j = 0; j &lt; dimy; j++ ) {
                <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> g = (<span class="keywordtype">unsigned</span> char)((m[i*dimy+j] + 1.0) / 2.0 * 255.0);
                <span class="keywordflow">if</span>( g &gt; 127 ) {
                    image(i,j,0) = 255;
                    image(i,j,1) = 2 * (g - 127);
                    image(i,j,2) = 2 * (g - 127);
                } <span class="keywordflow">else</span> {
                    image(i,j,0) = 0;
                    image(i,j,1) = 0;
                    image(i,j,2) = 2*g;
                }
            }

        <span class="comment">// Display the image with the current beliefs</span>
<span class="preprocessor">#ifndef NEW_CIMG</span>
<span class="preprocessor"></span>        disp &lt;&lt; image;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>        disp = image;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
        <span class="comment">// Perform the requested inference algorithm for only one step</span>
        ia-&gt;<a name="a6"></a><a class="code" href="classdai_1_1InfAlg.html#c48656e5d42a7d288e9ca6d70e264858" title="Sets maximum number of iterations (one iteration passes over the complete factorgraph)...">setMaxIter</a>( iter + 1 );
        maxDiff = ia-&gt;<a name="a7"></a><a class="code" href="classdai_1_1InfAlg.html#4ac173c4d4109fd1e2229dd83532d32f" title="Runs the approximate inference algorithm.">run</a>();

        <span class="comment">// Output progress</span>
        cout &lt;&lt; <span class="stringliteral">"  Iterations = "</span> &lt;&lt; iter &lt;&lt; <span class="stringliteral">", maxDiff = "</span> &lt;&lt; maxDiff &lt;&lt; endl;
    }
    cout &lt;&lt; <span class="stringliteral">"Finished inference algorithm"</span> &lt;&lt; endl;

    <span class="comment">// Clean up inference algorithm</span>
    <span class="keyword">delete</span> ia;

    <span class="comment">// Return reached convergence level</span>
    <span class="keywordflow">return</span> maxDiff;
}



<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc,<span class="keywordtype">char</span> **argv) {
    cout &lt;&lt; <span class="stringliteral">"This program is part of libDAI - http://www.libdai.org/"</span> &lt;&lt; endl;
    cout &lt;&lt; <span class="stringliteral">"(Use the option -h for getting help with the command line arguments.)"</span> &lt;&lt; endl;
    <span class="comment">// Display program usage, when invoked from the command line with option '-h'</span>
    cimg_usage( <span class="stringliteral">"This example shows how libDAI can be used for a simple image segmentation task"</span> );
    <span class="comment">// Get command line arguments</span>
    <span class="keyword">const</span> <span class="keywordtype">char</span>* file_i1 = cimg_option( <span class="stringliteral">"-i1"</span>, <span class="stringliteral">"example_img_in1.jpg"</span>, <span class="stringliteral">"Input image 1"</span> );
    <span class="keyword">const</span> <span class="keywordtype">char</span>* file_i2 = cimg_option( <span class="stringliteral">"-i2"</span>, <span class="stringliteral">"example_img_in2.jpg"</span>, <span class="stringliteral">"Input image 2"</span> );
    <span class="keyword">const</span> <span class="keywordtype">char</span>* file_o1 = cimg_option( <span class="stringliteral">"-o1"</span>, <span class="stringliteral">"example_img_out1.jpg"</span>, <span class="stringliteral">"Output image (local evidence)"</span> );
    <span class="keyword">const</span> <span class="keywordtype">char</span>* file_o2 = cimg_option( <span class="stringliteral">"-o2"</span>, <span class="stringliteral">"example_img_out2.jpg"</span>, <span class="stringliteral">"Output image (magnetizations)"</span> );
    <span class="keyword">const</span> <span class="keywordtype">double</span> J = cimg_option( <span class="stringliteral">"-J"</span>, 2.4, <span class="stringliteral">"Pairwise interaction strength (i.e., smoothing strength)"</span> );
    <span class="keyword">const</span> <span class="keywordtype">double</span> th_min = cimg_option( <span class="stringliteral">"-thmin"</span>, -3.0, <span class="stringliteral">"Local evidence strength of background"</span> );
    <span class="keyword">const</span> <span class="keywordtype">double</span> th_max = cimg_option( <span class="stringliteral">"-thmax"</span>, 3.2, <span class="stringliteral">"Local evidence strength of foreground"</span> );
    <span class="keyword">const</span> <span class="keywordtype">double</span> scale = cimg_option( <span class="stringliteral">"-scale"</span>, 40.0, <span class="stringliteral">"Typical difference in pixel values between fore- and background"</span> );
    <span class="keyword">const</span> <span class="keywordtype">double</span> pbg = cimg_option( <span class="stringliteral">"-pbg"</span>, 90.0, <span class="stringliteral">"Percentage of background in image"</span> );
    <span class="keyword">const</span> <span class="keywordtype">char</span> *infname = cimg_option( <span class="stringliteral">"-method"</span>, <span class="stringliteral">"BP[updates=SEQMAX,maxiter=1,tol=1e-9,logdomain=0]"</span>, <span class="stringliteral">"Inference method in format name[key1=val1,...,keyn=valn]"</span> );
    <span class="keyword">const</span> <span class="keywordtype">size_t</span> maxiter = cimg_option( <span class="stringliteral">"-maxiter"</span>, 100, <span class="stringliteral">"Maximum number of iterations for inference method"</span> );
    <span class="keyword">const</span> <span class="keywordtype">double</span> tol = cimg_option( <span class="stringliteral">"-tol"</span>, 1e-9, <span class="stringliteral">"Desired tolerance level for inference method"</span> );
    <span class="keyword">const</span> <span class="keywordtype">char</span> *file_fg = cimg_option( <span class="stringliteral">"-fg"</span>, <span class="stringliteral">""</span>, <span class="stringliteral">"Output factor graph"</span> );

    <span class="comment">// Read input images</span>
    cout &lt;&lt; endl;
    cout &lt;&lt; <span class="stringliteral">"Reading input image 1 ("</span> &lt;&lt; file_i1 &lt;&lt; <span class="stringliteral">")..."</span> &lt;&lt; endl;
    CImg&lt;unsigned char&gt; image1 = CImg&lt;&gt;( file_i1 );
    cout &lt;&lt; <span class="stringliteral">"Reading input image 2 ("</span> &lt;&lt; file_i2 &lt;&lt; <span class="stringliteral">")..."</span> &lt;&lt; endl;
    CImg&lt;unsigned char&gt; image2 = CImg&lt;&gt;( file_i2 );

    <span class="comment">// Check image sizes</span>
<span class="preprocessor">#ifndef NEW_CIMG</span>
<span class="preprocessor"></span>    <span class="keywordflow">if</span>( (image1.width != image2.width) || (image1.height != image2.height) )
        cerr &lt;&lt; <span class="stringliteral">"Error: input images should have same size."</span> &lt;&lt; endl;
    <span class="keywordtype">size_t</span> dimx = image1.width;
    <span class="keywordtype">size_t</span> dimy = image1.height;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>    <span class="keywordflow">if</span>( (image1.width() != image2.width()) || (image1.height() != image2.height()) )
        cerr &lt;&lt; <span class="stringliteral">"Error: input images should have same size."</span> &lt;&lt; endl;
    <span class="keywordtype">size_t</span> dimx = image1.width();
    <span class="keywordtype">size_t</span> dimy = image1.height();
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
    <span class="comment">// Display input images</span>
    cout &lt;&lt; <span class="stringliteral">"Displaying input image 1..."</span> &lt;&lt; endl;
    CImgDisplay disp1( image1, <span class="stringliteral">"Input image 1"</span>, 0 );
    cout &lt;&lt; <span class="stringliteral">"Displaying input image 2..."</span> &lt;&lt; endl;
    CImgDisplay disp2( image2, <span class="stringliteral">"Input image 2"</span>, 0 );

    <span class="comment">// Construct absolute difference image</span>
    cout &lt;&lt; <span class="stringliteral">"Constructing difference image..."</span> &lt;&lt; endl;
    CImg&lt;int&gt; image3( image1 );
    image3 -= image2;
    image3.abs();
    <span class="comment">// Normalize difference image</span>
    image3.norm( 1 ); <span class="comment">// 1 = L1, 2 = L2, -1 = Linf</span>

    <span class="comment">// Normalize the difference by the average value of the background image</span>
    <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i = 0; i &lt; dimx; i++ ) {
        <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> j = 0; j &lt; dimy; j++ ) {
            <span class="keywordtype">int</span> avg = 0;
<span class="preprocessor">#ifndef NEW_CIMG</span>
<span class="preprocessor"></span>            <span class="keywordflow">for</span>( <span class="keywordtype">int</span> c = 0; c &lt; image1.dimv(); c++ )
                avg += image1( i, j, c );
            avg /= image1.dimv();
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>            <span class="keywordflow">for</span>( <span class="keywordtype">int</span> c = 0; c &lt; image1.spectrum(); c++ )
                avg += image1( i, j, c );
            avg /= image1.spectrum();
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>            image3( i, j, 0 ) /= (1.0 + avg / 255.0);
        }
    }
    image3.normalize( 0, 255 );

    <span class="comment">// Display difference image</span>
    cout &lt;&lt; <span class="stringliteral">"Displaying difference image..."</span> &lt;&lt; endl;
    CImgDisplay disp3( image3, <span class="stringliteral">"Relative difference of both inputs"</span>, 0 );

    <span class="comment">// Convert difference image into a factor graph and store</span>
    <span class="comment">// the local evidence in image4 for visualization</span>
    CImg&lt;unsigned char&gt; image4( dimx, dimy, 1, 3 );
    cout &lt;&lt; <span class="stringliteral">"Converting difference image into factor graph..."</span> &lt;&lt; endl;
    <a class="code" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a> fg = img2fg( image3, J, th_min, th_max, scale, pbg, image4 );

    <span class="comment">// Display local evidence</span>
    cout &lt;&lt; <span class="stringliteral">"Displaying local evidence..."</span> &lt;&lt; endl;
    CImgDisplay disp4( image4, <span class="stringliteral">"Local evidence"</span>, 0 );
    cout &lt;&lt; <span class="stringliteral">"Saving local evidence as JPEG in "</span> &lt;&lt; file_o1 &lt;&lt; endl;
    image4.save_jpeg( file_o1, 100 );
    <span class="keywordflow">if</span>( strlen( file_fg ) &gt; 0 ) {
        cout &lt;&lt; <span class="stringliteral">"Saving factor graph as "</span> &lt;&lt; file_fg &lt;&lt; endl;
        fg.<a name="a8"></a><a class="code" href="classdai_1_1FactorGraph.html#5d574f5c52f67cb24971650562588f2e" title="Writes a factor graph to a file.">WriteToFile</a>( file_fg );
    }

    <span class="comment">// Solve the inference problem and visualize intermediate steps</span>
    CImgDisplay disp5( dimx, dimy, <span class="stringliteral">"Beliefs during inference"</span>, 0 );
    vector&lt;double&gt; m; <span class="comment">// Stores the final magnetizations</span>
    cout &lt;&lt; <span class="stringliteral">"Solving the inference problem...please be patient!"</span> &lt;&lt; endl;
    doInference( fg, infname, maxiter, tol, m, dimx, dimy, disp5 );

    <span class="comment">// Visualize the final magnetizations</span>
    <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i = 0; i &lt; dimx; i++ )
        <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> j = 0; j &lt; dimy; j++ ) {
            <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> g = (<span class="keywordtype">unsigned</span> char)((m[i*dimy+j] + 1.0) / 2.0 * 255.0);
            <span class="keywordflow">if</span>( g &gt; 127 ) {
                image4(i,j,0) = image2(i,j,0);
                image4(i,j,1) = image2(i,j,1);
                image4(i,j,2) = image2(i,j,2);
            } <span class="keywordflow">else</span>
<span class="preprocessor">#ifndef NEW_CIMG</span>
<span class="preprocessor"></span>                <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> c = 0; c &lt; (size_t)image4.dimv(); c++ )
                    image4(i,j,c) = 255;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>                <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> c = 0; c &lt; (size_t)image4.spectrum(); c++ )
                    image4(i,j,c) = 255;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>        }
    cout &lt;&lt; <span class="stringliteral">"Displaying the final result of the segmentation problem..."</span> &lt;&lt; endl;
    CImgDisplay main_disp( image4, <span class="stringliteral">"Foreground/background segmentation result"</span>, 0 );

    cout &lt;&lt; <span class="stringliteral">"Saving the final result of the segmentation problem as JPEG in "</span> &lt;&lt; file_o2 &lt;&lt; endl;
    image4.save_jpeg( file_o2, 100 );

    cout &lt;&lt; <span class="stringliteral">"Close the last image display in order to finish."</span> &lt;&lt; endl;
<span class="preprocessor">#ifndef NEW_CIMG</span>
<span class="preprocessor"></span>    <span class="keywordflow">while</span>( !main_disp.is_closed )
        cimg::wait( 40 );
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>    <span class="keywordflow">while</span>( !main_disp.is_closed() )
        cimg::wait( 40 );
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
    <span class="keywordflow">return</span> 0;
}
</pre></div> </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Aug 19 13:58:09 2010 for libDAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
