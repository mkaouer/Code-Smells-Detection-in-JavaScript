<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>libDAI: example_permute.cpp</title>
<link href="customdoxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>example_permute.cpp</h1>This example shows how to use the Permute, multifor and State classes.<h2><a class="anchor" name="Output">
Output</a></h2>
<div class="fragment"><pre class="fragment">V = (x1, x2, x0)
X = {x0, x1, x2}
Note that the ordering of the variables in X is the canonical ordering
(ascendingly according to their labels) but the ordering in V is different.

The permutation between both variable orderings is sigma = (2, 0, 1), or more verbosely:
  sigma[0] = 2
  sigma[1] = 0
  sigma[2] = 1
This means that variable V[sigma[n]] should correspond with the n'th variable in X (for n=0,...,2)...OK. 

The states of the variables x0,x1,x2 are, according to the ordering in V:
SV:  x0:  x1:  x2:
 0    0    0    0
 1    0    1    0
 2    0    2    0
 3    0    0    1
 4    0    1    1
 5    0    2    1
 6    1    0    0
 7    1    1    0
 8    1    2    0
 9    1    0    1
10    1    1    1
11    1    2    1

The states of the variables x0,x1,x2 are, according to the canonical ordering in X:
SX:  x0:  x1:  x2:
 0    0    0    0
 1    1    0    0
 2    0    1    0
 3    1    1    0
 4    0    2    0
 5    1    2    0
 6    0    0    1
 7    1    0    1
 8    0    1    1
 9    1    1    1
10    0    2    1
11    1    2    1

The permutation sigma induces the following permutation of linear indices of joint states:
SV:  SX:
 0    0
 1    2
 2    4
 3    6
 4    8
 5   10
 6    1
 7    3
 8    5
 9    7
10    9
11   11
</pre></div><h2><a class="anchor" name="Source">
Source</a></h2>
<div class="fragment"><pre class="fragment"><span class="comment">/*  This file is part of libDAI - http://www.libdai.org/</span>
<span class="comment"> *</span>
<span class="comment"> *  libDAI is licensed under the terms of the GNU General Public License version</span>
<span class="comment"> *  2, or (at your option) any later version. libDAI is distributed without any</span>
<span class="comment"> *  warranty. See the file COPYING for more details.</span>
<span class="comment"> *</span>
<span class="comment"> *  Copyright (C) 2008-2009  Joris Mooij  [joris dot mooij at libdai dot org]</span>
<span class="comment"> */</span>


<span class="preprocessor">#include &lt;<a class="code" href="varset_8h.html" title="Defines the VarSet class, which represents a set of random variables.">dai/varset.h</a>&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="index_8h.html" title="Defines the IndexFor, multifor, Permute and State classes, which all deal with indexing...">dai/index.h</a>&gt;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;iomanip&gt;</span>

<span class="keyword">using namespace </span>std;
<span class="keyword">using namespace </span>dai;

<span class="keywordtype">int</span> main() {
    <a name="_a0"></a><a class="code" href="classdai_1_1Var.html" title="Represents a discrete random variable.">Var</a> x0(0, 2);   <span class="comment">// Define binary  variable x0 (with label 0)</span>
    <a class="code" href="classdai_1_1Var.html" title="Represents a discrete random variable.">Var</a> x1(1, 3);   <span class="comment">// Define ternary variable x1 (with label 1)</span>
    <a class="code" href="classdai_1_1Var.html" title="Represents a discrete random variable.">Var</a> x2(2, 2);   <span class="comment">// Define binary  variable x2 (with label 2)</span>

    <span class="comment">// Define vector V = (x1, x2, x0)</span>
    vector&lt;Var&gt; V;      <span class="comment">// Define a vector of variables</span>
    V.push_back( x1 );  <span class="comment">// V[0] = x1;</span>
    V.push_back( x2 );  <span class="comment">// V[1] = x2;</span>
    V.push_back( x0 );  <span class="comment">// V[2] = x0;</span>
    cout &lt;&lt; <span class="stringliteral">"V = "</span> &lt;&lt; V &lt;&lt; endl; <span class="comment">// Note that the elements of X are not necessarily ordered according to their labels</span>

    <span class="comment">// Define set X = {x0, x1, x2}</span>
    <a name="_a1"></a><a class="code" href="classdai_1_1VarSet.html" title="Represents a set of variables.">VarSet</a> X; <span class="comment">// empty</span>
    X |= x2;  <span class="comment">// X = {x2}</span>
    X |= x0;  <span class="comment">// X = {x0, x2}</span>
    X |= x1;  <span class="comment">// X = {x0, x1, x2}</span>
    cout &lt;&lt; <span class="stringliteral">"X = "</span> &lt;&lt; X &lt;&lt; endl; <span class="comment">// Note that the elements of X are ordered according to their labels</span>

    cout &lt;&lt; <span class="stringliteral">"Note that the ordering of the variables in X is the canonical ordering"</span> &lt;&lt; endl;
    cout &lt;&lt; <span class="stringliteral">"(ascendingly according to their labels) but the ordering in V is different."</span> &lt;&lt; endl &lt;&lt; endl;

    <span class="comment">// N = number of variables in V (and X)</span>
    <span class="keywordtype">size_t</span> N = V.<a name="a2"></a><a class="code" href="classdai_1_1SmallSet.html#2fed6380b436090e0b7c6c260c82c49d" title="Returns number of elements.">size</a>();

    <span class="comment">// Define a Permute object based on the variables in V</span>
    <a name="_a3"></a><a class="code" href="classdai_1_1Permute.html" title="Tool for calculating permutations of linear indices of multi-dimensional arrays.">Permute</a> sigma(V);
    <span class="comment">// Each Var in V corresponds with a dimension in a multi-dimensional array.</span>
    <span class="comment">// The permutation sigma permutes these dimensions from the canonical ordering</span>
    <span class="comment">// (sorted ascendingly on the label of the variable, i.e., the same ordering as</span>
    <span class="comment">// in X) into the ordering these variables have in V.</span>
    cout &lt;&lt; <span class="stringliteral">"The permutation between both variable orderings is sigma = "</span> &lt;&lt; sigma.<a name="a4"></a><a class="code" href="classdai_1_1Permute.html#6d2529b4d398f79622e0540e91a630c9" title="Returns constant reference to the permutation.">sigma</a>() &lt;&lt; <span class="stringliteral">", or more verbosely:"</span> &lt;&lt; endl;
    <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> n = 0; n &lt; N; n++ )
        cout &lt;&lt; <span class="stringliteral">"  sigma["</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">"] = "</span> &lt;&lt; sigma[n] &lt;&lt; endl;
    cout &lt;&lt; <span class="stringliteral">"This means that variable V[sigma[n]] should correspond with the n'th variable in X (for n=0,...,"</span> &lt;&lt; (N-1) &lt;&lt; <span class="stringliteral">")..."</span>;
    <span class="comment">// Check whether the permutation works as advertised</span>
    VarSet::const_iterator X_n = X.<a name="a5"></a><a class="code" href="classdai_1_1SmallSet.html#3edafa1c2258b97745ba6e7662a529e8" title="Returns iterator that points to the first element.">begin</a>();
    <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> n = 0; n &lt; N; n++, X_n++ )
        <a name="a6"></a><a class="code" href="exceptions_8h.html#f50adc4fad1e07093579e746302bc884" title="Assertion mechanism, similar to the standard assert() macro. It is always active...">DAI_ASSERT</a>( V[sigma[n]] == *X_n );
    cout &lt;&lt; <span class="stringliteral">"OK. "</span> &lt;&lt; endl &lt;&lt; endl;

    <span class="comment">// Iterate over the joint states of the variables, according to the ordering in V</span>
    cout &lt;&lt; <span class="stringliteral">"The states of the variables x0,x1,x2 are, according to the ordering in V:"</span> &lt;&lt; endl;
    cout &lt;&lt; <span class="stringliteral">"SV:  x0:  x1:  x2:"</span> &lt;&lt; endl;
    std::vector&lt;size_t&gt; ranges;
    <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i = 0; i &lt; V.size(); i++ )
        ranges.push_back( V[i].states() );
    <span class="keywordflow">for</span>( <a name="_a7"></a><a class="code" href="classdai_1_1multifor.html" title="multifor makes it easy to perform a dynamic number of nested for loops.">multifor</a> SV(ranges); SV.valid(); ++SV )
        cout &lt;&lt; setw(2) &lt;&lt; (size_t)SV &lt;&lt; <span class="stringliteral">"    "</span> &lt;&lt; SV[sigma[0]] &lt;&lt; <span class="stringliteral">"    "</span> &lt;&lt; SV[sigma[1]] &lt;&lt; <span class="stringliteral">"    "</span> &lt;&lt; SV[sigma[2]] &lt;&lt; endl;
    cout &lt;&lt; endl;

    <span class="comment">// Iterate over the joint states of the variables, according to the canonical ordering in X</span>
    cout &lt;&lt; <span class="stringliteral">"The states of the variables x0,x1,x2 are, according to the canonical ordering in X:"</span> &lt;&lt; endl;
    cout &lt;&lt; <span class="stringliteral">"SX:  x0:  x1:  x2:"</span> &lt;&lt; endl;
    <span class="keywordflow">for</span>( <a name="_a8"></a><a class="code" href="classdai_1_1State.html" title="Makes it easy to iterate over all possible joint states of variables within a VarSet...">State</a> SX(X); SX.valid(); SX++ )
        cout &lt;&lt; setw(2) &lt;&lt; SX &lt;&lt; <span class="stringliteral">"    "</span> &lt;&lt; SX(x0) &lt;&lt; <span class="stringliteral">"    "</span> &lt;&lt; SX(x1) &lt;&lt; <span class="stringliteral">"    "</span> &lt;&lt; SX(x2) &lt;&lt; endl;
    cout &lt;&lt; endl;

    <span class="comment">// The main functionality of the Permute object is to calculate the induced permutation of linear indices of joint states</span>
    cout &lt;&lt; <span class="stringliteral">"The permutation sigma induces the following permutation of linear indices of joint states:"</span> &lt;&lt; endl;
    cout &lt;&lt; <span class="stringliteral">"SV:  SX:"</span> &lt;&lt; endl;
    <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> li = 0; li &lt; X.<a name="a9"></a><a class="code" href="classdai_1_1VarSet.html#7752595481046d4a62a847071e4b6c93" title="Calculates the number of states of this VarSet, which is simply the number of possible...">nrStates</a>(); li++ )
        cout &lt;&lt; setw(2) &lt;&lt; li &lt;&lt; <span class="stringliteral">"   "</span> &lt;&lt; setw(2) &lt;&lt; sigma.<a name="a10"></a><a class="code" href="classdai_1_1Permute.html#2517476f7de616bf6f4e3f053449f52e" title="Calculates a permuted linear index.">convertLinearIndex</a>( li ) &lt;&lt; endl;

    <span class="keywordflow">return</span> 0;
}
</pre></div> </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Aug 19 13:58:09 2010 for libDAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
