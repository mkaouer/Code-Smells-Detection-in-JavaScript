<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>libDAI: uai2010-aie-solver.cpp</title>
<link href="customdoxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>uai2010-aie-solver.cpp</h1>This example contains the full source code of the solver that was one of the winners (the 'libDAI2' solver) in the UAI 2010 Approximate Inference Challenge (see <a href="http://www.cs.huji.ac.il/project/UAI10/">http://www.cs.huji.ac.il/project/UAI10/</a> for more information).<p>
<div class="fragment"><pre class="fragment"><span class="comment">/*  This file is part of libDAI - http://www.libdai.org/</span>
<span class="comment"> *</span>
<span class="comment"> *  libDAI is licensed under the terms of the GNU General Public License version</span>
<span class="comment"> *  2, or (at your option) any later version. libDAI is distributed without any</span>
<span class="comment"> *  warranty. See the file COPYING for more details.</span>
<span class="comment"> *</span>
<span class="comment"> *  Copyright (C) 2008-2010  Joris Mooij  [joris dot mooij at libdai dot org]</span>
<span class="comment"> */</span>


<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="preprocessor">#include &lt;ostream&gt;</span>
<span class="preprocessor">#include &lt;cstdlib&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="alldai_8h.html" title="Main libDAI header file. It #includes all other libDAI headers.">dai/alldai.h</a>&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="io_8h.html" title="Provides functionality for input/output of data structures in various file formats...">dai/io.h</a>&gt;</span>


<span class="keyword">using namespace </span>std;
<span class="keyword">using namespace </span>dai;


<span class="comment">// Type for storing a joint state of all variables</span>
<span class="keyword">typedef</span> std::vector&lt;size_t&gt; stateVec;


<span class="keyword">struct </span>PRbest {
    <a name="a0"></a><a class="code" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf" title="Real number (alias for double, which could be changed to long double if necessary)...">Real</a> value;
    <a class="code" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf" title="Real number (alias for double, which could be changed to long double if necessary)...">Real</a> maxdiff;
    <span class="keywordtype">bool</span> ready;
    PRbest() : value(0.0), maxdiff(INFINITY), ready(<span class="keyword">false</span>) {}
};

<span class="keyword">struct </span>MARbest {
    vector&lt;Factor&gt; beliefs;
    <a class="code" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf" title="Real number (alias for double, which could be changed to long double if necessary)...">Real</a> maxdiff;
    <span class="keywordtype">bool</span> ready;
    MARbest() : beliefs(), maxdiff(INFINITY), ready(false) {}
};

<span class="keyword">struct </span>MPEbest {
    <a class="code" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf" title="Real number (alias for double, which could be changed to long double if necessary)...">Real</a> value;
    stateVec state;
    <span class="keywordtype">bool</span> ready;
    MPEbest() : value(-INFINITY), state(), ready(false) {}
};


<span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[] ) {
    <span class="keywordflow">if</span> ( argc != 5 ) {
        cout &lt;&lt; <span class="stringliteral">"This program is part of libDAI - http://www.libdai.org/"</span> &lt;&lt; endl &lt;&lt; endl;
        cout &lt;&lt; <span class="stringliteral">"It is one of the winning solvers that participated in the"</span> &lt;&lt; endl;
        cout &lt;&lt; <span class="stringliteral">"UAI 2010 Approximate Inference Challenge"</span> &lt;&lt; endl;
        cout &lt;&lt; <span class="stringliteral">"(see http://www.cs.huji.ac.il/project/UAI10/)"</span> &lt;&lt; endl &lt;&lt; endl;
        cout &lt;&lt; <span class="stringliteral">"Usage: "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" &lt;filename.uai&gt; &lt;filename.uai.evid&gt; &lt;seed&gt; &lt;task&gt;"</span> &lt;&lt; endl &lt;&lt; endl;
        <span class="keywordflow">return</span> 1;
    } <span class="keywordflow">else</span> {
        <span class="keywordtype">double</span> starttic = <a class="code" href="namespacedai.html#b27c0799ddef29bb3833477e32c53862" title="Returns wall clock time in seconds.">toc</a>();

        <span class="keywordtype">size_t</span> verbose = 1;    <span class="comment">// verbosity</span>
        <span class="keywordtype">size_t</span> ia_verbose = 0; <span class="comment">// verbosity of inference algorithms</span>
        <span class="keywordtype">bool</span> surgery = <span class="keyword">true</span>;   <span class="comment">// change factor graph structure based on evidence</span>
        <span class="keywordflow">if</span>( verbose )
            cout &lt;&lt; <span class="stringliteral">"Solver:               "</span> &lt;&lt; argv[0] &lt;&lt; endl;

        <span class="comment">// set random seed</span>
        <span class="keywordtype">size_t</span> seed = fromString&lt;size_t&gt;( argv[3] );
        <a class="code" href="namespacedai.html#e699eca7ca4d6e971b54c2b4a95942d4" title="Sets the random seed.">rnd_seed</a>( seed );
        <span class="keywordflow">if</span>( verbose )
            cout &lt;&lt; <span class="stringliteral">"Seed:                 "</span> &lt;&lt; seed &lt;&lt; endl;

        <span class="comment">// check whether the task is valid</span>
        <span class="keywordtype">string</span> task( argv[4] );
        <span class="keywordflow">if</span>( task != <span class="keywordtype">string</span>(<span class="stringliteral">"PR"</span>) &amp;&amp; task != <span class="keywordtype">string</span>(<span class="stringliteral">"MPE"</span>) &amp;&amp; task != <span class="keywordtype">string</span>(<span class="stringliteral">"MAR"</span>) )
            <a name="a1"></a><a class="code" href="exceptions_8h.html#29c0e906e26c7484c268d111c71f79da" title="Macro that simplifies throwing an exception with a user-defined error message.">DAI_THROWE</a>(RUNTIME_ERROR,<span class="stringliteral">"Unknown task"</span>);
        <span class="keywordflow">if</span>( verbose )
            cout &lt;&lt; <span class="stringliteral">"Task:                 "</span> &lt;&lt; task &lt;&lt; endl;

        <span class="comment">// output other command line options</span>
        <span class="keywordflow">if</span>( verbose ) {
            cout &lt;&lt; <span class="stringliteral">"Factorgraph filename: "</span> &lt;&lt; argv[1] &lt;&lt; endl;
            cout &lt;&lt; <span class="stringliteral">"Evidence filename:    "</span> &lt;&lt; argv[2] &lt;&lt; endl;
        }

        <span class="comment">// get time and memory limits</span>
        <span class="keywordtype">char</span> *buf = getenv( <span class="stringliteral">"UAI_TIME"</span> );
        <span class="keywordtype">double</span> UAI_time = INFINITY;
        <span class="keywordflow">if</span>( buf != NULL )
            UAI_time = fromString&lt;double&gt;( buf );
        buf = getenv( <span class="stringliteral">"UAI_MEMORY"</span> );
        <span class="keywordtype">size_t</span> UAI_memory = 0;
        <span class="keywordflow">if</span>( buf != NULL ) {
            UAI_memory = fromString&lt;double&gt;( buf ) * 1024 * 1024 * 1024;
        }
        <span class="keywordflow">if</span>( verbose ) {
            cout &lt;&lt; <span class="stringliteral">"Time limit:           "</span> &lt;&lt; UAI_time &lt;&lt; endl;
            cout &lt;&lt; <span class="stringliteral">"Memory limit:         "</span> &lt;&lt; UAI_memory &lt;&lt; endl;
        }

        <span class="comment">// build output file name</span>
        vector&lt;string&gt; pathComponents = <a class="code" href="namespacedai.html#87303da2767f4906ea37216bdc9278ca" title="Split a string into tokens delimited by one of the characters in delim.">tokenizeString</a>( <span class="keywordtype">string</span>(argv[1]), <span class="keyword">true</span>, <span class="stringliteral">"/"</span> );
        <span class="keywordtype">string</span> outfile = pathComponents.back() + <span class="stringliteral">"."</span> + task;
        <span class="keywordflow">if</span>( verbose )
            cout &lt;&lt; <span class="stringliteral">"Output filename:      "</span> &lt;&lt; outfile &lt;&lt; endl;

        <span class="comment">// open output stream</span>
        ofstream os;
        os.open( outfile.c_str() );
        <span class="keywordflow">if</span>( !os.is_open() )
            <a class="code" href="exceptions_8h.html#29c0e906e26c7484c268d111c71f79da" title="Macro that simplifies throwing an exception with a user-defined error message.">DAI_THROWE</a>(CANNOT_WRITE_FILE,<span class="stringliteral">"Cannot write to file "</span> + outfile);
        <span class="keywordflow">if</span>( verbose )
            cout &lt;&lt; <span class="stringliteral">"Opened output stream"</span> &lt;&lt; endl;

        <span class="comment">// read factor graph</span>
        vector&lt;Var&gt; vars;
        vector&lt;Factor&gt; facs0;
        vector&lt;Permute&gt; permutations;
        <span class="keywordflow">if</span>( verbose )
            cout &lt;&lt; <span class="stringliteral">"Reading factor graph..."</span> &lt;&lt; endl;
        <a class="code" href="namespacedai.html#fbde3d057ec404d5f4f962da46bccced" title="Reads factor graph (as a pair of a variable vector and factor vector) from a file...">ReadUaiAieFactorGraphFile</a>( argv[1], verbose, vars, facs0, permutations );
        <span class="keywordflow">if</span>( verbose )
            cout &lt;&lt; <span class="stringliteral">"Successfully read factor graph"</span> &lt;&lt; endl;

        <span class="comment">// check if it could be a grid</span>
        <span class="keywordtype">bool</span> couldBeGrid = <span class="keyword">true</span>;
        <a name="_a2"></a><a class="code" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a> fg0( facs0.begin(), facs0.end(), vars.begin(), vars.end(), facs0.size(), vars.size() );
        <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i = 0; i &lt; fg0.nrVars(); i++ )
            <span class="keywordflow">if</span>( fg0.delta(i).size() &gt; 4 ) {
                couldBeGrid = <span class="keyword">false</span>;
                <span class="keywordflow">break</span>;
            }
        <span class="keywordflow">if</span>( couldBeGrid )
            <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> I = 0; I &lt; fg0.nrFactors(); I++ )
                <span class="keywordflow">if</span>( fg0.factor(I).vars().size() &gt; 2 ) {
                    couldBeGrid = <span class="keyword">false</span>;
                    <span class="keywordflow">break</span>;
                }
        <span class="keywordflow">if</span>( verbose ) {
            <span class="keywordflow">if</span>( couldBeGrid )
                cout &lt;&lt; <span class="stringliteral">"This could be a grid!"</span> &lt;&lt; endl;
            <span class="keywordflow">else</span>
                cout &lt;&lt; <span class="stringliteral">"This cannot be a grid!"</span> &lt;&lt; endl;
        }

        <span class="comment">// read evidence</span>
        <span class="keywordflow">if</span>( verbose )
            cout &lt;&lt; <span class="stringliteral">"Reading evidence..."</span> &lt;&lt; endl;
        vector&lt;map&lt;size_t,size_t&gt; &gt; evid = <a class="code" href="namespacedai.html#b5cba3982dd0cd9d5fa3a06c05aef8b1" title="Reads evidence (a mapping from observed variable labels to the observed values) from...">ReadUaiAieEvidenceFile</a>( argv[2], verbose );
        <span class="keywordflow">if</span>( verbose )
            cout &lt;&lt; <span class="stringliteral">"Successfully read "</span> &lt;&lt; evid.size() &lt;&lt; <span class="stringliteral">" evidence cases"</span> &lt;&lt; endl;

        <span class="comment">// write output header</span>
        <span class="keywordflow">if</span>( verbose )
            cout &lt;&lt; <span class="stringliteral">"  Writing header to file..."</span> &lt;&lt; endl;
        os &lt;&lt; task &lt;&lt; endl;

        <span class="comment">// construct clamped factor graphs</span>
        <span class="keywordflow">if</span>( verbose )
            cout &lt;&lt; <span class="stringliteral">"Constructing clamped factor graphs..."</span> &lt;&lt; endl;
        vector&lt;FactorGraph&gt; fgs;
        fgs.reserve( evid.size() );
        <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> ev = 0; ev &lt; evid.size(); ev++ ) {
            <span class="keywordflow">if</span>( verbose )
                cout &lt;&lt; <span class="stringliteral">"  Evidence case "</span> &lt;&lt; ev &lt;&lt; <span class="stringliteral">"..."</span> &lt;&lt; endl;
            <span class="comment">// copy vector of factors</span>
            vector&lt;Factor&gt; facs( facs0 );

            <span class="comment">// change factor graph to reflect observed evidence</span>
            <span class="keywordflow">if</span>( verbose )
                cout &lt;&lt; <span class="stringliteral">"    Applying evidence..."</span> &lt;&lt; endl;
            <span class="keywordflow">if</span>( surgery ) {
                <span class="comment">// replace factors with clamped variables with slices</span>
                <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> I = 0; I &lt; facs.size(); I++ ) {
                    <span class="keywordflow">for</span>( map&lt;size_t,size_t&gt;::const_iterator e = evid[ev].begin(); e != evid[ev].end(); e++ ) {
                        <span class="keywordflow">if</span>( facs[I].vars() &gt;&gt; vars[e-&gt;first] ) {
                            <span class="keywordflow">if</span>( verbose &gt;= 2 )
                                cout &lt;&lt; <span class="stringliteral">"      Clamping "</span> &lt;&lt; e-&gt;first &lt;&lt; <span class="stringliteral">" to value "</span> &lt;&lt; e-&gt;second &lt;&lt; <span class="stringliteral">" in factor "</span> &lt;&lt; I &lt;&lt; <span class="stringliteral">" = "</span> &lt;&lt; facs[I].vars() &lt;&lt; endl;
                            facs[I] = facs[I].slice( vars[e-&gt;first], e-&gt;second );
                            <span class="keywordflow">if</span>( verbose &gt;= 2 )
                                cout &lt;&lt; <span class="stringliteral">"      ...remaining vars: "</span> &lt;&lt; facs[I].vars() &lt;&lt; endl;
                        }
                    }
                }
                <span class="comment">// remove empty factors</span>
                <a class="code" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf" title="Real number (alias for double, which could be changed to long double if necessary)...">Real</a> logZcorr = 0.0;
                <span class="keywordflow">for</span>( vector&lt;Factor&gt;::iterator I = facs.begin(); I != facs.end(); )
                    <span class="keywordflow">if</span>( I-&gt;vars().size() == 0 ) {
                        logZcorr += <a name="a3"></a><a class="code" href="namespacedai.html#934491ad55f57c9072271b4a32ea4919" title="Returns logarithm of x.">std::log</a>( (<a class="code" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf" title="Real number (alias for double, which could be changed to long double if necessary)...">Real</a>)(*I)[0] );
                        I = facs.erase( I );
                    } <span class="keywordflow">else</span>
                        I++;
                <span class="comment">// multiply with logZcorr constant</span>
                <span class="keywordflow">if</span>( facs.size() == 0 )
                    facs.push_back( <a name="a4"></a><a class="code" href="namespacedai.html#7515abf9952cd312e95a34ada0670e85" title="Represents a factor with values of type dai::Real.">Factor</a>( <a name="_a5"></a><a class="code" href="classdai_1_1VarSet.html" title="Represents a set of variables.">VarSet</a>(), <a name="a6"></a><a class="code" href="namespacedai.html#c336ffb182b6e6fa3f7df13620aab012" title="Returns exponent of x.">std::exp</a>(logZcorr) ) );
                <span class="keywordflow">else</span>
                    facs.front() *= <a class="code" href="namespacedai.html#c336ffb182b6e6fa3f7df13620aab012" title="Returns exponent of x.">std::exp</a>(logZcorr);
            }
            <span class="comment">// add delta factors corresponding to observed variable values</span>
            <span class="keywordflow">for</span>( map&lt;size_t,size_t&gt;::const_iterator e = evid[ev].begin(); e != evid[ev].end(); e++ )
                facs.push_back( <a class="code" href="namespacedai.html#df624997c47362bc5db95242b76a66a4" title="Returns a Kronecker delta point mass.">createFactorDelta</a>( vars[e-&gt;first], e-&gt;second ) );

            <span class="comment">// construct clamped factor graph</span>
            <span class="keywordflow">if</span>( verbose )
                cout &lt;&lt; <span class="stringliteral">"    Constructing factor graph..."</span> &lt;&lt; endl;
            fgs.push_back( <a class="code" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a>( facs.begin(), facs.end(), vars.begin(), vars.end(), facs.size(), vars.size() ) );
        }

        <span class="comment">// variables for storing best results so far</span>
        vector&lt;PRbest&gt; bestPR( evid.size() );
        vector&lt;MARbest&gt; bestMAR( evid.size() );
        vector&lt;MPEbest&gt; bestMPE( evid.size() );
        <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> ev = 0; ev &lt; evid.size(); ev++ )
            bestMPE[ev].state = stateVec( fgs[ev].nrVars(), 0 );
        vector&lt;size_t&gt; ev2go;
        ev2go.reserve( evid.size() );
        <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> ev = 0; ev &lt; evid.size(); ev++ )
            ev2go.push_back( ev );

        <span class="comment">// solve inference problems</span>
        <span class="keywordflow">if</span>( verbose )
            cout &lt;&lt; <span class="stringliteral">"Solving inference problems..."</span> &lt;&lt; endl;
        <span class="keywordtype">bool</span> first = <span class="keyword">true</span>;
        <span class="keywordtype">size_t</span> nrsolvers = 3;
        vector&lt;size_t&gt; nrsubsolvers( nrsolvers );
        nrsubsolvers[0] = 2;
        nrsubsolvers[1] = 1;
        nrsubsolvers[2] = 1;
        <span class="keywordtype">double</span> MPEdamping = 0.49;
        <span class="comment">// for each (sub)solver</span>
        <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> solver = 0; solver &lt; nrsolvers; solver++ ) {
            <span class="keywordflow">if</span>( verbose )
                cout &lt;&lt; <span class="stringliteral">"  Solver "</span> &lt;&lt; solver &lt;&lt; endl;

            <span class="comment">// for each evidence case</span>
            <span class="keywordtype">size_t</span> subsolver = 0;
            <span class="keywordflow">for</span>( <span class="keywordtype">long</span> _ev = 0; _ev &lt; (long)ev2go.size(); ) {
                <span class="keywordtype">bool</span> improved = <span class="keyword">false</span>;
                <span class="keywordtype">size_t</span> ev = ev2go[_ev];
                <span class="keywordflow">if</span>( verbose )
                    cout &lt;&lt; <span class="stringliteral">"    Evidence case "</span> &lt;&lt; ev &lt;&lt; <span class="stringliteral">", subsolver = "</span> &lt;&lt; subsolver &lt;&lt; <span class="stringliteral">"..."</span> &lt;&lt; endl;

                <span class="comment">// construct inference algorithm on clamped factor graph</span>
                <span class="keywordflow">if</span>( verbose )
                    cout &lt;&lt; <span class="stringliteral">"      Constructing inference algorithm..."</span> &lt;&lt; endl;
                <a name="_a7"></a><a class="code" href="classdai_1_1InfAlg.html" title="InfAlg is an abstract base class, defining the common interface of all inference...">InfAlg</a> *ia = NULL;
                <span class="keywordtype">double</span> tic = <a class="code" href="namespacedai.html#b27c0799ddef29bb3833477e32c53862" title="Returns wall clock time in seconds.">toc</a>();
                <span class="keywordtype">bool</span> failed = <span class="keyword">false</span>;
                <span class="keywordflow">try</span> {
                    <span class="comment">// construct</span>
                    <span class="keywordflow">if</span>( solver == 0 ) { <span class="comment">// the quick one</span>
                        <span class="keywordtype">double</span> remtime = (UAI_time - (<a class="code" href="namespacedai.html#b27c0799ddef29bb3833477e32c53862" title="Returns wall clock time in seconds.">toc</a>() - starttic)) * 0.9;
                        <span class="keywordflow">if</span>( remtime &lt; 1.0 )
                            remtime = 1.0 ;
                        <span class="keywordtype">double</span> maxtime = remtime / (ev2go.size() - _ev);
                        <span class="keywordflow">if</span>( verbose ) {
                            cout &lt;&lt; <span class="stringliteral">"      Past time:     "</span> &lt;&lt; (<a class="code" href="namespacedai.html#b27c0799ddef29bb3833477e32c53862" title="Returns wall clock time in seconds.">toc</a>() - starttic) &lt;&lt; endl;
                            cout &lt;&lt; <span class="stringliteral">"      Remaining time:"</span> &lt;&lt; remtime &lt;&lt; endl;
                            cout &lt;&lt; <span class="stringliteral">"      Allotted time: "</span> &lt;&lt; maxtime &lt;&lt; endl;
                        }
                        <span class="keywordtype">string</span> maxtimestr;
                        <span class="keywordflow">if</span>( maxtime != INFINITY )
                            maxtimestr = <span class="stringliteral">",maxtime="</span> + <a name="a8"></a><a class="code" href="namespacedai.html#039689f5b5f4a2f34479fd1a8fd21b8a" title="Converts a variable of type T to a std::string by using a boost::lexical_cast.">toString</a>(maxtime);
                        <span class="comment">// quick and dirty...</span>
                        <span class="keywordflow">if</span>( task == <span class="stringliteral">"MPE"</span> )
                            ia = <a class="code" href="namespacedai.html#246c23914fee45f8b7f01f9073bdd6fe" title="Constructs a new inference algorithm.">newInfAlgFromString</a>( <span class="stringliteral">"BP[inference=MAXPROD,updates=SEQRND,logdomain="</span> + <a class="code" href="namespacedai.html#039689f5b5f4a2f34479fd1a8fd21b8a" title="Converts a variable of type T to a std::string by using a boost::lexical_cast.">toString</a>(subsolver) + <span class="stringliteral">",tol=1e-9,maxiter=10000"</span> + maxtimestr + <span class="stringliteral">",damping=0.1,verbose="</span> + <a class="code" href="namespacedai.html#039689f5b5f4a2f34479fd1a8fd21b8a" title="Converts a variable of type T to a std::string by using a boost::lexical_cast.">toString</a>(ia_verbose) + <span class="stringliteral">"]"</span>, fgs[ev] );
                        <span class="keywordflow">else</span> {
                            <span class="keywordflow">if</span>( couldBeGrid )
                                ia = <a class="code" href="namespacedai.html#246c23914fee45f8b7f01f9073bdd6fe" title="Constructs a new inference algorithm.">newInfAlgFromString</a>( <span class="stringliteral">"HAK[doubleloop=1,clusters=LOOP,init=UNIFORM,loopdepth=4,tol=1e-9,maxiter=10000"</span> + maxtimestr + <span class="stringliteral">",verbose="</span> + <a class="code" href="namespacedai.html#039689f5b5f4a2f34479fd1a8fd21b8a" title="Converts a variable of type T to a std::string by using a boost::lexical_cast.">toString</a>(ia_verbose) + <span class="stringliteral">"]"</span>, fgs[ev] );
                            <span class="keywordflow">else</span>
                                ia = <a class="code" href="namespacedai.html#246c23914fee45f8b7f01f9073bdd6fe" title="Constructs a new inference algorithm.">newInfAlgFromString</a>( <span class="stringliteral">"BP[inference=SUMPROD,updates=SEQRND,logdomain="</span> + <a class="code" href="namespacedai.html#039689f5b5f4a2f34479fd1a8fd21b8a" title="Converts a variable of type T to a std::string by using a boost::lexical_cast.">toString</a>(subsolver) + <span class="stringliteral">",tol=1e-9,maxiter=10000"</span> + maxtimestr + <span class="stringliteral">",damping=0.0,verbose="</span> + <a class="code" href="namespacedai.html#039689f5b5f4a2f34479fd1a8fd21b8a" title="Converts a variable of type T to a std::string by using a boost::lexical_cast.">toString</a>(ia_verbose) + <span class="stringliteral">"]"</span>, fgs[ev] );
                        }
                    } <span class="keywordflow">else</span> <span class="keywordflow">if</span>( solver == 1 ) { <span class="comment">// the exact one</span>
                        <span class="keywordtype">string</span> maxmemstr;
                        <span class="keywordflow">if</span>( UAI_memory != 0 )
                            maxmemstr = <span class="stringliteral">",maxmem="</span> + <a class="code" href="namespacedai.html#039689f5b5f4a2f34479fd1a8fd21b8a" title="Converts a variable of type T to a std::string by using a boost::lexical_cast.">toString</a>(UAI_memory);
                        <span class="keywordflow">if</span>( task == <span class="stringliteral">"MPE"</span> )
                            ia = <a class="code" href="namespacedai.html#246c23914fee45f8b7f01f9073bdd6fe" title="Constructs a new inference algorithm.">newInfAlgFromString</a>( <span class="stringliteral">"JTREE[inference=MAXPROD,updates=HUGIN"</span> + maxmemstr + <span class="stringliteral">",verbose="</span> + <a class="code" href="namespacedai.html#039689f5b5f4a2f34479fd1a8fd21b8a" title="Converts a variable of type T to a std::string by using a boost::lexical_cast.">toString</a>(ia_verbose) + <span class="stringliteral">"]"</span>, fgs[ev] );
                        <span class="keywordflow">else</span>
                            ia = <a class="code" href="namespacedai.html#246c23914fee45f8b7f01f9073bdd6fe" title="Constructs a new inference algorithm.">newInfAlgFromString</a>( <span class="stringliteral">"JTREE[inference=SUMPROD,updates=HUGIN"</span> + maxmemstr + <span class="stringliteral">",verbose="</span> + <a class="code" href="namespacedai.html#039689f5b5f4a2f34479fd1a8fd21b8a" title="Converts a variable of type T to a std::string by using a boost::lexical_cast.">toString</a>(ia_verbose) + <span class="stringliteral">"]"</span>, fgs[ev] );
                    } <span class="keywordflow">else</span> <span class="keywordflow">if</span>( solver == 2 ) { <span class="comment">// the decent one</span>
                        <span class="keywordtype">double</span> remtime = (UAI_time - (<a class="code" href="namespacedai.html#b27c0799ddef29bb3833477e32c53862" title="Returns wall clock time in seconds.">toc</a>() - starttic));
                        <span class="keywordflow">if</span>( remtime &lt; 1.0 )
                            remtime = 1.0;
                        <span class="keywordtype">double</span> maxtime = 0.95 * remtime / (ev2go.size() - _ev);
                        <span class="keywordflow">if</span>( verbose ) {
                            cout &lt;&lt; <span class="stringliteral">"      Past time:     "</span> &lt;&lt; (<a class="code" href="namespacedai.html#b27c0799ddef29bb3833477e32c53862" title="Returns wall clock time in seconds.">toc</a>() - starttic) &lt;&lt; endl;
                            cout &lt;&lt; <span class="stringliteral">"      Remaining time:"</span> &lt;&lt; remtime &lt;&lt; endl;
                            cout &lt;&lt; <span class="stringliteral">"      Allotted time: "</span> &lt;&lt; maxtime &lt;&lt; endl;
                        }
                        <span class="keywordflow">if</span>( task == <span class="stringliteral">"MPE"</span> )
                            maxtime /= fgs[ev].nrVars();
                        <span class="keywordtype">string</span> maxtimestr;
                        <span class="keywordflow">if</span>( maxtime != INFINITY )
                            maxtimestr = <span class="stringliteral">",maxtime="</span> + <a class="code" href="namespacedai.html#039689f5b5f4a2f34479fd1a8fd21b8a" title="Converts a variable of type T to a std::string by using a boost::lexical_cast.">toString</a>(maxtime);
                        <span class="keywordflow">if</span>( task == <span class="stringliteral">"MPE"</span> )
                            ia = <a class="code" href="namespacedai.html#246c23914fee45f8b7f01f9073bdd6fe" title="Constructs a new inference algorithm.">newInfAlgFromString</a>( <span class="stringliteral">"DECMAP[ianame=BP,iaopts=[inference=MAXPROD,updates=SEQRND,logdomain=1,tol=1e-9,maxiter=10000"</span> + maxtimestr + <span class="stringliteral">",damping="</span> + <a class="code" href="namespacedai.html#039689f5b5f4a2f34479fd1a8fd21b8a" title="Converts a variable of type T to a std::string by using a boost::lexical_cast.">toString</a>(MPEdamping) + <span class="stringliteral">",verbose=0],reinit=1,verbose="</span> + <a class="code" href="namespacedai.html#039689f5b5f4a2f34479fd1a8fd21b8a" title="Converts a variable of type T to a std::string by using a boost::lexical_cast.">toString</a>(ia_verbose) + <span class="stringliteral">"]"</span>, fgs[ev] );
                        <span class="keywordflow">else</span> {
                            <span class="keywordflow">if</span>( couldBeGrid )
                                ia = <a class="code" href="namespacedai.html#246c23914fee45f8b7f01f9073bdd6fe" title="Constructs a new inference algorithm.">newInfAlgFromString</a>( <span class="stringliteral">"HAK[doubleloop=1,clusters=LOOP,init=UNIFORM,loopdepth=4,tol=1e-9"</span> + maxtimestr + <span class="stringliteral">",maxiter=100000,verbose="</span> + <a class="code" href="namespacedai.html#039689f5b5f4a2f34479fd1a8fd21b8a" title="Converts a variable of type T to a std::string by using a boost::lexical_cast.">toString</a>(ia_verbose) + <span class="stringliteral">"]"</span>, fgs[ev] );
                            <span class="keywordflow">else</span> {
                                <span class="keywordflow">if</span>( task == <span class="stringliteral">"PR"</span> )
                                    ia = <a class="code" href="namespacedai.html#246c23914fee45f8b7f01f9073bdd6fe" title="Constructs a new inference algorithm.">newInfAlgFromString</a>( <span class="stringliteral">"HAK[doubleloop=1,clusters=MIN,init=UNIFORM,tol=1e-9"</span> + maxtimestr + <span class="stringliteral">",maxiter=100000,verbose="</span> + <a class="code" href="namespacedai.html#039689f5b5f4a2f34479fd1a8fd21b8a" title="Converts a variable of type T to a std::string by using a boost::lexical_cast.">toString</a>(ia_verbose) + <span class="stringliteral">"]"</span>, fgs[ev] );
                                <span class="keywordflow">else</span>
                                    ia = <a class="code" href="namespacedai.html#246c23914fee45f8b7f01f9073bdd6fe" title="Constructs a new inference algorithm.">newInfAlgFromString</a>( <span class="stringliteral">"GIBBS[maxiter=1000000000,burnin=1000,restart=10000000"</span> + maxtimestr + <span class="stringliteral">",verbose="</span> + <a class="code" href="namespacedai.html#039689f5b5f4a2f34479fd1a8fd21b8a" title="Converts a variable of type T to a std::string by using a boost::lexical_cast.">toString</a>(ia_verbose) + <span class="stringliteral">"]"</span>, fgs[ev] );
                            }
                        }
                    }

                    <span class="comment">// initialize</span>
                    <span class="keywordflow">if</span>( verbose )
                        cout &lt;&lt; <span class="stringliteral">"      Initializing inference algorithm..."</span> &lt;&lt; endl;
                    ia-&gt;<a name="a9"></a><a class="code" href="classdai_1_1InfAlg.html#99dd53d1aaccf09a4b977a49a983cc85" title="Initializes all data structures of the approximate inference algorithm.">init</a>();
                    <span class="comment">// run</span>
                    <span class="keywordflow">if</span>( verbose )
                        cout &lt;&lt; <span class="stringliteral">"      Running inference algorithm..."</span> &lt;&lt; endl;
                    ia-&gt;<a name="a10"></a><a class="code" href="classdai_1_1InfAlg.html#4ac173c4d4109fd1e2229dd83532d32f" title="Runs the approximate inference algorithm.">run</a>();
                    <span class="keywordflow">if</span>( verbose )
                        cout &lt;&lt; <span class="stringliteral">"      Inference algorithm finished..."</span> &lt;&lt; endl;
                } <span class="keywordflow">catch</span>( <a name="_a11"></a><a class="code" href="classdai_1_1Exception.html" title="Error handling in libDAI is done by throwing an instance of the Exception class.">Exception</a> &amp;e ) {
                    failed = <span class="keyword">true</span>;
                    <span class="keywordflow">if</span>( verbose ) {
                        cout &lt;&lt; <span class="stringliteral">"      Inference algorithm failed...!"</span> &lt;&lt; endl;
                        cout &lt;&lt; <span class="stringliteral">"      Exception: "</span> &lt;&lt; e.what() &lt;&lt; endl;
                    }
                }

                <span class="keywordflow">if</span>( verbose )
                    cout &lt;&lt; <span class="stringliteral">"      Used time:             "</span> &lt;&lt; <a class="code" href="namespacedai.html#b27c0799ddef29bb3833477e32c53862" title="Returns wall clock time in seconds.">toc</a>() - tic &lt;&lt; endl;
                <span class="keywordflow">if</span>( !failed &amp;&amp; verbose ) {
                    <span class="keywordflow">try</span> {
                        cout &lt;&lt; <span class="stringliteral">"      Number of iterations:  "</span> &lt;&lt; ia-&gt;<a name="a12"></a><a class="code" href="classdai_1_1InfAlg.html#fcad51eed6ad8d6936b50f673458ff1b" title="Returns number of iterations done (one iteration passes over the complete factorgraph)...">Iterations</a>() &lt;&lt; endl;
                    } <span class="keywordflow">catch</span>( <a class="code" href="classdai_1_1Exception.html" title="Error handling in libDAI is done by throwing an instance of the Exception class.">Exception</a> &amp;e ) {
                        cout &lt;&lt; <span class="stringliteral">"      Number of iterations:   N/A"</span> &lt;&lt; endl;
                    }
                    <span class="keywordflow">try</span> {
                        cout &lt;&lt; <span class="stringliteral">"      Final maxdiff:         "</span> &lt;&lt; ia-&gt;<a name="a13"></a><a class="code" href="classdai_1_1InfAlg.html#b0b83b53b76ec3b612d2f6e940374e34" title="Returns maximum difference between single variable beliefs in the last iteration...">maxDiff</a>() &lt;&lt; endl;
                    } <span class="keywordflow">catch</span>( <a class="code" href="classdai_1_1Exception.html" title="Error handling in libDAI is done by throwing an instance of the Exception class.">Exception</a> &amp;e ) {
                        cout &lt;&lt; <span class="stringliteral">"      Final maxdiff:          N/A"</span> &lt;&lt; endl;
                    }
                }

                <span class="comment">// update results for inference task</span>
                <span class="keywordflow">if</span>( !failed ) {
                    <span class="keywordflow">if</span>( task == <span class="stringliteral">"PR"</span> ) {
                        PRbest cur;

                        <span class="comment">// calculate PR value</span>
                        cur.value = ia-&gt;<a name="a14"></a><a class="code" href="classdai_1_1InfAlg.html#40a2353d63c358ebca834d40b0a4fc70" title="Returns the logarithm of the (approximated) partition sum (normalizing constant of...">logZ</a>() / <a class="code" href="namespacedai.html#934491ad55f57c9072271b4a32ea4919" title="Returns logarithm of x.">dai::log</a>((<a class="code" href="namespacedai.html#e7d0472fdc89a8635825d01940e91cbf" title="Real number (alias for double, which could be changed to long double if necessary)...">Real</a>)10.0);

                        <span class="comment">// get maxdiff</span>
                        <span class="keywordflow">try</span> {
                            cur.maxdiff = ia-&gt;<a class="code" href="classdai_1_1InfAlg.html#b0b83b53b76ec3b612d2f6e940374e34" title="Returns maximum difference between single variable beliefs in the last iteration...">maxDiff</a>();
                        } <span class="keywordflow">catch</span>( <a class="code" href="classdai_1_1Exception.html" title="Error handling in libDAI is done by throwing an instance of the Exception class.">Exception</a> &amp;e ) {
                            cur.maxdiff = 1e-9;
                        }

                        <span class="comment">// only update if this run has converged</span>
                        <span class="keywordflow">if</span>( ((cur.maxdiff &lt;= 1e-9) || (cur.maxdiff &lt;= bestPR[ev].maxdiff)) &amp;&amp; !<a name="a15"></a><a class="code" href="namespacedai.html#9886ca4103eac52b3f82698e12e86672" title="Returns true if argument is NAN (Not A Number).">dai::isnan</a>(cur.value) ) {
                            <span class="comment">// if this was exact inference, we are ready</span>
                            <span class="keywordflow">if</span>( solver == 1 ) {
                                ev2go.erase( ev2go.begin() + _ev );
                                _ev--;
                                cur.ready = <span class="keyword">true</span>;
                            }

                            <span class="keywordflow">if</span>( verbose )
                                cout &lt;&lt; <span class="stringliteral">"    Replacing best PR value so far ("</span> &lt;&lt; bestPR[ev].value &lt;&lt; <span class="stringliteral">") with new value "</span> &lt;&lt; cur.value &lt;&lt; endl;
                            bestPR[ev] = cur;
                            improved = <span class="keyword">true</span>;
                        } <span class="keywordflow">else</span> {
                            <span class="keywordflow">if</span>( verbose )
                                cout &lt;&lt; <span class="stringliteral">"    Discarding PR value "</span> &lt;&lt; cur.value &lt;&lt; endl;
                        }
                    } <span class="keywordflow">else</span> <span class="keywordflow">if</span>( task == <span class="stringliteral">"MAR"</span> ) {
                        MARbest cur;

                        <span class="comment">// get variable beliefs</span>
                        <span class="keywordtype">bool</span> hasnans = <span class="keyword">false</span>;
                        cur.beliefs.reserve( fgs[ev].nrVars() );
                        <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i = 0; i &lt; fgs[ev].nrVars(); i++ ) {
                            cur.beliefs.push_back( ia-&gt;<a name="a16"></a><a class="code" href="classdai_1_1InfAlg.html#dcca5c7e5971d946198feb1a7c85db1c" title="Returns the (approximate) marginal probability distribution of the variable with...">beliefV</a>(i) );
                            <span class="keywordflow">if</span>( cur.beliefs.back().hasNaNs() )
                                hasnans = <span class="keyword">true</span>;
                        }

                        <span class="comment">// get maxdiff</span>
                        <span class="keywordflow">try</span> {
                            cur.maxdiff = ia-&gt;<a class="code" href="classdai_1_1InfAlg.html#b0b83b53b76ec3b612d2f6e940374e34" title="Returns maximum difference between single variable beliefs in the last iteration...">maxDiff</a>();
                        } <span class="keywordflow">catch</span>( <a class="code" href="classdai_1_1Exception.html" title="Error handling in libDAI is done by throwing an instance of the Exception class.">Exception</a> &amp;e ) {
                            cur.maxdiff = 1e-9;
                        }

                        <span class="comment">// only update if this run has converged</span>
                        <span class="keywordflow">if</span>( ((cur.maxdiff &lt;= 1e-9) || (cur.maxdiff &lt;= bestMAR[ev].maxdiff)) &amp;&amp; !hasnans ) {
                            <span class="comment">// if this was exact inference, we are ready</span>
                            <span class="keywordflow">if</span>( solver == 1 ) {
                                ev2go.erase( ev2go.begin() + _ev );
                                _ev--;
                                cur.ready = <span class="keyword">true</span>;
                            }

                            <span class="keywordflow">if</span>( verbose )
                                cout &lt;&lt; <span class="stringliteral">"    Replacing best beliefs so far with new beliefs"</span> &lt;&lt; endl;
                            bestMAR[ev] = cur;
                            improved = <span class="keyword">true</span>;
                        } <span class="keywordflow">else</span> {
                            <span class="keywordflow">if</span>( verbose )
                                cout &lt;&lt; <span class="stringliteral">"    Discarding beliefs"</span> &lt;&lt; endl;
                        }
                    } <span class="keywordflow">else</span> <span class="keywordflow">if</span>( task == <span class="stringliteral">"MPE"</span> ) {
                        MPEbest cur;

                        <span class="comment">// calculate MPE state</span>
                        cur.state = ia-&gt;<a name="a17"></a><a class="code" href="classdai_1_1InfAlg.html#4b9ad5f7128b7ce761db85efee392726" title="Calculates the joint state of all variables that has maximum probability.">findMaximum</a>();

                        <span class="comment">// calculate MPE value</span>
                        cur.value = fgs[ev].logScore( cur.state );

                        <span class="comment">// update best MPE state and value</span>
                        <span class="keywordflow">if</span>( cur.value &gt; bestMPE[ev].value &amp;&amp; !<a class="code" href="namespacedai.html#9886ca4103eac52b3f82698e12e86672" title="Returns true if argument is NAN (Not A Number).">dai::isnan</a>(cur.value) ) {
                            <span class="comment">// if this was exact inference, we are ready</span>
                            <span class="keywordflow">if</span>( solver == 1 ) {
                                ev2go.erase( ev2go.begin() + _ev );
                                _ev--;
                                cur.ready = <span class="keyword">true</span>;
                            }

                            <span class="keywordflow">if</span>( verbose )
                                cout &lt;&lt; <span class="stringliteral">"    Replacing best MPE value so far ("</span> &lt;&lt; bestMPE[ev].value &lt;&lt; <span class="stringliteral">") with new value "</span> &lt;&lt; cur.value &lt;&lt; endl;
                            bestMPE[ev] = cur;
                            improved = <span class="keyword">true</span>;
                        } <span class="keywordflow">else</span> {
                            <span class="keywordflow">if</span>( verbose )
                                cout &lt;&lt; <span class="stringliteral">"    New MPE value "</span> &lt;&lt; cur.value &lt;&lt; <span class="stringliteral">" not better than best one so far "</span> &lt;&lt; bestMPE[ev].value &lt;&lt; endl;
                        }
                    }
                }

                <span class="comment">// remove inference algorithm</span>
                <span class="keywordflow">if</span>( verbose )
                    cout &lt;&lt; <span class="stringliteral">"    Cleaning up..."</span> &lt;&lt; endl;
                <span class="keywordflow">if</span>( !failed )
                    <span class="keyword">delete</span> ia;

                <span class="comment">// write current best output to stream</span>
                <span class="keywordflow">if</span>( improved ) {
                    <span class="keywordflow">if</span>( verbose )
                        cout &lt;&lt; <span class="stringliteral">"    Writing output..."</span> &lt;&lt; endl;
                    <span class="keywordflow">if</span>( first )
                        first = <span class="keyword">false</span>;
                    <span class="keywordflow">else</span>
                        os &lt;&lt; <span class="stringliteral">"-BEGIN-"</span> &lt;&lt; endl;
                    os &lt;&lt; evid.size() &lt;&lt; endl;
                    <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> ev = 0; ev &lt; evid.size(); ev++ ) {
                        <span class="keywordflow">if</span>( task == <span class="stringliteral">"PR"</span> ) {
                            <span class="comment">// output probability of evidence</span>
                            os &lt;&lt; bestPR[ev].value &lt;&lt; endl;
                        } <span class="keywordflow">else</span> <span class="keywordflow">if</span>( task == <span class="stringliteral">"MAR"</span> ) {
                            <span class="comment">// output variable marginals</span>
                            os &lt;&lt; bestMAR[ev].<a name="a18"></a><a class="code" href="classdai_1_1InfAlg.html#eac9f6b52ff7a11a1e5ac2c03bbd6eb0" title="Returns all beliefs (approximate marginal probability distributions) calculated by...">beliefs</a>.size() &lt;&lt; <span class="stringliteral">" "</span>;
                            <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i = 0; i &lt; bestMAR[ev].beliefs.size(); i++ ) {
                                os &lt;&lt; bestMAR[ev].beliefs[i].nrStates() &lt;&lt; <span class="stringliteral">" "</span>;
                                <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> s = 0; s &lt; bestMAR[ev].beliefs[i].nrStates(); s++ )
                                    os &lt;&lt; bestMAR[ev].beliefs[i][s] &lt;&lt; <span class="stringliteral">" "</span>;
                            }
                            os &lt;&lt; endl;
                        } <span class="keywordflow">else</span> <span class="keywordflow">if</span>( task == <span class="stringliteral">"MPE"</span> ) {
                            <span class="comment">// output MPE state</span>
                            os &lt;&lt; fgs[ev].nrVars() &lt;&lt; <span class="stringliteral">" "</span>;
                            <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i = 0; i &lt; fgs[ev].nrVars(); i++ )
                                os &lt;&lt; bestMPE[ev].state[i] &lt;&lt; <span class="stringliteral">" "</span>;
                            os &lt;&lt; endl;
                        }
                    }
                    os.flush();
                }

                <span class="keywordflow">if</span>( verbose )
                    cout &lt;&lt; <span class="stringliteral">"    Done..."</span> &lt;&lt; endl;

                <span class="keywordflow">if</span>( !improved )
                    subsolver++;
                <span class="keywordflow">if</span>( improved || subsolver &gt;= nrsubsolvers[solver] || couldBeGrid ) {
                    subsolver = 0;
                    _ev++;
                }
            }

            <span class="keywordflow">if</span>( task == <span class="stringliteral">"MPE"</span> &amp;&amp; solver == 2 &amp;&amp; (<a class="code" href="namespacedai.html#b27c0799ddef29bb3833477e32c53862" title="Returns wall clock time in seconds.">toc</a>() - starttic) &lt; UAI_time &amp;&amp; MPEdamping != 0.0 ) {
                MPEdamping /= 2.0;
                solver--;  <span class="comment">// repeat this one</span>
            }
            <span class="keywordflow">if</span>( ev2go.size() == 0 )
                <span class="keywordflow">break</span>;
        }

        <span class="comment">// close output file</span>
        <span class="keywordflow">if</span>( verbose )
            cout &lt;&lt; <span class="stringliteral">"Closing output file..."</span> &lt;&lt; endl;
        os.close();
        
        <span class="keywordflow">if</span>( verbose )
            cout &lt;&lt; <span class="stringliteral">"Done!"</span> &lt;&lt; endl;
    }

    <span class="keywordflow">return</span> 0;
}
</pre></div> </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Aug 19 13:58:09 2010 for libDAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
