<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libDAI: dai::TProbSp&lt; T, spvector_type &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libDAI
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacedai.html">dai</a></li><li class="navelem"><a class="el" href="classdai_1_1TProbSp.html">TProbSp</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classdai_1_1TProbSp-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">dai::TProbSp&lt; T, spvector_type &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a vector with entries of type <em>T</em>.  
 <a href="classdai_1_1TProbSp.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="probsp_8h_source.html">dai/probsp.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abc9fe6deccea5808517e6dfb76c0c781"><td class="memItemLeft" align="right" valign="top">typedef spvector_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#abc9fe6deccea5808517e6dfb76c0c781">container_type</a></td></tr>
<tr class="memdesc:abc9fe6deccea5808517e6dfb76c0c781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of data structure used for storing the values.  <a href="#abc9fe6deccea5808517e6dfb76c0c781"></a><br/></td></tr>
<tr class="memitem:aa321f3b44dcc45b5e745f786acac3ed0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa321f3b44dcc45b5e745f786acac3ed0"></a>
typedef <a class="el" href="classdai_1_1TProbSp.html">TProbSp</a>&lt; T, spvector_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>this_type</b></td></tr>
<tr class="memitem:aabd97e809c0da7783bab509943d1ee59"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
container_type::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#aabd97e809c0da7783bab509943d1ee59">const_iterator</a></td></tr>
<tr class="memdesc:aabd97e809c0da7783bab509943d1ee59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant iterator over the elements.  <a href="#aabd97e809c0da7783bab509943d1ee59"></a><br/></td></tr>
<tr class="memitem:aca7c3f5a0f7630c2f03c42caf0e0b902"><td class="memItemLeft" align="right" valign="top">typedef container_type::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#aca7c3f5a0f7630c2f03c42caf0e0b902">iterator</a></td></tr>
<tr class="memdesc:aca7c3f5a0f7630c2f03c42caf0e0b902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over the elements.  <a href="#aca7c3f5a0f7630c2f03c42caf0e0b902"></a><br/></td></tr>
<tr class="memitem:a5cedb7c78fe5e7a2e157d4946b12b752"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
container_type::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a5cedb7c78fe5e7a2e157d4946b12b752">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a5cedb7c78fe5e7a2e157d4946b12b752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant reverse iterator over the elements.  <a href="#a5cedb7c78fe5e7a2e157d4946b12b752"></a><br/></td></tr>
<tr class="memitem:a4262c09993fd664db0bdbbececf0a52e"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
container_type::reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a4262c09993fd664db0bdbbececf0a52e">reverse_iterator</a></td></tr>
<tr class="memdesc:a4262c09993fd664db0bdbbececf0a52e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse iterator over the elements.  <a href="#a4262c09993fd664db0bdbbececf0a52e"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acd3a0c243af8d0e88e4dc785f69e38ed"><td class="memTemplParams" colspan="2">template&lt;typename binOp1 , typename binOp2 &gt; </td></tr>
<tr class="memitem:acd3a0c243af8d0e88e4dc785f69e38ed"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#acd3a0c243af8d0e88e4dc785f69e38ed">innerProduct</a> (const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;q, T init, binOp1 binaryOp1, binOp2 binaryOp2) const </td></tr>
<tr class="memdesc:acd3a0c243af8d0e88e4dc785f69e38ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a generalized inner product, similar to std::inner_product.  <a href="#acd3a0c243af8d0e88e4dc785f69e38ed"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and destructors</div></td></tr>
<tr class="memitem:a22e5501492f53a1a6898873a1367ae4c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a22e5501492f53a1a6898873a1367ae4c">TProbSp</a> ()</td></tr>
<tr class="memdesc:a22e5501492f53a1a6898873a1367ae4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor (constructs empty vector)  <a href="#a22e5501492f53a1a6898873a1367ae4c"></a><br/></td></tr>
<tr class="memitem:ad3d1133ddcb5898642c669c575e16912"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#ad3d1133ddcb5898642c669c575e16912">TProbSp</a> (size_t n)</td></tr>
<tr class="memdesc:ad3d1133ddcb5898642c669c575e16912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct uniform probability distribution over <em>n</em> outcomes (i.e., a vector of length <em>n</em> with each entry set to <img class="formulaInl" alt="$1/n$" src="form_76.png"/>)  <a href="#ad3d1133ddcb5898642c669c575e16912"></a><br/></td></tr>
<tr class="memitem:a0c16c8b2f7b35db18de492db58037067"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a0c16c8b2f7b35db18de492db58037067">TProbSp</a> (size_t n, T <a class="el" href="classdai_1_1TProbSp.html#a8a7fe58b7a23b22222a47b03a00801d6">p</a>)</td></tr>
<tr class="memdesc:a0c16c8b2f7b35db18de492db58037067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct vector of length <em>n</em> with each entry set to <em>p</em>.  <a href="#a0c16c8b2f7b35db18de492db58037067"></a><br/></td></tr>
<tr class="memitem:a2e962551c7a6c8a06bc7baf8691e8806"><td class="memTemplParams" colspan="2">template&lt;typename TIterator &gt; </td></tr>
<tr class="memitem:a2e962551c7a6c8a06bc7baf8691e8806"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a2e962551c7a6c8a06bc7baf8691e8806">TProbSp</a> (TIterator <a class="el" href="classdai_1_1TProbSp.html#a602a605f95318abf628a7b18387e606e">begin</a>, TIterator <a class="el" href="classdai_1_1TProbSp.html#a1f058670e888bffc3eb2e408348aac29">end</a>, size_t sizeHint, T <a class="el" href="classdai_1_1TProbSp.html#a8287de52cdc1fcdebaeb96906d64bb3c">def</a>=0)</td></tr>
<tr class="memdesc:a2e962551c7a6c8a06bc7baf8691e8806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct sparse vector from a range.  <a href="#a2e962551c7a6c8a06bc7baf8691e8806"></a><br/></td></tr>
<tr class="memitem:a256cd31f46b0b3bc16a0fa7dccd4be18"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:a256cd31f46b0b3bc16a0fa7dccd4be18"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a256cd31f46b0b3bc16a0fa7dccd4be18">TProbSp</a> (const std::vector&lt; S &gt; &amp;v, T <a class="el" href="classdai_1_1TProbSp.html#a8287de52cdc1fcdebaeb96906d64bb3c">def</a>=0)</td></tr>
<tr class="memdesc:a256cd31f46b0b3bc16a0fa7dccd4be18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct vector from another vector.  <a href="#a256cd31f46b0b3bc16a0fa7dccd4be18"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterator interface</div></td></tr>
<tr class="memitem:a602a605f95318abf628a7b18387e606e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html#aca7c3f5a0f7630c2f03c42caf0e0b902">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a602a605f95318abf628a7b18387e606e">begin</a> ()</td></tr>
<tr class="memdesc:a602a605f95318abf628a7b18387e606e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns iterator that points to the first nondefault element.  <a href="#a602a605f95318abf628a7b18387e606e"></a><br/></td></tr>
<tr class="memitem:ae7c45a694cbb4d7db8348a515cf137c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html#aabd97e809c0da7783bab509943d1ee59">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#ae7c45a694cbb4d7db8348a515cf137c3">begin</a> () const </td></tr>
<tr class="memdesc:ae7c45a694cbb4d7db8348a515cf137c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns constant iterator that points to the first nondefault element.  <a href="#ae7c45a694cbb4d7db8348a515cf137c3"></a><br/></td></tr>
<tr class="memitem:a1f058670e888bffc3eb2e408348aac29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html#aca7c3f5a0f7630c2f03c42caf0e0b902">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a1f058670e888bffc3eb2e408348aac29">end</a> ()</td></tr>
<tr class="memdesc:a1f058670e888bffc3eb2e408348aac29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns iterator that points beyond the last nondefault element.  <a href="#a1f058670e888bffc3eb2e408348aac29"></a><br/></td></tr>
<tr class="memitem:a4a43edf97dabe33c9da1c0e24b9b130a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html#aabd97e809c0da7783bab509943d1ee59">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a4a43edf97dabe33c9da1c0e24b9b130a">end</a> () const </td></tr>
<tr class="memdesc:a4a43edf97dabe33c9da1c0e24b9b130a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns constant iterator that points beyond the last nondefault element.  <a href="#a4a43edf97dabe33c9da1c0e24b9b130a"></a><br/></td></tr>
<tr class="memitem:ac6b5b3f0101cab702e350261a08ed07d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html#a4262c09993fd664db0bdbbececf0a52e">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#ac6b5b3f0101cab702e350261a08ed07d">rbegin</a> ()</td></tr>
<tr class="memdesc:ac6b5b3f0101cab702e350261a08ed07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reverse iterator that points to the last nondefault element.  <a href="#ac6b5b3f0101cab702e350261a08ed07d"></a><br/></td></tr>
<tr class="memitem:a9219b7ba5972d596776720a3590fd730"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html#a5cedb7c78fe5e7a2e157d4946b12b752">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a9219b7ba5972d596776720a3590fd730">rbegin</a> () const </td></tr>
<tr class="memdesc:a9219b7ba5972d596776720a3590fd730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns constant reverse iterator that points to the last nondefault element.  <a href="#a9219b7ba5972d596776720a3590fd730"></a><br/></td></tr>
<tr class="memitem:aed08dd3311314d3b18f015c6671ccf20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html#a4262c09993fd664db0bdbbececf0a52e">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#aed08dd3311314d3b18f015c6671ccf20">rend</a> ()</td></tr>
<tr class="memdesc:aed08dd3311314d3b18f015c6671ccf20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reverse iterator that points beyond the first nondefault element.  <a href="#aed08dd3311314d3b18f015c6671ccf20"></a><br/></td></tr>
<tr class="memitem:a7a4695cf7026f1b7f15ca62f7d62a623"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html#a5cedb7c78fe5e7a2e157d4946b12b752">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a7a4695cf7026f1b7f15ca62f7d62a623">rend</a> () const </td></tr>
<tr class="memdesc:a7a4695cf7026f1b7f15ca62f7d62a623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns constant reverse iterator that points beyond the first nondefault element.  <a href="#a7a4695cf7026f1b7f15ca62f7d62a623"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous operations</div></td></tr>
<tr class="memitem:a59adbeddfd3e855b8edd54dd170b876a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59adbeddfd3e855b8edd54dd170b876a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resize</b> (size_t sz)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Get/set individual entries</div></td></tr>
<tr class="memitem:ade1ce6d6334f6b7fe18e72e751ac35ca"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#ade1ce6d6334f6b7fe18e72e751ac35ca">get</a> (size_t i) const </td></tr>
<tr class="memdesc:ade1ce6d6334f6b7fe18e72e751ac35ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets <em>i</em> 'th entry.  <a href="#ade1ce6d6334f6b7fe18e72e751ac35ca"></a><br/></td></tr>
<tr class="memitem:ab687e2f8190f26a283ed8ae84ce8ea7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#ab687e2f8190f26a283ed8ae84ce8ea7e">set</a> (size_t i, T val)</td></tr>
<tr class="memdesc:ab687e2f8190f26a283ed8ae84ce8ea7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>i</em> 'th entry to <em>val</em>.  <a href="#ab687e2f8190f26a283ed8ae84ce8ea7e"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Queries</div></td></tr>
<tr class="memitem:a8a7fe58b7a23b22222a47b03a00801d6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdai_1_1TProbSp.html#abc9fe6deccea5808517e6dfb76c0c781">container_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a8a7fe58b7a23b22222a47b03a00801d6">p</a> () const </td></tr>
<tr class="memdesc:a8a7fe58b7a23b22222a47b03a00801d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the wrapped container.  <a href="#a8a7fe58b7a23b22222a47b03a00801d6"></a><br/></td></tr>
<tr class="memitem:a6f6c7e105ba41ecb8b130756bc6cb5a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html#abc9fe6deccea5808517e6dfb76c0c781">container_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a6f6c7e105ba41ecb8b130756bc6cb5a4">p</a> ()</td></tr>
<tr class="memdesc:a6f6c7e105ba41ecb8b130756bc6cb5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the wrapped container.  <a href="#a6f6c7e105ba41ecb8b130756bc6cb5a4"></a><br/></td></tr>
<tr class="memitem:a5a7e32f3448b45942e46f318dfe70bfe"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a5a7e32f3448b45942e46f318dfe70bfe">operator[]</a> (size_t i) const </td></tr>
<tr class="memdesc:a5a7e32f3448b45942e46f318dfe70bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the <em>i</em> 'th entry.  <a href="#a5a7e32f3448b45942e46f318dfe70bfe"></a><br/></td></tr>
<tr class="memitem:a74420561593b8243310ca03a45f608df"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a74420561593b8243310ca03a45f608df">size</a> () const </td></tr>
<tr class="memdesc:a74420561593b8243310ca03a45f608df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns length of the vector (i.e., the number of entries)  <a href="#a74420561593b8243310ca03a45f608df"></a><br/></td></tr>
<tr class="memitem:aa595f133e5c591978c779ad1f7805e8f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#aa595f133e5c591978c779ad1f7805e8f">nrDef</a> () const </td></tr>
<tr class="memdesc:aa595f133e5c591978c779ad1f7805e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of default values.  <a href="#aa595f133e5c591978c779ad1f7805e8f"></a><br/></td></tr>
<tr class="memitem:ac0ff0d5bb8316b621220cf4386d48f98"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#ac0ff0d5bb8316b621220cf4386d48f98">nrNonDef</a> () const </td></tr>
<tr class="memdesc:ac0ff0d5bb8316b621220cf4386d48f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of nondefault values.  <a href="#ac0ff0d5bb8316b621220cf4386d48f98"></a><br/></td></tr>
<tr class="memitem:a8287de52cdc1fcdebaeb96906d64bb3c"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a8287de52cdc1fcdebaeb96906d64bb3c">def</a> () const </td></tr>
<tr class="memdesc:a8287de52cdc1fcdebaeb96906d64bb3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns default value.  <a href="#a8287de52cdc1fcdebaeb96906d64bb3c"></a><br/></td></tr>
<tr class="memitem:a8fb92e76bd58abce8c1c8fa6e92e2f77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a8fb92e76bd58abce8c1c8fa6e92e2f77">setDef</a> (T <a class="el" href="classdai_1_1TProbSp.html#a8287de52cdc1fcdebaeb96906d64bb3c">def</a>)</td></tr>
<tr class="memdesc:a8fb92e76bd58abce8c1c8fa6e92e2f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets default value.  <a href="#a8fb92e76bd58abce8c1c8fa6e92e2f77"></a><br/></td></tr>
<tr class="memitem:ad9e362a9188f3e577e1006802fce0143"><td class="memTemplParams" colspan="2">template&lt;typename unOp &gt; </td></tr>
<tr class="memitem:ad9e362a9188f3e577e1006802fce0143"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#ad9e362a9188f3e577e1006802fce0143">accumulateSum</a> (T init, unOp op) const </td></tr>
<tr class="memdesc:ad9e362a9188f3e577e1006802fce0143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate all values (similar to std::accumulate) by summing.  <a href="#ad9e362a9188f3e577e1006802fce0143"></a><br/></td></tr>
<tr class="memitem:ad0de78e389920f8066130822e2114cea"><td class="memTemplParams" colspan="2">template&lt;typename unOp &gt; </td></tr>
<tr class="memitem:ad0de78e389920f8066130822e2114cea"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#ad0de78e389920f8066130822e2114cea">accumulateMax</a> (T init, unOp op, bool minimize) const </td></tr>
<tr class="memdesc:ad0de78e389920f8066130822e2114cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate all values (similar to std::accumulate) by maximization/minimization.  <a href="#ad0de78e389920f8066130822e2114cea"></a><br/></td></tr>
<tr class="memitem:a529a0139485202cfcf0b1cf292381bff"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a529a0139485202cfcf0b1cf292381bff">entropy</a> () const </td></tr>
<tr class="memdesc:a529a0139485202cfcf0b1cf292381bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Shannon entropy of <code>*this</code>, <img class="formulaInl" alt="$-\sum_i p_i \log p_i$" src="form_75.png"/>.  <a href="#a529a0139485202cfcf0b1cf292381bff"></a><br/></td></tr>
<tr class="memitem:ac7d37a119bd7f681b74786200ae284a7"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#ac7d37a119bd7f681b74786200ae284a7">max</a> () const </td></tr>
<tr class="memdesc:ac7d37a119bd7f681b74786200ae284a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns maximum value of all entries.  <a href="#ac7d37a119bd7f681b74786200ae284a7"></a><br/></td></tr>
<tr class="memitem:a05cad8dab5cf00e8c6b3d30a4a1e93d3"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a05cad8dab5cf00e8c6b3d30a4a1e93d3">min</a> () const </td></tr>
<tr class="memdesc:a05cad8dab5cf00e8c6b3d30a4a1e93d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns minimum value of all entries.  <a href="#a05cad8dab5cf00e8c6b3d30a4a1e93d3"></a><br/></td></tr>
<tr class="memitem:acf306d69c898656c3f41113cd7a4e0a2"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#acf306d69c898656c3f41113cd7a4e0a2">sum</a> () const </td></tr>
<tr class="memdesc:acf306d69c898656c3f41113cd7a4e0a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns sum of all entries.  <a href="#acf306d69c898656c3f41113cd7a4e0a2"></a><br/></td></tr>
<tr class="memitem:a5d72aaddbab7c397106d8c57177d5fda"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a5d72aaddbab7c397106d8c57177d5fda">sumAbs</a> () const </td></tr>
<tr class="memdesc:a5d72aaddbab7c397106d8c57177d5fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return sum of absolute value of all entries.  <a href="#a5d72aaddbab7c397106d8c57177d5fda"></a><br/></td></tr>
<tr class="memitem:ac25935142bda54d0e15ca2c02df015d5"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#ac25935142bda54d0e15ca2c02df015d5">maxAbs</a> () const </td></tr>
<tr class="memdesc:ac25935142bda54d0e15ca2c02df015d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns maximum absolute value of all entries.  <a href="#ac25935142bda54d0e15ca2c02df015d5"></a><br/></td></tr>
<tr class="memitem:a167ca35db39f57367f79802691a1ccc4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a167ca35db39f57367f79802691a1ccc4">hasNaNs</a> () const </td></tr>
<tr class="memdesc:a167ca35db39f57367f79802691a1ccc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if one or more entries are NaN.  <a href="#a167ca35db39f57367f79802691a1ccc4"></a><br/></td></tr>
<tr class="memitem:a706ed601ecb12960223e70f722e2f05e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a706ed601ecb12960223e70f722e2f05e">hasNegatives</a> () const </td></tr>
<tr class="memdesc:a706ed601ecb12960223e70f722e2f05e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if one or more entries are negative.  <a href="#a706ed601ecb12960223e70f722e2f05e"></a><br/></td></tr>
<tr class="memitem:a13ff29c2f22cc11eb12461d5b56629eb"><td class="memItemLeft" align="right" valign="top">std::pair&lt; size_t, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a13ff29c2f22cc11eb12461d5b56629eb">argmax</a> () const </td></tr>
<tr class="memdesc:a13ff29c2f22cc11eb12461d5b56629eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair consisting of the index of the maximum value and the maximum value itself.  <a href="#a13ff29c2f22cc11eb12461d5b56629eb"></a><br/></td></tr>
<tr class="memitem:a02458d75e5932d9852d282969180c19d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a02458d75e5932d9852d282969180c19d">draw</a> ()</td></tr>
<tr class="memdesc:a02458d75e5932d9852d282969180c19d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random index, according to the (normalized) distribution described by *this.  <a href="#a02458d75e5932d9852d282969180c19d"></a><br/></td></tr>
<tr class="memitem:a5900743aad10f112d17301db361a4009"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a5900743aad10f112d17301db361a4009">operator&lt;</a> (const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;q) const </td></tr>
<tr class="memdesc:a5900743aad10f112d17301db361a4009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographical comparison.  <a href="#a5900743aad10f112d17301db361a4009"></a><br/></td></tr>
<tr class="memitem:a1bfb47583ca5f57b65b22b55691fd50f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a1bfb47583ca5f57b65b22b55691fd50f">operator==</a> (const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;q) const </td></tr>
<tr class="memdesc:a1bfb47583ca5f57b65b22b55691fd50f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison.  <a href="#a1bfb47583ca5f57b65b22b55691fd50f"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Unary transformations</div></td></tr>
<tr class="memitem:a4f16a88c92c22a91d2cbdaa377bf492a"><td class="memTemplParams" colspan="2">template&lt;typename unaryOp &gt; </td></tr>
<tr class="memitem:a4f16a88c92c22a91d2cbdaa377bf492a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a4f16a88c92c22a91d2cbdaa377bf492a">pwUnaryTr</a> (unaryOp op) const </td></tr>
<tr class="memdesc:a4f16a88c92c22a91d2cbdaa377bf492a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of applying operation <em>op</em> pointwise on <code>*this</code>.  <a href="#a4f16a88c92c22a91d2cbdaa377bf492a"></a><br/></td></tr>
<tr class="memitem:a321e4bae60eef08e2062aba16d25ea06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a321e4bae60eef08e2062aba16d25ea06">operator-</a> () const </td></tr>
<tr class="memdesc:a321e4bae60eef08e2062aba16d25ea06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns negative of <code>*this</code>.  <a href="#a321e4bae60eef08e2062aba16d25ea06"></a><br/></td></tr>
<tr class="memitem:a26e92956bf6353985bd0318e5efa34f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a26e92956bf6353985bd0318e5efa34f5">abs</a> () const </td></tr>
<tr class="memdesc:a26e92956bf6353985bd0318e5efa34f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointwise absolute value.  <a href="#a26e92956bf6353985bd0318e5efa34f5"></a><br/></td></tr>
<tr class="memitem:aef0efd65b4b495496d37185ce25297d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#aef0efd65b4b495496d37185ce25297d3">exp</a> () const </td></tr>
<tr class="memdesc:aef0efd65b4b495496d37185ce25297d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointwise exponent.  <a href="#aef0efd65b4b495496d37185ce25297d3"></a><br/></td></tr>
<tr class="memitem:a06b614e4e8091be2b8a3809babde8a05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a06b614e4e8091be2b8a3809babde8a05">log</a> (bool zero=false) const </td></tr>
<tr class="memdesc:a06b614e4e8091be2b8a3809babde8a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointwise logarithm.  <a href="#a06b614e4e8091be2b8a3809babde8a05"></a><br/></td></tr>
<tr class="memitem:a3fcbbafe8b9c97e377467600ab28e623"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a3fcbbafe8b9c97e377467600ab28e623">inverse</a> (bool zero=true) const </td></tr>
<tr class="memdesc:a3fcbbafe8b9c97e377467600ab28e623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointwise inverse.  <a href="#a3fcbbafe8b9c97e377467600ab28e623"></a><br/></td></tr>
<tr class="memitem:a09535bb1a535cee1c00c3561a6070bb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a09535bb1a535cee1c00c3561a6070bb4">normalized</a> (<a class="el" href="namespacedai.html#ae0d0ef753bd0ba57586e556ab6312677">ProbNormType</a> norm=dai::NORMPROB) const </td></tr>
<tr class="memdesc:a09535bb1a535cee1c00c3561a6070bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns normalized copy of <code>*this</code>, using the specified norm.  <a href="#a09535bb1a535cee1c00c3561a6070bb4"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Unary operations</div></td></tr>
<tr class="memitem:af6c732492209dab12efe8ea3adc65c0f"><td class="memTemplParams" colspan="2">template&lt;typename unaryOp &gt; </td></tr>
<tr class="memitem:af6c732492209dab12efe8ea3adc65c0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#af6c732492209dab12efe8ea3adc65c0f">pwUnaryOp</a> (unaryOp op)</td></tr>
<tr class="memdesc:af6c732492209dab12efe8ea3adc65c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies unary operation <em>op</em> pointwise.  <a href="#af6c732492209dab12efe8ea3adc65c0f"></a><br/></td></tr>
<tr class="memitem:acdf4994010b6766f731c4bc9e5d26b39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#acdf4994010b6766f731c4bc9e5d26b39">randomize</a> ()</td></tr>
<tr class="memdesc:acdf4994010b6766f731c4bc9e5d26b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws all entries i.i.d. from a uniform distribution on [0,1)  <a href="#acdf4994010b6766f731c4bc9e5d26b39"></a><br/></td></tr>
<tr class="memitem:a95b669f1e6d665f8cbd18c211825b829"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a95b669f1e6d665f8cbd18c211825b829">setUniform</a> ()</td></tr>
<tr class="memdesc:a95b669f1e6d665f8cbd18c211825b829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all entries to <img class="formulaInl" alt="$1/n$" src="form_76.png"/> where <em>n</em> is the length of the vector.  <a href="#a95b669f1e6d665f8cbd18c211825b829"></a><br/></td></tr>
<tr class="memitem:ae2f8397269282697f7cb7b86dacc1bec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#ae2f8397269282697f7cb7b86dacc1bec">takeAbs</a> ()</td></tr>
<tr class="memdesc:ae2f8397269282697f7cb7b86dacc1bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies absolute value pointwise.  <a href="#ae2f8397269282697f7cb7b86dacc1bec"></a><br/></td></tr>
<tr class="memitem:a967218c9182d99d6a494aef636c5d858"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a967218c9182d99d6a494aef636c5d858">takeExp</a> ()</td></tr>
<tr class="memdesc:a967218c9182d99d6a494aef636c5d858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies exponent pointwise.  <a href="#a967218c9182d99d6a494aef636c5d858"></a><br/></td></tr>
<tr class="memitem:a55fe8debcb7e54963264debc18fb841d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a55fe8debcb7e54963264debc18fb841d">takeLog</a> (bool zero=false)</td></tr>
<tr class="memdesc:a55fe8debcb7e54963264debc18fb841d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies logarithm pointwise.  <a href="#a55fe8debcb7e54963264debc18fb841d"></a><br/></td></tr>
<tr class="memitem:a03ddd08f1a0f5c4b8b5ea4a6c571bd64"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a03ddd08f1a0f5c4b8b5ea4a6c571bd64">normalize</a> (<a class="el" href="namespacedai.html#ae0d0ef753bd0ba57586e556ab6312677">ProbNormType</a> norm=dai::NORMPROB)</td></tr>
<tr class="memdesc:a03ddd08f1a0f5c4b8b5ea4a6c571bd64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes vector using the specified norm.  <a href="#a03ddd08f1a0f5c4b8b5ea4a6c571bd64"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Operations with scalars</div></td></tr>
<tr class="memitem:aac66c404d9b842f604178537b0102936"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#aac66c404d9b842f604178537b0102936">fill</a> (T x)</td></tr>
<tr class="memdesc:aac66c404d9b842f604178537b0102936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all entries to <em>x</em>.  <a href="#aac66c404d9b842f604178537b0102936"></a><br/></td></tr>
<tr class="memitem:a8516c5364c802637f2dcaa1a81d70ad9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a8516c5364c802637f2dcaa1a81d70ad9">operator+=</a> (T x)</td></tr>
<tr class="memdesc:a8516c5364c802637f2dcaa1a81d70ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds scalar <em>x</em> to each entry.  <a href="#a8516c5364c802637f2dcaa1a81d70ad9"></a><br/></td></tr>
<tr class="memitem:aaebbbe6db98f3854b66a760dbc333db4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#aaebbbe6db98f3854b66a760dbc333db4">operator-=</a> (T x)</td></tr>
<tr class="memdesc:aaebbbe6db98f3854b66a760dbc333db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts scalar <em>x</em> from each entry.  <a href="#aaebbbe6db98f3854b66a760dbc333db4"></a><br/></td></tr>
<tr class="memitem:a6a4a6839e1750c66c004ca7e80fceb2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a6a4a6839e1750c66c004ca7e80fceb2d">operator*=</a> (T x)</td></tr>
<tr class="memdesc:a6a4a6839e1750c66c004ca7e80fceb2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies each entry with scalar <em>x</em>.  <a href="#a6a4a6839e1750c66c004ca7e80fceb2d"></a><br/></td></tr>
<tr class="memitem:a49484931a6e8d0480aba5cbc32b1a673"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a49484931a6e8d0480aba5cbc32b1a673">operator/=</a> (T x)</td></tr>
<tr class="memdesc:a49484931a6e8d0480aba5cbc32b1a673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides each entry by scalar <em>x</em>, where division by 0 yields 0.  <a href="#a49484931a6e8d0480aba5cbc32b1a673"></a><br/></td></tr>
<tr class="memitem:a81096f7f1141770a3ef56354eb4f58c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a81096f7f1141770a3ef56354eb4f58c3">operator^=</a> (T x)</td></tr>
<tr class="memdesc:a81096f7f1141770a3ef56354eb4f58c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises entries to the power <em>x</em>.  <a href="#a81096f7f1141770a3ef56354eb4f58c3"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Transformations with scalars</div></td></tr>
<tr class="memitem:ae5f9b709dd6ad346ca6c53bd75656105"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#ae5f9b709dd6ad346ca6c53bd75656105">operator+</a> (T x) const </td></tr>
<tr class="memdesc:ae5f9b709dd6ad346ca6c53bd75656105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns sum of <code>*this</code> and scalar <em>x</em>.  <a href="#ae5f9b709dd6ad346ca6c53bd75656105"></a><br/></td></tr>
<tr class="memitem:ad89e73cb01d21c494ddc6864323061ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#ad89e73cb01d21c494ddc6864323061ff">operator-</a> (T x) const </td></tr>
<tr class="memdesc:ad89e73cb01d21c494ddc6864323061ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns difference of <code>*this</code> and scalar <em>x</em>.  <a href="#ad89e73cb01d21c494ddc6864323061ff"></a><br/></td></tr>
<tr class="memitem:a49b549c4cc9a239a50acb48a5ba49bda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a49b549c4cc9a239a50acb48a5ba49bda">operator*</a> (T x) const </td></tr>
<tr class="memdesc:a49b549c4cc9a239a50acb48a5ba49bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns product of <code>*this</code> with scalar <em>x</em>.  <a href="#a49b549c4cc9a239a50acb48a5ba49bda"></a><br/></td></tr>
<tr class="memitem:aed66f0e2846db7689ae09cab9006471e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#aed66f0e2846db7689ae09cab9006471e">operator/</a> (T x) const </td></tr>
<tr class="memdesc:aed66f0e2846db7689ae09cab9006471e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns quotient of <code>*this</code> and scalar <em>x</em>, where division by 0 yields 0.  <a href="#aed66f0e2846db7689ae09cab9006471e"></a><br/></td></tr>
<tr class="memitem:a6f8817f05b231ed203ea64fd91da71d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a6f8817f05b231ed203ea64fd91da71d1">operator^</a> (T x) const </td></tr>
<tr class="memdesc:a6f8817f05b231ed203ea64fd91da71d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>*this</code> raised to the power <em>x</em>.  <a href="#a6f8817f05b231ed203ea64fd91da71d1"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Operations with other equally-sized vectors</div></td></tr>
<tr class="memitem:ac622097c86e7cd68b45961c1becab698"><td class="memTemplParams" colspan="2">template&lt;typename binaryOp &gt; </td></tr>
<tr class="memitem:ac622097c86e7cd68b45961c1becab698"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#ac622097c86e7cd68b45961c1becab698">pwBinaryOp</a> (const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;q, binaryOp op)</td></tr>
<tr class="memdesc:ac622097c86e7cd68b45961c1becab698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies binary operation pointwise on two vectors.  <a href="#ac622097c86e7cd68b45961c1becab698"></a><br/></td></tr>
<tr class="memitem:a0fbcb8e7badcd1eb05ad899a4c94be4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a0fbcb8e7badcd1eb05ad899a4c94be4a">operator+=</a> (const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;q)</td></tr>
<tr class="memdesc:a0fbcb8e7badcd1eb05ad899a4c94be4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointwise addition with <em>q</em>.  <a href="#a0fbcb8e7badcd1eb05ad899a4c94be4a"></a><br/></td></tr>
<tr class="memitem:a91a0208000eaaf9ffb80473a43d58d20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a91a0208000eaaf9ffb80473a43d58d20">operator-=</a> (const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;q)</td></tr>
<tr class="memdesc:a91a0208000eaaf9ffb80473a43d58d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointwise subtraction of <em>q</em>.  <a href="#a91a0208000eaaf9ffb80473a43d58d20"></a><br/></td></tr>
<tr class="memitem:a839a9fbcf311df461232c1020fb7a30b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a839a9fbcf311df461232c1020fb7a30b">operator*=</a> (const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;q)</td></tr>
<tr class="memdesc:a839a9fbcf311df461232c1020fb7a30b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointwise multiplication with <em>q</em>.  <a href="#a839a9fbcf311df461232c1020fb7a30b"></a><br/></td></tr>
<tr class="memitem:a567790517d542bfd9e1c513898646e7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a567790517d542bfd9e1c513898646e7e">operator/=</a> (const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;q)</td></tr>
<tr class="memdesc:a567790517d542bfd9e1c513898646e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointwise division by <em>q</em>, where division by 0 yields 0.  <a href="#a567790517d542bfd9e1c513898646e7e"></a><br/></td></tr>
<tr class="memitem:a675c22b9232036bf7e1e32fdfdacb7b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a675c22b9232036bf7e1e32fdfdacb7b5">divide</a> (const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;q)</td></tr>
<tr class="memdesc:a675c22b9232036bf7e1e32fdfdacb7b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointwise division by <em>q</em>, where division by 0 yields +Inf.  <a href="#a675c22b9232036bf7e1e32fdfdacb7b5"></a><br/></td></tr>
<tr class="memitem:a068e1e4db9e3a17c8790210a10e190d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a068e1e4db9e3a17c8790210a10e190d1">operator^=</a> (const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;q)</td></tr>
<tr class="memdesc:a068e1e4db9e3a17c8790210a10e190d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointwise power.  <a href="#a068e1e4db9e3a17c8790210a10e190d1"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Transformations with other equally-sized vectors</div></td></tr>
<tr class="memitem:aac77943294bae49769351ed1f6c99c2d"><td class="memTemplParams" colspan="2">template&lt;typename binaryOp &gt; </td></tr>
<tr class="memitem:aac77943294bae49769351ed1f6c99c2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#aac77943294bae49769351ed1f6c99c2d">pwBinaryTr</a> (const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;q, binaryOp op) const </td></tr>
<tr class="memdesc:aac77943294bae49769351ed1f6c99c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of applying binary operation <em>op</em> pointwise on <code>*this</code> and <em>q</em>.  <a href="#aac77943294bae49769351ed1f6c99c2d"></a><br/></td></tr>
<tr class="memitem:abb8502b1b7a3344f5b1bb80dfd69a3e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#abb8502b1b7a3344f5b1bb80dfd69a3e6">operator+</a> (const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;q) const </td></tr>
<tr class="memdesc:abb8502b1b7a3344f5b1bb80dfd69a3e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns sum of <code>*this</code> and <em>q</em>.  <a href="#abb8502b1b7a3344f5b1bb80dfd69a3e6"></a><br/></td></tr>
<tr class="memitem:a0aea2fec50a253397e4024a0fa3e5238"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a0aea2fec50a253397e4024a0fa3e5238">operator-</a> (const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;q) const </td></tr>
<tr class="memdesc:a0aea2fec50a253397e4024a0fa3e5238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>*this</code> minus <em>q</em>.  <a href="#a0aea2fec50a253397e4024a0fa3e5238"></a><br/></td></tr>
<tr class="memitem:ab33a4fe805034b4990ebdd16d5a2c4eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#ab33a4fe805034b4990ebdd16d5a2c4eb">operator*</a> (const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;q) const </td></tr>
<tr class="memdesc:ab33a4fe805034b4990ebdd16d5a2c4eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return product of <code>*this</code> with <em>q</em>.  <a href="#ab33a4fe805034b4990ebdd16d5a2c4eb"></a><br/></td></tr>
<tr class="memitem:ab0a24c79d9ad9211f2fabd7e257c6aba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#ab0a24c79d9ad9211f2fabd7e257c6aba">operator/</a> (const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;q) const </td></tr>
<tr class="memdesc:ab0a24c79d9ad9211f2fabd7e257c6aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns quotient of <code>*this</code> with <em>q</em>, where division by 0 yields 0.  <a href="#ab0a24c79d9ad9211f2fabd7e257c6aba"></a><br/></td></tr>
<tr class="memitem:aa504d2457c6f2b07a3eba02165bb51a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#aa504d2457c6f2b07a3eba02165bb51a3">divided_by</a> (const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;q) const </td></tr>
<tr class="memdesc:aa504d2457c6f2b07a3eba02165bb51a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointwise division by <em>q</em>, where division by 0 yields +Inf.  <a href="#aa504d2457c6f2b07a3eba02165bb51a3"></a><br/></td></tr>
<tr class="memitem:af221d5251fdebcac3df742924a3f34ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#af221d5251fdebcac3df742924a3f34ec">operator^</a> (const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;q) const </td></tr>
<tr class="memdesc:af221d5251fdebcac3df742924a3f34ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>*this</code> to the power <em>q</em>.  <a href="#af221d5251fdebcac3df742924a3f34ec"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aaaf14f80c4a6358d0572d5845f54c159"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html#abc9fe6deccea5808517e6dfb76c0c781">container_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#aaaf14f80c4a6358d0572d5845f54c159">_p</a></td></tr>
<tr class="memdesc:aaaf14f80c4a6358d0572d5845f54c159"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data structure that stores the nondefault values.  <a href="#aaaf14f80c4a6358d0572d5845f54c159"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ac5bef5c385d7c57bb39fbbc7458359fe"><td class="memTemplParams" colspan="2">template&lt;typename T , typename spvector_type &gt; </td></tr>
<tr class="memitem:ac5bef5c385d7c57bb39fbbc7458359fe"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#ac5bef5c385d7c57bb39fbbc7458359fe">dist</a> (const <a class="el" href="classdai_1_1TProbSp.html">TProbSp</a>&lt; T, spvector_type &gt; &amp;<a class="el" href="classdai_1_1TProbSp.html#a8a7fe58b7a23b22222a47b03a00801d6">p</a>, const <a class="el" href="classdai_1_1TProbSp.html">TProbSp</a>&lt; T, spvector_type &gt; &amp;q, <a class="el" href="namespacedai.html#aa2735a823696443089d2de23e8ee6ecb">ProbDistType</a> dt)</td></tr>
<tr class="memdesc:ac5bef5c385d7c57bb39fbbc7458359fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns distance between <em>p</em> and <em>q</em>, measured using distance measure <em>dt</em>.  <a href="#ac5bef5c385d7c57bb39fbbc7458359fe"></a><br/></td></tr>
<tr class="memitem:aef5d347ef0a121e621a311fee44a8c7d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename spvector_type &gt; </td></tr>
<tr class="memitem:aef5d347ef0a121e621a311fee44a8c7d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#aef5d347ef0a121e621a311fee44a8c7d">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdai_1_1TProbSp.html">TProbSp</a>&lt; T, spvector_type &gt; &amp;<a class="el" href="classdai_1_1TProbSp.html#a8a7fe58b7a23b22222a47b03a00801d6">p</a>)</td></tr>
<tr class="memdesc:aef5d347ef0a121e621a311fee44a8c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a <a class="el" href="classdai_1_1TProbSp.html" title="Represents a vector with entries of type T.">TProbSp</a> to an output stream.  <a href="#aef5d347ef0a121e621a311fee44a8c7d"></a><br/></td></tr>
<tr class="memitem:a8fdfd6b93c5d9addc3ae3643945ad6af"><td class="memTemplParams" colspan="2">template&lt;typename T , typename spvector_type &gt; </td></tr>
<tr class="memitem:a8fdfd6b93c5d9addc3ae3643945ad6af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">TProbSp</a>&lt; T, spvector_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a8fdfd6b93c5d9addc3ae3643945ad6af">min</a> (const <a class="el" href="classdai_1_1TProbSp.html">TProbSp</a>&lt; T, spvector_type &gt; &amp;a, const <a class="el" href="classdai_1_1TProbSp.html">TProbSp</a>&lt; T, spvector_type &gt; &amp;b)</td></tr>
<tr class="memdesc:a8fdfd6b93c5d9addc3ae3643945ad6af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pointwise minimum of <em>a</em> and <em>b</em>.  <a href="#a8fdfd6b93c5d9addc3ae3643945ad6af"></a><br/></td></tr>
<tr class="memitem:a410a2d6cc83b6459115a51b57681a781"><td class="memTemplParams" colspan="2">template&lt;typename T , typename spvector_type &gt; </td></tr>
<tr class="memitem:a410a2d6cc83b6459115a51b57681a781"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TProbSp.html">TProbSp</a>&lt; T, spvector_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html#a410a2d6cc83b6459115a51b57681a781">max</a> (const <a class="el" href="classdai_1_1TProbSp.html">TProbSp</a>&lt; T, spvector_type &gt; &amp;a, const <a class="el" href="classdai_1_1TProbSp.html">TProbSp</a>&lt; T, spvector_type &gt; &amp;b)</td></tr>
<tr class="memdesc:a410a2d6cc83b6459115a51b57681a781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pointwise maximum of <em>a</em> and <em>b</em>.  <a href="#a410a2d6cc83b6459115a51b57681a781"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename spvector_type&gt;<br/>
class dai::TProbSp&lt; T, spvector_type &gt;</h3>

<p>Represents a vector with entries of type <em>T</em>. </p>
<p>It is simply a <code>std::vector</code>&lt;<em>T</em>&gt; with an interface designed for dealing with probability mass functions.</p>
<p>It is mainly used for representing measures on a finite outcome space, for example, the probability distribution of a discrete random variable. However, entries are not necessarily non-negative; it is also used to represent logarithms of probability mass functions.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Should be a scalar that is castable from and to <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf" title="Real number (alias for double, which could be changed to long double if necessary)">dai::Real</a> and should support elementary arithmetic operations. </td></tr>
  </table>
  </dd>
</dl>
</div><h2>Member Typedef Documentation</h2>
<a class="anchor" id="abc9fe6deccea5808517e6dfb76c0c781"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef spvector_type <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::<a class="el" href="classdai_1_1TProbSp.html#abc9fe6deccea5808517e6dfb76c0c781">container_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of data structure used for storing the values. </p>

</div>
</div>
<a class="anchor" id="aabd97e809c0da7783bab509943d1ee59"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef container_type::const_iterator <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::<a class="el" href="classdai_1_1TProbSp.html#aabd97e809c0da7783bab509943d1ee59">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant iterator over the elements. </p>

</div>
</div>
<a class="anchor" id="aca7c3f5a0f7630c2f03c42caf0e0b902"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef container_type::iterator <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::<a class="el" href="classdai_1_1TProbSp.html#aca7c3f5a0f7630c2f03c42caf0e0b902">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator over the elements. </p>

</div>
</div>
<a class="anchor" id="a5cedb7c78fe5e7a2e157d4946b12b752"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef container_type::const_reverse_iterator <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::<a class="el" href="classdai_1_1TProbSp.html#a5cedb7c78fe5e7a2e157d4946b12b752">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant reverse iterator over the elements. </p>

</div>
</div>
<a class="anchor" id="a4262c09993fd664db0bdbbececf0a52e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef container_type::reverse_iterator <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::<a class="el" href="classdai_1_1TProbSp.html#a4262c09993fd664db0bdbbececf0a52e">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse iterator over the elements. </p>

</div>
</div>
<h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a22e5501492f53a1a6898873a1367ae4c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::<a class="el" href="classdai_1_1TProbSp.html">TProbSp</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor (constructs empty vector) </p>

</div>
</div>
<a class="anchor" id="ad3d1133ddcb5898642c669c575e16912"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::<a class="el" href="classdai_1_1TProbSp.html">TProbSp</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct uniform probability distribution over <em>n</em> outcomes (i.e., a vector of length <em>n</em> with each entry set to <img class="formulaInl" alt="$1/n$" src="form_76.png"/>) </p>

</div>
</div>
<a class="anchor" id="a0c16c8b2f7b35db18de492db58037067"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::<a class="el" href="classdai_1_1TProbSp.html">TProbSp</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct vector of length <em>n</em> with each entry set to <em>p</em>. </p>

</div>
</div>
<a class="anchor" id="a2e962551c7a6c8a06bc7baf8691e8806"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<div class="memtemplate">
template&lt;typename TIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::<a class="el" href="classdai_1_1TProbSp.html">TProbSp</a> </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeHint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>def</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct sparse vector from a range. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIterator</td><td>Iterates over instances that can be cast to <em>T</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Points to first instance to be added. </td></tr>
    <tr><td class="paramname">end</td><td>Points just beyond last instance to be added. </td></tr>
    <tr><td class="paramname">sizeHint</td><td>For efficiency, the number of entries can be speficied by <em>sizeHint</em>; the value 0 can be given if the size is unknown, but this will result in a performance penalty. </td></tr>
    <tr><td class="paramname">def</td><td>Default value to use for the constructed sparse vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a256cd31f46b0b3bc16a0fa7dccd4be18"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<div class="memtemplate">
template&lt;typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::<a class="el" href="classdai_1_1TProbSp.html">TProbSp</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; S &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>def</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct vector from another vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>type of elements in <em>v</em> (should be castable to type <em>T</em>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>vector used for initialization. </td></tr>
    <tr><td class="paramname">def</td><td>Default value to used for the constructed sparse vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="a602a605f95318abf628a7b18387e606e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html#aca7c3f5a0f7630c2f03c42caf0e0b902">iterator</a> <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns iterator that points to the first nondefault element. </p>

</div>
</div>
<a class="anchor" id="ae7c45a694cbb4d7db8348a515cf137c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html#aabd97e809c0da7783bab509943d1ee59">const_iterator</a> <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns constant iterator that points to the first nondefault element. </p>

</div>
</div>
<a class="anchor" id="a1f058670e888bffc3eb2e408348aac29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html#aca7c3f5a0f7630c2f03c42caf0e0b902">iterator</a> <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns iterator that points beyond the last nondefault element. </p>

</div>
</div>
<a class="anchor" id="a4a43edf97dabe33c9da1c0e24b9b130a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html#aabd97e809c0da7783bab509943d1ee59">const_iterator</a> <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns constant iterator that points beyond the last nondefault element. </p>

</div>
</div>
<a class="anchor" id="ac6b5b3f0101cab702e350261a08ed07d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html#a4262c09993fd664db0bdbbececf0a52e">reverse_iterator</a> <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns reverse iterator that points to the last nondefault element. </p>

</div>
</div>
<a class="anchor" id="a9219b7ba5972d596776720a3590fd730"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html#a5cedb7c78fe5e7a2e157d4946b12b752">const_reverse_iterator</a> <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns constant reverse iterator that points to the last nondefault element. </p>

</div>
</div>
<a class="anchor" id="aed08dd3311314d3b18f015c6671ccf20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html#a4262c09993fd664db0bdbbececf0a52e">reverse_iterator</a> <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns reverse iterator that points beyond the first nondefault element. </p>

</div>
</div>
<a class="anchor" id="a7a4695cf7026f1b7f15ca62f7d62a623"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html#a5cedb7c78fe5e7a2e157d4946b12b752">const_reverse_iterator</a> <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns constant reverse iterator that points beyond the first nondefault element. </p>

</div>
</div>
<a class="anchor" id="ade1ce6d6334f6b7fe18e72e751ac35ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::get </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets <em>i</em> 'th entry. </p>

</div>
</div>
<a class="anchor" id="ab687e2f8190f26a283ed8ae84ce8ea7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::set </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <em>i</em> 'th entry to <em>val</em>. </p>

</div>
</div>
<a class="anchor" id="a8a7fe58b7a23b22222a47b03a00801d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdai_1_1TProbSp.html#abc9fe6deccea5808517e6dfb76c0c781">container_type</a>&amp; <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::p </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reference to the wrapped container. </p>

</div>
</div>
<a class="anchor" id="a6f6c7e105ba41ecb8b130756bc6cb5a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html#abc9fe6deccea5808517e6dfb76c0c781">container_type</a>&amp; <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::p </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the wrapped container. </p>

</div>
</div>
<a class="anchor" id="a5a7e32f3448b45942e46f318dfe70bfe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the <em>i</em> 'th entry. </p>

</div>
</div>
<a class="anchor" id="a74420561593b8243310ca03a45f608df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns length of the vector (i.e., the number of entries) </p>

</div>
</div>
<a class="anchor" id="aa595f133e5c591978c779ad1f7805e8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::nrDef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns number of default values. </p>

</div>
</div>
<a class="anchor" id="ac0ff0d5bb8316b621220cf4386d48f98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::nrNonDef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns number of nondefault values. </p>

</div>
</div>
<a class="anchor" id="a8287de52cdc1fcdebaeb96906d64bb3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::def </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns default value. </p>

</div>
</div>
<a class="anchor" id="a8fb92e76bd58abce8c1c8fa6e92e2f77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::setDef </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>def</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets default value. </p>

</div>
</div>
<a class="anchor" id="ad9e362a9188f3e577e1006802fce0143"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<div class="memtemplate">
template&lt;typename unOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::accumulateSum </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accumulate all values (similar to std::accumulate) by summing. </p>
<p>The following calculation is done: </p>
<div class="fragment"><div class="line">T t = op(init);</div>
<div class="line"><span class="keywordflow">for</span>( <a class="code" href="classdai_1_1TProbSp.html#aabd97e809c0da7783bab509943d1ee59" title="Constant iterator over the elements.">const_iterator</a> it = <a class="code" href="classdai_1_1TProbSp.html#a602a605f95318abf628a7b18387e606e" title="Returns iterator that points to the first nondefault element.">begin</a>(); it != <a class="code" href="classdai_1_1TProbSp.html#a1f058670e888bffc3eb2e408348aac29" title="Returns iterator that points beyond the last nondefault element.">end</a>(); it++ )</div>
<div class="line">    t += op(*it);</div>
<div class="line"><span class="keywordflow">return</span> t;</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ad0de78e389920f8066130822e2114cea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<div class="memtemplate">
template&lt;typename unOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::accumulateMax </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>minimize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accumulate all values (similar to std::accumulate) by maximization/minimization. </p>
<p>The following calculation is done (with "max" replaced by "min" if <em>minimize</em> == <code>true</code>): </p>
<div class="fragment"><div class="line">T t = op(init);</div>
<div class="line"><span class="keywordflow">for</span>( <a class="code" href="classdai_1_1TProbSp.html#aabd97e809c0da7783bab509943d1ee59" title="Constant iterator over the elements.">const_iterator</a> it = <a class="code" href="classdai_1_1TProbSp.html#a602a605f95318abf628a7b18387e606e" title="Returns iterator that points to the first nondefault element.">begin</a>(); it != <a class="code" href="classdai_1_1TProbSp.html#a1f058670e888bffc3eb2e408348aac29" title="Returns iterator that points beyond the last nondefault element.">end</a>(); it++ )</div>
<div class="line">    t = std::max( t, op(*it) );</div>
<div class="line"><span class="keywordflow">return</span> t;</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a529a0139485202cfcf0b1cf292381bff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::entropy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Shannon entropy of <code>*this</code>, <img class="formulaInl" alt="$-\sum_i p_i \log p_i$" src="form_75.png"/>. </p>

</div>
</div>
<a class="anchor" id="ac7d37a119bd7f681b74786200ae284a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns maximum value of all entries. </p>

</div>
</div>
<a class="anchor" id="a05cad8dab5cf00e8c6b3d30a4a1e93d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns minimum value of all entries. </p>

</div>
</div>
<a class="anchor" id="acf306d69c898656c3f41113cd7a4e0a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::sum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns sum of all entries. </p>

</div>
</div>
<a class="anchor" id="a5d72aaddbab7c397106d8c57177d5fda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::sumAbs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return sum of absolute value of all entries. </p>

</div>
</div>
<a class="anchor" id="ac25935142bda54d0e15ca2c02df015d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::maxAbs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns maximum absolute value of all entries. </p>

</div>
</div>
<a class="anchor" id="a167ca35db39f57367f79802691a1ccc4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::hasNaNs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if one or more entries are NaN. </p>

</div>
</div>
<a class="anchor" id="a706ed601ecb12960223e70f722e2f05e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::hasNegatives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if one or more entries are negative. </p>

</div>
</div>
<a class="anchor" id="a13ff29c2f22cc11eb12461d5b56629eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;size_t,T&gt; <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::argmax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pair consisting of the index of the maximum value and the maximum value itself. </p>

</div>
</div>
<a class="anchor" id="a02458d75e5932d9852d282969180c19d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::draw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a random index, according to the (normalized) distribution described by *this. </p>

</div>
</div>
<a class="anchor" id="a5900743aad10f112d17301db361a4009"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexicographical comparison. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProbSp.html#a74420561593b8243310ca03a45f608df" title="Returns length of the vector (i.e., the number of entries)">size()</a> == q.size()</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a1bfb47583ca5f57b65b22b55691fd50f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison. </p>

</div>
</div>
<a class="anchor" id="a4f16a88c92c22a91d2cbdaa377bf492a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<div class="memtemplate">
template&lt;typename unaryOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::pwUnaryTr </td>
          <td>(</td>
          <td class="paramtype">unaryOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of applying operation <em>op</em> pointwise on <code>*this</code>. </p>

</div>
</div>
<a class="anchor" id="a321e4bae60eef08e2062aba16d25ea06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns negative of <code>*this</code>. </p>

</div>
</div>
<a class="anchor" id="a26e92956bf6353985bd0318e5efa34f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::abs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointwise absolute value. </p>

</div>
</div>
<a class="anchor" id="aef0efd65b4b495496d37185ce25297d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::exp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointwise exponent. </p>

</div>
</div>
<a class="anchor" id="a06b614e4e8091be2b8a3809babde8a05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::log </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>zero</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointwise logarithm. </p>
<p>If <em>zero</em> == <code>true</code>, uses <code>log(0)==0</code>; otherwise, <code>log(0)==-Inf</code>. </p>

</div>
</div>
<a class="anchor" id="a3fcbbafe8b9c97e377467600ab28e623"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::inverse </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>zero</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointwise inverse. </p>
<p>If <em>zero</em> == <code>true</code>, uses <code>1/0==0</code>; otherwise, <code>1/0==Inf</code>. </p>

</div>
</div>
<a class="anchor" id="a09535bb1a535cee1c00c3561a6070bb4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::normalized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedai.html#ae0d0ef753bd0ba57586e556ab6312677">ProbNormType</a>&#160;</td>
          <td class="paramname"><em>norm</em> = <code>dai::NORMPROB</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns normalized copy of <code>*this</code>, using the specified norm. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NOT_NORMALIZABLE</td><td>if the norm is zero </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af6c732492209dab12efe8ea3adc65c0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<div class="memtemplate">
template&lt;typename unaryOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::pwUnaryOp </td>
          <td>(</td>
          <td class="paramtype">unaryOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies unary operation <em>op</em> pointwise. </p>

</div>
</div>
<a class="anchor" id="acdf4994010b6766f731c4bc9e5d26b39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::randomize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws all entries i.i.d. from a uniform distribution on [0,1) </p>

</div>
</div>
<a class="anchor" id="a95b669f1e6d665f8cbd18c211825b829"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::setUniform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all entries to <img class="formulaInl" alt="$1/n$" src="form_76.png"/> where <em>n</em> is the length of the vector. </p>

</div>
</div>
<a class="anchor" id="ae2f8397269282697f7cb7b86dacc1bec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::takeAbs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies absolute value pointwise. </p>

</div>
</div>
<a class="anchor" id="a967218c9182d99d6a494aef636c5d858"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::takeExp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies exponent pointwise. </p>

</div>
</div>
<a class="anchor" id="a55fe8debcb7e54963264debc18fb841d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::takeLog </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>zero</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies logarithm pointwise. </p>
<p>If <em>zero</em> == <code>true</code>, uses <code>log(0)==0</code>; otherwise, <code>log(0)==-Inf</code>. </p>

</div>
</div>
<a class="anchor" id="a03ddd08f1a0f5c4b8b5ea4a6c571bd64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::normalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedai.html#ae0d0ef753bd0ba57586e556ab6312677">ProbNormType</a>&#160;</td>
          <td class="paramname"><em>norm</em> = <code>dai::NORMPROB</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalizes vector using the specified norm. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NOT_NORMALIZABLE</td><td>if the norm is zero </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aac66c404d9b842f604178537b0102936"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all entries to <em>x</em>. </p>

</div>
</div>
<a class="anchor" id="a8516c5364c802637f2dcaa1a81d70ad9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds scalar <em>x</em> to each entry. </p>

</div>
</div>
<a class="anchor" id="aaebbbe6db98f3854b66a760dbc333db4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts scalar <em>x</em> from each entry. </p>

</div>
</div>
<a class="anchor" id="a6a4a6839e1750c66c004ca7e80fceb2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies each entry with scalar <em>x</em>. </p>

</div>
</div>
<a class="anchor" id="a49484931a6e8d0480aba5cbc32b1a673"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides each entry by scalar <em>x</em>, where division by 0 yields 0. </p>

</div>
</div>
<a class="anchor" id="a81096f7f1141770a3ef56354eb4f58c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::operator^= </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Raises entries to the power <em>x</em>. </p>

</div>
</div>
<a class="anchor" id="ae5f9b709dd6ad346ca6c53bd75656105"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns sum of <code>*this</code> and scalar <em>x</em>. </p>

</div>
</div>
<a class="anchor" id="ad89e73cb01d21c494ddc6864323061ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns difference of <code>*this</code> and scalar <em>x</em>. </p>

</div>
</div>
<a class="anchor" id="a49b549c4cc9a239a50acb48a5ba49bda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns product of <code>*this</code> with scalar <em>x</em>. </p>

</div>
</div>
<a class="anchor" id="aed66f0e2846db7689ae09cab9006471e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns quotient of <code>*this</code> and scalar <em>x</em>, where division by 0 yields 0. </p>

</div>
</div>
<a class="anchor" id="a6f8817f05b231ed203ea64fd91da71d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::operator^ </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>*this</code> raised to the power <em>x</em>. </p>

</div>
</div>
<a class="anchor" id="ac622097c86e7cd68b45961c1becab698"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<div class="memtemplate">
template&lt;typename binaryOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::pwBinaryOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">binaryOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies binary operation pointwise on two vectors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">binaryOp</td><td>Type of function object that accepts two arguments of type <em>T</em> and outputs a type <em>T</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Right operand </td></tr>
    <tr><td class="paramname">op</td><td>Operation of type <em>binaryOp</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0fbcb8e7badcd1eb05ad899a4c94be4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointwise addition with <em>q</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProbSp.html#a74420561593b8243310ca03a45f608df" title="Returns length of the vector (i.e., the number of entries)">size()</a> == q.size()</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a91a0208000eaaf9ffb80473a43d58d20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointwise subtraction of <em>q</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProbSp.html#a74420561593b8243310ca03a45f608df" title="Returns length of the vector (i.e., the number of entries)">size()</a> == q.size()</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a839a9fbcf311df461232c1020fb7a30b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointwise multiplication with <em>q</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProbSp.html#a74420561593b8243310ca03a45f608df" title="Returns length of the vector (i.e., the number of entries)">size()</a> == q.size()</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a567790517d542bfd9e1c513898646e7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointwise division by <em>q</em>, where division by 0 yields 0. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProbSp.html#a74420561593b8243310ca03a45f608df" title="Returns length of the vector (i.e., the number of entries)">size()</a> == q.size()</code> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classdai_1_1TProbSp.html#a675c22b9232036bf7e1e32fdfdacb7b5" title="Pointwise division by q, where division by 0 yields +Inf.">divide(const this_type &amp;)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a675c22b9232036bf7e1e32fdfdacb7b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::divide </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointwise division by <em>q</em>, where division by 0 yields +Inf. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProbSp.html#a74420561593b8243310ca03a45f608df" title="Returns length of the vector (i.e., the number of entries)">size()</a> == q.size()</code> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classdai_1_1TProbSp.html#a567790517d542bfd9e1c513898646e7e" title="Pointwise division by q, where division by 0 yields 0.">operator/=(const this_type &amp;)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a068e1e4db9e3a17c8790210a10e190d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a>&amp; <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::operator^= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointwise power. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProbSp.html#a74420561593b8243310ca03a45f608df" title="Returns length of the vector (i.e., the number of entries)">size()</a> == q.size()</code> </dd></dl>

</div>
</div>
<a class="anchor" id="aac77943294bae49769351ed1f6c99c2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<div class="memtemplate">
template&lt;typename binaryOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::pwBinaryTr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">binaryOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of applying binary operation <em>op</em> pointwise on <code>*this</code> and <em>q</em>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">binaryOp</td><td>Type of function object that accepts two arguments of type <em>T</em> and outputs a type <em>T</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Right operand </td></tr>
    <tr><td class="paramname">op</td><td>Operation of type <em>binaryOp</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb8502b1b7a3344f5b1bb80dfd69a3e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns sum of <code>*this</code> and <em>q</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProbSp.html#a74420561593b8243310ca03a45f608df" title="Returns length of the vector (i.e., the number of entries)">size()</a> == q.size()</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a0aea2fec50a253397e4024a0fa3e5238"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>*this</code> minus <em>q</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProbSp.html#a74420561593b8243310ca03a45f608df" title="Returns length of the vector (i.e., the number of entries)">size()</a> == q.size()</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ab33a4fe805034b4990ebdd16d5a2c4eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return product of <code>*this</code> with <em>q</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProbSp.html#a74420561593b8243310ca03a45f608df" title="Returns length of the vector (i.e., the number of entries)">size()</a> == q.size()</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ab0a24c79d9ad9211f2fabd7e257c6aba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns quotient of <code>*this</code> with <em>q</em>, where division by 0 yields 0. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProbSp.html#a74420561593b8243310ca03a45f608df" title="Returns length of the vector (i.e., the number of entries)">size()</a> == q.size()</code> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>divided_by(const this_type &amp;) </dd></dl>

</div>
</div>
<a class="anchor" id="aa504d2457c6f2b07a3eba02165bb51a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::divided_by </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointwise division by <em>q</em>, where division by 0 yields +Inf. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProbSp.html#a74420561593b8243310ca03a45f608df" title="Returns length of the vector (i.e., the number of entries)">size()</a> == q.size()</code> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>operator/(const this_type &amp;) </dd></dl>

</div>
</div>
<a class="anchor" id="af221d5251fdebcac3df742924a3f34ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">this_type</a> <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::operator^ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>*this</code> to the power <em>q</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProbSp.html#a74420561593b8243310ca03a45f608df" title="Returns length of the vector (i.e., the number of entries)">size()</a> == q.size()</code> </dd></dl>

</div>
</div>
<a class="anchor" id="acd3a0c243af8d0e88e4dc785f69e38ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<div class="memtemplate">
template&lt;typename binOp1 , typename binOp2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::innerProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProbSp.html">this_type</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">binOp1&#160;</td>
          <td class="paramname"><em>binaryOp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">binOp2&#160;</td>
          <td class="paramname"><em>binaryOp2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a generalized inner product, similar to std::inner_product. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProbSp.html#a74420561593b8243310ca03a45f608df" title="Returns length of the vector (i.e., the number of entries)">size()</a> == q.size()</code> </dd></dl>

</div>
</div>
<h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="ac5bef5c385d7c57bb39fbbc7458359fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename spvector_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T dist </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProbSp.html">TProbSp</a>&lt; T, spvector_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProbSp.html">TProbSp</a>&lt; T, spvector_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedai.html#aa2735a823696443089d2de23e8ee6ecb">ProbDistType</a>&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns distance between <em>p</em> and <em>q</em>, measured using distance measure <em>dt</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProbSp.html#a74420561593b8243310ca03a45f608df" title="Returns length of the vector (i.e., the number of entries)">size()</a> == q.size()</code> </dd></dl>

</div>
</div>
<a class="anchor" id="aef5d347ef0a121e621a311fee44a8c7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename spvector_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProbSp.html">TProbSp</a>&lt; T, spvector_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a <a class="el" href="classdai_1_1TProbSp.html" title="Represents a vector with entries of type T.">TProbSp</a> to an output stream. </p>

</div>
</div>
<a class="anchor" id="a8fdfd6b93c5d9addc3ae3643945ad6af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename spvector_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">TProbSp</a>&lt; T, spvector_type &gt; min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProbSp.html">TProbSp</a>&lt; T, spvector_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProbSp.html">TProbSp</a>&lt; T, spvector_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the pointwise minimum of <em>a</em> and <em>b</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProbSp.html#a74420561593b8243310ca03a45f608df" title="Returns length of the vector (i.e., the number of entries)">size()</a> == q.size()</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a410a2d6cc83b6459115a51b57681a781"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename spvector_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html">TProbSp</a>&lt; T, spvector_type &gt; max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProbSp.html">TProbSp</a>&lt; T, spvector_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdai_1_1TProbSp.html">TProbSp</a>&lt; T, spvector_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the pointwise maximum of <em>a</em> and <em>b</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>this-&gt;<a class="el" href="classdai_1_1TProbSp.html#a74420561593b8243310ca03a45f608df" title="Returns length of the vector (i.e., the number of entries)">size()</a> == q.size()</code> </dd></dl>

</div>
</div>
<h2>Member Data Documentation</h2>
<a class="anchor" id="aaaf14f80c4a6358d0572d5845f54c159"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename spvector_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TProbSp.html#abc9fe6deccea5808517e6dfb76c0c781">container_type</a> <a class="el" href="classdai_1_1TProbSp.html">dai::TProbSp</a>&lt; T, spvector_type &gt;::_p</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The data structure that stores the nondefault values. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/dai/<a class="el" href="probsp_8h_source.html">probsp.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 17 2012 12:30:39 for libDAI by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
