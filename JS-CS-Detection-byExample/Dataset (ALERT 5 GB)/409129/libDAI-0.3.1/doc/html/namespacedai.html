<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libDAI: dai Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libDAI
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">dai Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace for libDAI.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1BBPCostFunction.html">BBPCostFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predefined cost functions that can be used with <a class="el" href="classdai_1_1BBP.html" title="Implements BBP (Back-Belief-Propagation) [EaG09].">BBP</a>.  <a href="classdai_1_1BBPCostFunction.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1BBP.html">BBP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classdai_1_1BBP.html" title="Implements BBP (Back-Belief-Propagation) [EaG09].">BBP</a> (Back-Belief-Propagation) [<a class="el" href="bibliography.html#EaG09">EaG09</a>].  <a href="classdai_1_1BBP.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1BipartiteGraph.html">BipartiteGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the neighborhood structure of nodes in an undirected, bipartite graph.  <a href="classdai_1_1BipartiteGraph.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1BP.html">BP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate inference algorithm "(Loopy) Belief Propagation".  <a href="classdai_1_1BP.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1BP__dual.html">BP_dual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates both types of <a class="el" href="classdai_1_1BP.html" title="Approximate inference algorithm &quot;(Loopy) Belief Propagation&quot;.">BP</a> messages and their normalizers from an <a class="el" href="classdai_1_1InfAlg.html" title="InfAlg is an abstract base class, defining the common interface of all inference algorithms in libDAI...">InfAlg</a>.  <a href="classdai_1_1BP__dual.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1CBP.html">CBP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for <a class="el" href="classdai_1_1CBP.html" title="Class for CBP (Conditioned Belief Propagation) [EaG09].">CBP</a> (Conditioned Belief Propagation) [<a class="el" href="bibliography.html#EaG09">EaG09</a>].  <a href="classdai_1_1CBP.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1ClusterGraph.html">ClusterGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classdai_1_1ClusterGraph.html" title="A ClusterGraph is a hypergraph with variables as nodes, and &quot;clusters&quot; (sets of variables) as hypered...">ClusterGraph</a> is a hypergraph with variables as nodes, and "clusters" (sets of variables) as hyperedges.  <a href="classdai_1_1ClusterGraph.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1sequentialVariableElimination.html">sequentialVariableElimination</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper object for <a class="el" href="classdai_1_1ClusterGraph.html#af5933f4b66937cee2cec9b5805d718ca" title="Performs Variable Elimination, keeping track of the interactions that are created along the way...">dai::ClusterGraph::VarElim()</a>  <a href="classdai_1_1sequentialVariableElimination.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1greedyVariableElimination.html">greedyVariableElimination</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper object for <a class="el" href="classdai_1_1ClusterGraph.html#af5933f4b66937cee2cec9b5805d718ca" title="Performs Variable Elimination, keeping track of the interactions that are created along the way...">dai::ClusterGraph::VarElim()</a>  <a href="classdai_1_1greedyVariableElimination.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1DAG.html">DAG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the neighborhood structure of nodes in a directed cyclic graph.  <a href="classdai_1_1DAG.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1InfAlg.html">InfAlg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdai_1_1InfAlg.html" title="InfAlg is an abstract base class, defining the common interface of all inference algorithms in libDAI...">InfAlg</a> is an abstract base class, defining the common interface of all inference algorithms in libDAI.  <a href="classdai_1_1InfAlg.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1DAIAlg.html">DAIAlg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines the abstract base class <a class="el" href="classdai_1_1InfAlg.html" title="InfAlg is an abstract base class, defining the common interface of all inference algorithms in libDAI...">InfAlg</a> with a graphical model (e.g., a <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a> or <a class="el" href="classdai_1_1RegionGraph.html" title="A RegionGraph combines a bipartite graph consisting of outer regions (type FRegion) and inner regions...">RegionGraph</a>).  <a href="classdai_1_1DAIAlg.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1DecMAP.html">DecMAP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate inference algorithm <a class="el" href="classdai_1_1DecMAP.html" title="Approximate inference algorithm DecMAP, which constructs a MAP state by decimation.">DecMAP</a>, which constructs a MAP state by decimation.  <a href="classdai_1_1DecMAP.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1ParameterEstimation.html">ParameterEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for parameter estimation methods.  <a href="classdai_1_1ParameterEstimation.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1CondProbEstimation.html">CondProbEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the parameters of a conditional probability table, using pseudocounts.  <a href="classdai_1_1CondProbEstimation.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1SharedParameters.html">SharedParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a single factor or set of factors whose parameters should be estimated.  <a href="classdai_1_1SharedParameters.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1MaximizationStep.html">MaximizationStep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classdai_1_1MaximizationStep.html" title="A MaximizationStep groups together several parameter estimation tasks (SharedParameters objects) into...">MaximizationStep</a> groups together several parameter estimation tasks (<a class="el" href="classdai_1_1SharedParameters.html" title="Represents a single factor or set of factors whose parameters should be estimated.">SharedParameters</a> objects) into a single unit.  <a href="classdai_1_1MaximizationStep.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1EMAlg.html">EMAlg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdai_1_1EMAlg.html" title="EMAlg performs Expectation Maximization to learn factor parameters.">EMAlg</a> performs Expectation Maximization to learn factor parameters.  <a href="classdai_1_1EMAlg.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1Evidence.html">Evidence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a data set consisting of multiple samples, where each sample is the observed joint state of some variables.  <a href="classdai_1_1Evidence.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1ExactInf.html">ExactInf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exact inference algorithm using brute force enumeration (mainly useful for testing purposes)  <a href="classdai_1_1ExactInf.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1Exception.html">Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error handling in libDAI is done by throwing an instance of the <a class="el" href="classdai_1_1Exception.html" title="Error handling in libDAI is done by throwing an instance of the Exception class.">Exception</a> class.  <a href="classdai_1_1Exception.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TFactor.html">TFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a (probability) factor.  <a href="classdai_1_1TFactor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a factor graph.  <a href="classdai_1_1FactorGraph.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TFactorSp.html">TFactorSp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a (probability) factor.  <a href="classdai_1_1TFactorSp.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1FBP.html">FBP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate inference algorithm "Fractional Belief Propagation" [<a class="el" href="bibliography.html#WiH03">WiH03</a>].  <a href="classdai_1_1FBP.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__id.html">fo_id</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object that returns the value itself.  <a href="structdai_1_1fo__id.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__abs.html">fo_abs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object that takes the absolute value.  <a href="structdai_1_1fo__abs.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__exp.html">fo_exp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object that takes the exponent.  <a href="structdai_1_1fo__exp.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__log.html">fo_log</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object that takes the logarithm.  <a href="structdai_1_1fo__log.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__log0.html">fo_log0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object that takes the logarithm, except that log(0) is defined to be 0.  <a href="structdai_1_1fo__log0.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__inv.html">fo_inv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object that takes the inverse.  <a href="structdai_1_1fo__inv.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__inv0.html">fo_inv0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object that takes the inverse, except that 1/0 is defined to be 0.  <a href="structdai_1_1fo__inv0.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__plog0p.html">fo_plog0p</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object that returns p*log0(p)  <a href="structdai_1_1fo__plog0p.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__divides0.html">fo_divides0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object similar to std::divides(), but different in that dividing by zero results in zero.  <a href="structdai_1_1fo__divides0.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__KL.html">fo_KL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object useful for calculating the KL distance.  <a href="structdai_1_1fo__KL.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__Hellinger.html">fo_Hellinger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object useful for calculating the Hellinger distance.  <a href="structdai_1_1fo__Hellinger.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__pow.html">fo_pow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object that returns x to the power y.  <a href="structdai_1_1fo__pow.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__max.html">fo_max</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object that returns the maximum of two values.  <a href="structdai_1_1fo__max.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__min.html">fo_min</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object that returns the minimum of two values.  <a href="structdai_1_1fo__min.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1fo__absdiff.html">fo_absdiff</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object that returns the absolute difference of x and y.  <a href="structdai_1_1fo__absdiff.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1Gibbs.html">Gibbs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate inference algorithm "Gibbs sampling".  <a href="classdai_1_1Gibbs.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1Neighbor.html">Neighbor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the neighbor relationship of two nodes in a graph.  <a href="structdai_1_1Neighbor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the neighborhood structure of nodes in an undirected graph.  <a href="classdai_1_1GraphAL.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1HAK.html">HAK</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate inference algorithm: implementation of single-loop ("Generalized Belief Propagation") and double-loop algorithms by Heskes, Albers and Kappen [<a class="el" href="bibliography.html#HAK03">HAK03</a>].  <a href="classdai_1_1HAK.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1IndexFor.html">IndexFor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tool for looping over the states of several variables.  <a href="classdai_1_1IndexFor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1Permute.html">Permute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tool for calculating permutations of linear indices of multi-dimensional arrays.  <a href="classdai_1_1Permute.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1multifor.html">multifor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">multifor makes it easy to perform a dynamic number of nested <code>for</code> loops.  <a href="classdai_1_1multifor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1State.html">State</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes it easy to iterate over all possible joint states of variables within a <a class="el" href="classdai_1_1VarSet.html" title="Represents a set of variables.">VarSet</a>.  <a href="classdai_1_1State.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1JTree.html">JTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exact inference algorithm using junction tree.  <a href="classdai_1_1JTree.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1LC.html">LC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate inference algorithm "Loop Corrected Belief Propagation" [<a class="el" href="bibliography.html#MoK07">MoK07</a>].  <a href="classdai_1_1LC.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1MF.html">MF</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate inference algorithm "Mean Field".  <a href="classdai_1_1MF.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1MR.html">MR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate inference algorithm by Montanari and Rizzo [<a class="el" href="bibliography.html#MoR05">MoR05</a>].  <a href="classdai_1_1MR.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProb.html">TProb</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector with entries of type <em>T</em>.  <a href="classdai_1_1TProb.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TProbSp.html">TProbSp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector with entries of type <em>T</em>.  <a href="classdai_1_1TProbSp.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1PropertySet.html">PropertySet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a set of properties, mapping keys (of type PropertyKey) to values (of type PropertyValue)  <a href="classdai_1_1PropertySet.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1Region.html">Region</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classdai_1_1Region.html" title="A Region is a set of variables with a counting number.">Region</a> is a set of variables with a counting number.  <a href="classdai_1_1Region.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1FRegion.html">FRegion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classdai_1_1FRegion.html" title="An FRegion is a factor with a counting number.">FRegion</a> is a factor with a counting number.  <a href="classdai_1_1FRegion.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1RegionGraph.html">RegionGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classdai_1_1RegionGraph.html" title="A RegionGraph combines a bipartite graph consisting of outer regions (type FRegion) and inner regions...">RegionGraph</a> combines a bipartite graph consisting of outer regions (type <a class="el" href="classdai_1_1FRegion.html" title="An FRegion is a factor with a counting number.">FRegion</a>) and inner regions (type <a class="el" href="classdai_1_1Region.html" title="A Region is a set of variables with a counting number.">Region</a>) with a <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a>.  <a href="classdai_1_1RegionGraph.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1SmallSet.html">SmallSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a set; the implementation is optimized for a small number of elements.  <a href="classdai_1_1SmallSet.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdai_1_1first__less.html">first_less</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object that returns true if a.first &lt; b.first.  <a href="structdai_1_1first__less.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TreeEP.html">TreeEP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate inference algorithm "Tree Expectation Propagation" [<a class="el" href="bibliography.html#MiQ04">MiQ04</a>].  <a href="classdai_1_1TreeEP.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1TRWBP.html">TRWBP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate inference algorithm "Tree-Reweighted Belief Propagation" [<a class="el" href="bibliography.html#WJW03">WJW03</a>].  <a href="classdai_1_1TRWBP.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1hash__map.html">hash_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdai_1_1hash__map.html" title="hash_map is an alias for std::tr1::unordered_map.">hash_map</a> is an alias for <code>std::tr1::unordered_map</code>.  <a href="classdai_1_1hash__map.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1Var.html">Var</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a discrete random variable.  <a href="classdai_1_1Var.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1VarSet.html">VarSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a set of variables.  <a href="classdai_1_1VarSet.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1DEdge.html">DEdge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a directed edge.  <a href="classdai_1_1DEdge.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1UEdge.html">UEdge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an undirected edge.  <a href="classdai_1_1UEdge.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1GraphEL.html">GraphEL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an undirected graph, implemented as a std::set of undirected edges.  <a href="classdai_1_1GraphEL.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1WeightedGraph.html">WeightedGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an undirected weighted graph, with weights of type <em>T</em>, implemented as a std::map mapping undirected edges to weights.  <a href="classdai_1_1WeightedGraph.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdai_1_1RootedTree.html">RootedTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a rooted tree, implemented as a vector of directed edges.  <a href="classdai_1_1RootedTree.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a18604ca744bd93c2946b6207472414a6"><td class="memItemLeft" align="right" valign="top">typedef boost::mt19937&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a18604ca744bd93c2946b6207472414a6">_rnd_gen_type</a></td></tr>
<tr class="memdesc:a18604ca744bd93c2946b6207472414a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of global random number generator.  <a href="#a18604ca744bd93c2946b6207472414a6"></a><br/></td></tr>
<tr class="memitem:a4d66d71f2b2c7ac4845bba057eb7cee5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classdai_1_1DAIAlg.html">DAIAlg</a>&lt; <a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a4d66d71f2b2c7ac4845bba057eb7cee5">DAIAlgFG</a></td></tr>
<tr class="memdesc:a4d66d71f2b2c7ac4845bba057eb7cee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for inference algorithms that operate on a <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a>.  <a href="#a4d66d71f2b2c7ac4845bba057eb7cee5"></a><br/></td></tr>
<tr class="memitem:a6b5cb6d79a324915d2c88ad368437e21"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classdai_1_1DAIAlg.html">DAIAlg</a>&lt; <a class="el" href="classdai_1_1RegionGraph.html">RegionGraph</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a6b5cb6d79a324915d2c88ad368437e21">DAIAlgRG</a></td></tr>
<tr class="memdesc:a6b5cb6d79a324915d2c88ad368437e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for inference algorithms that operate on a <a class="el" href="classdai_1_1RegionGraph.html" title="A RegionGraph combines a bipartite graph consisting of outer regions (type FRegion) and inner regions...">RegionGraph</a>.  <a href="#a6b5cb6d79a324915d2c88ad368437e21"></a><br/></td></tr>
<tr class="memitem:a7515abf9952cd312e95a34ada0670e85"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classdai_1_1TFactor.html">TFactor</a>&lt; <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a7515abf9952cd312e95a34ada0670e85">Factor</a></td></tr>
<tr class="memdesc:a7515abf9952cd312e95a34ada0670e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a factor with values of type <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf" title="Real number (alias for double, which could be changed to long double if necessary)">dai::Real</a>.  <a href="#a7515abf9952cd312e95a34ada0670e85"></a><br/></td></tr>
<tr class="memitem:a14c563f2e5f6acf255903cae5c3b415c"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="structdai_1_1Neighbor.html">Neighbor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a14c563f2e5f6acf255903cae5c3b415c">Neighbors</a></td></tr>
<tr class="memdesc:a14c563f2e5f6acf255903cae5c3b415c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the set of neighbors of some node in a graph.  <a href="#a14c563f2e5f6acf255903cae5c3b415c"></a><br/></td></tr>
<tr class="memitem:aca51f13415f708db9eabda981b107a14"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#aca51f13415f708db9eabda981b107a14">Edge</a></td></tr>
<tr class="memdesc:aca51f13415f708db9eabda981b107a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an edge in a graph: an Edge(<em>i</em>,<em>j</em>) corresponds to the edge between node <em>i</em> and node <em>j</em>.  <a href="#aca51f13415f708db9eabda981b107a14"></a><br/></td></tr>
<tr class="memitem:a90f06137ef74bb483e30ee2c7e31b2c8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classdai_1_1TProb.html">TProb</a>&lt; <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a90f06137ef74bb483e30ee2c7e31b2c8">Prob</a></td></tr>
<tr class="memdesc:a90f06137ef74bb483e30ee2c7e31b2c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector with entries of type <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf" title="Real number (alias for double, which could be changed to long double if necessary)">dai::Real</a>.  <a href="#a90f06137ef74bb483e30ee2c7e31b2c8"></a><br/></td></tr>
<tr class="memitem:acc877a85f4f4dbb6a0d58c434bb2b996"><td class="memItemLeft" align="right" valign="top">typedef std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#acc877a85f4f4dbb6a0d58c434bb2b996">PropertyKey</a></td></tr>
<tr class="memdesc:acc877a85f4f4dbb6a0d58c434bb2b996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the key of a Property.  <a href="#acc877a85f4f4dbb6a0d58c434bb2b996"></a><br/></td></tr>
<tr class="memitem:aeb056b768d73d02c5796c4012f4170c7"><td class="memItemLeft" align="right" valign="top">typedef boost::any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#aeb056b768d73d02c5796c4012f4170c7">PropertyValue</a></td></tr>
<tr class="memdesc:aeb056b768d73d02c5796c4012f4170c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the value of a Property.  <a href="#aeb056b768d73d02c5796c4012f4170c7"></a><br/></td></tr>
<tr class="memitem:acbc670414e04eecf5c284e42d9d036e3"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; <a class="el" href="namespacedai.html#acc877a85f4f4dbb6a0d58c434bb2b996">PropertyKey</a>, <br class="typebreak"/>
<a class="el" href="namespacedai.html#aeb056b768d73d02c5796c4012f4170c7">PropertyValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#acbc670414e04eecf5c284e42d9d036e3">Property</a></td></tr>
<tr class="memdesc:acbc670414e04eecf5c284e42d9d036e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Property is a pair of a key and a corresponding value.  <a href="#acbc670414e04eecf5c284e42d9d036e3"></a><br/></td></tr>
<tr class="memitem:ae7d0472fdc89a8635825d01940e91cbf"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a></td></tr>
<tr class="memdesc:ae7d0472fdc89a8635825d01940e91cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real number (alias for <code>double</code>, which could be changed to <code>long double</code> if necessary)  <a href="#ae7d0472fdc89a8635825d01940e91cbf"></a><br/></td></tr>
<tr class="memitem:acc277bd4f0edae875fca22f063a37220"><td class="memItemLeft" align="right" valign="top">typedef mpz_class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#acc277bd4f0edae875fca22f063a37220">BigInt</a></td></tr>
<tr class="memdesc:acc277bd4f0edae875fca22f063a37220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arbitrary precision integer number.  <a href="#acc277bd4f0edae875fca22f063a37220"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae0d0ef753bd0ba57586e556ab6312677"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ae0d0ef753bd0ba57586e556ab6312677">ProbNormType</a> { <b>NORMPROB</b>, 
<b>NORMLINF</b>
 }</td></tr>
<tr class="memdesc:ae0d0ef753bd0ba57586e556ab6312677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates different ways of normalizing a probability measure.  <a href="namespacedai.html#ae0d0ef753bd0ba57586e556ab6312677">More...</a><br/></td></tr>
<tr class="memitem:aa2735a823696443089d2de23e8ee6ecb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#aa2735a823696443089d2de23e8ee6ecb">ProbDistType</a> { <br/>
&#160;&#160;<b>DISTL1</b>, 
<b>DISTLINF</b>, 
<b>DISTTV</b>, 
<b>DISTKL</b>, 
<br/>
&#160;&#160;<b>DISTHEL</b>
<br/>
 }</td></tr>
<tr class="memdesc:aa2735a823696443089d2de23e8ee6ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates different distance measures between probability measures.  <a href="namespacedai.html#aa2735a823696443089d2de23e8ee6ecb">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa4fae69226f56a38066c2cac1a343fe1"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#aa4fae69226f56a38066c2cac1a343fe1">builtinInfAlgs</a> ()</td></tr>
<tr class="memdesc:aa4fae69226f56a38066c2cac1a343fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map that contains for each built-in inference algorithm its name and a pointer to an object of that type.  <a href="#aa4fae69226f56a38066c2cac1a343fe1"></a><br/></td></tr>
<tr class="memitem:a16d6acf1e82fdf9ae23b655a12517b91"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a16d6acf1e82fdf9ae23b655a12517b91">builtinInfAlgNames</a> ()</td></tr>
<tr class="memdesc:a16d6acf1e82fdf9ae23b655a12517b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a set of names of all available inference algorithms.  <a href="#a16d6acf1e82fdf9ae23b655a12517b91"></a><br/></td></tr>
<tr class="memitem:a4b9e5254e7ec388e69aa68dfc54509e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a4b9e5254e7ec388e69aa68dfc54509e0">newInfAlg</a> (const std::string &amp;name, const <a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a> &amp;fg, const <a class="el" href="classdai_1_1PropertySet.html">PropertySet</a> &amp;opts)</td></tr>
<tr class="memdesc:a4b9e5254e7ec388e69aa68dfc54509e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new inference algorithm.  <a href="#a4b9e5254e7ec388e69aa68dfc54509e0"></a><br/></td></tr>
<tr class="memitem:a246c23914fee45f8b7f01f9073bdd6fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a246c23914fee45f8b7f01f9073bdd6fe">newInfAlgFromString</a> (const std::string &amp;nameOpts, const <a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a> &amp;fg)</td></tr>
<tr class="memdesc:a246c23914fee45f8b7f01f9073bdd6fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new inference algorithm.  <a href="#a246c23914fee45f8b7f01f9073bdd6fe"></a><br/></td></tr>
<tr class="memitem:af688c62fd7c8dff22e24835547cec7e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#af688c62fd7c8dff22e24835547cec7e7">newInfAlgFromString</a> (const std::string &amp;nameOpts, const <a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a> &amp;fg, const std::map&lt; std::string, std::string &gt; &amp;aliases)</td></tr>
<tr class="memdesc:af688c62fd7c8dff22e24835547cec7e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new inference algorithm.  <a href="#af688c62fd7c8dff22e24835547cec7e7"></a><br/></td></tr>
<tr class="memitem:a8f6e164a012fff145d683d64ac4d7b7f"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, <br class="typebreak"/>
<a class="el" href="classdai_1_1PropertySet.html">PropertySet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a8f6e164a012fff145d683d64ac4d7b7f">parseNameProperties</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a8f6e164a012fff145d683d64ac4d7b7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the name and property set from a string <em>s</em> in the format "name[key1=val1,key2=val2,...]" or "name".  <a href="#a8f6e164a012fff145d683d64ac4d7b7f"></a><br/></td></tr>
<tr class="memitem:a18ef8153f219f1cad48e4f1f1a00a2a6"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, <br class="typebreak"/>
<a class="el" href="classdai_1_1PropertySet.html">PropertySet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a18ef8153f219f1cad48e4f1f1a00a2a6">parseNameProperties</a> (const std::string &amp;s, const std::map&lt; std::string, std::string &gt; &amp;aliases)</td></tr>
<tr class="memdesc:a18ef8153f219f1cad48e4f1f1a00a2a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the name and property set from a string <em>s</em> in the format "name[key1=val1,key2=val2,...]" or "name", performing alias substitution.  <a href="#a18ef8153f219f1cad48e4f1f1a00a2a6"></a><br/></td></tr>
<tr class="memitem:afffceb04ae10c57ff54a9c57ac3bfc29"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <br class="typebreak"/>
std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#afffceb04ae10c57ff54a9c57ac3bfc29">readAliasesFile</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:afffceb04ae10c57ff54a9c57ac3bfc29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads aliases from file named <em>filename</em>.  <a href="#afffceb04ae10c57ff54a9c57ac3bfc29"></a><br/></td></tr>
<tr class="memitem:acfb030b9c48de7885795f4d03d7226ee"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#acfb030b9c48de7885795f4d03d7226ee">getFactorEntryForState</a> (const <a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a> &amp;fg, size_t I, const vector&lt; size_t &gt; &amp;state)</td></tr>
<tr class="memdesc:acfb030b9c48de7885795f4d03d7226ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the entry of the I'th factor corresponding to a global state.  <a href="#acfb030b9c48de7885795f4d03d7226ee"></a><br/></td></tr>
<tr class="memitem:a6154e193b6b0581b1552728a03b26f39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6154e193b6b0581b1552728a03b26f39"></a>
<a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>numericBBPTest</b> (const <a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> &amp;bp, const std::vector&lt; size_t &gt; *state, const <a class="el" href="classdai_1_1PropertySet.html">PropertySet</a> &amp;bbp_props, const <a class="el" href="classdai_1_1BBPCostFunction.html">BBPCostFunction</a> &amp;cfn, <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> h)</td></tr>
<tr class="memitem:a7796e22fdea01e8fe5e4d51b85ae0548"><td class="memItemLeft" align="right" valign="top">vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a7796e22fdea01e8fe5e4d51b85ae0548">complement</a> (vector&lt; size_t &gt; &amp;xis, size_t n_states)</td></tr>
<tr class="memdesc:a7796e22fdea01e8fe5e4d51b85ae0548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a sorted vector of states <em>xis</em> and total state count <em>n_states</em>, return a vector of states not in <em>xis</em>.  <a href="#a7796e22fdea01e8fe5e4d51b85ae0548"></a><br/></td></tr>
<tr class="memitem:a1091a5da35d620692783a17dbf265158"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a1091a5da35d620692783a17dbf265158">unSoftMax</a> (<a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> a, <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> b)</td></tr>
<tr class="memdesc:a1091a5da35d620692783a17dbf265158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$\frac{\exp(a)}{\exp(a)+\exp(b)}$" src="form_0.png"/>.  <a href="#a1091a5da35d620692783a17dbf265158"></a><br/></td></tr>
<tr class="memitem:a56e006b34155719d5ab9c0dbc9bd57f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a56e006b34155719d5ab9c0dbc9bd57f4">logSumExp</a> (<a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> a, <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> b)</td></tr>
<tr class="memdesc:a56e006b34155719d5ab9c0dbc9bd57f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes log of sum of exponents, i.e., <img class="formulaInl" alt="$\log\left(\exp(a) + \exp(b)\right)$" src="form_1.png"/>.  <a href="#a56e006b34155719d5ab9c0dbc9bd57f4"></a><br/></td></tr>
<tr class="memitem:aee9a0cc9279a7add0849f964e3bdfbed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#aee9a0cc9279a7add0849f964e3bdfbed">dist</a> (const vector&lt; <a class="el" href="namespacedai.html#a7515abf9952cd312e95a34ada0670e85">Factor</a> &gt; &amp;b1, const vector&lt; <a class="el" href="namespacedai.html#a7515abf9952cd312e95a34ada0670e85">Factor</a> &gt; &amp;b2, size_t nv)</td></tr>
<tr class="memdesc:aee9a0cc9279a7add0849f964e3bdfbed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute sum of pairwise L-infinity distances of the first <em>nv</em> factors in each vector.  <a href="#aee9a0cc9279a7add0849f964e3bdfbed"></a><br/></td></tr>
<tr class="memitem:aadf664acf42371b8f25ade335a805da1"><td class="memItemLeft" align="right" valign="top">static vector&lt; <a class="el" href="namespacedai.html#a7515abf9952cd312e95a34ada0670e85">Factor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#aadf664acf42371b8f25ade335a805da1">mixBeliefs</a> (<a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> p, const vector&lt; <a class="el" href="namespacedai.html#a7515abf9952cd312e95a34ada0670e85">Factor</a> &gt; &amp;b, const vector&lt; <a class="el" href="namespacedai.html#a7515abf9952cd312e95a34ada0670e85">Factor</a> &gt; &amp;c)</td></tr>
<tr class="memdesc:aadf664acf42371b8f25ade335a805da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a vector of mixtures p * b + (1-p) * c.  <a href="#aadf664acf42371b8f25ade335a805da1"></a><br/></td></tr>
<tr class="memitem:ab41645939efa15bb66b14e20d1641c8f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab41645939efa15bb66b14e20d1641c8f"></a>
std::pair&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>BBPFindClampVar</b> (const <a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> &amp;in_bp, bool clampingVar, const <a class="el" href="classdai_1_1PropertySet.html">PropertySet</a> &amp;bbp_props, const <a class="el" href="classdai_1_1BBPCostFunction.html">BBPCostFunction</a> &amp;cfn, <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> *maxVarOut)</td></tr>
<tr class="memitem:abb00ff16fe071140d9eb4c555c43e5d3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#abb00ff16fe071140d9eb4c555c43e5d3">eliminationCost_MinNeighbors</a> (const <a class="el" href="classdai_1_1ClusterGraph.html">ClusterGraph</a> &amp;cl, size_t i)</td></tr>
<tr class="memdesc:abb00ff16fe071140d9eb4c555c43e5d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates cost of eliminating the <em>i</em> 'th variable from cluster graph <em>cl</em> according to the "MinNeighbors" criterion.  <a href="#abb00ff16fe071140d9eb4c555c43e5d3"></a><br/></td></tr>
<tr class="memitem:a68ec048cdbefcf8a488469dd14938452"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a68ec048cdbefcf8a488469dd14938452">eliminationCost_MinWeight</a> (const <a class="el" href="classdai_1_1ClusterGraph.html">ClusterGraph</a> &amp;cl, size_t i)</td></tr>
<tr class="memdesc:a68ec048cdbefcf8a488469dd14938452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates cost of eliminating the <em>i</em> 'th variable from cluster graph <em>cl</em> according to the "MinWeight" criterion.  <a href="#a68ec048cdbefcf8a488469dd14938452"></a><br/></td></tr>
<tr class="memitem:ab6cfdf0bf047e72e324c04e96d310edb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ab6cfdf0bf047e72e324c04e96d310edb">eliminationCost_MinFill</a> (const <a class="el" href="classdai_1_1ClusterGraph.html">ClusterGraph</a> &amp;cl, size_t i)</td></tr>
<tr class="memdesc:ab6cfdf0bf047e72e324c04e96d310edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates cost of eliminating the <em>i</em> 'th variable from cluster graph <em>cl</em> according to the "MinFill" criterion.  <a href="#ab6cfdf0bf047e72e324c04e96d310edb"></a><br/></td></tr>
<tr class="memitem:a990ea70014c5c6a90932d9cee11f393b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a990ea70014c5c6a90932d9cee11f393b">eliminationCost_WeightedMinFill</a> (const <a class="el" href="classdai_1_1ClusterGraph.html">ClusterGraph</a> &amp;cl, size_t i)</td></tr>
<tr class="memdesc:a990ea70014c5c6a90932d9cee11f393b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates cost of eliminating the <em>i</em> 'th variable from cluster graph <em>cl</em> according to the "WeightedMinFill" criterion.  <a href="#a990ea70014c5c6a90932d9cee11f393b"></a><br/></td></tr>
<tr class="memitem:ad6e23438f9dd7ea3e7514c3ba6238875"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ad6e23438f9dd7ea3e7514c3ba6238875">createFG</a> (const <a class="el" href="classdai_1_1GraphAL.html">GraphAL</a> &amp;G, FactorType ft, size_t states, const <a class="el" href="classdai_1_1PropertySet.html">PropertySet</a> &amp;props)</td></tr>
<tr class="memdesc:ad6e23438f9dd7ea3e7514c3ba6238875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a factor graph from a pairwise interactions graph.  <a href="#ad6e23438f9dd7ea3e7514c3ba6238875"></a><br/></td></tr>
<tr class="memitem:a269bd60101452a427cc794572a6018a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a269bd60101452a427cc794572a6018a6">createHOIFG</a> (size_t N, size_t M, size_t k, <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> beta)</td></tr>
<tr class="memdesc:a269bd60101452a427cc794572a6018a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random factor graph with higher-order interactions.  <a href="#a269bd60101452a427cc794572a6018a6"></a><br/></td></tr>
<tr class="memitem:a5b4bd583e26a7cf273d31f65602bf997"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1BipartiteGraph.html">BipartiteGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a5b4bd583e26a7cf273d31f65602bf997">createRandomBipartiteGraph</a> (size_t N1, size_t N2, size_t d1, size_t d2)</td></tr>
<tr class="memdesc:a5b4bd583e26a7cf273d31f65602bf997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a regular random bipartite graph.  <a href="#a5b4bd583e26a7cf273d31f65602bf997"></a><br/></td></tr>
<tr class="memitem:afcfa4209cac6166d01a9d1d59f96f3e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#afcfa4209cac6166d01a9d1d59f96f3e2">powmod</a> (int x, int n, int p)</td></tr>
<tr class="memdesc:afcfa4209cac6166d01a9d1d59f96f3e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns x**n % p, assuming p is prime.  <a href="#afcfa4209cac6166d01a9d1d59f96f3e2"></a><br/></td></tr>
<tr class="memitem:a48699de918fb0dcf60451b5706417f45"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a48699de918fb0dcf60451b5706417f45">order</a> (int x, int p)</td></tr>
<tr class="memdesc:a48699de918fb0dcf60451b5706417f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns order of x in GF(p) with p prime.  <a href="#a48699de918fb0dcf60451b5706417f45"></a><br/></td></tr>
<tr class="memitem:a8a874e49f4d4da3a5158291777f325d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a8a874e49f4d4da3a5158291777f325d3">isPrime</a> (size_t n)</td></tr>
<tr class="memdesc:a8a874e49f4d4da3a5158291777f325d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether n is a prime number.  <a href="#a8a874e49f4d4da3a5158291777f325d3"></a><br/></td></tr>
<tr class="memitem:ab52c9df9be8edbd7f43664608c22cc9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1BipartiteGraph.html">BipartiteGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ab52c9df9be8edbd7f43664608c22cc9b">createSmallLDPCGraph</a> ()</td></tr>
<tr class="memdesc:ab52c9df9be8edbd7f43664608c22cc9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a regular LDPC graph with N=6, j=2, K=4, k=3.  <a href="#ab52c9df9be8edbd7f43664608c22cc9b"></a><br/></td></tr>
<tr class="memitem:ad4b22f71661686c7ee6af183ceb3180b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1BipartiteGraph.html">BipartiteGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ad4b22f71661686c7ee6af183ceb3180b">createGroupStructuredLDPCGraph</a> (size_t p, size_t j, size_t k)</td></tr>
<tr class="memdesc:ad4b22f71661686c7ee6af183ceb3180b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates group-structured LDPC code.  <a href="#ad4b22f71661686c7ee6af183ceb3180b"></a><br/></td></tr>
<tr class="memitem:a05a9012934012426c9ea6a5d8ba26a72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05a9012934012426c9ea6a5d8ba26a72"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>createParityCheck</b> (<a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> *result, size_t n, <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> eps)</td></tr>
<tr class="memitem:affbd147a343d77586a66047bca831612"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#affbd147a343d77586a66047bca831612">DAI_ENUM</a> (LDPCType, SMALL, GROUP, RANDOM)</td></tr>
<tr class="memdesc:affbd147a343d77586a66047bca831612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible LDPC structures.  <a href="#affbd147a343d77586a66047bca831612"></a><br/></td></tr>
<tr class="memitem:aab8aabfe0fcfd4b4bd24757c101449d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedai.html#a7515abf9952cd312e95a34ada0670e85">Factor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#aab8aabfe0fcfd4b4bd24757c101449d5">calcMarginal</a> (const <a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> &amp;obj, const <a class="el" href="classdai_1_1VarSet.html">VarSet</a> &amp;vs, bool reInit)</td></tr>
<tr class="memdesc:aab8aabfe0fcfd4b4bd24757c101449d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the marginal probability distribution for <em>vs</em> using inference algorithm <em>obj</em>.  <a href="#aab8aabfe0fcfd4b4bd24757c101449d5"></a><br/></td></tr>
<tr class="memitem:a82e775a1e2908856f13fa1aa7c081d4c"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="namespacedai.html#a7515abf9952cd312e95a34ada0670e85">Factor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a82e775a1e2908856f13fa1aa7c081d4c">calcPairBeliefs</a> (const <a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> &amp;obj, const <a class="el" href="classdai_1_1VarSet.html">VarSet</a> &amp;vs, bool reInit, bool accurate=false)</td></tr>
<tr class="memdesc:a82e775a1e2908856f13fa1aa7c081d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates beliefs for all pairs of variables in <em>vs</em> using inference algorithm <em>obj</em>.  <a href="#a82e775a1e2908856f13fa1aa7c081d4c"></a><br/></td></tr>
<tr class="memitem:ae686384295f9909532d78328f87ae260"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ae686384295f9909532d78328f87ae260">findMaximum</a> (const <a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> &amp;obj)</td></tr>
<tr class="memdesc:ae686384295f9909532d78328f87ae260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the joint state of all variables that has maximum probability, according to the inference algorithm <em>obj</em>.  <a href="#ae686384295f9909532d78328f87ae260"></a><br/></td></tr>
<tr class="memitem:a7dd9cb2405e798802d8cbb9b879fdf90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedai.html#a7515abf9952cd312e95a34ada0670e85">Factor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a7dd9cb2405e798802d8cbb9b879fdf90">createFactorIsing</a> (const <a class="el" href="classdai_1_1Var.html">Var</a> &amp;x, <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> h)</td></tr>
<tr class="memdesc:a7dd9cb2405e798802d8cbb9b879fdf90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a binary unnormalized single-variable factor <img class="formulaInl" alt="$ \exp(hx) $" src="form_69.png"/> where <img class="formulaInl" alt="$ x = \pm 1 $" src="form_70.png"/>.  <a href="#a7dd9cb2405e798802d8cbb9b879fdf90"></a><br/></td></tr>
<tr class="memitem:ade7f623237328458325bce5322abe03e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedai.html#a7515abf9952cd312e95a34ada0670e85">Factor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ade7f623237328458325bce5322abe03e">createFactorIsing</a> (const <a class="el" href="classdai_1_1Var.html">Var</a> &amp;x1, const <a class="el" href="classdai_1_1Var.html">Var</a> &amp;x2, <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> J)</td></tr>
<tr class="memdesc:ade7f623237328458325bce5322abe03e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a binary unnormalized pairwise factor <img class="formulaInl" alt="$ \exp(J x_1 x_2) $" src="form_71.png"/> where <img class="formulaInl" alt="$ x_1, x_2 = \pm 1 $" src="form_72.png"/>.  <a href="#ade7f623237328458325bce5322abe03e"></a><br/></td></tr>
<tr class="memitem:a6715831e60e66582bce1c69518a40dd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedai.html#a7515abf9952cd312e95a34ada0670e85">Factor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a6715831e60e66582bce1c69518a40dd3">createFactorExpGauss</a> (const <a class="el" href="classdai_1_1VarSet.html">VarSet</a> &amp;vs, <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> beta)</td></tr>
<tr class="memdesc:a6715831e60e66582bce1c69518a40dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random factor on the variables <em>vs</em> with strength <em>beta</em>.  <a href="#a6715831e60e66582bce1c69518a40dd3"></a><br/></td></tr>
<tr class="memitem:aab6d25e30baf39ea06c57b5f71c61a4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedai.html#a7515abf9952cd312e95a34ada0670e85">Factor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#aab6d25e30baf39ea06c57b5f71c61a4e">createFactorPotts</a> (const <a class="el" href="classdai_1_1Var.html">Var</a> &amp;x1, const <a class="el" href="classdai_1_1Var.html">Var</a> &amp;x2, <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> J)</td></tr>
<tr class="memdesc:aab6d25e30baf39ea06c57b5f71c61a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pairwise Potts factor <img class="formulaInl" alt="$ \exp( J \delta_{x_1, x_2} ) $" src="form_73.png"/>.  <a href="#aab6d25e30baf39ea06c57b5f71c61a4e"></a><br/></td></tr>
<tr class="memitem:adf624997c47362bc5db95242b76a66a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedai.html#a7515abf9952cd312e95a34ada0670e85">Factor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#adf624997c47362bc5db95242b76a66a4">createFactorDelta</a> (const <a class="el" href="classdai_1_1Var.html">Var</a> &amp;v, size_t state)</td></tr>
<tr class="memdesc:adf624997c47362bc5db95242b76a66a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Kronecker delta point mass.  <a href="#adf624997c47362bc5db95242b76a66a4"></a><br/></td></tr>
<tr class="memitem:aa9aa5a66a5df1ae48e29c4ad0965f3c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedai.html#a7515abf9952cd312e95a34ada0670e85">Factor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#aa9aa5a66a5df1ae48e29c4ad0965f3c6">createFactorDelta</a> (const <a class="el" href="classdai_1_1VarSet.html">VarSet</a> &amp;vs, size_t state)</td></tr>
<tr class="memdesc:aa9aa5a66a5df1ae48e29c4ad0965f3c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Kronecker delta point mass.  <a href="#aa9aa5a66a5df1ae48e29c4ad0965f3c6"></a><br/></td></tr>
<tr class="memitem:a57fa52134afbd3da21c99975fbba7080"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a57fa52134afbd3da21c99975fbba7080">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a> &amp;fg)</td></tr>
<tr class="memdesc:a57fa52134afbd3da21c99975fbba7080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a> to an output stream.  <a href="#a57fa52134afbd3da21c99975fbba7080"></a><br/></td></tr>
<tr class="memitem:ab1b9d59848e415c32330d4a7cbb3269a"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ab1b9d59848e415c32330d4a7cbb3269a">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a> &amp;fg)</td></tr>
<tr class="memdesc:ab1b9d59848e415c32330d4a7cbb3269a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a> from an input stream.  <a href="#ab1b9d59848e415c32330d4a7cbb3269a"></a><br/></td></tr>
<tr class="memitem:a9fcdb2332486b1b9944a551040b8bcf6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9fcdb2332486b1b9944a551040b8bcf6"></a>
std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getGibbsState</b> (const <a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a> &amp;fg, size_t maxiter)</td></tr>
<tr class="memitem:aedbe32ae13acdd8b62050b18e81a53ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#aedbe32ae13acdd8b62050b18e81a53ea">createGraphFull</a> (size_t N)</td></tr>
<tr class="memdesc:aedbe32ae13acdd8b62050b18e81a53ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a fully-connected graph with <em>N</em> nodes.  <a href="#aedbe32ae13acdd8b62050b18e81a53ea"></a><br/></td></tr>
<tr class="memitem:aaeeffaf06b9cd2fecccaf2bf773baed7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#aaeeffaf06b9cd2fecccaf2bf773baed7">createGraphGrid</a> (size_t N1, size_t N2, bool periodic)</td></tr>
<tr class="memdesc:aaeeffaf06b9cd2fecccaf2bf773baed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a two-dimensional rectangular grid of <em>N1</em> by <em>N2</em> nodes, which can be <em>periodic</em>.  <a href="#aaeeffaf06b9cd2fecccaf2bf773baed7"></a><br/></td></tr>
<tr class="memitem:a9950d08bd6190ea12f50b4be6f2584cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a9950d08bd6190ea12f50b4be6f2584cf">createGraphGrid3D</a> (size_t N1, size_t N2, size_t N3, bool periodic)</td></tr>
<tr class="memdesc:a9950d08bd6190ea12f50b4be6f2584cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a three-dimensional rectangular grid of <em>N1</em> by <em>N2</em> by <em>N3</em> nodes, which can be <em>periodic</em>.  <a href="#a9950d08bd6190ea12f50b4be6f2584cf"></a><br/></td></tr>
<tr class="memitem:a7f65fc1665a6fa04b1b6897a4551bccc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a7f65fc1665a6fa04b1b6897a4551bccc">createGraphLoop</a> (size_t N)</td></tr>
<tr class="memdesc:a7f65fc1665a6fa04b1b6897a4551bccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a graph consisting of a single loop of <em>N</em> nodes.  <a href="#a7f65fc1665a6fa04b1b6897a4551bccc"></a><br/></td></tr>
<tr class="memitem:ad3fbe55f9fdb020e7a2b04f1d2451d20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ad3fbe55f9fdb020e7a2b04f1d2451d20">createGraphTree</a> (size_t N)</td></tr>
<tr class="memdesc:ad3fbe55f9fdb020e7a2b04f1d2451d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a random tree-structured graph of <em>N</em> nodes.  <a href="#ad3fbe55f9fdb020e7a2b04f1d2451d20"></a><br/></td></tr>
<tr class="memitem:abfd6bb3f4b6135a99a68b9b13bee8bae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#abfd6bb3f4b6135a99a68b9b13bee8bae">createGraphRegular</a> (size_t N, size_t d)</td></tr>
<tr class="memdesc:abfd6bb3f4b6135a99a68b9b13bee8bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a random regular graph of <em>N</em> nodes with uniform connectivity <em>d</em>.  <a href="#abfd6bb3f4b6135a99a68b9b13bee8bae"></a><br/></td></tr>
<tr class="memitem:ae412446097e88867fc9a327d07f12daa"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae412446097e88867fc9a327d07f12daa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TFactor.html">TFactor</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#ae412446097e88867fc9a327d07f12daa">makePositive</a> (<a class="el" href="classdai_1_1TFactor.html">TFactor</a>&lt; T &gt; &amp;f, T epsilon)</td></tr>
<tr class="memdesc:ae412446097e88867fc9a327d07f12daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets factor entries that lie between 0 and <em>epsilon</em> to <em>epsilon</em>.  <a href="#ae412446097e88867fc9a327d07f12daa"></a><br/></td></tr>
<tr class="memitem:a47ac972d2a1556524159ff0765ae19c5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a47ac972d2a1556524159ff0765ae19c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1TFactor.html">TFactor</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#a47ac972d2a1556524159ff0765ae19c5">makeZero</a> (<a class="el" href="classdai_1_1TFactor.html">TFactor</a>&lt; T &gt; &amp;f, T epsilon)</td></tr>
<tr class="memdesc:a47ac972d2a1556524159ff0765ae19c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets factor entries that are smaller (in absolute value) than <em>epsilon</em> to 0.  <a href="#a47ac972d2a1556524159ff0765ae19c5"></a><br/></td></tr>
<tr class="memitem:afbde3d057ec404d5f4f962da46bccced"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#afbde3d057ec404d5f4f962da46bccced">ReadUaiAieFactorGraphFile</a> (const char *filename, size_t verbose, std::vector&lt; <a class="el" href="classdai_1_1Var.html">Var</a> &gt; &amp;vars, std::vector&lt; <a class="el" href="namespacedai.html#a7515abf9952cd312e95a34ada0670e85">Factor</a> &gt; &amp;factors, std::vector&lt; <a class="el" href="classdai_1_1Permute.html">Permute</a> &gt; &amp;permutations)</td></tr>
<tr class="memdesc:afbde3d057ec404d5f4f962da46bccced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads factor graph (as a pair of a variable vector and factor vector) from a file in the UAI approximate inference challenge format.  <a href="#afbde3d057ec404d5f4f962da46bccced"></a><br/></td></tr>
<tr class="memitem:ab5cba3982dd0cd9d5fa3a06c05aef8b1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::map&lt; size_t, <br class="typebreak"/>
size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ab5cba3982dd0cd9d5fa3a06c05aef8b1">ReadUaiAieEvidenceFile</a> (const char *filename, size_t verbose)</td></tr>
<tr class="memdesc:ab5cba3982dd0cd9d5fa3a06c05aef8b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads evidence (a mapping from observed variable labels to the observed values) from a file in the UAI approximate inference challenge format.  <a href="#ab5cba3982dd0cd9d5fa3a06c05aef8b1"></a><br/></td></tr>
<tr class="memitem:a4ac9b14596c7195e8401be42f18a4bf9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ac9b14596c7195e8401be42f18a4bf9"></a>
std::pair&lt; size_t, <a class="el" href="namespacedai.html#acc277bd4f0edae875fca22f063a37220">BigInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>boundTreewidth</b> (const <a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a> &amp;fg, <a class="el" href="classdai_1_1greedyVariableElimination.html#a367d3a2c003842d28e27f10d9c0ea3fb">greedyVariableElimination::eliminationCostFunction</a> fn, size_t maxStates)</td></tr>
<tr class="memitem:ac63c2f1d67d01aeda5c3cdd95843ea86"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ac63c2f1d67d01aeda5c3cdd95843ea86">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="namespacedai.html#acbc670414e04eecf5c284e42d9d036e3">Property</a> &amp;p)</td></tr>
<tr class="memdesc:ac63c2f1d67d01aeda5c3cdd95843ea86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a Property object (key-value pair) to an output stream.  <a href="#ac63c2f1d67d01aeda5c3cdd95843ea86"></a><br/></td></tr>
<tr class="memitem:ab339baefa9f588de2fba07526d8df7ba"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ab339baefa9f588de2fba07526d8df7ba">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdai_1_1PropertySet.html">PropertySet</a> &amp;ps)</td></tr>
<tr class="memdesc:ab339baefa9f588de2fba07526d8df7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a <a class="el" href="classdai_1_1PropertySet.html" title="Represents a set of properties, mapping keys (of type PropertyKey) to values (of type PropertyValue)...">PropertySet</a> object to an output stream.  <a href="#ab339baefa9f588de2fba07526d8df7ba"></a><br/></td></tr>
<tr class="memitem:aab0479dd285fd4021ecaa80947d40da3"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#aab0479dd285fd4021ecaa80947d40da3">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classdai_1_1PropertySet.html">PropertySet</a> &amp;ps)</td></tr>
<tr class="memdesc:aab0479dd285fd4021ecaa80947d40da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a <a class="el" href="classdai_1_1PropertySet.html" title="Represents a set of properties, mapping keys (of type PropertyKey) to values (of type PropertyValue)...">PropertySet</a> object from an input stream, storing values as strings.  <a href="#aab0479dd285fd4021ecaa80947d40da3"></a><br/></td></tr>
<tr class="memitem:a0e910ae9247869ee549df8eed173a6df"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a0e910ae9247869ee549df8eed173a6df">operator&lt;&lt;</a> (ostream &amp;os, const <a class="el" href="classdai_1_1RegionGraph.html">RegionGraph</a> &amp;rg)</td></tr>
<tr class="memdesc:a0e910ae9247869ee549df8eed173a6df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send <a class="el" href="classdai_1_1RegionGraph.html" title="A RegionGraph combines a bipartite graph consisting of outer regions (type FRegion) and inner regions...">RegionGraph</a> to output stream.  <a href="#a0e910ae9247869ee549df8eed173a6df"></a><br/></td></tr>
<tr class="memitem:a9886ca4103eac52b3f82698e12e86672"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a9886ca4103eac52b3f82698e12e86672">isnan</a> (<a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> x)</td></tr>
<tr class="memdesc:a9886ca4103eac52b3f82698e12e86672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if argument is NAN (Not A Number)  <a href="#a9886ca4103eac52b3f82698e12e86672"></a><br/></td></tr>
<tr class="memitem:ab27c0799ddef29bb3833477e32c53862"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ab27c0799ddef29bb3833477e32c53862">toc</a> ()</td></tr>
<tr class="memdesc:ab27c0799ddef29bb3833477e32c53862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns wall clock time in seconds.  <a href="#ab27c0799ddef29bb3833477e32c53862"></a><br/></td></tr>
<tr class="memitem:a8676cd0faacaec12b2acf0e0472e3280"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedai.html#a18604ca744bd93c2946b6207472414a6">_rnd_gen_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a8676cd0faacaec12b2acf0e0472e3280">_rnd_gen</a> (42U)</td></tr>
<tr class="memdesc:a8676cd0faacaec12b2acf0e0472e3280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global random number generator.  <a href="#a8676cd0faacaec12b2acf0e0472e3280"></a><br/></td></tr>
<tr class="memitem:a2cff7aad0084432ddcc7ef52618b74bd"><td class="memItemLeft" align="right" valign="top">boost::uniform_real&lt; <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a2cff7aad0084432ddcc7ef52618b74bd">_uni_dist</a> (0, 1)</td></tr>
<tr class="memdesc:a2cff7aad0084432ddcc7ef52618b74bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniform distribution with values between 0 and 1 (0 inclusive, 1 exclusive).  <a href="#a2cff7aad0084432ddcc7ef52618b74bd"></a><br/></td></tr>
<tr class="memitem:a95e934001307cafa4576b31fb0569e2c"><td class="memItemLeft" align="right" valign="top">boost::variate_generator<br class="typebreak"/>
&lt; <a class="el" href="namespacedai.html#a18604ca744bd93c2946b6207472414a6">_rnd_gen_type</a> <br class="typebreak"/>
&amp;, boost::uniform_real&lt; <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a95e934001307cafa4576b31fb0569e2c">_uni_rnd</a> (<a class="el" href="namespacedai.html#a8676cd0faacaec12b2acf0e0472e3280">_rnd_gen</a>, <a class="el" href="namespacedai.html#a2cff7aad0084432ddcc7ef52618b74bd">_uni_dist</a>)</td></tr>
<tr class="memdesc:a95e934001307cafa4576b31fb0569e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global uniform random random number.  <a href="#a95e934001307cafa4576b31fb0569e2c"></a><br/></td></tr>
<tr class="memitem:a205aca5e7688c28a95ecc978b4f79879"><td class="memItemLeft" align="right" valign="top">boost::variate_generator<br class="typebreak"/>
&lt; <a class="el" href="namespacedai.html#a18604ca744bd93c2946b6207472414a6">_rnd_gen_type</a> <br class="typebreak"/>
&amp;, boost::normal_distribution<br class="typebreak"/>
&lt; <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a205aca5e7688c28a95ecc978b4f79879">_normal_rnd</a> (<a class="el" href="namespacedai.html#a8676cd0faacaec12b2acf0e0472e3280">_rnd_gen</a>, <a class="el" href="namespacedai.html#a72200157ce1fbccfe91f66a3f8416823">_normal_dist</a>)</td></tr>
<tr class="memdesc:a205aca5e7688c28a95ecc978b4f79879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global random number generator with standard normal distribution.  <a href="#a205aca5e7688c28a95ecc978b4f79879"></a><br/></td></tr>
<tr class="memitem:ae699eca7ca4d6e971b54c2b4a95942d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ae699eca7ca4d6e971b54c2b4a95942d4">rnd_seed</a> (size_t seed)</td></tr>
<tr class="memdesc:ae699eca7ca4d6e971b54c2b4a95942d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the random seed.  <a href="#ae699eca7ca4d6e971b54c2b4a95942d4"></a><br/></td></tr>
<tr class="memitem:a129f3a9c518c632c985d045a4f8c60f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a129f3a9c518c632c985d045a4f8c60f9">rnd_uniform</a> ()</td></tr>
<tr class="memdesc:a129f3a9c518c632c985d045a4f8c60f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a real number, distributed uniformly on [0,1)  <a href="#a129f3a9c518c632c985d045a4f8c60f9"></a><br/></td></tr>
<tr class="memitem:ac3f6d317ca42fbb4b643aa8c82692d74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ac3f6d317ca42fbb4b643aa8c82692d74">rnd_stdnormal</a> ()</td></tr>
<tr class="memdesc:ac3f6d317ca42fbb4b643aa8c82692d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a real number from a standard-normal distribution.  <a href="#ac3f6d317ca42fbb4b643aa8c82692d74"></a><br/></td></tr>
<tr class="memitem:ac02317b960b112637976333f90d1f937"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ac02317b960b112637976333f90d1f937">rnd_int</a> (int min, int max)</td></tr>
<tr class="memdesc:ac02317b960b112637976333f90d1f937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random integer in interval [<em>min</em>, <em>max</em>].  <a href="#ac02317b960b112637976333f90d1f937"></a><br/></td></tr>
<tr class="memitem:a87303da2767f4906ea37216bdc9278ca"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a87303da2767f4906ea37216bdc9278ca">tokenizeString</a> (const std::string &amp;s, bool singleDelim, const std::string &amp;delim=&quot;\t\n&quot;)</td></tr>
<tr class="memdesc:a87303da2767f4906ea37216bdc9278ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into tokens delimited by one of the characters in <em>delim</em>.  <a href="#a87303da2767f4906ea37216bdc9278ca"></a><br/></td></tr>
<tr class="memitem:a750c3807e7375265c3fb410a1f1223fe"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a750c3807e7375265c3fb410a1f1223fe">calcLinearState</a> (const <a class="el" href="classdai_1_1VarSet.html">VarSet</a> &amp;vs, const std::map&lt; <a class="el" href="classdai_1_1Var.html">Var</a>, size_t &gt; &amp;state)</td></tr>
<tr class="memdesc:a750c3807e7375265c3fb410a1f1223fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the linear index in the Cartesian product of the variables in <em>vs</em> that corresponds to a particular joint assignment of the variables, specified by <em>state</em>.  <a href="#a750c3807e7375265c3fb410a1f1223fe"></a><br/></td></tr>
<tr class="memitem:afcfc874f85b4a2944ec128ebd1dd19f1"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="classdai_1_1Var.html">Var</a>, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#afcfc874f85b4a2944ec128ebd1dd19f1">calcState</a> (const <a class="el" href="classdai_1_1VarSet.html">VarSet</a> &amp;vs, size_t linearState)</td></tr>
<tr class="memdesc:afcfc874f85b4a2944ec128ebd1dd19f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the joint assignment of the variables in <em>vs</em> corresponding to the linear index <em>linearState</em>.  <a href="#afcfc874f85b4a2944ec128ebd1dd19f1"></a><br/></td></tr>
<tr class="memitem:ae62bf4dfaa6694edc2d180b71656d430"><td class="memItemLeft" align="right" valign="top">mxArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ae62bf4dfaa6694edc2d180b71656d430">Factors2mx</a> (const std::vector&lt; <a class="el" href="namespacedai.html#a7515abf9952cd312e95a34ada0670e85">Factor</a> &gt; &amp;Ps)</td></tr>
<tr class="memdesc:ae62bf4dfaa6694edc2d180b71656d430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert vector&lt;Factor&gt; structure to a cell vector of CPTAB-like structs.  <a href="#ae62bf4dfaa6694edc2d180b71656d430"></a><br/></td></tr>
<tr class="memitem:abdd1a935e89ca8dc1d4e0c1cea371d44"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="namespacedai.html#a7515abf9952cd312e95a34ada0670e85">Factor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#abdd1a935e89ca8dc1d4e0c1cea371d44">mx2Factors</a> (const mxArray *psi, long verbose)</td></tr>
<tr class="memdesc:abdd1a935e89ca8dc1d4e0c1cea371d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert cell vector of CPTAB-like structs to vector&lt;Factor&gt;  <a href="#abdd1a935e89ca8dc1d4e0c1cea371d44"></a><br/></td></tr>
<tr class="memitem:a573a608f62779c1a08f8e10c3fa4e940"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedai.html#a7515abf9952cd312e95a34ada0670e85">Factor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a573a608f62779c1a08f8e10c3fa4e940">mx2Factor</a> (const mxArray *psi)</td></tr>
<tr class="memdesc:a573a608f62779c1a08f8e10c3fa4e940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert CPTAB-like struct to Factor.  <a href="#a573a608f62779c1a08f8e10c3fa4e940"></a><br/></td></tr>
<tr class="memitem:aef8d342ac50bdaed5d513df6349be31c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#aef8d342ac50bdaed5d513df6349be31c">DAI_ENUM</a> (BBPCostFunctionBase, CFN_GIBBS_B, CFN_GIBBS_B2, CFN_GIBBS_EXP, CFN_GIBBS_B_FACTOR, CFN_GIBBS_B2_FACTOR, CFN_GIBBS_EXP_FACTOR, CFN_VAR_ENT, CFN_FACTOR_ENT, CFN_BETHE_ENT)</td></tr>
<tr class="memdesc:aef8d342ac50bdaed5d513df6349be31c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of several cost functions that can be used with <a class="el" href="classdai_1_1BBP.html" title="Implements BBP (Back-Belief-Propagation) [EaG09].">BBP</a>.  <a href="#aef8d342ac50bdaed5d513df6349be31c"></a><br/></td></tr>
<tr class="memitem:a42325c9b677ff8f4e5407981ef4e9754"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a42325c9b677ff8f4e5407981ef4e9754">DAI_ENUM</a> (FactorType, ISINGGAUSS, ISINGUNIFORM, EXPGAUSS, POTTS)</td></tr>
<tr class="memdesc:a42325c9b677ff8f4e5407981ef4e9754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible factor types.  <a href="#a42325c9b677ff8f4e5407981ef4e9754"></a><br/></td></tr>
<tr class="memitem:a697e9e5c47bd35a05f8313d3aa34a9c0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a697e9e5c47bd35a05f8313d3aa34a9c0"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#a697e9e5c47bd35a05f8313d3aa34a9c0">operator&lt;&lt;</a> (std::ostream &amp;os, const spvector&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a697e9e5c47bd35a05f8313d3aa34a9c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a <code>spvector&lt;&gt;</code> to a <code>std::ostream</code>.  <a href="#a697e9e5c47bd35a05f8313d3aa34a9c0"></a><br/></td></tr>
<tr class="memitem:a514b0fd2197af61701a456ea01534c4d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a514b0fd2197af61701a456ea01534c4d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#a514b0fd2197af61701a456ea01534c4d">operator&lt;&lt;</a> (std::ostream &amp;os, const spvector_map&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a514b0fd2197af61701a456ea01534c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a <code>spvector_map&lt;&gt;</code> to a <code>std::ostream</code>.  <a href="#a514b0fd2197af61701a456ea01534c4d"></a><br/></td></tr>
<tr class="memitem:a8f9fdd7b607434fcda10d5be59f512d1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a8f9fdd7b607434fcda10d5be59f512d1">BigInt_size_t</a> (const <a class="el" href="namespacedai.html#acc277bd4f0edae875fca22f063a37220">BigInt</a> &amp;N)</td></tr>
<tr class="memdesc:a8f9fdd7b607434fcda10d5be59f512d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe down-cast of big integer to size_t.  <a href="#a8f9fdd7b607434fcda10d5be59f512d1"></a><br/></td></tr>
<tr class="memitem:a934491ad55f57c9072271b4a32ea4919"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a934491ad55f57c9072271b4a32ea4919">log</a> (<a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> x)</td></tr>
<tr class="memdesc:a934491ad55f57c9072271b4a32ea4919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns logarithm of <em>x</em>.  <a href="#a934491ad55f57c9072271b4a32ea4919"></a><br/></td></tr>
<tr class="memitem:a00375a4d7b55534c14f993c909b04c3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a00375a4d7b55534c14f993c909b04c3c">log0</a> (<a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> x)</td></tr>
<tr class="memdesc:a00375a4d7b55534c14f993c909b04c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns logarithm of <em>x</em>, or 0 if <em>x</em> == 0.  <a href="#a00375a4d7b55534c14f993c909b04c3c"></a><br/></td></tr>
<tr class="memitem:ac336ffb182b6e6fa3f7df13620aab012"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#ac336ffb182b6e6fa3f7df13620aab012">exp</a> (<a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> x)</td></tr>
<tr class="memdesc:ac336ffb182b6e6fa3f7df13620aab012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns exponent of <em>x</em>.  <a href="#ac336ffb182b6e6fa3f7df13620aab012"></a><br/></td></tr>
<tr class="memitem:a16465ce3d62a6456fd06e9a226c966f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a16465ce3d62a6456fd06e9a226c966f2">pow</a> (<a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> x, <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> y)</td></tr>
<tr class="memdesc:a16465ce3d62a6456fd06e9a226c966f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <em>to</em> the power <em>y</em>.  <a href="#a16465ce3d62a6456fd06e9a226c966f2"></a><br/></td></tr>
<tr class="memitem:a89f208a23b353176f4797877a0b2b2a5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a89f208a23b353176f4797877a0b2b2a5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#a89f208a23b353176f4797877a0b2b2a5">abs</a> (const T &amp;t)</td></tr>
<tr class="memdesc:a89f208a23b353176f4797877a0b2b2a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns absolute value of <em>t</em>.  <a href="#a89f208a23b353176f4797877a0b2b2a5"></a><br/></td></tr>
<tr class="memitem:affae7aacdd26b4a580fbb8790cbccc86"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#affae7aacdd26b4a580fbb8790cbccc86">rnd</a> (int n)</td></tr>
<tr class="memdesc:affae7aacdd26b4a580fbb8790cbccc86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random integer in the half-open interval [0, <em>n</em>)  <a href="#affae7aacdd26b4a580fbb8790cbccc86"></a><br/></td></tr>
<tr class="memitem:a20efc75c125a2a3e97eda59fbb77b4f5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a20efc75c125a2a3e97eda59fbb77b4f5"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#a20efc75c125a2a3e97eda59fbb77b4f5">toString</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a20efc75c125a2a3e97eda59fbb77b4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a variable of type <em>T</em> to a <code>std::string</code> by using a <code>boost::lexical_cast</code>.  <a href="#a20efc75c125a2a3e97eda59fbb77b4f5"></a><br/></td></tr>
<tr class="memitem:a94b4dd96324af3c0511584a0925f9c15"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a94b4dd96324af3c0511584a0925f9c15"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#a94b4dd96324af3c0511584a0925f9c15">fromString</a> (const std::string &amp;x)</td></tr>
<tr class="memdesc:a94b4dd96324af3c0511584a0925f9c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a variable of type std::string to <em>T</em> by using a <code>boost::lexical_cast</code>.  <a href="#a94b4dd96324af3c0511584a0925f9c15"></a><br/></td></tr>
<tr class="memitem:af29736151cce84724f1250dbd69843af"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af29736151cce84724f1250dbd69843af"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#af29736151cce84724f1250dbd69843af">operator&lt;&lt;</a> (std::ostream &amp;os, const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:af29736151cce84724f1250dbd69843af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a <code>std::vector&lt;&gt;</code> to a <code>std::ostream</code>.  <a href="#af29736151cce84724f1250dbd69843af"></a><br/></td></tr>
<tr class="memitem:a2587403bd40a1dc12a4623c4f733d42f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2587403bd40a1dc12a4623c4f733d42f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#a2587403bd40a1dc12a4623c4f733d42f">operator&lt;&lt;</a> (std::ostream &amp;os, const std::set&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a2587403bd40a1dc12a4623c4f733d42f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a <code>std::set&lt;&gt;</code> to a <code>std::ostream</code>.  <a href="#a2587403bd40a1dc12a4623c4f733d42f"></a><br/></td></tr>
<tr class="memitem:a68eb439acde316a2d3018fd73c3f0495"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a68eb439acde316a2d3018fd73c3f0495"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#a68eb439acde316a2d3018fd73c3f0495">operator&lt;&lt;</a> (std::ostream &amp;os, const std::map&lt; T1, T2 &gt; &amp;x)</td></tr>
<tr class="memdesc:a68eb439acde316a2d3018fd73c3f0495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a <code>std::map&lt;&gt;</code> to a <code>std::ostream</code>.  <a href="#a68eb439acde316a2d3018fd73c3f0495"></a><br/></td></tr>
<tr class="memitem:a2386565a315305a0af6bc1dd2b2028d2"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a2386565a315305a0af6bc1dd2b2028d2"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#a2386565a315305a0af6bc1dd2b2028d2">operator&lt;&lt;</a> (std::ostream &amp;os, const std::pair&lt; T1, T2 &gt; &amp;x)</td></tr>
<tr class="memdesc:a2386565a315305a0af6bc1dd2b2028d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a <code>std::pair&lt;&gt;</code> to a <code>std::ostream</code>.  <a href="#a2386565a315305a0af6bc1dd2b2028d2"></a><br/></td></tr>
<tr class="memitem:a02ec8ea1644e02ce9bc1c958123761f8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a02ec8ea1644e02ce9bc1c958123761f8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#a02ec8ea1644e02ce9bc1c958123761f8">concat</a> (const std::vector&lt; T &gt; &amp;u, const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a02ec8ea1644e02ce9bc1c958123761f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two vectors.  <a href="#a02ec8ea1644e02ce9bc1c958123761f8"></a><br/></td></tr>
<tr class="memitem:af37305c285dbe556f8a40cbf3ccf4be3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af37305c285dbe556f8a40cbf3ccf4be3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1RootedTree.html">RootedTree</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#af37305c285dbe556f8a40cbf3ccf4be3">MinSpanningTree</a> (const <a class="el" href="classdai_1_1WeightedGraph.html">WeightedGraph</a>&lt; T &gt; &amp;G, bool usePrim)</td></tr>
<tr class="memdesc:af37305c285dbe556f8a40cbf3ccf4be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a minimum spanning tree from the (non-negatively) weighted graph <em>G</em>.  <a href="#af37305c285dbe556f8a40cbf3ccf4be3"></a><br/></td></tr>
<tr class="memitem:a394197d7c57ab6f1dd5bad99df18d51c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a394197d7c57ab6f1dd5bad99df18d51c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdai_1_1RootedTree.html">RootedTree</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedai.html#a394197d7c57ab6f1dd5bad99df18d51c">MaxSpanningTree</a> (const <a class="el" href="classdai_1_1WeightedGraph.html">WeightedGraph</a>&lt; T &gt; &amp;G, bool usePrim)</td></tr>
<tr class="memdesc:a394197d7c57ab6f1dd5bad99df18d51c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a minimum spanning tree from the (non-negatively) weighted graph <em>G</em>.  <a href="#a394197d7c57ab6f1dd5bad99df18d51c"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aed99853da1587287b03584cd3337696a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed99853da1587287b03584cd3337696a"></a>
static _builtinInfAlgs&#160;</td><td class="memItemRight" valign="bottom"><b>allBuiltinInfAlgs</b></td></tr>
<tr class="memitem:abed7f60e6cf2bb5857c39fa4ffbbce05"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#abed7f60e6cf2bb5857c39fa4ffbbce05">FULL_TYPE</a> = &quot;FULL&quot;</td></tr>
<tr class="memdesc:abed7f60e6cf2bb5857c39fa4ffbbce05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predefined names of various factor graph types.  <a href="#abed7f60e6cf2bb5857c39fa4ffbbce05"></a><br/></td></tr>
<tr class="memitem:af1228418b33cec430e3fbe13c46892f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1228418b33cec430e3fbe13c46892f5"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>DREG_TYPE</b> = &quot;DREG&quot;</td></tr>
<tr class="memitem:a9c5a4cc36a5b1246ee2dbe61b58c5c22"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c5a4cc36a5b1246ee2dbe61b58c5c22"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>LOOP_TYPE</b> = &quot;LOOP&quot;</td></tr>
<tr class="memitem:a04d4a9cd237aa54ceb6f965a705699dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04d4a9cd237aa54ceb6f965a705699dc"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>TREE_TYPE</b> = &quot;TREE&quot;</td></tr>
<tr class="memitem:a59fe330b899ca800b47e398ea5f52472"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59fe330b899ca800b47e398ea5f52472"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>GRID_TYPE</b> = &quot;GRID&quot;</td></tr>
<tr class="memitem:a9070d3a16568269218dfd67138e6141f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9070d3a16568269218dfd67138e6141f"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>GRID3D_TYPE</b> = &quot;GRID3D&quot;</td></tr>
<tr class="memitem:a416e5ebdc8bfa78b72696aab305ff69f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a416e5ebdc8bfa78b72696aab305ff69f"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>HOI_TYPE</b> = &quot;HOI&quot;</td></tr>
<tr class="memitem:a6ce0b6750c5675e512c14491a2c07e7e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ce0b6750c5675e512c14491a2c07e7e"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>LDPC_TYPE</b> = &quot;LDPC&quot;</td></tr>
<tr class="memitem:a72200157ce1fbccfe91f66a3f8416823"><td class="memItemLeft" align="right" valign="top">boost::normal_distribution&lt; <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedai.html#a72200157ce1fbccfe91f66a3f8416823">_normal_dist</a></td></tr>
<tr class="memdesc:a72200157ce1fbccfe91f66a3f8416823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normal distribution with mean 0 and standard deviation 1.  <a href="#a72200157ce1fbccfe91f66a3f8416823"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Namespace for libDAI. </p>
</div><h2>Typedef Documentation</h2>
<a class="anchor" id="a18604ca744bd93c2946b6207472414a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::mt19937 <a class="el" href="namespacedai.html#a18604ca744bd93c2946b6207472414a6">dai::_rnd_gen_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of global random number generator. </p>

</div>
</div>
<a class="anchor" id="a4d66d71f2b2c7ac4845bba057eb7cee5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classdai_1_1DAIAlg.html">DAIAlg</a>&lt;<a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a>&gt; <a class="el" href="namespacedai.html#a4d66d71f2b2c7ac4845bba057eb7cee5">dai::DAIAlgFG</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base class for inference algorithms that operate on a <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a>. </p>

</div>
</div>
<a class="anchor" id="a6b5cb6d79a324915d2c88ad368437e21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classdai_1_1DAIAlg.html">DAIAlg</a>&lt;<a class="el" href="classdai_1_1RegionGraph.html">RegionGraph</a>&gt; <a class="el" href="namespacedai.html#a6b5cb6d79a324915d2c88ad368437e21">dai::DAIAlgRG</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base class for inference algorithms that operate on a <a class="el" href="classdai_1_1RegionGraph.html" title="A RegionGraph combines a bipartite graph consisting of outer regions (type FRegion) and inner regions...">RegionGraph</a>. </p>

</div>
</div>
<a class="anchor" id="a7515abf9952cd312e95a34ada0670e85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classdai_1_1TFactor.html">TFactor</a>&lt;<a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&gt; <a class="el" href="namespacedai.html#a7515abf9952cd312e95a34ada0670e85">dai::Factor</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents a factor with values of type <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf" title="Real number (alias for double, which could be changed to long double if necessary)">dai::Real</a>. </p>

</div>
</div>
<a class="anchor" id="a14c563f2e5f6acf255903cae5c3b415c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="structdai_1_1Neighbor.html">Neighbor</a>&gt; <a class="el" href="namespacedai.html#a14c563f2e5f6acf255903cae5c3b415c">dai::Neighbors</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describes the set of neighbors of some node in a graph. </p>

</div>
</div>
<a class="anchor" id="aca51f13415f708db9eabda981b107a14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;size_t,size_t&gt; <a class="el" href="namespacedai.html#aca51f13415f708db9eabda981b107a14">dai::Edge</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents an edge in a graph: an Edge(<em>i</em>,<em>j</em>) corresponds to the edge between node <em>i</em> and node <em>j</em>. </p>
<dl class="section note"><dt>Note</dt><dd>If the edge is interpreted as a directed edge, then it points from <em>i</em> to <em>j</em>. </dd>
<dd>
If the edge is part of a bipartite graph, <em>i</em> is understood to correspond to a node of type 1, and <em>j</em> to a node of type 2. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="example_bipgraph_8cpp-example.html#a0">example_bipgraph.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a90f06137ef74bb483e30ee2c7e31b2c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classdai_1_1TProb.html">TProb</a>&lt;<a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&gt; <a class="el" href="namespacedai.html#a90f06137ef74bb483e30ee2c7e31b2c8">dai::Prob</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents a vector with entries of type <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf" title="Real number (alias for double, which could be changed to long double if necessary)">dai::Real</a>. </p>

</div>
</div>
<a class="anchor" id="acc877a85f4f4dbb6a0d58c434bb2b996"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::string <a class="el" href="namespacedai.html#acc877a85f4f4dbb6a0d58c434bb2b996">dai::PropertyKey</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the key of a Property. </p>

</div>
</div>
<a class="anchor" id="aeb056b768d73d02c5796c4012f4170c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::any <a class="el" href="namespacedai.html#aeb056b768d73d02c5796c4012f4170c7">dai::PropertyValue</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the value of a Property. </p>

</div>
</div>
<a class="anchor" id="acbc670414e04eecf5c284e42d9d036e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;<a class="el" href="namespacedai.html#acc877a85f4f4dbb6a0d58c434bb2b996">PropertyKey</a>, <a class="el" href="namespacedai.html#aeb056b768d73d02c5796c4012f4170c7">PropertyValue</a>&gt; <a class="el" href="namespacedai.html#acbc670414e04eecf5c284e42d9d036e3">dai::Property</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A Property is a pair of a key and a corresponding value. </p>

</div>
</div>
<a class="anchor" id="ae7d0472fdc89a8635825d01940e91cbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">dai::Real</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Real number (alias for <code>double</code>, which could be changed to <code>long double</code> if necessary) </p>

</div>
</div>
<a class="anchor" id="acc277bd4f0edae875fca22f063a37220"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef mpz_class <a class="el" href="namespacedai.html#acc277bd4f0edae875fca22f063a37220">dai::BigInt</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arbitrary precision integer number. </p>

</div>
</div>
<h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ae0d0ef753bd0ba57586e556ab6312677"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedai.html#ae0d0ef753bd0ba57586e556ab6312677">dai::ProbNormType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerates different ways of normalizing a probability measure. </p>
<ul>
<li>NORMPROB means that the sum of all entries should be 1;</li>
<li>NORMLINF means that the maximum absolute value of all entries should be 1. </li>
</ul>

</div>
</div>
<a class="anchor" id="aa2735a823696443089d2de23e8ee6ecb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedai.html#aa2735a823696443089d2de23e8ee6ecb">dai::ProbDistType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerates different distance measures between probability measures. </p>
<ul>
<li>DISTL1 is the <img class="formulaInl" alt="$\ell_1$" src="form_129.png"/> distance (sum of absolute values of pointwise difference);</li>
<li>DISTLINF is the <img class="formulaInl" alt="$\ell_\infty$" src="form_130.png"/> distance (maximum absolute value of pointwise difference);</li>
<li>DISTTV is the total variation distance (half of the <img class="formulaInl" alt="$\ell_1$" src="form_129.png"/> distance);</li>
<li>DISTKL is the Kullback-Leibler distance ( <img class="formulaInl" alt="$\sum_i p_i (\log p_i - \log q_i)$" src="form_131.png"/>).</li>
<li>DISTHEL is the Hellinger distance ( <img class="formulaInl" alt="$\frac{1}{2}\sum_i (\sqrt{p_i}-\sqrt{q_i})^2$" src="form_132.png"/>). </li>
</ul>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="aa4fae69226f56a38066c2cac1a343fe1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, <a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> * &gt; &amp; dai::builtinInfAlgs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a map that contains for each built-in inference algorithm its name and a pointer to an object of that type. </p>
<p>This functionality is obsolete and will be removed in future versions of libDAI </p>

</div>
</div>
<a class="anchor" id="a16d6acf1e82fdf9ae23b655a12517b91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; std::string &gt; dai::builtinInfAlgNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a set of names of all available inference algorithms. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="example_8cpp-example.html#a0">example.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a4b9e5254e7ec388e69aa68dfc54509e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> * dai::newInfAlg </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FactorGraph &amp;&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PropertySet &amp;&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new inference algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the inference algorithm. </td></tr>
    <tr><td class="paramname">fg</td><td>The <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a> that the algorithm should be applied to. </td></tr>
    <tr><td class="paramname">opts</td><td>A <a class="el" href="classdai_1_1PropertySet.html" title="Represents a set of properties, mapping keys (of type PropertyKey) to values (of type PropertyValue)...">PropertySet</a> specifying the options for the algorithm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the new <a class="el" href="classdai_1_1InfAlg.html" title="InfAlg is an abstract base class, defining the common interface of all inference algorithms in libDAI...">InfAlg</a> object; it is the responsibility of the caller to delete it later. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">UNKNOWN_DAI_ALGORITHM</td><td>if the requested name is not known/compiled in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a246c23914fee45f8b7f01f9073bdd6fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> * dai::newInfAlgFromString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nameOpts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FactorGraph &amp;&#160;</td>
          <td class="paramname"><em>fg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new inference algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nameOpts</td><td>The name and options of the inference algorithm (should be in the format "name[key1=val1,key2=val2,...,keyn=valn]"). </td></tr>
    <tr><td class="paramname">fg</td><td>The <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a> that the algorithm should be applied to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the new <a class="el" href="classdai_1_1InfAlg.html" title="InfAlg is an abstract base class, defining the common interface of all inference algorithms in libDAI...">InfAlg</a> object; it is the responsibility of the caller to delete it later. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">UNKNOWN_DAI_ALGORITHM</td><td>if the requested name is not known/compiled in. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="example_imagesegmentation_8cpp-example.html#a4">example_imagesegmentation.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="af688c62fd7c8dff22e24835547cec7e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1InfAlg.html">InfAlg</a> * dai::newInfAlgFromString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nameOpts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FactorGraph &amp;&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>aliases</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new inference algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nameOpts</td><td>The name and options of the inference algorithm (should be in the format "name[key1=val1,key2=val2,...,keyn=valn]"). </td></tr>
    <tr><td class="paramname">fg</td><td>The <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a> that the algorithm should be applied to. </td></tr>
    <tr><td class="paramname">aliases</td><td>Maps names to strings in the format "name[key1=val1,key2=val2,...,keyn=valn]"; if not empty, alias substitution will be performed when parsing <em>nameOpts</em> by invoking <a class="el" href="namespacedai.html#a18ef8153f219f1cad48e4f1f1a00a2a6" title="Extracts the name and property set from a string s in the format &quot;name[key1=val1,key2=val2,...]&quot; or &quot;name&quot;, performing alias substitution.">parseNameProperties(const std::string &amp;,const std::map&lt;std::string,std::string&gt; &amp;)</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespacedai.html#a246c23914fee45f8b7f01f9073bdd6fe" title="Constructs a new inference algorithm.">newInfAlgFromString(const std::string &amp;, const FactorGraph &amp;)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8f6e164a012fff145d683d64ac4d7b7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, <a class="el" href="classdai_1_1PropertySet.html">PropertySet</a> &gt; dai::parseNameProperties </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the name and property set from a string <em>s</em> in the format "name[key1=val1,key2=val2,...]" or "name". </p>

</div>
</div>
<a class="anchor" id="a18ef8153f219f1cad48e4f1f1a00a2a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, <a class="el" href="classdai_1_1PropertySet.html">PropertySet</a> &gt; dai::parseNameProperties </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>aliases</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the name and property set from a string <em>s</em> in the format "name[key1=val1,key2=val2,...]" or "name", performing alias substitution. </p>
<p>Alias substitution is performed as follows: as long as name appears as a key in <em>aliases</em>, it is substituted by its value. Properties in <em>s</em> override those of the alias (in case of recursion, the "outer" properties override those of the "inner" aliases). </p>

</div>
</div>
<a class="anchor" id="afffceb04ae10c57ff54a9c57ac3bfc29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, std::string &gt; dai::readAliasesFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads aliases from file named <em>filename</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of the alias file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map that maps aliases to the strings they should be substituted with. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fileformats.html#fileformats-aliases">Aliases file format</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acfb030b9c48de7885795f4d03d7226ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dai::getFactorEntryForState </td>
          <td>(</td>
          <td class="paramtype">const FactorGraph &amp;&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the entry of the I'th factor corresponding to a global state. </p>

</div>
</div>
<a class="anchor" id="a7796e22fdea01e8fe5e4d51b85ae0548"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;size_t&gt; dai::complement </td>
          <td>(</td>
          <td class="paramtype">vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>xis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_states</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a sorted vector of states <em>xis</em> and total state count <em>n_states</em>, return a vector of states not in <em>xis</em>. </p>

</div>
</div>
<a class="anchor" id="a1091a5da35d620692783a17dbf265158"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> dai::unSoftMax </td>
          <td>(</td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes <img class="formulaInl" alt="$\frac{\exp(a)}{\exp(a)+\exp(b)}$" src="form_0.png"/>. </p>

</div>
</div>
<a class="anchor" id="a56e006b34155719d5ab9c0dbc9bd57f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> dai::logSumExp </td>
          <td>(</td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes log of sum of exponents, i.e., <img class="formulaInl" alt="$\log\left(\exp(a) + \exp(b)\right)$" src="form_1.png"/>. </p>

</div>
</div>
<a class="anchor" id="aee9a0cc9279a7add0849f964e3bdfbed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> dai::dist </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; Factor &gt; &amp;&#160;</td>
          <td class="paramname"><em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; Factor &gt; &amp;&#160;</td>
          <td class="paramname"><em>b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute sum of pairwise L-infinity distances of the first <em>nv</em> factors in each vector. </p>

</div>
</div>
<a class="anchor" id="aadf664acf42371b8f25ade335a805da1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static vector&lt;<a class="el" href="namespacedai.html#a7515abf9952cd312e95a34ada0670e85">Factor</a>&gt; dai::mixBeliefs </td>
          <td>(</td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; Factor &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; Factor &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a vector of mixtures p * b + (1-p) * c. </p>

</div>
</div>
<a class="anchor" id="abb00ff16fe071140d9eb4c555c43e5d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dai::eliminationCost_MinNeighbors </td>
          <td>(</td>
          <td class="paramtype">const ClusterGraph &amp;&#160;</td>
          <td class="paramname"><em>cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates cost of eliminating the <em>i</em> 'th variable from cluster graph <em>cl</em> according to the "MinNeighbors" criterion. </p>
<p>The cost is measured as "number of neigboring nodes in the current adjacency graph", where the adjacency graph has the variables as its nodes and connects nodes <em>i1</em> and <em>i2</em> iff <em>i1</em> and <em>i2</em> occur together in some common cluster. </p>

</div>
</div>
<a class="anchor" id="a68ec048cdbefcf8a488469dd14938452"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dai::eliminationCost_MinWeight </td>
          <td>(</td>
          <td class="paramtype">const ClusterGraph &amp;&#160;</td>
          <td class="paramname"><em>cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates cost of eliminating the <em>i</em> 'th variable from cluster graph <em>cl</em> according to the "MinWeight" criterion. </p>
<p>The cost is measured as "product of weights of neighboring nodes in the current adjacency graph", where the adjacency graph has the variables as its nodes and connects nodes <em>i1</em> and <em>i2</em> iff <em>i1</em> and <em>i2</em> occur together in some common cluster. The weight of a node is the number of states of the corresponding variable. </p>

</div>
</div>
<a class="anchor" id="ab6cfdf0bf047e72e324c04e96d310edb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dai::eliminationCost_MinFill </td>
          <td>(</td>
          <td class="paramtype">const ClusterGraph &amp;&#160;</td>
          <td class="paramname"><em>cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates cost of eliminating the <em>i</em> 'th variable from cluster graph <em>cl</em> according to the "MinFill" criterion. </p>
<p>The cost is measured as "number of added edges in the adjacency graph", where the adjacency graph has the variables as its nodes and connects nodes <em>i1</em> and <em>i2</em> iff <em>i1</em> and <em>i2</em> occur together in some common cluster. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="example_8cpp-example.html#a5">example.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a990ea70014c5c6a90932d9cee11f393b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dai::eliminationCost_WeightedMinFill </td>
          <td>(</td>
          <td class="paramtype">const ClusterGraph &amp;&#160;</td>
          <td class="paramname"><em>cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates cost of eliminating the <em>i</em> 'th variable from cluster graph <em>cl</em> according to the "WeightedMinFill" criterion. </p>
<p>The cost is measured as "total weight of added edges in the adjacency graph", where the adjacency graph has the variables as its nodes and connects nodes <em>i1</em> and <em>i2</em> iff <em>i1</em> and <em>i2</em> occur together in some common cluster. The weight of an edge is the product of the number of states of the variables corresponding with its nodes. </p>

</div>
</div>
<a class="anchor" id="ad6e23438f9dd7ea3e7514c3ba6238875"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a> dai::createFG </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdai_1_1GraphAL.html">GraphAL</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FactorType&#160;</td>
          <td class="paramname"><em>ft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdai_1_1PropertySet.html">PropertySet</a> &amp;&#160;</td>
          <td class="paramname"><em>props</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a factor graph from a pairwise interactions graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Graph describing interactions between variables </td></tr>
    <tr><td class="paramname">ft</td><td>Type of factors to use for interactions </td></tr>
    <tr><td class="paramname">states</td><td>Number of states of the variables </td></tr>
    <tr><td class="paramname">props</td><td>Additional properties for generating the interactions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a269bd60101452a427cc794572a6018a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1FactorGraph.html">FactorGraph</a> dai::createHOIFG </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a random factor graph with higher-order interactions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>number of variables </td></tr>
    <tr><td class="paramname">M</td><td>number of factors </td></tr>
    <tr><td class="paramname">k</td><td>number of variables that each factor depends on </td></tr>
    <tr><td class="paramname">beta</td><td>standard-deviation of Gaussian log-factor entries </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5b4bd583e26a7cf273d31f65602bf997"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1BipartiteGraph.html">BipartiteGraph</a> dai::createRandomBipartiteGraph </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>d2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a regular random bipartite graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N1</td><td>= number of nodes of type 1 </td></tr>
    <tr><td class="paramname">d1</td><td>= size of neighborhoods of nodes of type 1 </td></tr>
    <tr><td class="paramname">N2</td><td>= number of nodes of type 2 </td></tr>
    <tr><td class="paramname">d2</td><td>= size of neighborhoods of nodes of type 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>asserts that N1 * d1 == N2 * d2 </dd></dl>

</div>
</div>
<a class="anchor" id="afcfa4209cac6166d01a9d1d59f96f3e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dai::powmod </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns x**n % p, assuming p is prime. </p>

</div>
</div>
<a class="anchor" id="a48699de918fb0dcf60451b5706417f45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dai::order </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns order of x in GF(p) with p prime. </p>

</div>
</div>
<a class="anchor" id="a8a874e49f4d4da3a5158291777f325d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dai::isPrime </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether n is a prime number. </p>

</div>
</div>
<a class="anchor" id="ab52c9df9be8edbd7f43664608c22cc9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1BipartiteGraph.html">BipartiteGraph</a> dai::createSmallLDPCGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a regular LDPC graph with N=6, j=2, K=4, k=3. </p>

</div>
</div>
<a class="anchor" id="ad4b22f71661686c7ee6af183ceb3180b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1BipartiteGraph.html">BipartiteGraph</a> dai::createGroupStructuredLDPCGraph </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates group-structured LDPC code. </p>
<p>Use construction described in "A Class of Group-Structured LDPC Codes" by R. M. Tanner, D. Sridhara and T. Fuja Proceedings of ICSTA, 2001</p>
<p>Example parameters: (p,j,k) = (31,3,5) (p,j,k) = (37,3,4) (p,j,k) = (7,2,4) (p,j,k) = (29,2,4)</p>
<p>j and k must be divisors of p-1 </p>

</div>
</div>
<a class="anchor" id="affbd147a343d77586a66047bca831612"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dai::DAI_ENUM </td>
          <td>(</td>
          <td class="paramtype">LDPCType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SMALL&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GROUP&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RANDOM&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Possible LDPC structures. </p>

</div>
</div>
<a class="anchor" id="aab8aabfe0fcfd4b4bd24757c101449d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#a7515abf9952cd312e95a34ada0670e85">Factor</a> dai::calcMarginal </td>
          <td>(</td>
          <td class="paramtype">const InfAlg &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VarSet &amp;&#160;</td>
          <td class="paramname"><em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reInit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the marginal probability distribution for <em>vs</em> using inference algorithm <em>obj</em>. </p>
<p><a class="el" href="namespacedai.html#aab8aabfe0fcfd4b4bd24757c101449d5" title="Calculates the marginal probability distribution for vs using inference algorithm obj...">calcMarginal()</a> works by clamping all variables in <em>vs</em> and calculating the partition sum for each clamped state. Therefore, it can be used in combination with any inference algorithm that can calculate/approximate partition sums. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>instance of inference algorithm to be used </td></tr>
    <tr><td class="paramname">vs</td><td>variables for which the marginal should be calculated </td></tr>
    <tr><td class="paramname">reInit</td><td>should be set to <code>true</code> if at least one of the possible clamped states would be invalid (leading to a factor graph with zero partition sum). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a82e775a1e2908856f13fa1aa7c081d4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacedai.html#a7515abf9952cd312e95a34ada0670e85">Factor</a> &gt; dai::calcPairBeliefs </td>
          <td>(</td>
          <td class="paramtype">const InfAlg &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VarSet &amp;&#160;</td>
          <td class="paramname"><em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reInit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>accurate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates beliefs for all pairs of variables in <em>vs</em> using inference algorithm <em>obj</em>. </p>
<p><a class="el" href="namespacedai.html#a82e775a1e2908856f13fa1aa7c081d4c" title="Calculates beliefs for all pairs of variables in vs using inference algorithm obj.">calcPairBeliefs()</a> works by</p>
<ul>
<li>clamping single variables in <em>vs</em> and calculating the partition sum and the single variable beliefs for each clamped state, if <em>accurate</em> == <code>false</code>;</li>
<li>clamping pairs of variables in <em>vs</em> and calculating the partition sum for each clamped state, if <em>accurate</em> == <code>true</code>.</li>
</ul>
<p>Therefore, it can be used in combination with any inference algorithm that can calculate/approximate partition sums (and single variable beliefs, if <em>accurate</em> == <code>true</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>instance of inference algorithm to be used </td></tr>
    <tr><td class="paramname">vs</td><td>variables for which the pair beliefs should be calculated </td></tr>
    <tr><td class="paramname">reInit</td><td>should be set to <code>true</code> if at least one of the possible clamped states would be invalid (leading to a factor graph with zero partition sum). </td></tr>
    <tr><td class="paramname">accurate</td><td>if <code>true</code>, uses a slower but more accurate approximation algorithm </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae686384295f9909532d78328f87ae260"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; dai::findMaximum </td>
          <td>(</td>
          <td class="paramtype">const InfAlg &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the joint state of all variables that has maximum probability, according to the inference algorithm <em>obj</em>. </p>
<dl class="section note"><dt>Note</dt><dd>Before this method is called, obj.run() should have been called. </dd></dl>

</div>
</div>
<a class="anchor" id="a7dd9cb2405e798802d8cbb9b879fdf90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#a7515abf9952cd312e95a34ada0670e85">Factor</a> dai::createFactorIsing </td>
          <td>(</td>
          <td class="paramtype">const Var &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a binary unnormalized single-variable factor <img class="formulaInl" alt="$ \exp(hx) $" src="form_69.png"/> where <img class="formulaInl" alt="$ x = \pm 1 $" src="form_70.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Variable (should be binary) </td></tr>
    <tr><td class="paramname">h</td><td>Field strength </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="example_imagesegmentation_8cpp-example.html#a2">example_imagesegmentation.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ade7f623237328458325bce5322abe03e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#a7515abf9952cd312e95a34ada0670e85">Factor</a> dai::createFactorIsing </td>
          <td>(</td>
          <td class="paramtype">const Var &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Var &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a binary unnormalized pairwise factor <img class="formulaInl" alt="$ \exp(J x_1 x_2) $" src="form_71.png"/> where <img class="formulaInl" alt="$ x_1, x_2 = \pm 1 $" src="form_72.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>First variable (should be binary) </td></tr>
    <tr><td class="paramname">x2</td><td>Second variable (should be binary) </td></tr>
    <tr><td class="paramname">J</td><td>Coupling strength </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6715831e60e66582bce1c69518a40dd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#a7515abf9952cd312e95a34ada0670e85">Factor</a> dai::createFactorExpGauss </td>
          <td>(</td>
          <td class="paramtype">const VarSet &amp;&#160;</td>
          <td class="paramname"><em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a random factor on the variables <em>vs</em> with strength <em>beta</em>. </p>
<p>Each entry are set by drawing a normally distributed random with mean 0 and standard-deviation <em>beta</em>, and taking its exponent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vs</td><td>Variables </td></tr>
    <tr><td class="paramname">beta</td><td>Factor strength (inverse temperature) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aab6d25e30baf39ea06c57b5f71c61a4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#a7515abf9952cd312e95a34ada0670e85">Factor</a> dai::createFactorPotts </td>
          <td>(</td>
          <td class="paramtype">const Var &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Var &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pairwise Potts factor <img class="formulaInl" alt="$ \exp( J \delta_{x_1, x_2} ) $" src="form_73.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>First variable </td></tr>
    <tr><td class="paramname">x2</td><td>Second variable (should have the same number of states as <em>x1</em>) </td></tr>
    <tr><td class="paramname">J</td><td>Factor strength </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf624997c47362bc5db95242b76a66a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#a7515abf9952cd312e95a34ada0670e85">Factor</a> dai::createFactorDelta </td>
          <td>(</td>
          <td class="paramtype">const Var &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a Kronecker delta point mass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Variable </td></tr>
    <tr><td class="paramname">state</td><td>The state of <em>v</em> that should get value 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa9aa5a66a5df1ae48e29c4ad0965f3c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#a7515abf9952cd312e95a34ada0670e85">Factor</a> dai::createFactorDelta </td>
          <td>(</td>
          <td class="paramtype">const VarSet &amp;&#160;</td>
          <td class="paramname"><em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a Kronecker delta point mass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vs</td><td>Set of variables </td></tr>
    <tr><td class="paramname">state</td><td>The state of <em>vs</em> that should get value 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57fa52134afbd3da21c99975fbba7080"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; dai::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FactorGraph &amp;&#160;</td>
          <td class="paramname"><em>fg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a> to an output stream. </p>
<p>Writes a factor graph to an output stream.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fileformats.html#fileformats-factorgraph">Factor graph (.fg) file format</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab1b9d59848e415c32330d4a7cbb3269a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; dai::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FactorGraph &amp;&#160;</td>
          <td class="paramname"><em>fg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a> from an input stream. </p>
<p>Reads a factor graph from an input stream.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fileformats.html#fileformats-factorgraph">Factor graph (.fg) file format</a> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">INVALID_FACTORGRAPH_FILE</td><td>if the input stream is not valid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aedbe32ae13acdd8b62050b18e81a53ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a> dai::createGraphFull </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a fully-connected graph with <em>N</em> nodes. </p>

</div>
</div>
<a class="anchor" id="aaeeffaf06b9cd2fecccaf2bf773baed7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a> dai::createGraphGrid </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>periodic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a two-dimensional rectangular grid of <em>N1</em> by <em>N2</em> nodes, which can be <em>periodic</em>. </p>

</div>
</div>
<a class="anchor" id="a9950d08bd6190ea12f50b4be6f2584cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a> dai::createGraphGrid3D </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>periodic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a three-dimensional rectangular grid of <em>N1</em> by <em>N2</em> by <em>N3</em> nodes, which can be <em>periodic</em>. </p>

</div>
</div>
<a class="anchor" id="a7f65fc1665a6fa04b1b6897a4551bccc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a> dai::createGraphLoop </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a graph consisting of a single loop of <em>N</em> nodes. </p>

</div>
</div>
<a class="anchor" id="ad3fbe55f9fdb020e7a2b04f1d2451d20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a> dai::createGraphTree </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a random tree-structured graph of <em>N</em> nodes. </p>

</div>
</div>
<a class="anchor" id="abfd6bb3f4b6135a99a68b9b13bee8bae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1GraphAL.html">GraphAL</a> dai::createGraphRegular </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a random regular graph of <em>N</em> nodes with uniform connectivity <em>d</em>. </p>
<p>Algorithm 1 in [<a class="el" href="bibliography.html#StW99">StW99</a>]. Draws a random graph of size <em>N</em> and uniform degree <em>d</em> from an almost uniform probability distribution over these graphs (which becomes uniform in the limit that <em>d</em> is small and <em>N</em> goes to infinity). </p>

</div>
</div>
<a class="anchor" id="ae412446097e88867fc9a327d07f12daa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TFactor.html">TFactor</a>&lt;T&gt;&amp; dai::makePositive </td>
          <td>(</td>
          <td class="paramtype">TFactor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets factor entries that lie between 0 and <em>epsilon</em> to <em>epsilon</em>. </p>

</div>
</div>
<a class="anchor" id="a47ac972d2a1556524159ff0765ae19c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1TFactor.html">TFactor</a>&lt;T&gt;&amp; dai::makeZero </td>
          <td>(</td>
          <td class="paramtype">TFactor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets factor entries that are smaller (in absolute value) than <em>epsilon</em> to 0. </p>

</div>
</div>
<a class="anchor" id="afbde3d057ec404d5f4f962da46bccced"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dai::ReadUaiAieFactorGraphFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Var &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Factor &gt; &amp;&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Permute &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads factor graph (as a pair of a variable vector and factor vector) from a file in the UAI approximate inference challenge format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>The filename (usually ends with ".uai") </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>The amount of output sent to cout </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vars</td><td>Array of variables read from the file </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">factors</td><td>Array of factors read from the file </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">permutations</td><td>Array of permutations, which permute between libDAI canonical ordering and ordering specified by the file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a href="http://www.cs.huji.ac.il/project/UAI10">http://www.cs.huji.ac.il/project/UAI10</a> and <a href="http://graphmod.ics.uci.edu/uai08">http://graphmod.ics.uci.edu/uai08</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab5cba3982dd0cd9d5fa3a06c05aef8b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::map&lt; size_t, size_t &gt; &gt; dai::ReadUaiAieEvidenceFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads evidence (a mapping from observed variable labels to the observed values) from a file in the UAI approximate inference challenge format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>The filename (usually ends with ".uai.evid") </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>The amount of output sent to cout </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a href="http://www.cs.huji.ac.il/project/UAI10">http://www.cs.huji.ac.il/project/UAI10</a> and <a href="http://graphmod.ics.uci.edu/uai08">http://graphmod.ics.uci.edu/uai08</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac63c2f1d67d01aeda5c3cdd95843ea86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; dai::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Property &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a Property object (key-value pair) to an output stream. </p>
<dl class="section note"><dt>Note</dt><dd>Not all value types are automatically supported; if a type is unknown, an UNKNOWN_PROPERTY_TYPE exception is thrown. Adding support for a new type can be done by changing this function body. </dd></dl>

</div>
</div>
<a class="anchor" id="ab339baefa9f588de2fba07526d8df7ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; dai::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PropertySet &amp;&#160;</td>
          <td class="paramname"><em>ps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a <a class="el" href="classdai_1_1PropertySet.html" title="Represents a set of properties, mapping keys (of type PropertyKey) to values (of type PropertyValue)...">PropertySet</a> object to an output stream. </p>
<p>It uses the format <code>"[key1=val1,key2=val2,...,keyn=valn]"</code>. </p>
<dl class="section note"><dt>Note</dt><dd>Only a subset of all possible types is supported (see the implementation of this function). Adding support for more types has to be done by hand. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">UNKNOWN_PROPERTY_TYPE</td><td>if the type of a property value is not supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aab0479dd285fd4021ecaa80947d40da3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; dai::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertySet &amp;&#160;</td>
          <td class="paramname"><em>ps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a <a class="el" href="classdai_1_1PropertySet.html" title="Represents a set of properties, mapping keys (of type PropertyKey) to values (of type PropertyValue)...">PropertySet</a> object from an input stream, storing values as strings. </p>
<p>Reads a <a class="el" href="classdai_1_1PropertySet.html" title="Represents a set of properties, mapping keys (of type PropertyKey) to values (of type PropertyValue)...">PropertySet</a> object from an input stream.</p>
<p>It expects a string in the format <code>"[key1=val1,key2=val2,...,keyn=valn]"</code>. Values are stored as strings. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">MALFORMED_PROPERTY</td><td>if the string is not in the expected format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e910ae9247869ee549df8eed173a6df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; dai::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RegionGraph &amp;&#160;</td>
          <td class="paramname"><em>rg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send <a class="el" href="classdai_1_1RegionGraph.html" title="A RegionGraph combines a bipartite graph consisting of outer regions (type FRegion) and inner regions...">RegionGraph</a> to output stream. </p>
<p>Writes a <a class="el" href="classdai_1_1RegionGraph.html" title="A RegionGraph combines a bipartite graph consisting of outer regions (type FRegion) and inner regions...">RegionGraph</a> to an output stream. </p>

</div>
</div>
<a class="anchor" id="a9886ca4103eac52b3f82698e12e86672"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dai::isnan </td>
          <td>(</td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if argument is NAN (Not A Number) </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="uai2010-aie-solver_8cpp-example.html#a14">uai2010-aie-solver.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ab27c0799ddef29bb3833477e32c53862"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dai::toc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns wall clock time in seconds. </p>

</div>
</div>
<a class="anchor" id="a8676cd0faacaec12b2acf0e0472e3280"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#a18604ca744bd93c2946b6207472414a6">_rnd_gen_type</a> dai::_rnd_gen </td>
          <td>(</td>
          <td class="paramtype">42U&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Global random number generator. </p>

</div>
</div>
<a class="anchor" id="a2cff7aad0084432ddcc7ef52618b74bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::uniform_real&lt;<a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&gt; dai::_uni_dist </td>
          <td>(</td>
          <td class="paramtype">0&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uniform distribution with values between 0 and 1 (0 inclusive, 1 exclusive). </p>

</div>
</div>
<a class="anchor" id="a95e934001307cafa4576b31fb0569e2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::variate_generator&lt;<a class="el" href="namespacedai.html#a18604ca744bd93c2946b6207472414a6">_rnd_gen_type</a>&amp;, boost::uniform_real&lt;<a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&gt; &gt; dai::_uni_rnd </td>
          <td>(</td>
          <td class="paramtype">_rnd_gen&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_uni_dist&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Global uniform random random number. </p>

</div>
</div>
<a class="anchor" id="a205aca5e7688c28a95ecc978b4f79879"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::variate_generator&lt;<a class="el" href="namespacedai.html#a18604ca744bd93c2946b6207472414a6">_rnd_gen_type</a>&amp;, boost::normal_distribution&lt;<a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&gt; &gt; dai::_normal_rnd </td>
          <td>(</td>
          <td class="paramtype">_rnd_gen&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_normal_dist&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Global random number generator with standard normal distribution. </p>

</div>
</div>
<a class="anchor" id="ae699eca7ca4d6e971b54c2b4a95942d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dai::rnd_seed </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the random seed. </p>

</div>
</div>
<a class="anchor" id="a129f3a9c518c632c985d045a4f8c60f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> dai::rnd_uniform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a real number, distributed uniformly on [0,1) </p>

</div>
</div>
<a class="anchor" id="ac3f6d317ca42fbb4b643aa8c82692d74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> dai::rnd_stdnormal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a real number from a standard-normal distribution. </p>

</div>
</div>
<a class="anchor" id="ac02317b960b112637976333f90d1f937"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dai::rnd_int </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a random integer in interval [<em>min</em>, <em>max</em>]. </p>

</div>
</div>
<a class="anchor" id="a87303da2767f4906ea37216bdc9278ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; dai::tokenizeString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>singleDelim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delim</em> = <code>&quot;\t\n&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a string into tokens delimited by one of the characters in <em>delim</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the string to be split into tokens </td></tr>
    <tr><td class="paramname">singleDelim</td><td>if <code>true</code>, any single delimiter forms a boundary between two tokens; if <code>false</code>, a maximal group of consecutive delimiters forms a boundary between two tokens </td></tr>
    <tr><td class="paramname">delim</td><td>delimiter characters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a750c3807e7375265c3fb410a1f1223fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dai::calcLinearState </td>
          <td>(</td>
          <td class="paramtype">const VarSet &amp;&#160;</td>
          <td class="paramname"><em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; Var, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the linear index in the Cartesian product of the variables in <em>vs</em> that corresponds to a particular joint assignment of the variables, specified by <em>state</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vs</td><td>Set of variables for which the linear state should be calculated; </td></tr>
    <tr><td class="paramname">state</td><td>Specifies the states of some variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The linear index in the Cartesian product of the variables in <em>vs</em> corresponding with the joint assignment specified by <em>state</em>, where variables for which no state is specified are assumed to be in state 0.</dd></dl>
<p>The linear index is calculated as follows. The variables in <em>vs</em> are ordered according to their label (in ascending order); say <em>vs</em> corresponds with the set <img class="formulaInl" alt="$\{x_{l(0)},x_{l(1)},\dots,x_{l(n-1)}\}$" src="form_133.png"/> with <img class="formulaInl" alt="$l(0) < l(1) < \dots < l(n-1)$" src="form_134.png"/>, where variable <img class="formulaInl" alt="$x_l$" src="form_30.png"/> has label <em>l</em>. Denote by <img class="formulaInl" alt="$S_l$" src="form_32.png"/> the number of possible values ("states") of variable <img class="formulaInl" alt="$x_l$" src="form_30.png"/>. The argument <em>state</em> corresponds with a mapping <em>s</em> that assigns to each variable <img class="formulaInl" alt="$x_l$" src="form_30.png"/> a state <img class="formulaInl" alt="$s(x_l) \in \{0,1,\dots,S_l-1\}$" src="form_135.png"/>, where <img class="formulaInl" alt="$s(x_l)=0$" src="form_136.png"/> if <img class="formulaInl" alt="$x_l$" src="form_30.png"/> is not specified in <em>state</em>. The linear index <img class="formulaInl" alt="$S$" src="form_137.png"/> corresponding with <em>state</em> is now calculated by: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} S &amp;:=&amp; \sum_{i=0}^{n-1} s(x_{l(i)}) \prod_{j=0}^{i-1} S_{l(j)} \\ &amp;= &amp; s(x_{l(0)}) + s(x_{l(1)}) S_{l(0)} + s(x_{l(2)}) S_{l(0)} S_{l(1)} + \dots + s(x_{l(n-1)}) S_{l(0)} \cdots S_{l(n-2)}. \end{eqnarray*}" src="form_138.png"/>
</p>
<dl class="section note"><dt>Note</dt><dd>If <em>vs</em> corresponds with <img class="formulaInl" alt="$\{x_l\}_{l\in L}$" src="form_64.png"/>, and <em>state</em> specifies a state for each variable <img class="formulaInl" alt="$x_l$" src="form_30.png"/> for <img class="formulaInl" alt="$l\in L$" src="form_139.png"/>, <a class="el" href="namespacedai.html#a750c3807e7375265c3fb410a1f1223fe" title="Calculates the linear index in the Cartesian product of the variables in vs that corresponds to a par...">calcLinearState()</a> induces a mapping <img class="formulaInl" alt="$\sigma : \prod_{l\in L} X_l \to \{0,1,\dots,\prod_{l\in L} S_l-1\}$" src="form_140.png"/> that maps a joint state to a linear index; this is the inverse of the mapping <img class="formulaInl" alt="$\sigma^{-1}$" src="form_141.png"/> induced by <a class="el" href="namespacedai.html#afcfc874f85b4a2944ec128ebd1dd19f1" title="Calculates the joint assignment of the variables in vs corresponding to the linear index linearState...">calcState()</a>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespacedai.html#afcfc874f85b4a2944ec128ebd1dd19f1" title="Calculates the joint assignment of the variables in vs corresponding to the linear index linearState...">calcState()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afcfc874f85b4a2944ec128ebd1dd19f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; <a class="el" href="classdai_1_1Var.html">Var</a>, size_t &gt; dai::calcState </td>
          <td>(</td>
          <td class="paramtype">const VarSet &amp;&#160;</td>
          <td class="paramname"><em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>linearState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the joint assignment of the variables in <em>vs</em> corresponding to the linear index <em>linearState</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vs</td><td>Set of variables to which <em>linearState</em> refers </td></tr>
    <tr><td class="paramname">linearState</td><td>should be smaller than vs.nrStates(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mapping <img class="formulaInl" alt="$s$" src="form_84.png"/> that maps each <a class="el" href="classdai_1_1Var.html" title="Represents a discrete random variable.">Var</a> <img class="formulaInl" alt="$x_l$" src="form_30.png"/> in <em>vs</em> to its state <img class="formulaInl" alt="$s(x_l)$" src="form_142.png"/>, as specified by <em>linearState</em>.</dd></dl>
<p>The variables in <em>vs</em> are ordered according to their label (in ascending order); say <em>vs</em> corresponds with the set <img class="formulaInl" alt="$\{x_{l(0)},x_{l(1)},\dots,x_{l(n-1)}\}$" src="form_133.png"/> with <img class="formulaInl" alt="$l(0) < l(1) < \dots < l(n-1)$" src="form_134.png"/>, where variable <img class="formulaInl" alt="$x_l$" src="form_30.png"/> has label <em>l</em>. Denote by <img class="formulaInl" alt="$S_l$" src="form_32.png"/> the number of possible values ("states") of variable <img class="formulaInl" alt="$x_l$" src="form_30.png"/> with label <em>l</em>. The mapping <img class="formulaInl" alt="$s$" src="form_84.png"/> returned by this function is defined as: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} s(x_{l(i)}) = \left\lfloor\frac{S \mbox { mod } \prod_{j=0}^{i} S_{l(j)}}{\prod_{j=0}^{i-1} S_{l(j)}}\right\rfloor \qquad \mbox{for all $i=0,\dots,n-1$}. \end{eqnarray*}" src="form_143.png"/>
</p>
<p> where <img class="formulaInl" alt="$S$" src="form_137.png"/> denotes the value of <em>linearState</em>.</p>
<dl class="section note"><dt>Note</dt><dd>If <em>vs</em> corresponds with <img class="formulaInl" alt="$\{x_l\}_{l\in L}$" src="form_64.png"/>, <a class="el" href="namespacedai.html#afcfc874f85b4a2944ec128ebd1dd19f1" title="Calculates the joint assignment of the variables in vs corresponding to the linear index linearState...">calcState()</a> induces a mapping <img class="formulaInl" alt="$\sigma^{-1} : \{0,1,\dots,\prod_{l\in L} S_l-1\} \to \prod_{l\in L} X_l$" src="form_144.png"/> that maps a linear index to a joint state; this is the inverse of the mapping <img class="formulaInl" alt="$\sigma$" src="form_68.png"/> induced by <a class="el" href="namespacedai.html#a750c3807e7375265c3fb410a1f1223fe" title="Calculates the linear index in the Cartesian product of the variables in vs that corresponds to a par...">calcLinearState()</a>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespacedai.html#a750c3807e7375265c3fb410a1f1223fe" title="Calculates the linear index in the Cartesian product of the variables in vs that corresponds to a par...">calcLinearState()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae62bf4dfaa6694edc2d180b71656d430"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mxArray * dai::Factors2mx </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; Factor &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert vector&lt;Factor&gt; structure to a cell vector of CPTAB-like structs. </p>

</div>
</div>
<a class="anchor" id="abdd1a935e89ca8dc1d4e0c1cea371d44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacedai.html#a7515abf9952cd312e95a34ada0670e85">Factor</a> &gt; dai::mx2Factors </td>
          <td>(</td>
          <td class="paramtype">const mxArray *&#160;</td>
          <td class="paramname"><em>psi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert cell vector of CPTAB-like structs to vector&lt;Factor&gt; </p>

</div>
</div>
<a class="anchor" id="a573a608f62779c1a08f8e10c3fa4e940"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#a7515abf9952cd312e95a34ada0670e85">Factor</a> dai::mx2Factor </td>
          <td>(</td>
          <td class="paramtype">const mxArray *&#160;</td>
          <td class="paramname"><em>psi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert CPTAB-like struct to Factor. </p>

</div>
</div>
<a class="anchor" id="aef8d342ac50bdaed5d513df6349be31c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dai::DAI_ENUM </td>
          <td>(</td>
          <td class="paramtype">BBPCostFunctionBase&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFN_GIBBS_B&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFN_GIBBS_B2&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFN_GIBBS_EXP&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFN_GIBBS_B_FACTOR&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFN_GIBBS_B2_FACTOR&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFN_GIBBS_EXP_FACTOR&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFN_VAR_ENT&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFN_FACTOR_ENT&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFN_BETHE_ENT&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumeration of several cost functions that can be used with <a class="el" href="classdai_1_1BBP.html" title="Implements BBP (Back-Belief-Propagation) [EaG09].">BBP</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This class is meant as a base class for <a class="el" href="classdai_1_1BBPCostFunction.html" title="Predefined cost functions that can be used with BBP.">BBPCostFunction</a>, which provides additional functionality. </dd></dl>

</div>
</div>
<a class="anchor" id="a42325c9b677ff8f4e5407981ef4e9754"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dai::DAI_ENUM </td>
          <td>(</td>
          <td class="paramtype">FactorType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ISINGGAUSS&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ISINGUNIFORM&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EXPGAUSS&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">POTTS&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Possible factor types. </p>

</div>
</div>
<a class="anchor" id="a697e9e5c47bd35a05f8313d3aa34a9c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; dai::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const spvector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a <code>spvector&lt;&gt;</code> to a <code>std::ostream</code>. </p>

</div>
</div>
<a class="anchor" id="a514b0fd2197af61701a456ea01534c4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; dai::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const spvector_map&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a <code>spvector_map&lt;&gt;</code> to a <code>std::ostream</code>. </p>

</div>
</div>
<a class="anchor" id="a8f9fdd7b607434fcda10d5be59f512d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t dai::BigInt_size_t </td>
          <td>(</td>
          <td class="paramtype">const BigInt &amp;&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safe down-cast of big integer to size_t. </p>

</div>
</div>
<a class="anchor" id="a934491ad55f57c9072271b4a32ea4919"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> dai::log </td>
          <td>(</td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns logarithm of <em>x</em>. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="uai2010-aie-solver_8cpp-example.html#a2">uai2010-aie-solver.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a00375a4d7b55534c14f993c909b04c3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> dai::log0 </td>
          <td>(</td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns logarithm of <em>x</em>, or 0 if <em>x</em> == 0. </p>

</div>
</div>
<a class="anchor" id="ac336ffb182b6e6fa3f7df13620aab012"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> dai::exp </td>
          <td>(</td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns exponent of <em>x</em>. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="uai2010-aie-solver_8cpp-example.html#a5">uai2010-aie-solver.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a16465ce3d62a6456fd06e9a226c966f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a> dai::pow </td>
          <td>(</td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <em>to</em> the power <em>y</em>. </p>

</div>
</div>
<a class="anchor" id="a89f208a23b353176f4797877a0b2b2a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T dai::abs </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns absolute value of <em>t</em>. </p>

</div>
</div>
<a class="anchor" id="affae7aacdd26b4a580fbb8790cbccc86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int dai::rnd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a random integer in the half-open interval [0, <em>n</em>) </p>

</div>
</div>
<a class="anchor" id="a20efc75c125a2a3e97eda59fbb77b4f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string dai::toString </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a variable of type <em>T</em> to a <code>std::string</code> by using a <code>boost::lexical_cast</code>. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="uai2010-aie-solver_8cpp-example.html#a7">uai2010-aie-solver.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a94b4dd96324af3c0511584a0925f9c15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T dai::fromString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a variable of type std::string to <em>T</em> by using a <code>boost::lexical_cast</code>. </p>

</div>
</div>
<a class="anchor" id="af29736151cce84724f1250dbd69843af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; dai::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a <code>std::vector&lt;&gt;</code> to a <code>std::ostream</code>. </p>

</div>
</div>
<a class="anchor" id="a2587403bd40a1dc12a4623c4f733d42f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; dai::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a <code>std::set&lt;&gt;</code> to a <code>std::ostream</code>. </p>

</div>
</div>
<a class="anchor" id="a68eb439acde316a2d3018fd73c3f0495"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; dai::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a <code>std::map&lt;&gt;</code> to a <code>std::ostream</code>. </p>

</div>
</div>
<a class="anchor" id="a2386565a315305a0af6bc1dd2b2028d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; dai::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a <code>std::pair&lt;&gt;</code> to a <code>std::ostream</code>. </p>

</div>
</div>
<a class="anchor" id="a02ec8ea1644e02ce9bc1c958123761f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; dai::concat </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates two vectors. </p>

</div>
</div>
<a class="anchor" id="af37305c285dbe556f8a40cbf3ccf4be3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1RootedTree.html">RootedTree</a> dai::MinSpanningTree </td>
          <td>(</td>
          <td class="paramtype">const WeightedGraph&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>usePrim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a minimum spanning tree from the (non-negatively) weighted graph <em>G</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Weighted graph that should have non-negative weights. </td></tr>
    <tr><td class="paramname">usePrim</td><td>If true, use Prim's algorithm (complexity O(E log(V))), otherwise, use Kruskal's algorithm (complexity O(E log(E))). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Uses implementation from Boost Graph Library. </dd>
<dd>
The vertices of <em>G</em> must be in the range [0,N) where N is the number of vertices of <em>G</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a394197d7c57ab6f1dd5bad99df18d51c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdai_1_1RootedTree.html">RootedTree</a> dai::MaxSpanningTree </td>
          <td>(</td>
          <td class="paramtype">const WeightedGraph&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>usePrim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a minimum spanning tree from the (non-negatively) weighted graph <em>G</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Weighted graph that should have non-negative weights. </td></tr>
    <tr><td class="paramname">usePrim</td><td>If true, use Prim's algorithm (complexity O(E log(V))), otherwise, use Kruskal's algorithm (complexity O(E log(E))). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Uses implementation from Boost Graph Library. </dd>
<dd>
The vertices of <em>G</em> must be in the range [0,N) where N is the number of vertices of <em>G</em>. </dd></dl>

</div>
</div>
<h2>Variable Documentation</h2>
<a class="anchor" id="abed7f60e6cf2bb5857c39fa4ffbbce05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* dai::FULL_TYPE = &quot;FULL&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predefined names of various factor graph types. </p>

</div>
</div>
<a class="anchor" id="a72200157ce1fbccfe91f66a3f8416823"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::normal_distribution&lt;<a class="el" href="namespacedai.html#ae7d0472fdc89a8635825d01940e91cbf">Real</a>&gt; dai::_normal_dist</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normal distribution with mean 0 and standard deviation 1. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 17 2012 12:30:35 for libDAI by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
