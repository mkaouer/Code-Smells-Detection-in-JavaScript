<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
"http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>API Users Guide</title>
</head>

<body bgcolor="#FFFFFF">
<div align="center">
	<img src="../images/jPOS.gif"><br>
	<img src="../images/API-users-guide.gif">
</div>
<b><i>j</i>POS</b> is a java based financial transaction
library/framework that can be customized and extended in order
to implement any particular financial interchange.

<p>
It currently implements <b>ISO-8583</b>, <b>ANSI X9.2</b>
and has backward compatibility with simple protocols such
as <b>VISA-1</b>.

<p>
<b><i>j</i>POS's</b> patterns
(as well as any modern OO project's patterns)
are easier to understand if you learn about <b>design patterns</b>.
You may want to read 
<i>Design Patterns, Elements of Reusable Object-Oriented Software,
[Gamma, Helm, Johnson, Vlissides]</i>
<code>ISBN 0-201-63361-2</code>.<br>

<h1 align="center">ISO Package Overview</h1>
<h4 align="center">(packing and unpacking ISO-8583 messages)</h4>

<p>
The basic building blocks are designed around the
<b>Composite pattern</b> where 
<a href="org/jpos/iso/ISOComponent.html">ISOComponent</a>
is an abstract class that represent a <b>Component</b>,
<a href="org/jpos/iso/ISOMsg.html">ISOMsg</a> implements
the <b>Composite</b> and
<a href="org/jpos/iso/ISOField.html">ISOField</a>,
<a href="org/jpos/iso/ISOBinaryField.html">ISOBinaryField</a> and
<a href="org/jpos/iso/ISOBitMap.html">ISOBitMap</a> 
implements <b>Leafs</b> within the <b>Composite</b> pattern.

<p>
<div align="center">
<img src="../images/Composite-pattern.gif">
</div>

The <b>Composite pattern</b> is intended to be used also whithin fields.
Several ISO 8583 implementations (such as VISA's SMS) use variable
length, bitmapped fields. It should be easy to implement those
fields as Composite components that can be nested within an ISOMsg.

<p>An <b>ISOMsg</b> is an internal representation independent of
the packaging method used in a given interchange.

<p>The following sample code fragment creates a simple 
ISO-8583 message.

<pre>
	import org.jpos.iso.*;

	ISOMsg m = new ISOMsg();
	m.set(new ISOField(0, "0800"));
	m.set(new ISOField(7, ISODate.getDateTime(new Date()));
</pre>

In order to implement different packaging agreements and easy
packaging conversions we use the <b>Peer Pattern</b>. 
An ISOMsg can have a peer that implements the
<a href="org/jpos/iso/ISOPackager.html">ISOPackager</a> interfase.

<p>
<b><i>j</i>POS</b> comes with an increasing
number of ISOPackagers such as:<br><br>
<table border="0" align="center">
  <tr><td><a href="org/jpos/iso/ISO87APackager.html">ISO87APackager</a>
      <td>ISO-8583 v 1987 ASCII Packager
  <tr><td><a href="org/jpos/iso/ISO87BPackager.html">ISO87BPackager</a>
      <td>ISO-8583 v 1987 Binary Packager
  <tr><td><a href="org/jpos/iso/X92Packager.html">X92Packager</a>
      <td>ANSI X9.2 packager
  <tr><td><a href="org/jpos/iso/VISA1Packager.html">VISA1Packager</a>
      <td>Maps ISO-8583 messages to legacy VISA-1 format
</table>
<br><br>

<p>We would like to include new tested packagers.
Please <a href="mailto:jpos@cs.com.uy">contact</a> us if you want
to contribute.

<h3 align="center"><i>j</i>POS in the middle</h3>
<h4 align="center">(converting message formats)</h4>

Imagine you are in the middle of two interchanges, 
converting from two different ISO-8583 dialects.
For example, on the receiving side you are using ISO87APackager
(ASCII Packager) and you have to transmit the same message
using ISO87BPackager (Binary packager).

<p>
You have a <code>byte[] rx</code> array holding
the received message (we'll get to ISOChannel soon).
The following code will do the conversion:

<pre>
    ISOMsg m = new ISOMsg();
    m.setPackager (new ISO87APackager());
    m.unpack (rx);
    m.setPackager (new ISO87BPackager());
    byte[] tx = m.pack();
    System.out.println (ISOUtil.hexString(tx));
</pre>

<p>
<h3 align="center">Transmiting, receiving and multiplexing</h3>
<h4 align="center">ISOChannel, ISOMUX</h4>

In any case the programmer implementing the high level application logic
must not deal with packaging and interchange low level details.
The helper class
<a href="org/jpos/iso/ISOChannel.html">ISOChannel</a>
takes care of that.

<p>
<div align="center">
<img src="../images/ISOChannel.gif">
</div>

<p>
The 
<a href="org/jpos/iso/ISOChannel.html">
ISOChannel constructor</a> receives a TCP address and
port number as parameters and also a default packager.
It connects to a server (possibly running on a different machine)
and sends and receives properly packaged ISO-8583 messages.

<p>It can act as a base class for more specialized <code>ISOChannels</code>.
You can easily inherit from <code>ISOChannel</code> in order to be
compatible with a particular interchange. There are plans for 
<b>SSLChannel</b> and possibly <b>QTPChannel</b> in the near
future as well.

<h3 align="center">X.25, ISDN, HDCL, SDLC, SNA</h3>
<h4 align="center">(low level adapters)</h4>
<p>There are cases where a 100% Java solution is not possible for
special devices such as X.25 adapters with propietary APIs. A gateway
daemon or 'port server' written in another language (such as C or C++) can
solve the problem. An <code>ISOChannel</code> (or a specialized 
<code>ISOChannel</code> subclass such as 
<a href="org/jpos/iso/channel/RawChannel.html">RawChannel</a>)
talks to that server by means of
a TCP/IP standard connection while the 'port server daemon' takes care of the
low level API details.

<p>ISOMsg objects sent or received over an ISOChannel do not need an
associated ISOPackager peer. ISOChannel calls 
<a href="org/jpos/iso/ISOMsg.html#setPackager">ISOMsg.setPackager</a>
with every ISOMsg sent or received.

<h3 align="center">Multiplexing messages with ISOMUX</h3>
An <a href="org/jpos/iso/ISOMUX.html">ISOMUX</a> is a runnable class
that asynchronously handles multiplexing and demultiplexing of ISOMsgs over a 
single ISOChannel.

<p>
<div align="center">
<img src="../images/ISOMUX.gif">
</div>
</a>


<p>The multiplexing/demultiplexing is based on the protected function
ISOMUX.getKey().
The default implementation returns the concatenated (zero padded) values
of fields 41 + field 11 (TerminalID+TraceNumber). 
<b>You can subclass to provide different behaviour</b>.

<p>ISOMUX relies on one simple new class
<a href="org/jpos/iso/ISORequest.html">ISORequest</a><br>
In order to queue an ISOMsg to be sent over an ISOChannel by means
of an ISOMUX you must create an ISORequest.

<p>The following simplified sample code sends a request and waits for
the matching response using an ISOMUX.

<pre>
    // 
    // create an ISOChannel with a default
    // ISO8583 version 1987 Binary Packager
    // 
    ISOChannel channel=new VAPChannel
	("vap-tcp-address", vap-port, new ISO87BPackager());
    // create and start MUX in its own thread
    ISOMUX mux = new ISOMUX (channel);
    new Thread (mux).start();

    // Send a sample message
    ISOMsg m = new ISOMsg ();
    try {
       m.set(new ISOField (0,  "0200"));
       // ...
       // ...
       m.set(new ISOField (11, "1");
       m.set(new ISOField (41, "00000001"));
       ISORequest r = new ISORequest(m);
       mux.queue (r);
       ISOMsg response = r.getResponse (60*1000); // wait 60 seconds
       if (response != null) 
          response.dump(System.out, "");
       mux.showCounters(System.out);
    } catch (ISOException e) {
        e.printStackTrace();
    }
</pre>

ISOMUX allows multiple terminals in a LAN or WAN to asynchronously send
and receive messages over a single ISOChannel link. It also
automatically handles ISOChannel reconnections.

<h2>Further reading</h2>
This is work in progress, code evolves faster that documentation,
you may consider reading the following related documents:

<ul>
  <li><a href="../LoggerGuide.html">Logger Guide</a>
  <li><a href="../AgentsProposal.html">Agents Proposal</a>
</ul>

<br>
--<b>The <i>j</i>POS Team</b><br><br>
<font size="-1">
<center>$Id$</center>
</font>
</body>
</html>
