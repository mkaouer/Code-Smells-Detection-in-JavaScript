<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>spot: Emptiness-check algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">spot
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Emptiness-check algorithms</div>  </div>
<div class="ingroups"><a class="el" href="group__emptiness__check.html">Emptiness-checks</a></div></div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1couvreur99__check.html">spot::couvreur99_check</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of the Couvreur99 emptiness-check algorithm.  <a href="classspot_1_1couvreur99__check.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1couvreur99__check__shy.html">spot::couvreur99_check_shy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A version of <a class="el" href="classspot_1_1couvreur99__check.html" title="An implementation of the Couvreur99 emptiness-check algorithm.">spot::couvreur99_check</a> that tries to visit known states first.  <a href="classspot_1_1couvreur99__check__shy.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9bb3670ecff03df6d792c8a315c3e75c"><td class="memItemLeft" align="right" valign="top">emptiness_check *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga9bb3670ecff03df6d792c8a315c3e75c">spot::couvreur99</a> (const tgba *a, option_map options=option_map(), const numbered_state_heap_factory *nshf=numbered_state_heap_hash_map_factory::instance())</td></tr>
<tr class="memdesc:ga9bb3670ecff03df6d792c8a315c3e75c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the language of an automate is empty.  <a href="#ga9bb3670ecff03df6d792c8a315c3e75c"></a><br/></td></tr>
<tr class="memitem:gae45e3a4c2ba4b8c0609a2afca67eabe8"><td class="memItemLeft" align="right" valign="top">emptiness_check *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#gae45e3a4c2ba4b8c0609a2afca67eabe8">spot::explicit_gv04_check</a> (const tgba *a, option_map o=option_map())</td></tr>
<tr class="memdesc:gae45e3a4c2ba4b8c0609a2afca67eabe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emptiness check based on Geldenhuys and Valmari's TACAS'04 paper.  <a href="#gae45e3a4c2ba4b8c0609a2afca67eabe8"></a><br/></td></tr>
<tr class="memitem:ga392d772bf851002cdda0ca34615aa54b"><td class="memItemLeft" align="right" valign="top">emptiness_check *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga392d772bf851002cdda0ca34615aa54b">spot::explicit_magic_search</a> (const tgba *a, option_map o=option_map())</td></tr>
<tr class="memdesc:ga392d772bf851002cdda0ca34615aa54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>.  <a href="#ga392d772bf851002cdda0ca34615aa54b"></a><br/></td></tr>
<tr class="memitem:gadae7938a96420813bcdabb1b31295294"><td class="memItemLeft" align="right" valign="top">emptiness_check *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#gadae7938a96420813bcdabb1b31295294">spot::bit_state_hashing_magic_search</a> (const tgba *a, size_t size, option_map o=option_map())</td></tr>
<tr class="memdesc:gadae7938a96420813bcdabb1b31295294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>.  <a href="#gadae7938a96420813bcdabb1b31295294"></a><br/></td></tr>
<tr class="memitem:ga054c1948b6c5076350e44a85ad580403"><td class="memItemLeft" align="right" valign="top">emptiness_check *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga054c1948b6c5076350e44a85ad580403">spot::magic_search</a> (const tgba *a, option_map o=option_map())</td></tr>
<tr class="memdesc:ga054c1948b6c5076350e44a85ad580403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for the two magic_search implementations.  <a href="#ga054c1948b6c5076350e44a85ad580403"></a><br/></td></tr>
<tr class="memitem:ga8c176368673a0c009dd3e934d57fb492"><td class="memItemLeft" align="right" valign="top">emptiness_check *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga8c176368673a0c009dd3e934d57fb492">spot::explicit_se05_search</a> (const tgba *a, option_map o=option_map())</td></tr>
<tr class="memdesc:ga8c176368673a0c009dd3e934d57fb492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an emptiness check on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>.  <a href="#ga8c176368673a0c009dd3e934d57fb492"></a><br/></td></tr>
<tr class="memitem:gae822266082cdb9772ce31388a6538cb9"><td class="memItemLeft" align="right" valign="top">emptiness_check *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#gae822266082cdb9772ce31388a6538cb9">spot::bit_state_hashing_se05_search</a> (const tgba *a, size_t size, option_map o=option_map())</td></tr>
<tr class="memdesc:gae822266082cdb9772ce31388a6538cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>.  <a href="#gae822266082cdb9772ce31388a6538cb9"></a><br/></td></tr>
<tr class="memitem:ga23a00d19bf7613222e6e41833e515c00"><td class="memItemLeft" align="right" valign="top">emptiness_check *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga23a00d19bf7613222e6e41833e515c00">spot::se05</a> (const tgba *a, option_map o)</td></tr>
<tr class="memdesc:ga23a00d19bf7613222e6e41833e515c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for the two se05 implementations.  <a href="#ga23a00d19bf7613222e6e41833e515c00"></a><br/></td></tr>
<tr class="memitem:ga159e81f9b91f99b2a749185f47924d99"><td class="memItemLeft" align="right" valign="top">emptiness_check *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga159e81f9b91f99b2a749185f47924d99">spot::explicit_tau03_search</a> (const tgba *a, option_map o=option_map())</td></tr>
<tr class="memdesc:ga159e81f9b91f99b2a749185f47924d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>.  <a href="#ga159e81f9b91f99b2a749185f47924d99"></a><br/></td></tr>
<tr class="memitem:ga68f7245733f5fe5a86e6dd416d7746f1"><td class="memItemLeft" align="right" valign="top">emptiness_check *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga68f7245733f5fe5a86e6dd416d7746f1">spot::explicit_tau03_opt_search</a> (const tgba *a, option_map o=option_map())</td></tr>
<tr class="memdesc:ga68f7245733f5fe5a86e6dd416d7746f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>.  <a href="#ga68f7245733f5fe5a86e6dd416d7746f1"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<h2>Function Documentation</h2>
<a class="anchor" id="gadae7938a96420813bcdabb1b31295294"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">emptiness_check* spot::bit_state_hashing_magic_search </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">option_map&#160;</td>
          <td class="paramname"><em>o</em> = <code>option_map()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>. </p>
<pre class="fragment">\pre The automaton \a a must have at most one acceptance condition (i.e.
it is a TBA).

During the visit of \a a, the returned checker does not store explicitely
the traversed states but uses the bit-state hashing technic presented in:

@verbatim 
</pre><p> /// {Holzmann91, /// author = {G.J. Holzmann}, /// title = {Design and Validation of Computer Protocols}, /// publisher = {Prentice-Hall}, /// address = {Englewood Cliffs, New Jersey}, /// year = {1991} /// } ///  </p>
<pre class="fragment">Consequently, the detection of an acceptence cycle is not ensured.

The size of the heap is limited to \n size bytes.

The implemented algorithm is the same as the one of
spot::explicit_magic_search.

\sa spot::explicit_magic_search</pre> 
</div>
</div>
<a class="anchor" id="gae822266082cdb9772ce31388a6538cb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">emptiness_check* spot::bit_state_hashing_se05_search </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">option_map&#160;</td>
          <td class="paramname"><em>o</em> = <code>option_map()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>. </p>
<pre class="fragment">\pre The automaton \a a must have at most one acceptance condition (i.e.
it is a TBA).

During the visit of \a a, the returned checker does not store explicitely
the traversed states but uses the bit-state hashing technic presented in:

@verbatim 
</pre><p> /// {Holzmann91, /// author = {G.J. Holzmann}, /// title = {Design and Validation of Computer Protocols}, /// publisher = {Prentice-Hall}, /// address = {Englewood Cliffs, New Jersey}, /// year = {1991} /// } ///  </p>
<pre class="fragment">Consequently, the detection of an acceptence cycle is not ensured.

The size of the heap is limited to \n size bytes.

The implemented algorithm is the same as the one of
spot::explicit_se05_search.

\sa spot::explicit_se05_search</pre> 
</div>
</div>
<a class="anchor" id="ga9bb3670ecff03df6d792c8a315c3e75c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">emptiness_check* spot::couvreur99 </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">option_map&#160;</td>
          <td class="paramname"><em>options</em> = <code>option_map()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const numbered_state_heap_factory *&#160;</td>
          <td class="paramname"><em>nshf</em> = <code>numbered_state_heap_hash_map_factory::instance()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the language of an automate is empty. </p>
<pre class="fragment">This is based on the following paper.
@verbatim 
</pre><p> /// {couvreur.99.fm, /// author = {Jean-Michel Couvreur}, /// title = {On-the-fly Verification of Temporal Logic}, /// pages = {253&ndash;271}, /// editor = {Jeannette M. Wing and Jim Woodcock and Jim Davies}, /// booktitle = {Proceedings of the World Congress on Formal Methods in /// the Development of Computing Systems (FM'99)}, /// publisher = {Springer-Verlag}, /// series = {Lecture Notes in Computer Science}, /// volume = {1708}, /// year = {1999}, /// address = {Toulouse, France}, /// month = {September}, /// isbn = {3-540-66587-0} /// } ///  </p>
<pre class="fragment">A recursive definition of the algorithm would look as follows,
but the implementation is of course not recursive.
(&lt;code&gt;&amp;lt;Sigma, Q, delta, q, F&amp;gt;&lt;/code&gt; is the automaton to
check, H is an associative array mapping each state to its
positive DFS order or 0 if it is dead, SCC is and ACC are two
stacks.)

@verbatim 
</pre><p> /// check(&lt;Sigma, Q, delta, q, F&gt;, H, SCC, ACC) /// if q is not in H // new state /// H[q] = H.size + 1 /// SCC.push(&lt;H[q], {}&gt;) /// forall &lt;a, s&gt; : &lt;q, _, a, s&gt; in delta /// ACC.push(a) /// res = check(&lt;Sigma, Q, delta, s, F&gt;, H, SCC, ACC) /// if res /// return res /// &lt;n, _&gt; = SCC.top() /// if n = H[q] /// SCC.pop() /// mark_reachable_states_as_dead(&lt;Sigma, Q, delta, q, F&gt;, H$) /// return 0 /// else /// if H[q] = 0 // dead state /// ACC.pop() /// return true /// else // state in stack: merge SCC /// all = {} /// do /// &lt;n, a&gt; = SCC.pop() /// all = all union a union { ACC.pop() } /// until n &lt;= H[q] /// SCC.push(&lt;n, all&gt;) /// if all != F /// return 0 /// return new emptiness_check_result(necessary data) ///  </p>
<pre class="fragment">check() returns 0 iff the automaton's language is empty.  It
returns an instance of emptiness_check_result.  If the automaton
accept a word.  (Use emptiness_check_result::accepting_run() to
extract an accepting run.)

There are two variants of this algorithm: spot::couvreur99_check and
spot::couvreur99_check_shy.  They differ in their memory usage, the
number for successors computed before they are used and the way
the depth first search is directed.

spot::couvreur99_check performs a straightforward depth first search.
The DFS stacks store tgba_succ_iterators, so that only the
iterators which really are explored are computed.

spot::couvreur99_check_shy tries to explore successors which are
visited states first.  this helps to merge SCCs and generally
helps to produce shorter counter-examples.  However this
algorithm cannot stores unprocessed successors as
tgba_succ_iterators: it must compute all successors of a state
at once in order to decide which to explore first, and must keep
a list of all unexplored successors in its DFS stack.

The couvreur99() function is a wrapper around these two flavors
of the algorithm.  \a options is an option map that specifies
which algorithms should be used, and how.

The following options are available.
\li \c "shy" : if non zero, then spot::couvreur99_check_shy is used,
               otherwise (and by default) spot::couvreur99_check is used.

\li \c "poprem" : specifies how the algorithm should handle the
destruction of non-accepting maximal strongly connected
components.  If \c poprem is non null, the algorithm will keep a
list of all states of a SCC that are fully processed and should
be removed once the MSCC is popped.  If \c poprem is null (the
default), the MSCC will be traversed again (i.e. generating the
successors of the root recursively) for deletion.  This is a
choice between memory and speed.

\li \c "group" : this options is used only by spot::couvreur99_check_shy.
If non null (the default), the successors of all the
states that belong to the same SCC will be considered when
choosing a successor.  Otherwise, only the successor of the
topmost state on the DFS stack are considered.  </pre> 
</div>
</div>
<a class="anchor" id="gae45e3a4c2ba4b8c0609a2afca67eabe8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">emptiness_check* spot::explicit_gv04_check </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">option_map&#160;</td>
          <td class="paramname"><em>o</em> = <code>option_map()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emptiness check based on Geldenhuys and Valmari's TACAS'04 paper. </p>
<pre class="fragment">\pre The automaton \a a must have at most one acceptance condition.

The original algorithm, coming from the following paper, has only
been slightly modified to work on transition-based automata.
@verbatim 
</pre><p> /// {geldenhuys.04.tacas, /// author = {Jaco Geldenhuys and Antti Valmari}, /// title = {Tarjan's Algorithm Makes On-the-Fly {LTL} Verification /// More Efficient}, /// booktitle = {Proceedings of the 10th International Conference on Tools /// and Algorithms for the Construction and Analysis of Systems /// (TACAS'04)}, /// editor = {Kurt Jensen and Andreas Podelski}, /// pages = {205&ndash;219}, /// year = {2004}, /// publisher = {Springer-Verlag}, /// series = {Lecture Notes in Computer Science}, /// volume = {2988}, /// isbn = {3-540-21299-X} /// } ///  </p>

</div>
</div>
<a class="anchor" id="ga392d772bf851002cdda0ca34615aa54b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">emptiness_check* spot::explicit_magic_search </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">option_map&#160;</td>
          <td class="paramname"><em>o</em> = <code>option_map()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>. </p>
<pre class="fragment">\pre The automaton \a a must have at most one acceptance condition (i.e.
it is a TBA).

During the visit of \a a, the returned checker stores explicitely all
the traversed states.
The method \a check() of the checker can be called several times
(until it returns a null pointer) to enumerate all the visited acceptance
paths. The implemented algorithm is the following:

@verbatim 
</pre><p> /// procedure check () /// begin /// call dfs_blue(s0); /// end; /// /// procedure dfs_blue (s) /// begin /// s.color = blue; /// for all t in post(s) do /// if t.color == white then /// call dfs_blue(t); /// end if; /// if (the edge (s,t) is accepting) then /// target = s; /// call dfs_red(t); /// end if; /// end for; /// end; /// /// procedure dfs_red(s) /// begin /// s.color = red; /// if s == target then /// report cycle /// end if; /// for all t in post(s) do /// if t.color == blue then /// call dfs_red(t); /// end if; /// end for; /// end; ///  </p>
<pre class="fragment">This algorithm is an adaptation to TBA of the one
(which deals with accepting states) presented in

@verbatim 
</pre><p> /// Article{ courcoubetis.92.fmsd, /// author = {Costas Courcoubetis and Moshe Y. Vardi and Pierre /// Wolper and Mihalis Yannakakis}, /// title = {Memory-Efficient Algorithm for the Verification of /// Temporal Properties}, /// journal = {Formal Methods in System Design}, /// pages = {275&ndash;288}, /// year = {1992}, /// volume = {1} /// } ///  </p>
<pre class="fragment">\xrefitem bug 1.</pre> 
</div>
</div>
<a class="anchor" id="ga8c176368673a0c009dd3e934d57fb492"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">emptiness_check* spot::explicit_se05_search </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">option_map&#160;</td>
          <td class="paramname"><em>o</em> = <code>option_map()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an emptiness check on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>. </p>
<pre class="fragment">\pre The automaton \a a must have at most one acceptance condition (i.e.
it is a TBA).

During the visit of \a a, the returned checker stores explicitely all
the traversed states.
The method \a check() of the checker can be called several times
(until it returns a null pointer) to enumerate all the visited accepting
paths. The implemented algorithm is an optimization of
spot::explicit_magic_search and is the following:

@verbatim 
</pre><p> /// procedure check () /// begin /// call dfs_blue(s0); /// end; /// /// procedure dfs_blue (s) /// begin /// s.color = cyan; /// for all t in post(s) do /// if t.color == white then /// call dfs_blue(t); /// else if t.color == cyan and /// (the edge (s,t) is accepting or /// (it exists a predecessor p of s in st_blue and s != t and /// the arc between p and s is accepting)) then /// report cycle; /// end if; /// if the edge (s,t) is accepting then /// call dfs_red(t); /// end if; /// end for; /// s.color = blue; /// end; /// /// procedure dfs_red(s) /// begin /// if s.color == cyan then /// report cycle; /// end if; /// s.color = red; /// for all t in post(s) do /// if t.color == blue then /// call dfs_red(t); /// end if; /// end for; /// end; ///  </p>
<pre class="fragment">It is an adaptation to TBA of the one presented in
@verbatim 
</pre><p> /// {SE04, /// author = {Stefan Schwoon and Javier Esparza}, /// institution = {Universit{"a}t Stuttgart, Fakult"at Informatik, /// Elektrotechnik und Informationstechnik}, /// month = {November}, /// number = {2004/06}, /// title = {A Note on On-The-Fly Verification Algorithms}, /// year = {2004}, /// url = ///{<a href="http://www.fmi.uni-stuttgart.de/szs/publications/info/schwoosn.SE04.shtml">http://www.fmi.uni-stuttgart.de/szs/publications/info/schwoosn.SE04.shtml</a>} /// } ///  </p>
<pre class="fragment">\sa spot::explicit_magic_search</pre> 
</div>
</div>
<a class="anchor" id="ga68f7245733f5fe5a86e6dd416d7746f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">emptiness_check* spot::explicit_tau03_opt_search </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">option_map&#160;</td>
          <td class="paramname"><em>o</em> = <code>option_map()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>. </p>
<pre class="fragment">\pre The automaton \a a must have at least one acceptance condition.

During the visit of \a a, the returned checker stores explicitely all
the traversed states. The implemented algorithm is the following:

@verbatim 
</pre><p> /// procedure check () /// begin /// weight = 0; // the null vector /// call dfs_blue(s0); /// end; /// /// procedure dfs_blue (s) /// begin /// s.color = cyan; /// s.acc = emptyset; /// s.weight = weight; /// for all t in post(s) do /// let (s, l, a, t) be the edge from s to t; /// if t.color == white then /// for all b in a do /// weight[b] = weight[b] + 1; /// end for; /// call dfs_blue(t); /// for all b in a do /// weight[b] = weight[b] - 1; /// end for; /// end if; /// Acc = s.acc U a; /// if t.color == cyan &amp;&amp; /// (Acc U support(weight - t.weight) U t.acc) == all_acc then /// report a cycle; /// else if Acc not included in t.acc then /// t.acc := t.acc U Acc; /// call dfs_red(t, Acc); /// end if; /// end for; /// s.color = blue; /// end; /// /// procedure dfs_red(s, Acc) /// begin /// for all t in post(s) do /// let (s, l, a, t) be the edge from s to t; /// if t.color == cyan &amp;&amp; /// (Acc U support(weight - t.weight) U t.acc) == all_acc then /// report a cycle; /// else if t.color != white and Acc not included in t.acc then /// t.acc := t.acc U Acc; /// call dfs_red(t, Acc); /// end if; /// end for; /// end; ///  </p>
<pre class="fragment">This algorithm is a generalisation to TGBA of the one implemented in
spot::explicit_se05_search. It is based on the acceptance set labelling
of states used in spot::explicit_tau03_search. Moreover, it introduce
a slight optimisation based on vectors of integers counting for each
acceptance condition how many time the condition has been visited in
the path stored in the blue stack. Such a vector is associated to each
state of this stack.</pre> 
</div>
</div>
<a class="anchor" id="ga159e81f9b91f99b2a749185f47924d99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">emptiness_check* spot::explicit_tau03_search </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">option_map&#160;</td>
          <td class="paramname"><em>o</em> = <code>option_map()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>. </p>
<pre class="fragment">\pre The automaton \a a must have at least one acceptance condition.

During the visit of \a a, the returned checker stores explicitely all
the traversed states. The implemented algorithm is the following:

@verbatim 
</pre><p> /// procedure check () /// begin /// call dfs_blue(s0); /// end; /// /// procedure dfs_blue (s) /// begin /// s.color = blue; /// s.acc = emptyset; /// for all t in post(s) do /// if t.color == white then /// call dfs_blue(t); /// end if; /// end for; /// for all t in post(s) do /// let (s, l, a, t) be the edge from s to t; /// if s.acc U a not included in t.acc then /// call dfs_red(t, a U s.acc); /// end if; /// end for; /// if s.acc == all_acc then /// report a cycle; /// end if; /// end; /// /// procedure dfs_red(s, A) /// begin /// s.acc = s.acc U A; /// for all t in post(s) do /// if t.color != white and A not included in t.acc then /// call dfs_red(t, A); /// end if; /// end for; /// end; ///  </p>
<pre class="fragment">This algorithm is the one presented in

@verbatim 
</pre><p> /// {HUT-TCS-A83, /// address = {Espoo, Finland}, /// author = {Heikki Tauriainen}, /// institution = {Helsinki University of Technology, Laboratory for /// Theoretical Computer Science}, /// month = {December}, /// number = {A83}, /// pages = {132}, /// title = {On Translating Linear Temporal Logic into Alternating and /// Nondeterministic Automata}, /// type = {Research Report}, /// year = {2003}, /// url = {<a href="http://www.tcs.hut.fi/Publications/info/bibdb.HUT-TCS-A83.shtml">http://www.tcs.hut.fi/Publications/info/bibdb.HUT-TCS-A83.shtml</a>} /// } ///  </p>

</div>
</div>
<a class="anchor" id="ga054c1948b6c5076350e44a85ad580403"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">emptiness_check* spot::magic_search </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">option_map&#160;</td>
          <td class="paramname"><em>o</em> = <code>option_map()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for the two magic_search implementations. </p>
<p>This wrapper calls explicit_magic_search_search() or <a class="el" href="group__emptiness__check__algorithms.html#gadae7938a96420813bcdabb1b31295294" title="Returns an emptiness checker on the spot::tgba automaton a.">bit_state_hashing_magic_search()</a> according to the <code>"bsh"</code> option in the <code><a class="el" href="classspot_1_1option__map.html" title="Manage a map of options.Each option is defined by a string and is associated to an integer value...">option_map</a></code>. If <code>"bsh"</code> is set and non null, its value is used as the size of the hash map. </p>

</div>
</div>
<a class="anchor" id="ga23a00d19bf7613222e6e41833e515c00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">emptiness_check* spot::se05 </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">option_map&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for the two se05 implementations. </p>
<p>This wrapper calls <a class="el" href="group__emptiness__check__algorithms.html#ga8c176368673a0c009dd3e934d57fb492" title="Returns an emptiness check on the spot::tgba automaton a.">explicit_se05_search()</a> or <a class="el" href="group__emptiness__check__algorithms.html#gae822266082cdb9772ce31388a6538cb9" title="Returns an emptiness checker on the spot::tgba automaton a.">bit_state_hashing_se05_search()</a> according to the <code>"bsh"</code> option in the <code><a class="el" href="classspot_1_1option__map.html" title="Manage a map of options.Each option is defined by a string and is associated to an integer value...">option_map</a></code>. If <code>"bsh"</code> is set and non null, its value is used as the size of the hash map. </p>

</div>
</div>
</div><!-- contents -->
<hr size="1">
Please <b>comment</b> this page and <b>report errors</b> about it on
<a href="http://spot.lip6.fr/wiki/RefDocComments">the RefDocComments page</a>.
<br><address style="align: right;"><small>
Generated on Sat Oct 27 2012 09:34:33 for spot by <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border=0></a> 1.8.1.2</small></address>
</body>
</html>
