<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>spot: spot Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">spot
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">spot Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacespot_1_1eltl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1eltl.html">eltl</a></td></tr>
<tr class="memitem:namespacespot_1_1ltl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html">ltl</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1evtgba.html">evtgba</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1evtgba__iterator.html">evtgba_iterator</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1evtgba__explicit.html">evtgba_explicit</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1state__evtgba__explicit.html">state_evtgba_explicit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">States used by spot::tgba_evtgba_explicit.  <a href="classspot_1_1state__evtgba__explicit.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1evtgba__product.html">evtgba_product</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1symbol.html">symbol</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1rsymbol.html">rsymbol</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1evtgba__reachable__iterator.html">evtgba_reachable_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all reachable states of a <a class="el" href="classspot_1_1evtgba.html">spot::evtgba</a>.  <a href="classspot_1_1evtgba__reachable__iterator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1evtgba__reachable__iterator__depth__first.html">evtgba_reachable_iterator_depth_first</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="classspot_1_1evtgba__reachable__iterator.html" title="Iterate over all reachable states of a spot::evtgba.">spot::evtgba_reachable_iterator</a> that browses states depth first.  <a href="classspot_1_1evtgba__reachable__iterator__depth__first.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1evtgba__reachable__iterator__breadth__first.html">evtgba_reachable_iterator_breadth_first</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="classspot_1_1evtgba__reachable__iterator.html" title="Iterate over all reachable states of a spot::evtgba.">spot::evtgba_reachable_iterator</a> that browses states breadth first.  <a href="classspot_1_1evtgba__reachable__iterator__breadth__first.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1fair__kripke__succ__iterator.html">fair_kripke_succ_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator code for a Fair Kripke structure.This iterator can be used to simplify the writing of an iterator on a Fair Kripke structure (or lookalike).  <a href="classspot_1_1fair__kripke__succ__iterator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1fair__kripke.html">fair_kripke</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for a Fair Kripke structure.A Kripke structure is a graph in which each node (=state) is labeled by a conjunction of atomic proposition, and a set of acceptance conditions.  <a href="classspot_1_1fair__kripke.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1kripke__succ__iterator.html">kripke_succ_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator code for Kripke structureThis iterator can be used to simplify the writing of an iterator on a Kripke structure (or lookalike).  <a href="classspot_1_1kripke__succ__iterator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1kripke.html">kripke</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for a Kripke structureA Kripke structure is a graph in which each node (=state) is labeled by a conjunction of atomic proposition.  <a href="classspot_1_1kripke.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1state__kripke.html">state_kripke</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete class for kripke states.  <a href="classspot_1_1state__kripke.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1kripke__explicit__succ__iterator.html">kripke_explicit_succ_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement iterator pattern on successor of a <a class="el" href="classspot_1_1state__kripke.html" title="Concrete class for kripke states.">state_kripke</a>.  <a href="classspot_1_1kripke__explicit__succ__iterator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1kripke__explicit.html">kripke_explicit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kripke Structure.  <a href="classspot_1_1kripke__explicit.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1acc__compl.html">acc_compl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to convert acceptance conditions into promises.  <a href="classspot_1_1acc__compl.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1acceptance__convertor.html">acceptance_convertor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Help class to convert between acceptance conditions to other BDD formats.  <a href="classspot_1_1acceptance__convertor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__allocator.html">bdd_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manage ranges of variables.  <a href="classspot_1_1bdd__allocator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1bdd__less__than.html">bdd_less_than</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison functor for BDDs.  <a href="structspot_1_1bdd__less__than.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1bdd__hash.html">bdd_hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor for BDDs.  <a href="structspot_1_1bdd__hash.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1fixed__size__pool.html">fixed_size_pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fixed-size memory pool implementation.  <a href="classspot_1_1fixed__size__pool.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1printable.html">printable</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1printable__value.html">printable_value</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1printable__id.html">printable_id</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default callback simply writes "%c".  <a href="classspot_1_1printable__id.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1printable__percent.html">printable_percent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by default for "%%" and "%\0".  <a href="classspot_1_1printable__percent.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1formater.html">formater</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1free__list.html">free_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manage list of free integers.  <a href="classspot_1_1free__list.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1ptr__hash.html">ptr_hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hash function for pointers.  <a href="structspot_1_1ptr__hash.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1identity__hash.html">identity_hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hash function that returns identity.  <a href="structspot_1_1identity__hash.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1char__ptr__less__than.html">char_ptr_less_than</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strict Weak Ordering for <code>char*</code>.This is meant to be used as a comparison functor for STL <code>map</code> whose key are of type <code>const char*</code>.  <a href="structspot_1_1char__ptr__less__than.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1minato__isop.html">minato_isop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an irredundant sum-of-products (ISOP) form of a BDD function.This algorithm implements a derecursived version the Minato-Morreale algorithm presented in the following paper.  <a href="classspot_1_1minato__isop.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html">loopless_modular_mixed_radix_gray_code</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loopless modular mixed radix Gray code iteration.This class is based on the loopless modular mixed radix gray code algorithm described in exercise 77 of "The Art of Computer
     Programming", Pre-Fascicle 2A (Draft of section 7.2.1.1: generating all n-tuples) by Donald E. Knuth.  <a href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1multiple__size__pool.html">multiple_size_pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multiple-size memory pool implementation.  <a href="classspot_1_1multiple__size__pool.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1option__map.html">option_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manage a map of options.Each option is defined by a string and is associated to an integer value.  <a href="classspot_1_1option__map.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1barand.html">barand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute pseudo-random integer value between 0 and <em>n</em> included, following a binomial distribution for probability <em>p</em>.  <a href="classspot_1_1barand.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1time__info.html">time_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure to record elapsed time in clock ticks.  <a href="structspot_1_1time__info.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1timer.html">timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A timekeeper that accumulate interval of time.  <a href="classspot_1_1timer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1timer__map.html">timer_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map of timer, where each timer has a name.  <a href="classspot_1_1timer__map.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1unique__ptr.html">unique_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take ownership of a pointer at its construction, and destroy it at the end of the scope.  <a href="classspot_1_1unique__ptr.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1explicit__state__conjunction.html">explicit_state_conjunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic implementation of <a class="el" href="classspot_1_1saba__state__conjunction.html" title="Iterate over a conjunction of saba_state.This class provides the basic functionalities required to it...">saba_state_conjunction</a>.This class provides a basic implementation to iterate over a conjunction of states of a saba.  <a href="classspot_1_1explicit__state__conjunction.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1saba.html">saba</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A State-based Alternating (Generalized) Büchi Automaton.Browsing such automaton can be achieved using two functions: <code>get_init_state</code>, and <code>succ_iter</code>. The former returns the initial state while the latter lists the successor states of any state.  <a href="classspot_1_1saba.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1saba__complement__tgba.html">saba_complement_tgba</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complement a TGBA and produce a SABA.The original TGBA is transformed into a States-based Büchi Automaton.  <a href="classspot_1_1saba__complement__tgba.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1saba__state.html">saba_state</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for saba states.  <a href="classspot_1_1saba__state.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1saba__state__ptr__less__than.html">saba_state_ptr_less_than</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strict Weak Ordering for <code>saba_state*</code>.This is meant to be used as a comparison functor for STL <code>map</code> whose key are of type <code>saba_state*</code>.  <a href="structspot_1_1saba__state__ptr__less__than.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1saba__state__ptr__equal.html">saba_state_ptr_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Equivalence Relation for <code>saba_state*</code>.This is meant to be used as a comparison functor for Sgi <code>hash_map</code> whose key are of type <code>saba_state*</code>.  <a href="structspot_1_1saba__state__ptr__equal.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1saba__state__ptr__hash.html">saba_state_ptr_hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash Function for <code>saba_state*</code>.This is meant to be used as a hash functor for Sgi's <code>hash_map</code> whose key are of type <code>saba_state*</code>.  <a href="structspot_1_1saba__state__ptr__hash.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1saba__state__shared__ptr__less__than.html">saba_state_shared_ptr_less_than</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strict Weak Ordering for <code>shared_saba_state</code> (shared_ptr&lt;const saba_state*&gt;).This is meant to be used as a comparison functor for STL <code>map</code> whose key are of type <code>shared_saba_state</code>.  <a href="structspot_1_1saba__state__shared__ptr__less__than.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1saba__state__shared__ptr__equal.html">saba_state_shared_ptr_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Equivalence Relation for <code>shared_saba_state</code> (shared_ptr&lt;const saba_state*&gt;).This is meant to be used as a comparison functor for Sgi <code>hash_map</code> whose key are of type <code>shared_saba_state</code>.  <a href="structspot_1_1saba__state__shared__ptr__equal.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1saba__state__shared__ptr__hash.html">saba_state_shared_ptr_hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash Function for <code>shared_saba_state</code> (shared_ptr&lt;const saba_state*&gt;).This is meant to be used as a hash functor for Sgi's <code>hash_map</code> whose key are of type <code>shared_saba_state</code>.  <a href="structspot_1_1saba__state__shared__ptr__hash.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1saba__state__conjunction.html">saba_state_conjunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over a conjunction of <a class="el" href="classspot_1_1saba__state.html" title="Abstract class for saba states.">saba_state</a>.This class provides the basic functionalities required to iterate over a conjunction of states of a saba.  <a href="classspot_1_1saba__state__conjunction.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1saba__succ__iterator.html">saba_succ_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over the successors of a <a class="el" href="classspot_1_1saba__state.html" title="Abstract class for saba states.">saba_state</a>.This class provides the basic functionalities required to iterate over the successors of a state of a saba. Since transitions of an alternating automaton are defined as a boolean function with conjunctions (universal) and disjunctions (non-deterministic),.  <a href="classspot_1_1saba__succ__iterator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1saba__reachable__iterator.html">saba_reachable_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all reachable states of a <a class="el" href="classspot_1_1saba.html" title="A State-based Alternating (Generalized) Büchi Automaton.Browsing such automaton can be achieved using...">spot::saba</a>.  <a href="classspot_1_1saba__reachable__iterator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1saba__reachable__iterator__depth__first.html">saba_reachable_iterator_depth_first</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="classspot_1_1saba__reachable__iterator.html" title="Iterate over all reachable states of a spot::saba.">spot::saba_reachable_iterator</a> that browses states depth first.  <a href="classspot_1_1saba__reachable__iterator__depth__first.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1saba__reachable__iterator__breadth__first.html">saba_reachable_iterator_breadth_first</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="classspot_1_1saba__reachable__iterator.html" title="Iterate over all reachable states of a spot::saba.">spot::saba_reachable_iterator</a> that browses states breadth first.  <a href="classspot_1_1saba__reachable__iterator__breadth__first.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta.html">ta</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Testing Automaton.The Testing Automata (TA) were introduced by Henri Hansen, Wojciech Penczek and Antti Valmari in "Stuttering-insensitive automata for on-the-fly detection of livelock
properties" In Proc. of FMICSÕ02, vol. 66(2) of Electronic Notes in Theoretical Computer Science.Elsevier.  <a href="classspot_1_1ta.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__succ__iterator.html">ta_succ_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over the successors of a state.This class provides the basic functionalities required to iterate over the successors of a state, as well as querying transition labels. Because transitions are never explicitely encoded, labels (conditions and acceptance conditions) can only be queried while iterating over the successors.  <a href="classspot_1_1ta__succ__iterator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1scc__stack__ta.html">scc_stack_ta</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__explicit.html">ta_explicit</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1state__ta__explicit.html">state_ta_explicit</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__explicit__succ__iterator.html">ta_explicit_succ_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Successor iterators used by <a class="el" href="classspot_1_1ta__explicit.html">spot::ta_explicit</a>.  <a href="classspot_1_1ta__explicit__succ__iterator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1state__ta__product.html">state_ta_product</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A state for <a class="el" href="classspot_1_1ta__product.html" title="A lazy product between a Testing automaton and a Kripke structure. (States are computed on the fly...">spot::ta_product</a>.This state is in fact a pair of state: the state from the TA automaton and that of Kripke structure.  <a href="classspot_1_1state__ta__product.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__succ__iterator__product.html">ta_succ_iterator_product</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over the successors of a product computed on the fly.  <a href="classspot_1_1ta__succ__iterator__product.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__product.html">ta_product</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lazy product between a Testing automaton and a Kripke structure. (States are computed on the fly.)  <a href="classspot_1_1ta__product.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__succ__iterator__product__by__changeset.html">ta_succ_iterator_product_by_changeset</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgta.html">tgta</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Transition-based Generalized Testing Automaton (TGTA).Transition-based Generalized Testing Automaton (TGTA) is a new kind of automaton that combines features from both TA and TGBA. From TA, we take the idea of labeling transitions with changesets, however we remove the use of livelock-acceptance (because it may require a two-pass emptiness check), and the implicit stuttering. From TGBA, we inherit the use of transition-based generalized acceptance conditions. The resulting Chimera, which we call {Transition-based Generalized Testing Automaton} (TGTA), accepts only stuttering-insensitive languages like TA, and inherits advantages from both TA and TGBA: it has a simple one-pass emptiness-check procedure (the same as algorithm the one for TGBA), and can benefit from reductions based on the stuttering of the properties pretty much like a TA. Livelock acceptance states, which are no longer supported are emulated using states with a BÃ¼chi accepting self-loop labeled by empty changeset.  <a href="classspot_1_1tgta.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgta__explicit.html">tgta_explicit</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgta__product.html">tgta_product</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lazy product. (States are computed on the fly.)  <a href="classspot_1_1tgta__product.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgta__succ__iterator__product.html">tgta_succ_iterator_product</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over the successors of a product computed on the fly.  <a href="classspot_1_1tgta__succ__iterator__product.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__check.html">ta_check</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of the emptiness-check algorithm for a product between a TA and a Kripke structure.  <a href="classspot_1_1ta__check.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__reachable__iterator.html">ta_reachable_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all reachable states of a <a class="el" href="classspot_1_1ta.html" title="A Testing Automaton.The Testing Automata (TA) were introduced by Henri Hansen, Wojciech Penczek and A...">spot::ta</a>.  <a href="classspot_1_1ta__reachable__iterator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__reachable__iterator__depth__first.html">ta_reachable_iterator_depth_first</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="classspot_1_1ta__reachable__iterator.html" title="Iterate over all reachable states of a spot::ta.">spot::ta_reachable_iterator</a> that browses states depth first.  <a href="classspot_1_1ta__reachable__iterator__depth__first.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__reachable__iterator__breadth__first.html">ta_reachable_iterator_breadth_first</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="classspot_1_1ta__reachable__iterator.html" title="Iterate over all reachable states of a spot::ta.">spot::ta_reachable_iterator</a> that browses states breadth first.  <a href="classspot_1_1ta__reachable__iterator__breadth__first.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1ta__statistics.html">ta_statistics</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map BDD variables to formulae.  <a href="classspot_1_1bdd__dict.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1future__conditions__collector.html">future_conditions_collector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a tgba to offer information about upcoming conditions.This class is a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> wrapper that simply add a new method, <a class="el" href="classspot_1_1future__conditions__collector.html#a9417271a5ecac3517205108fbcf1e638" title="Returns the set of future conditions visible after s.">future_conditions()</a>, to any <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a>.  <a href="classspot_1_1future__conditions__collector.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1sba.html">sba</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A State-based Generalized BÃ¼chi Automaton.An SBA is a TGBA in which the outgoing transitions of a state are either all accepting (in which case the source state is said "accepting"(, or all non-accepting.  <a href="classspot_1_1sba.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1state.html">state</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for states.  <a href="classspot_1_1state.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1state__ptr__less__than.html">state_ptr_less_than</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strict Weak Ordering for <code>state*</code>.This is meant to be used as a comparison functor for STL <code>map</code> whose key are of type <code>state*</code>.  <a href="structspot_1_1state__ptr__less__than.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1state__ptr__equal.html">state_ptr_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Equivalence Relation for <code>state*</code>.This is meant to be used as a comparison functor for Sgi <code>hash_map</code> whose key are of type <code>state*</code>.  <a href="structspot_1_1state__ptr__equal.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1state__ptr__hash.html">state_ptr_hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash Function for <code>state*</code>.This is meant to be used as a hash functor for Sgi's <code>hash_map</code> whose key are of type <code>state*</code>.  <a href="structspot_1_1state__ptr__hash.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1state__shared__ptr__less__than.html">state_shared_ptr_less_than</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strict Weak Ordering for <code>shared_state</code> (shared_ptr&lt;const state*&gt;).This is meant to be used as a comparison functor for STL <code>map</code> whose key are of type <code>shared_state</code>.  <a href="structspot_1_1state__shared__ptr__less__than.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1state__shared__ptr__equal.html">state_shared_ptr_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Equivalence Relation for <code>shared_state</code> (shared_ptr&lt;const state*&gt;).This is meant to be used as a comparison functor for Sgi <code>hash_map</code> whose key are of type <code>shared_state</code>.  <a href="structspot_1_1state__shared__ptr__equal.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1state__shared__ptr__hash.html">state_shared_ptr_hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash Function for <code>shared_state</code> (shared_ptr&lt;const state*&gt;).This is meant to be used as a hash functor for Sgi's <code>hash_map</code> whose key are of type <code>shared_state</code>.  <a href="structspot_1_1state__shared__ptr__hash.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1state__bdd.html">state_bdd</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__succ__iterator.html">tgba_succ_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over the successors of a state.This class provides the basic functionalities required to iterate over the successors of a state, as well as querying transition labels. Because transitions are never explicitely encoded, labels (conditions and acceptance conditions) can only be queried while iterating over the successors.  <a href="classspot_1_1tgba__succ__iterator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__succ__iterator__concrete.html">tgba_succ_iterator_concrete</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1taa__tgba.html">taa_tgba</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A self-loop Transition-based Alternating Automaton (TAA) which is seen as a TGBA (abstract class, see below).  <a href="classspot_1_1taa__tgba.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1state__set.html">state_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of states deriving from <a class="el" href="classspot_1_1state.html" title="Abstract class for states.">spot::state</a>.  <a href="classspot_1_1state__set.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1taa__succ__iterator.html">taa_succ_iterator</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1taa__tgba__labelled.html">taa_tgba_labelled</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1taa__tgba__string.html">taa_tgba_string</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1taa__tgba__formula.html">taa_tgba_formula</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba.html">tgba</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi Automaton) was coined by Dimitra Giannakopoulou and Flavio Lerda in "From States to Transitions: Improving Translation of LTL
Formulae to Büchi Automata". (FORTE'02)  <a href="classspot_1_1tgba.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__bdd__concrete.html">tgba_bdd_concrete</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concrete <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> implemented using BDDs.  <a href="classspot_1_1tgba__bdd__concrete.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__bdd__concrete__factory.html">tgba_bdd_concrete_factory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to build a <a class="el" href="classspot_1_1tgba__bdd__concrete.html" title="A concrete spot::tgba implemented using BDDs.">spot::tgba_bdd_concrete</a> object.  <a href="classspot_1_1tgba__bdd__concrete__factory.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1tgba__bdd__core__data.html">tgba_bdd_core_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Core data for a TGBA encoded using BDDs.  <a href="structspot_1_1tgba__bdd__core__data.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__bdd__factory.html">tgba_bdd_factory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for <a class="el" href="classspot_1_1tgba__bdd__concrete.html" title="A concrete spot::tgba implemented using BDDs.">spot::tgba_bdd_concrete</a> factories.  <a href="classspot_1_1tgba__bdd__factory.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1destroy__key.html">destroy_key</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1destroy__key_3_01const_01ltl_1_1formula_01_5_01_4.html">destroy_key&lt; const ltl::formula * &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1state__explicit.html">state_explicit</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1state__explicit__number.html">state_explicit_number</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1state__explicit__string.html">state_explicit_string</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1state__explicit__formula.html">state_explicit_formula</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__explicit__succ__iterator.html">tgba_explicit_succ_iterator</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1explicit__graph.html">explicit_graph</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__explicit.html">tgba_explicit</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1sba__explicit.html">sba_explicit</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1explicit__conf.html">explicit_conf</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1explicit__conf_3_01graph_00_01state__explicit__string_01_4.html">explicit_conf&lt; graph, state_explicit_string &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1explicit__conf_3_01graph_00_01state__explicit__formula_01_4.html">explicit_conf&lt; graph, state_explicit_formula &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__ordered.html">bdd_ordered</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__kv__complement.html">tgba_kv_complement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a complemented automaton.The construction comes from:  <a href="classspot_1_1tgba__kv__complement.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1state__product.html">state_product</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A state for <a class="el" href="classspot_1_1tgba__product.html" title="A lazy product. (States are computed on the fly.)">spot::tgba_product</a>.This state is in fact a pair of state: the state from the left automaton and that of the right.  <a href="classspot_1_1state__product.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__product.html">tgba_product</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lazy product. (States are computed on the fly.)  <a href="classspot_1_1tgba__product.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__product__init.html">tgba_product_init</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lazy product with different initial states.  <a href="classspot_1_1tgba__product__init.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__safra__complement.html">tgba_safra_complement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a complemented automaton.It creates an automaton that recognizes the negated language of <em>aut</em>.  <a href="classspot_1_1tgba__safra__complement.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__scc.html">tgba_scc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a tgba to offer information about strongly connected components.This class is a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> wrapper that simply add a new method <a class="el" href="classspot_1_1tgba__scc.html#a0710f2fdfd1d418eef39b96f03b21d68" title="Returns the number of the SCC s belongs to.">scc_of_state()</a> to retrieve the number of a SCC a state belongs to.  <a href="classspot_1_1tgba__scc.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__sgba__proxy.html">tgba_sgba_proxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the labeling-mode of <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> on the fly, producing a state-based generalized Büchi automaton.This class acts as a proxy in front of a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a>, that should label on states on-the-fly. The result is still a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a>, but acceptances conditions are also on states.  <a href="classspot_1_1tgba__sgba__proxy.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__tba__proxy.html">tgba_tba_proxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Degeneralize a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> on the fly, producing a TBA.This class acts as a proxy in front of a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a>, that should be degeneralized on the fly. The result is still a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a>, but it will always have exactly one acceptance condition so it could be called TBA (without the G).  <a href="classspot_1_1tgba__tba__proxy.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__sba__proxy.html">tgba_sba_proxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Degeneralize a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> on the fly, producing an SBA.This class acts as a proxy in front of a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a>, that should be degeneralized on the fly.  <a href="classspot_1_1tgba__sba__proxy.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1state__union.html">state_union</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A state for <a class="el" href="classspot_1_1tgba__union.html" title="A lazy union. (States are computed on the fly.)">spot::tgba_union</a>.This state is in fact a pair. If the first member equals 0 and the second is different from 0, the state belongs to the left automaton. If the first member is different from 0 and the second is 0, the state belongs to the right automaton. If both members are 0, the state is the initial state.  <a href="classspot_1_1state__union.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__succ__iterator__union.html">tgba_succ_iterator_union</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over the successors of an union computed on the fly.  <a href="classspot_1_1tgba__succ__iterator__union.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__union.html">tgba_union</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lazy union. (States are computed on the fly.)  <a href="classspot_1_1tgba__union.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bfs__steps.html">bfs_steps</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a BFS in a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> to compute a <a class="el" href="structspot_1_1tgba__run.html#a992869805fc5a8c3146e77309be61312">tgba_run::steps</a>.This class should be used to compute the shortest path between a state of a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> and the first transition or state that matches some conditions.  <a href="classspot_1_1bfs__steps.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1sccs__set.html">sccs_set</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1enumerate__cycles.html">enumerate_cycles</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate elementary cycles in a SCC.  <a href="classspot_1_1enumerate__cycles.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1dotty__decorator.html">dotty_decorator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose state and link styles for <a class="el" href="namespacespot.html#ab3ff98345b771b22e0a9b67063676e84" title="Print reachable states in dot format.">spot::dotty_reachable</a>.  <a href="classspot_1_1dotty__decorator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1emptiness__check__result.html">emptiness_check_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result of an emptiness check.  <a href="classspot_1_1emptiness__check__result.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common interface to emptiness check algorithms.  <a href="classspot_1_1emptiness__check.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1emptiness__check__instantiator.html">emptiness_check_instantiator</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1tgba__run.html">tgba_run</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An accepted run, for a tgba.  <a href="structspot_1_1tgba__run.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1unsigned__statistics.html">unsigned_statistics</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1unsigned__statistics__copy.html">unsigned_statistics_copy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparable statistics  <a href="classspot_1_1unsigned__statistics__copy.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ec__statistics.html">ec_statistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emptiness-check statistics.  <a href="classspot_1_1ec__statistics.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ars__statistics.html">ars_statistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accepting Run Search statistics.  <a href="classspot_1_1ars__statistics.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1acss__statistics.html">acss_statistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accepting Cycle Search Space statistics.  <a href="classspot_1_1acss__statistics.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1couvreur99__check__result.html">couvreur99_check_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a counter example from a <a class="el" href="classspot_1_1couvreur99__check__status.html" title="The status of the emptiness-check on success.">spot::couvreur99_check_status</a>.  <a href="classspot_1_1couvreur99__check__result.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1explicit__connected__component.html">explicit_connected_component</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An SCC storing all its states explicitly.  <a href="classspot_1_1explicit__connected__component.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1connected__component__hash__set.html">connected_component_hash_set</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1explicit__connected__component__factory.html">explicit_connected_component_factory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract factory for <a class="el" href="classspot_1_1explicit__connected__component.html" title="An SCC storing all its states explicitly.">explicit_connected_component</a>.  <a href="classspot_1_1explicit__connected__component__factory.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1connected__component__hash__set__factory.html">connected_component_hash_set_factory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for <a class="el" href="classspot_1_1connected__component__hash__set.html">connected_component_hash_set</a>.  <a href="classspot_1_1connected__component__hash__set__factory.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1couvreur99__check.html">couvreur99_check</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of the Couvreur99 emptiness-check algorithm.  <a href="classspot_1_1couvreur99__check.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1couvreur99__check__shy.html">couvreur99_check_shy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A version of <a class="el" href="classspot_1_1couvreur99__check.html" title="An implementation of the Couvreur99 emptiness-check algorithm.">spot::couvreur99_check</a> that tries to visit known states first.  <a href="classspot_1_1couvreur99__check__shy.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1numbered__state__heap__const__iterator.html">numbered_state_heap_const_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator on <a class="el" href="classspot_1_1numbered__state__heap.html" title="Keep track of a large quantity of indexed states.">numbered_state_heap</a> objects.  <a href="classspot_1_1numbered__state__heap__const__iterator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1numbered__state__heap.html">numbered_state_heap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep track of a large quantity of indexed states.  <a href="classspot_1_1numbered__state__heap.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1numbered__state__heap__factory.html">numbered_state_heap_factory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract factory for <a class="el" href="classspot_1_1numbered__state__heap.html" title="Keep track of a large quantity of indexed states.">numbered_state_heap</a>.  <a href="classspot_1_1numbered__state__heap__factory.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1numbered__state__heap__hash__map.html">numbered_state_heap_hash_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A straightforward implementation of <a class="el" href="classspot_1_1numbered__state__heap.html" title="Keep track of a large quantity of indexed states.">numbered_state_heap</a> with a hash map.  <a href="classspot_1_1numbered__state__heap__hash__map.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1numbered__state__heap__hash__map__factory.html">numbered_state_heap_hash_map_factory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for <a class="el" href="classspot_1_1numbered__state__heap__hash__map.html" title="A straightforward implementation of numbered_state_heap with a hash map.">numbered_state_heap_hash_map</a>.  <a href="classspot_1_1numbered__state__heap__hash__map__factory.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1scc__stack.html">scc_stack</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1couvreur99__check__status.html">couvreur99_check_status</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The status of the emptiness-check on success.  <a href="classspot_1_1couvreur99__check__status.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1postprocessor.html">postprocessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap TGBA/BA/Monitor post-processing algorithms in an easy interface.  <a href="classspot_1_1postprocessor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1power__map.html">power_map</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__reachable__iterator.html">tgba_reachable_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all reachable states of a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a>.  <a href="classspot_1_1tgba__reachable__iterator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__reachable__iterator__depth__first.html">tgba_reachable_iterator_depth_first</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="classspot_1_1tgba__reachable__iterator.html" title="Iterate over all reachable states of a spot::tgba.">spot::tgba_reachable_iterator</a> that browses states depth first.  <a href="classspot_1_1tgba__reachable__iterator__depth__first.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__reachable__iterator__breadth__first.html">tgba_reachable_iterator_breadth_first</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="classspot_1_1tgba__reachable__iterator.html" title="Iterate over all reachable states of a spot::tgba.">spot::tgba_reachable_iterator</a> that browses states breadth first.  <a href="classspot_1_1tgba__reachable__iterator__breadth__first.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__run__dotty__decorator.html">tgba_run_dotty_decorator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Highlight a <a class="el" href="structspot_1_1tgba__run.html" title="An accepted run, for a tgba.">spot::tgba_run</a> on a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a>.An instance of this class can be passed to <a class="el" href="namespacespot.html#ab3ff98345b771b22e0a9b67063676e84" title="Print reachable states in dot format.">spot::dotty_reachable</a>.  <a href="classspot_1_1tgba__run__dotty__decorator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1scc__stats.html">scc_stats</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1scc__map.html">scc_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a map of Strongly Connected components in in a TGBA.  <a href="classspot_1_1scc__map.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1tgba__statistics.html">tgba_statistics</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1tgba__sub__statistics.html">tgba_sub_statistics</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1printable__formula.html">printable_formula</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1stat__printer.html">stat_printer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints various statistics about a TGBA  <a href="classspot_1_1stat__printer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1weight.html">weight</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manage for a given automaton a vector of counter indexed by its acceptance condition.  <a href="classspot_1_1weight.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1gspn__exception.html">gspn_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception used to forward GSPN errors.  <a href="classspot_1_1gspn__exception.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1gspn__interface.html">gspn_interface</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1gspn__ssp__interface.html">gspn_ssp_interface</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab1fe964166144356a185c98ce0bcbde6"><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; const <a class="el" href="classspot_1_1symbol.html">symbol</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#ab1fe964166144356a185c98ce0bcbde6">symbol_set</a></td></tr>
<tr class="memitem:a5f139f442de158fbe3bf9fab3ddee7f3"><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; <a class="el" href="classspot_1_1rsymbol.html">rsymbol</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a5f139f442de158fbe3bf9fab3ddee7f3">rsymbol_set</a></td></tr>
<tr class="memitem:ad049f28e03c2ebe740e5597034fd5c93"><td class="memItemLeft" align="right" valign="top">typedef std::pair<br class="typebreak"/>
&lt; evtgbayy::location, <br class="typebreak"/>
std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#ad049f28e03c2ebe740e5597034fd5c93">evtgba_parse_error</a></td></tr>
<tr class="memdesc:ad049f28e03c2ebe740e5597034fd5c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parse diagnostic with its location.  <a href="#ad049f28e03c2ebe740e5597034fd5c93"></a><br/></td></tr>
<tr class="memitem:a90dc0e2318bb80c45893922f42ec44fe"><td class="memItemLeft" align="right" valign="top">typedef std::list<br class="typebreak"/>
&lt; <a class="el" href="namespacespot.html#ad049f28e03c2ebe740e5597034fd5c93">evtgba_parse_error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a90dc0e2318bb80c45893922f42ec44fe">evtgba_parse_error_list</a></td></tr>
<tr class="memdesc:a90dc0e2318bb80c45893922f42ec44fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of parser diagnostics, as filled by parse.  <a href="#a90dc0e2318bb80c45893922f42ec44fe"></a><br/></td></tr>
<tr class="memitem:a68ac7577bed0b7af5dd8e45135797759"><td class="memItemLeft" align="right" valign="top">typedef std::pair<br class="typebreak"/>
&lt; <a class="el" href="classkripkeyy_1_1location.html">kripkeyy::location</a>, <br class="typebreak"/>
std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a68ac7577bed0b7af5dd8e45135797759">kripke_parse_error</a></td></tr>
<tr class="memdesc:a68ac7577bed0b7af5dd8e45135797759"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parse diagnostic with its location.  <a href="#a68ac7577bed0b7af5dd8e45135797759"></a><br/></td></tr>
<tr class="memitem:a429e9facc10a0958d14ff3f94d71b006"><td class="memItemLeft" align="right" valign="top">typedef std::list<br class="typebreak"/>
&lt; <a class="el" href="namespacespot.html#a68ac7577bed0b7af5dd8e45135797759">kripke_parse_error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a429e9facc10a0958d14ff3f94d71b006">kripke_parse_error_list</a></td></tr>
<tr class="memdesc:a429e9facc10a0958d14ff3f94d71b006"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of parser diagnostics, as filled by parse.  <a href="#a429e9facc10a0958d14ff3f94d71b006"></a><br/></td></tr>
<tr class="memitem:ga3a14d5793c8decc8de5c19f640c721bf"><td class="memItemLeft" align="right" valign="top">typedef std::pair<br class="typebreak"/>
&lt; <a class="el" href="classneverclaimyy_1_1location.html">neverclaimyy::location</a>, <br class="typebreak"/>
std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#ga3a14d5793c8decc8de5c19f640c721bf">neverclaim_parse_error</a></td></tr>
<tr class="memdesc:ga3a14d5793c8decc8de5c19f640c721bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parse diagnostic with its location.  <a href="group__tgba__io.html#ga3a14d5793c8decc8de5c19f640c721bf"></a><br/></td></tr>
<tr class="memitem:ga15242b071d7c485804548ff2ee41b3d1"><td class="memItemLeft" align="right" valign="top">typedef std::list<br class="typebreak"/>
&lt; <a class="el" href="group__tgba__io.html#ga3a14d5793c8decc8de5c19f640c721bf">neverclaim_parse_error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#ga15242b071d7c485804548ff2ee41b3d1">neverclaim_parse_error_list</a></td></tr>
<tr class="memdesc:ga15242b071d7c485804548ff2ee41b3d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of parser diagnostics, as filled by parse.  <a href="group__tgba__io.html#ga15242b071d7c485804548ff2ee41b3d1"></a><br/></td></tr>
<tr class="memitem:a5494e2802ca03bd036c523a1c65f3a3e"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; const <a class="el" href="classspot_1_1saba__state.html">saba_state</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a5494e2802ca03bd036c523a1c65f3a3e">shared_saba_state</a></td></tr>
<tr class="memitem:a13a1db95095eccfe0a4ce4a818442fbf"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; const <a class="el" href="classspot_1_1state.html">state</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a13a1db95095eccfe0a4ce4a818442fbf">shared_state</a></td></tr>
<tr class="memitem:a3ace0ebc1ab16f0766fa681785750794"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classspot_1_1explicit__conf.html">explicit_conf</a><br class="typebreak"/>
&lt; <a class="el" href="classspot_1_1tgba__explicit.html">tgba_explicit</a><br class="typebreak"/>
&lt; <a class="el" href="classspot_1_1state__explicit__string.html">state_explicit_string</a> &gt;<br class="typebreak"/>
, <a class="el" href="classspot_1_1state__explicit__string.html">state_explicit_string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a3ace0ebc1ab16f0766fa681785750794">tgba_explicit_string</a></td></tr>
<tr class="memitem:a24df826dd55ad1b8a6fd711c8ab1785e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classspot_1_1explicit__conf.html">explicit_conf</a><br class="typebreak"/>
&lt; <a class="el" href="classspot_1_1tgba__explicit.html">tgba_explicit</a><br class="typebreak"/>
&lt; <a class="el" href="classspot_1_1state__explicit__formula.html">state_explicit_formula</a> &gt;<br class="typebreak"/>
, <a class="el" href="classspot_1_1state__explicit__formula.html">state_explicit_formula</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a24df826dd55ad1b8a6fd711c8ab1785e">tgba_explicit_formula</a></td></tr>
<tr class="memitem:ad566cf6234b8c875958ed4001f959bb4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classspot_1_1explicit__conf.html">explicit_conf</a><br class="typebreak"/>
&lt; <a class="el" href="classspot_1_1tgba__explicit.html">tgba_explicit</a><br class="typebreak"/>
&lt; <a class="el" href="classspot_1_1state__explicit__number.html">state_explicit_number</a> &gt;<br class="typebreak"/>
, <a class="el" href="classspot_1_1state__explicit__number.html">state_explicit_number</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#ad566cf6234b8c875958ed4001f959bb4">tgba_explicit_number</a></td></tr>
<tr class="memitem:a118b4701825f7a8860cebf5c0a68eee3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classspot_1_1explicit__conf.html">explicit_conf</a><br class="typebreak"/>
&lt; <a class="el" href="classspot_1_1sba__explicit.html">sba_explicit</a><br class="typebreak"/>
&lt; <a class="el" href="classspot_1_1state__explicit__string.html">state_explicit_string</a> &gt;<br class="typebreak"/>
, <a class="el" href="classspot_1_1state__explicit__string.html">state_explicit_string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a118b4701825f7a8860cebf5c0a68eee3">sba_explicit_string</a></td></tr>
<tr class="memitem:a7ce8b43567a8c7e16773717dcf683eb3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classspot_1_1explicit__conf.html">explicit_conf</a><br class="typebreak"/>
&lt; <a class="el" href="classspot_1_1sba__explicit.html">sba_explicit</a><br class="typebreak"/>
&lt; <a class="el" href="classspot_1_1state__explicit__formula.html">state_explicit_formula</a> &gt;<br class="typebreak"/>
, <a class="el" href="classspot_1_1state__explicit__formula.html">state_explicit_formula</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a7ce8b43567a8c7e16773717dcf683eb3">sba_explicit_formula</a></td></tr>
<tr class="memitem:a13bc152377363a78e3ab83a43a6be053"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classspot_1_1explicit__conf.html">explicit_conf</a><br class="typebreak"/>
&lt; <a class="el" href="classspot_1_1sba__explicit.html">sba_explicit</a><br class="typebreak"/>
&lt; <a class="el" href="classspot_1_1state__explicit__number.html">state_explicit_number</a> &gt;<br class="typebreak"/>
, <a class="el" href="classspot_1_1state__explicit__number.html">state_explicit_number</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a13bc152377363a78e3ab83a43a6be053">sba_explicit_number</a></td></tr>
<tr class="memitem:a4260b69cfc6b42df1b242d141d250acc"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="classspot_1_1bdd__ordered.html">bdd_ordered</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a4260b69cfc6b42df1b242d141d250acc">acc_list_t</a></td></tr>
<tr class="memitem:gadcc2cd9b328a5c3f63918c577f86f18c"><td class="memItemLeft" align="right" valign="top">typedef std::pair<br class="typebreak"/>
&lt; tgbayy::location, <br class="typebreak"/>
std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#gadcc2cd9b328a5c3f63918c577f86f18c">tgba_parse_error</a></td></tr>
<tr class="memdesc:gadcc2cd9b328a5c3f63918c577f86f18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parse diagnostic with its location.  <a href="group__tgba__io.html#gadcc2cd9b328a5c3f63918c577f86f18c"></a><br/></td></tr>
<tr class="memitem:ga76b22bb081d5c36378098caa5bf58081"><td class="memItemLeft" align="right" valign="top">typedef std::list<br class="typebreak"/>
&lt; <a class="el" href="group__tgba__io.html#gadcc2cd9b328a5c3f63918c577f86f18c">tgba_parse_error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#ga76b22bb081d5c36378098caa5bf58081">tgba_parse_error_list</a></td></tr>
<tr class="memdesc:ga76b22bb081d5c36378098caa5bf58081"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of parser diagnostics, as filled by parse.  <a href="group__tgba__io.html#ga76b22bb081d5c36378098caa5bf58081"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga33960cd9c4aa7bb175efe1debb7534b0"><td class="memItemLeft" align="right" valign="top">typedef Sgi::hash&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hash__funcs.html#ga33960cd9c4aa7bb175efe1debb7534b0">string_hash</a></td></tr>
<tr class="memdesc:ga33960cd9c4aa7bb175efe1debb7534b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hash function for strings.  <a href="group__hash__funcs.html#ga33960cd9c4aa7bb175efe1debb7534b0"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga5bd08ab74b3ab10a27beceaa04d9217a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__reduction.html#ga5bd08ab74b3ab10a27beceaa04d9217a">reduce_tgba_options</a> { <br/>
&#160;&#160;<a class="el" href="group__tgba__reduction.html#gga5bd08ab74b3ab10a27beceaa04d9217aa28ab8e63b3f476424eec1d49fb19b1e6">Reduce_None</a> =  0, 
<a class="el" href="group__tgba__reduction.html#gga5bd08ab74b3ab10a27beceaa04d9217aa6ef94353974a1119b8c3265eb0bcbe42">Reduce_quotient_Dir_Sim</a> =  1, 
<a class="el" href="group__tgba__reduction.html#gga5bd08ab74b3ab10a27beceaa04d9217aa7b2d15a717f241527e25e1266370033e">Reduce_transition_Dir_Sim</a> =  2, 
<a class="el" href="group__tgba__reduction.html#gga5bd08ab74b3ab10a27beceaa04d9217aa040be3fac90f0ddb426644a52418d7a3">Reduce_quotient_Del_Sim</a> =  4, 
<br/>
&#160;&#160;<a class="el" href="group__tgba__reduction.html#gga5bd08ab74b3ab10a27beceaa04d9217aa21c74a793193bfe95e63b43ef1b59350">Reduce_transition_Del_Sim</a> =  8, 
<a class="el" href="group__tgba__reduction.html#gga5bd08ab74b3ab10a27beceaa04d9217aa685daa8530de270e1588cdc2c178a2ab">Reduce_Scc</a> =  16, 
<a class="el" href="group__tgba__reduction.html#gga5bd08ab74b3ab10a27beceaa04d9217aa81a405e18e9bbd601c4183e1c7ff49e1">Reduce_All</a> =  -1U
<br/>
 }</td></tr>
<tr class="memdesc:ga5bd08ab74b3ab10a27beceaa04d9217a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for reduce.  <a href="group__tgba__reduction.html#ga5bd08ab74b3ab10a27beceaa04d9217a">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab3ff98345b771b22e0a9b67063676e84"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#ab3ff98345b771b22e0a9b67063676e84">dotty_reachable</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1evtgba.html">evtgba</a> *g)</td></tr>
<tr class="memdesc:ab3ff98345b771b22e0a9b67063676e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print reachable states in dot format.  <a href="#ab3ff98345b771b22e0a9b67063676e84"></a><br/></td></tr>
<tr class="memitem:aade1f7e5b6c685b5393d8a6d3ab7e09d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#aade1f7e5b6c685b5393d8a6d3ab7e09d">evtgba_save_reachable</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1evtgba.html">evtgba</a> *g)</td></tr>
<tr class="memdesc:aade1f7e5b6c685b5393d8a6d3ab7e09d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save reachable states in text format.  <a href="#aade1f7e5b6c685b5393d8a6d3ab7e09d"></a><br/></td></tr>
<tr class="memitem:a3b22a05fb3e16d693b2d80425dfa4500"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1evtgba__explicit.html">evtgba_explicit</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a3b22a05fb3e16d693b2d80425dfa4500">tgba_to_evtgba</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a)</td></tr>
<tr class="memdesc:a3b22a05fb3e16d693b2d80425dfa4500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a tgba into an evtgba.  <a href="#a3b22a05fb3e16d693b2d80425dfa4500"></a><br/></td></tr>
<tr class="memitem:a6805befaee0df3f7cb4427d30782f230"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1evtgba__explicit.html">evtgba_explicit</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a6805befaee0df3f7cb4427d30782f230">evtgba_parse</a> (const std::string &amp;filename, <a class="el" href="namespacespot.html#a90dc0e2318bb80c45893922f42ec44fe">evtgba_parse_error_list</a> &amp;error_list, bool debug=false)</td></tr>
<tr class="memdesc:a6805befaee0df3f7cb4427d30782f230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="classspot_1_1evtgba__explicit.html">spot::evtgba_explicit</a> from a text file.  <a href="#a6805befaee0df3f7cb4427d30782f230"></a><br/></td></tr>
<tr class="memitem:a805ae4b750b93c1d2e19d81faa609065"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a805ae4b750b93c1d2e19d81faa609065">format_evtgba_parse_errors</a> (std::ostream &amp;os, const std::string &amp;filename, <a class="el" href="namespacespot.html#a90dc0e2318bb80c45893922f42ec44fe">evtgba_parse_error_list</a> &amp;error_list)</td></tr>
<tr class="memdesc:a805ae4b750b93c1d2e19d81faa609065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format diagnostics produced by <a class="el" href="namespacespot.html#a6805befaee0df3f7cb4427d30782f230" title="Build a spot::evtgba_explicit from a text file.">spot::evtgba_parse</a>.  <a href="#a805ae4b750b93c1d2e19d81faa609065"></a><br/></td></tr>
<tr class="memitem:ga297ff6967b82ecb1de793bce48701379"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#ga297ff6967b82ecb1de793bce48701379">kripke_save_reachable</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1kripke.html">kripke</a> *k)</td></tr>
<tr class="memdesc:ga297ff6967b82ecb1de793bce48701379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the reachable part of Kripke structure in text format.  <a href="group__tgba__io.html#ga297ff6967b82ecb1de793bce48701379"></a><br/></td></tr>
<tr class="memitem:ga65e6d2507fc1692b1405a26b7306379f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#ga65e6d2507fc1692b1405a26b7306379f">kripke_save_reachable_renumbered</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1kripke.html">kripke</a> *k)</td></tr>
<tr class="memdesc:ga65e6d2507fc1692b1405a26b7306379f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the reachable part of Kripke structure in text format.  <a href="group__tgba__io.html#ga65e6d2507fc1692b1405a26b7306379f"></a><br/></td></tr>
<tr class="memitem:ad7749e1e9d7c9449aa0c0639f6e7add0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1kripke__explicit.html">kripke_explicit</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#ad7749e1e9d7c9449aa0c0639f6e7add0">kripke_parse</a> (const std::string &amp;name, <a class="el" href="namespacespot.html#a429e9facc10a0958d14ff3f94d71b006">kripke_parse_error_list</a> &amp;error_list, <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, <a class="el" href="classspot_1_1ltl_1_1environment.html">ltl::environment</a> &amp;env=<a class="el" href="classspot_1_1ltl_1_1default__environment.html#a6f82853f22c3bf57128a484a28a4d550">ltl::default_environment::instance</a>(), bool debug=false)</td></tr>
<tr class="memitem:a119f3d265650a37c30f816ad189725ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a119f3d265650a37c30f816ad189725ae">format_kripke_parse_errors</a> (std::ostream &amp;os, const std::string &amp;filename, <a class="el" href="namespacespot.html#a429e9facc10a0958d14ff3f94d71b006">kripke_parse_error_list</a> &amp;error_list)</td></tr>
<tr class="memdesc:a119f3d265650a37c30f816ad189725ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format diagnostics produced by <a class="el" href="namespacespot.html#ad7749e1e9d7c9449aa0c0639f6e7add0">spot::kripke_parse</a>.  <a href="#a119f3d265650a37c30f816ad189725ae"></a><br/></td></tr>
<tr class="memitem:gaae6fadac6a2f91d7b8e27b3eb6ad647e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#gaae6fadac6a2f91d7b8e27b3eb6ad647e">is_bare_word</a> (const char *str)</td></tr>
<tr class="memitem:ga4731f21b7b43332b5c7b5bc63c6d67e6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#ga4731f21b7b43332b5c7b5bc63c6d67e6">quote_unless_bare_word</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga4731f21b7b43332b5c7b5bc63c6d67e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double-quote words that are not bare.  <a href="group__misc__tools.html#ga4731f21b7b43332b5c7b5bc63c6d67e6"></a><br/></td></tr>
<tr class="memitem:a1c1c9963ce3385c106461526f80e4d7a"><td class="memItemLeft" align="right" valign="top">bdd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a1c1c9963ce3385c106461526f80e4d7a">compute_all_acceptance_conditions</a> (bdd neg_acceptance_conditions)</td></tr>
<tr class="memdesc:a1c1c9963ce3385c106461526f80e4d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute all acceptance conditions from all neg acceptance conditions.  <a href="#a1c1c9963ce3385c106461526f80e4d7a"></a><br/></td></tr>
<tr class="memitem:acbfcdc0a54e339085eb6c5458c994832"><td class="memItemLeft" align="right" valign="top">bdd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#acbfcdc0a54e339085eb6c5458c994832">compute_neg_acceptance_conditions</a> (bdd all_acceptance_conditions)</td></tr>
<tr class="memdesc:acbfcdc0a54e339085eb6c5458c994832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute neg acceptance conditions from all acceptance conditions.  <a href="#acbfcdc0a54e339085eb6c5458c994832"></a><br/></td></tr>
<tr class="memitem:ga84a8b196e2ec651f0fd039c70c7ff6cb"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#ga84a8b196e2ec651f0fd039c70c7ff6cb">escape_str</a> (std::ostream &amp;os, const std::string &amp;str)</td></tr>
<tr class="memdesc:ga84a8b196e2ec651f0fd039c70c7ff6cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape characters <code>"</code>, <code>\</code>, and <code>\n</code> in <em>str</em>.  <a href="group__misc__tools.html#ga84a8b196e2ec651f0fd039c70c7ff6cb"></a><br/></td></tr>
<tr class="memitem:gad4b0b4fae7b93db7d704a5fef6e021c6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#gad4b0b4fae7b93db7d704a5fef6e021c6">escape_str</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:gad4b0b4fae7b93db7d704a5fef6e021c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape characters <code>"</code>, <code>\</code>, and <code>\n</code> in <em>str</em>.  <a href="group__misc__tools.html#gad4b0b4fae7b93db7d704a5fef6e021c6"></a><br/></td></tr>
<tr class="memitem:ga3f3dad2e940fa844eeccda24e9386608"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#ga3f3dad2e940fa844eeccda24e9386608">trim</a> (std::string &amp;str)</td></tr>
<tr class="memdesc:ga3f3dad2e940fa844eeccda24e9386608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove spaces at the front and back of <em>str</em>.  <a href="group__misc__tools.html#ga3f3dad2e940fa844eeccda24e9386608"></a><br/></td></tr>
<tr class="memitem:ga9422ff0c16df957910dd4a0275d9f726"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hash__funcs.html#ga9422ff0c16df957910dd4a0275d9f726">wang32_hash</a> (size_t key)</td></tr>
<tr class="memdesc:ga9422ff0c16df957910dd4a0275d9f726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thomas Wang's 32 bit hash function.  <a href="group__hash__funcs.html#ga9422ff0c16df957910dd4a0275d9f726"></a><br/></td></tr>
<tr class="memitem:gaea94dbea4a286b0bde253baf07e7a56e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hash__funcs.html#gaea94dbea4a286b0bde253baf07e7a56e">knuth32_hash</a> (size_t key)</td></tr>
<tr class="memdesc:gaea94dbea4a286b0bde253baf07e7a56e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Knuth's Multiplicative hash function.  <a href="group__hash__funcs.html#gaea94dbea4a286b0bde253baf07e7a56e"></a><br/></td></tr>
<tr class="memitem:ga5253b7b9fd60f3285091b39a1f1b815d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#ga5253b7b9fd60f3285091b39a1f1b815d">int_array_array_compress2</a> (const int *array, size_t n, int *dest, size_t &amp;dest_size)</td></tr>
<tr class="memdesc:ga5253b7b9fd60f3285091b39a1f1b815d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress an int array of size <em>n</em> into a int array.  <a href="group__misc__tools.html#ga5253b7b9fd60f3285091b39a1f1b815d"></a><br/></td></tr>
<tr class="memitem:gaed78e6934b190995ba5a162ad0e76560"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#gaed78e6934b190995ba5a162ad0e76560">int_array_array_decompress2</a> (const int *array, size_t array_size, int *res, size_t size)</td></tr>
<tr class="memdesc:gaed78e6934b190995ba5a162ad0e76560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uncompress an int array of size <em>array_size</em> into a int array of size <em>size</em>.  <a href="group__misc__tools.html#gaed78e6934b190995ba5a162ad0e76560"></a><br/></td></tr>
<tr class="memitem:ga86ac44d535ef8f28e5d81a2edf907065"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#ga86ac44d535ef8f28e5d81a2edf907065">int_vector_vector_compress</a> (const std::vector&lt; int &gt; &amp;input, std::vector&lt; unsigned int &gt; &amp;output)</td></tr>
<tr class="memdesc:ga86ac44d535ef8f28e5d81a2edf907065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress an int vector into a vector of unsigned int.  <a href="group__misc__tools.html#ga86ac44d535ef8f28e5d81a2edf907065"></a><br/></td></tr>
<tr class="memitem:gade72f3d754ef89b594db989893ee3e7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#gade72f3d754ef89b594db989893ee3e7b">int_vector_vector_decompress</a> (const std::vector&lt; unsigned int &gt; &amp;array, std::vector&lt; int &gt; &amp;output, size_t size)</td></tr>
<tr class="memdesc:gade72f3d754ef89b594db989893ee3e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uncompress a vector of unsigned int into a vector of size <em>size</em>.  <a href="group__misc__tools.html#gade72f3d754ef89b594db989893ee3e7b"></a><br/></td></tr>
<tr class="memitem:gae8556060f7963410dd8c52d2426d7269"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned int &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#gae8556060f7963410dd8c52d2426d7269">int_array_vector_compress</a> (const int *array, size_t n)</td></tr>
<tr class="memdesc:gae8556060f7963410dd8c52d2426d7269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress an int array if size <em>n</em> into a vector of unsigned int.  <a href="group__misc__tools.html#gae8556060f7963410dd8c52d2426d7269"></a><br/></td></tr>
<tr class="memitem:ga6c161d70b36c5637b6511f2192f2d9bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#ga6c161d70b36c5637b6511f2192f2d9bf">int_vector_array_decompress</a> (const std::vector&lt; unsigned int &gt; *array, int *res, size_t size)</td></tr>
<tr class="memdesc:ga6c161d70b36c5637b6511f2192f2d9bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uncompress a vector of unsigned int into an int array of size <em>size</em>.  <a href="group__misc__tools.html#ga6c161d70b36c5637b6511f2192f2d9bf"></a><br/></td></tr>
<tr class="memitem:ga72a6bb80b592f562634a6bd8aedd9ff6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#ga72a6bb80b592f562634a6bd8aedd9ff6">int_array_array_compress</a> (const int *array, size_t n, int *dest, size_t &amp;dest_size)</td></tr>
<tr class="memdesc:ga72a6bb80b592f562634a6bd8aedd9ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress an int array of size <em>n</em> into a int array.  <a href="group__misc__tools.html#ga72a6bb80b592f562634a6bd8aedd9ff6"></a><br/></td></tr>
<tr class="memitem:gad595c02553de6187297d09d2b47c995c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#gad595c02553de6187297d09d2b47c995c">int_array_array_decompress</a> (const int *array, size_t array_size, int *res, size_t size)</td></tr>
<tr class="memdesc:gad595c02553de6187297d09d2b47c995c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uncompress an int array of size <em>array_size</em> into a int array of size <em>size</em>.  <a href="group__misc__tools.html#gad595c02553de6187297d09d2b47c995c"></a><br/></td></tr>
<tr class="memitem:a1a8d0610b61c0a30aad16791b0b73d15"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a1a8d0610b61c0a30aad16791b0b73d15">memusage</a> ()</td></tr>
<tr class="memdesc:a1a8d0610b61c0a30aad16791b0b73d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of pages in use by the program.  <a href="#a1a8d0610b61c0a30aad16791b0b73d15"></a><br/></td></tr>
<tr class="memitem:ga539812ab355a561fee1ecbfe60b276e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__random.html#ga539812ab355a561fee1ecbfe60b276e4">srand</a> (unsigned int seed)</td></tr>
<tr class="memdesc:ga539812ab355a561fee1ecbfe60b276e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the seed of the pseudo-random number generator.  <a href="group__random.html#ga539812ab355a561fee1ecbfe60b276e4"></a><br/></td></tr>
<tr class="memitem:ga86ce713fe60de9af440a7331de74aa1a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__random.html#ga86ce713fe60de9af440a7331de74aa1a">rrand</a> (int min, int max)</td></tr>
<tr class="memdesc:ga86ce713fe60de9af440a7331de74aa1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a pseudo-random integer value between <em>min</em> and <em>max</em> included.  <a href="group__random.html#ga86ce713fe60de9af440a7331de74aa1a"></a><br/></td></tr>
<tr class="memitem:gafe8da996f40caa7d188f6b408ae62904"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__random.html#gafe8da996f40caa7d188f6b408ae62904">mrand</a> (int max)</td></tr>
<tr class="memdesc:gafe8da996f40caa7d188f6b408ae62904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a pseudo-random integer value between 0 and <em>max-1</em> included.  <a href="group__random.html#gafe8da996f40caa7d188f6b408ae62904"></a><br/></td></tr>
<tr class="memitem:ga42801cd81368df5c1c61aa1626e299ff"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__random.html#ga42801cd81368df5c1c61aa1626e299ff">drand</a> ()</td></tr>
<tr class="memdesc:ga42801cd81368df5c1c61aa1626e299ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a pseudo-random double value between 0.0 and 1.0 (1.0 excluded).  <a href="group__random.html#ga42801cd81368df5c1c61aa1626e299ff"></a><br/></td></tr>
<tr class="memitem:ga978e1c6fb8f447274a05ddd3f87ce58b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__random.html#ga978e1c6fb8f447274a05ddd3f87ce58b">nrand</a> ()</td></tr>
<tr class="memdesc:ga978e1c6fb8f447274a05ddd3f87ce58b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a pseudo-random double value following a standard normal distribution. (Odeh &amp; Evans)  <a href="group__random.html#ga978e1c6fb8f447274a05ddd3f87ce58b"></a><br/></td></tr>
<tr class="memitem:ga0130217a19e5156f796ab774dca4b08c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__random.html#ga0130217a19e5156f796ab774dca4b08c">bmrand</a> ()</td></tr>
<tr class="memdesc:ga0130217a19e5156f796ab774dca4b08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a pseudo-random double value following a standard normal distribution. (Box-Muller)  <a href="group__random.html#ga0130217a19e5156f796ab774dca4b08c"></a><br/></td></tr>
<tr class="memitem:ga816b558a7c64daca3a2a018704377dac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__random.html#ga816b558a7c64daca3a2a018704377dac">prand</a> (double p)</td></tr>
<tr class="memdesc:ga816b558a7c64daca3a2a018704377dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pseudo-random positive integer value following a Poisson distribution with parameter <em>p</em>.  <a href="group__random.html#ga816b558a7c64daca3a2a018704377dac"></a><br/></td></tr>
<tr class="memitem:ab35966460c1f984c2db09456bdf08b42"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab35966460c1f984c2db09456bdf08b42"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1unique__ptr.html">unique_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacespot.html#ab35966460c1f984c2db09456bdf08b42">make_unique</a> (T *ptr)</td></tr>
<tr class="memdesc:ab35966460c1f984c2db09456bdf08b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change a pointer into a <a class="el" href="classspot_1_1unique__ptr.html" title="Take ownership of a pointer at its construction, and destroy it at the end of the scope...">unique_ptr</a>.  <a href="#ab35966460c1f984c2db09456bdf08b42"></a><br/></td></tr>
<tr class="memitem:ga85c83eb1d18703782d129dbe4a518fca"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#ga85c83eb1d18703782d129dbe4a518fca">version</a> ()</td></tr>
<tr class="memdesc:ga85c83eb1d18703782d129dbe4a518fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Spot's version.  <a href="group__misc__tools.html#ga85c83eb1d18703782d129dbe4a518fca"></a><br/></td></tr>
<tr class="memitem:gadc0e10bdf5a88fc8ee6fb83952f537e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacespot.html#a3ace0ebc1ab16f0766fa681785750794">tgba_explicit_string</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#gadc0e10bdf5a88fc8ee6fb83952f537e0">neverclaim_parse</a> (const std::string &amp;filename, <a class="el" href="group__tgba__io.html#ga15242b071d7c485804548ff2ee41b3d1">neverclaim_parse_error_list</a> &amp;error_list, <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, <a class="el" href="classspot_1_1ltl_1_1environment.html">ltl::environment</a> &amp;env=<a class="el" href="classspot_1_1ltl_1_1default__environment.html#a6f82853f22c3bf57128a484a28a4d550">ltl::default_environment::instance</a>(), bool debug=false)</td></tr>
<tr class="memdesc:gadc0e10bdf5a88fc8ee6fb83952f537e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="classspot_1_1tgba__explicit.html">spot::tgba_explicit</a> from a Spin never claim file.  <a href="group__tgba__io.html#gadc0e10bdf5a88fc8ee6fb83952f537e0"></a><br/></td></tr>
<tr class="memitem:ga596bbd8f0703340f2b556e43dfa7995e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#ga596bbd8f0703340f2b556e43dfa7995e">format_neverclaim_parse_errors</a> (std::ostream &amp;os, const std::string &amp;filename, <a class="el" href="group__tgba__io.html#ga15242b071d7c485804548ff2ee41b3d1">neverclaim_parse_error_list</a> &amp;error_list)</td></tr>
<tr class="memdesc:ga596bbd8f0703340f2b556e43dfa7995e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format diagnostics produced by <a class="el" href="group__tgba__io.html#gadc0e10bdf5a88fc8ee6fb83952f537e0" title="Build a spot::tgba_explicit from a Spin never claim file.">spot::neverclaim_parse</a>.  <a href="group__tgba__io.html#ga596bbd8f0703340f2b556e43dfa7995e"></a><br/></td></tr>
<tr class="memitem:a9f2c6c63ca4916813045c4326c635b93"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a9f2c6c63ca4916813045c4326c635b93">saba_dotty_reachable</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1saba.html">saba</a> *g)</td></tr>
<tr class="memdesc:a9f2c6c63ca4916813045c4326c635b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print reachable states in dot format.  <a href="#a9f2c6c63ca4916813045c4326c635b93"></a><br/></td></tr>
<tr class="memitem:a6d777a0a353d8c7502742e3fa3b4a5b3"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a6d777a0a353d8c7502742e3fa3b4a5b3">dotty_reachable</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1ta.html">ta</a> *a)</td></tr>
<tr class="memitem:gab6d913bd6fddb9c5c1919c97373bd6bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1ta.html">ta</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ta__reduction.html#gab6d913bd6fddb9c5c1919c97373bd6bd">minimize_ta</a> (const <a class="el" href="classspot_1_1ta.html">ta</a> *ta_)</td></tr>
<tr class="memdesc:gab6d913bd6fddb9c5c1919c97373bd6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a simplified TA by merging bisimilar states.  <a href="group__ta__reduction.html#gab6d913bd6fddb9c5c1919c97373bd6bd"></a><br/></td></tr>
<tr class="memitem:ga333ff9524f1e1a2988ac318f81dfae74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1tgta__explicit.html">tgta_explicit</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ta__reduction.html#ga333ff9524f1e1a2988ac318f81dfae74">minimize_tgta</a> (const <a class="el" href="classspot_1_1tgta__explicit.html">tgta_explicit</a> *tgta_)</td></tr>
<tr class="memdesc:ga333ff9524f1e1a2988ac318f81dfae74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a simplified TGTA by merging bisimilar states.  <a href="group__ta__reduction.html#ga333ff9524f1e1a2988ac318f81dfae74"></a><br/></td></tr>
<tr class="memitem:a4e83dbca5f5008ab4cac60ee423b905d"><td class="memItemLeft" align="right" valign="top">std::set&lt; const <a class="el" href="classspot_1_1state.html">state</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a4e83dbca5f5008ab4cac60ee423b905d">get_states_set</a> (const <a class="el" href="classspot_1_1ta.html">ta</a> *t)</td></tr>
<tr class="memdesc:a4e83dbca5f5008ab4cac60ee423b905d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute states set for an automaton.  <a href="#a4e83dbca5f5008ab4cac60ee423b905d"></a><br/></td></tr>
<tr class="memitem:ga6f9e7ec5c5d7b706b0c5184c4d3dbe3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structspot_1_1ta__statistics.html">ta_statistics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ta__misc.html#ga6f9e7ec5c5d7b706b0c5184c4d3dbe3c">stats_reachable</a> (const <a class="el" href="classspot_1_1ta.html">ta</a> *t)</td></tr>
<tr class="memdesc:ga6f9e7ec5c5d7b706b0c5184c4d3dbe3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute statistics for an automaton.  <a href="group__ta__misc.html#ga6f9e7ec5c5d7b706b0c5184c4d3dbe3c"></a><br/></td></tr>
<tr class="memitem:ga5d3967eb107ea9bbb5f71b73f8dad2ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1ta__explicit.html">ta_explicit</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__ta.html#ga5d3967eb107ea9bbb5f71b73f8dad2ef">tgba_to_ta</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *tgba_to_convert, bdd atomic_propositions_set, bool degeneralized=true, bool artificial_initial_state_mode=true, bool single_pass_emptiness_check=false, bool artificial_livelock_state_mode=false)</td></tr>
<tr class="memdesc:ga5d3967eb107ea9bbb5f71b73f8dad2ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="classspot_1_1ta__explicit.html">spot::ta_explicit</a>* (TA) from an LTL formula.This is based on the following paper.  <a href="group__tgba__ta.html#ga5d3967eb107ea9bbb5f71b73f8dad2ef"></a><br/></td></tr>
<tr class="memitem:gabe1fa2db8c3bd35f340ad3a46654959a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1tgta__explicit.html">tgta_explicit</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__ta.html#gabe1fa2db8c3bd35f340ad3a46654959a">tgba_to_tgta</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *tgba_to_convert, bdd atomic_propositions_set)</td></tr>
<tr class="memdesc:gabe1fa2db8c3bd35f340ad3a46654959a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="classspot_1_1tgta__explicit.html">spot::tgta_explicit</a>* (TGTA) from an LTL formula.  <a href="group__tgba__ta.html#gabe1fa2db8c3bd35f340ad3a46654959a"></a><br/></td></tr>
<tr class="memitem:a59e91579989d390a3979a5badf302255"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a59e91579989d390a3979a5badf302255">bdd_print_sat</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>
<tr class="memdesc:a59e91579989d390a3979a5badf302255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a BDD as a list of literals.  <a href="#a59e91579989d390a3979a5badf302255"></a><br/></td></tr>
<tr class="memitem:aba342c9d66d191b7ed930e2b02043e7f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#aba342c9d66d191b7ed930e2b02043e7f">bdd_format_sat</a> (const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>
<tr class="memdesc:aba342c9d66d191b7ed930e2b02043e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a BDD as a list of literals.  <a href="#aba342c9d66d191b7ed930e2b02043e7f"></a><br/></td></tr>
<tr class="memitem:a3b659fe265e2014282d3b25db928794b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a3b659fe265e2014282d3b25db928794b">bdd_print_acc</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>
<tr class="memdesc:a3b659fe265e2014282d3b25db928794b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a BDD as a list of acceptance conditions.  <a href="#a3b659fe265e2014282d3b25db928794b"></a><br/></td></tr>
<tr class="memitem:aa75a117405f2292f6d80abc2ae930946"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#aa75a117405f2292f6d80abc2ae930946">bdd_print_accset</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>
<tr class="memdesc:aa75a117405f2292f6d80abc2ae930946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a BDD as a set of acceptance conditions.  <a href="#aa75a117405f2292f6d80abc2ae930946"></a><br/></td></tr>
<tr class="memitem:aa04818924fa41d2230160b499d95173d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#aa04818924fa41d2230160b499d95173d">bdd_format_accset</a> (const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>
<tr class="memdesc:aa04818924fa41d2230160b499d95173d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a BDD as a set of acceptance conditions.  <a href="#aa04818924fa41d2230160b499d95173d"></a><br/></td></tr>
<tr class="memitem:aca49e9ec778c8a6b38455a68db8d6ece"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#aca49e9ec778c8a6b38455a68db8d6ece">bdd_print_set</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>
<tr class="memdesc:aca49e9ec778c8a6b38455a68db8d6ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a BDD as a set.  <a href="#aca49e9ec778c8a6b38455a68db8d6ece"></a><br/></td></tr>
<tr class="memitem:a73d8fa997efd95d08e0d1b9dfa7b7073"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a73d8fa997efd95d08e0d1b9dfa7b7073">bdd_format_set</a> (const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>
<tr class="memdesc:a73d8fa997efd95d08e0d1b9dfa7b7073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a BDD as a set.  <a href="#a73d8fa997efd95d08e0d1b9dfa7b7073"></a><br/></td></tr>
<tr class="memitem:a174c8f965f37e9a26b33c9f76183720f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a174c8f965f37e9a26b33c9f76183720f">bdd_print_formula</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>
<tr class="memdesc:a174c8f965f37e9a26b33c9f76183720f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a BDD as a formula.  <a href="#a174c8f965f37e9a26b33c9f76183720f"></a><br/></td></tr>
<tr class="memitem:ab9eea881fdb5d8e629db7102fde452ea"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#ab9eea881fdb5d8e629db7102fde452ea">bdd_format_formula</a> (const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>
<tr class="memdesc:ab9eea881fdb5d8e629db7102fde452ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a BDD as a formula.  <a href="#ab9eea881fdb5d8e629db7102fde452ea"></a><br/></td></tr>
<tr class="memitem:a3ec151057e33aadb60d2b47ffaa64c24"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a3ec151057e33aadb60d2b47ffaa64c24">bdd_print_dot</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>
<tr class="memdesc:a3ec151057e33aadb60d2b47ffaa64c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a BDD as a diagram in dotty format.  <a href="#a3ec151057e33aadb60d2b47ffaa64c24"></a><br/></td></tr>
<tr class="memitem:ac8434843d2dcb0d99a027e398b01bafe"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#ac8434843d2dcb0d99a027e398b01bafe">bdd_print_table</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>
<tr class="memdesc:ac8434843d2dcb0d99a027e398b01bafe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a BDD as a table.  <a href="#ac8434843d2dcb0d99a027e398b01bafe"></a><br/></td></tr>
<tr class="memitem:a9da9924abc8e1cb4086202c87b4213df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a9da9924abc8e1cb4086202c87b4213df">enable_utf8</a> ()</td></tr>
<tr class="memdesc:a9da9924abc8e1cb4086202c87b4213df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable UTF-8 output for bdd printers.  <a href="#a9da9924abc8e1cb4086202c87b4213df"></a><br/></td></tr>
<tr class="memitem:ab6641d7d9896e016376b1c618da92469"><td class="memItemLeft" align="right" valign="top">bdd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#ab6641d7d9896e016376b1c618da92469">formula_to_bdd</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f, <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *d, void *for_me)</td></tr>
<tr class="memdesc:ab6641d7d9896e016376b1c618da92469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a formula into a BDD.  <a href="#ab6641d7d9896e016376b1c618da92469"></a><br/></td></tr>
<tr class="memitem:aebfbc06108c79ba74f84a838af4f1772"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#aebfbc06108c79ba74f84a838af4f1772">bdd_to_formula</a> (bdd f, const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *d)</td></tr>
<tr class="memdesc:aebfbc06108c79ba74f84a838af4f1772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a BDD into a formula.  <a href="#aebfbc06108c79ba74f84a838af4f1772"></a><br/></td></tr>
<tr class="memitem:a361af6c0080f2280ac0a884960374bd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a361af6c0080f2280ac0a884960374bd3">shared_state_deleter</a> (<a class="el" href="classspot_1_1state.html">state</a> *s)</td></tr>
<tr class="memitem:ga9a8f2973e4358cf18aa162634b61ab51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1tgba__bdd__concrete.html">tgba_bdd_concrete</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__algorithms.html#ga9a8f2973e4358cf18aa162634b61ab51">product</a> (const <a class="el" href="classspot_1_1tgba__bdd__concrete.html">tgba_bdd_concrete</a> *left, const <a class="el" href="classspot_1_1tgba__bdd__concrete.html">tgba_bdd_concrete</a> *right)</td></tr>
<tr class="memdesc:ga9a8f2973e4358cf18aa162634b61ab51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies two <a class="el" href="classspot_1_1tgba__bdd__concrete.html" title="A concrete spot::tgba implemented using BDDs.">spot::tgba_bdd_concrete</a> automata.This function builds the resulting product as another <a class="el" href="classspot_1_1tgba__bdd__concrete.html" title="A concrete spot::tgba implemented using BDDs.">spot::tgba_bdd_concrete</a> automaton.  <a href="group__tgba__algorithms.html#ga9a8f2973e4358cf18aa162634b61ab51"></a><br/></td></tr>
<tr class="memitem:ae6985cd6c82ba766e2e853f5a1e82e24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#ae6985cd6c82ba766e2e853f5a1e82e24">display_safra</a> (const <a class="el" href="classspot_1_1tgba__safra__complement.html">tgba_safra_complement</a> *a)</td></tr>
<tr class="memdesc:ae6985cd6c82ba766e2e853f5a1e82e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a dot output of the Safra automaton associated to <em>a</em>.  <a href="#ae6985cd6c82ba766e2e853f5a1e82e24"></a><br/></td></tr>
<tr class="memitem:ga3d28f3aabd3fc1014482983f48a691e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1tgba.html">tgba</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__on__the__fly__algorithms.html#ga3d28f3aabd3fc1014482983f48a691e9">wdba_complement</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *aut)</td></tr>
<tr class="memdesc:ga3d28f3aabd3fc1014482983f48a691e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complement a weak deterministic Büchi automaton.  <a href="group__tgba__on__the__fly__algorithms.html#ga3d28f3aabd3fc1014482983f48a691e9"></a><br/></td></tr>
<tr class="memitem:a7a3b33efec82bd649f01077850ddfc2a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector<br class="typebreak"/>
&lt; <a class="el" href="structspot_1_1sccs__set.html">sccs_set</a> * &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a7a3b33efec82bd649f01077850ddfc2a">find_paths</a> (<a class="el" href="classspot_1_1tgba.html">tgba</a> *a, const <a class="el" href="classspot_1_1scc__map.html">scc_map</a> &amp;m)</td></tr>
<tr class="memitem:af2a55d9921bf9eab8f9b410ff0ad0e0d"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#af2a55d9921bf9eab8f9b410ff0ad0e0d">max_spanning_paths</a> (std::vector&lt; <a class="el" href="structspot_1_1sccs__set.html">sccs_set</a> * &gt; *paths, <a class="el" href="classspot_1_1scc__map.html">scc_map</a> &amp;m)</td></tr>
<tr class="memitem:a9f710ac23d3a22a3a66244d15de62a3c"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="classspot_1_1tgba.html">tgba</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a9f710ac23d3a22a3a66244d15de62a3c">split_tgba</a> (<a class="el" href="classspot_1_1tgba.html">tgba</a> *a, const <a class="el" href="classspot_1_1scc__map.html">scc_map</a> &amp;m, unsigned split_number)</td></tr>
<tr class="memitem:ga7bf747ce302af354c18a28799016dc42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1sba.html">sba</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#ga7bf747ce302af354c18a28799016dc42">degeneralize</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a)</td></tr>
<tr class="memdesc:ga7bf747ce302af354c18a28799016dc42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Degeneralize a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> into an equivalent sba with only one acceptance condition.  <a href="group__tgba__misc.html#ga7bf747ce302af354c18a28799016dc42"></a><br/></td></tr>
<tr class="memitem:ga91590a0cf2e914df96d62e3509907cb4"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#ga91590a0cf2e914df96d62e3509907cb4">dotty_reachable</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1tgba.html">tgba</a> *g, bool assume_sba=false, <a class="el" href="classspot_1_1dotty__decorator.html">dotty_decorator</a> *dd=0)</td></tr>
<tr class="memdesc:ga91590a0cf2e914df96d62e3509907cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print reachable states in dot format.If <em>assume_sba</em> is set, this assumes that the automaton is an SBA and use double elipse to mark accepting states.  <a href="group__tgba__io.html#ga91590a0cf2e914df96d62e3509907cb4"></a><br/></td></tr>
<tr class="memitem:ga482c19d4b66ca51b15b1b5a0c51d114d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacespot.html#ad566cf6234b8c875958ed4001f959bb4">tgba_explicit_number</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#ga482c19d4b66ca51b15b1b5a0c51d114d">tgba_dupexp_bfs</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *aut)</td></tr>
<tr class="memdesc:ga482c19d4b66ca51b15b1b5a0c51d114d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an explicit automata from all states of <em>aut</em>, numbering states in bread first order as they are processed.  <a href="group__tgba__misc.html#ga482c19d4b66ca51b15b1b5a0c51d114d"></a><br/></td></tr>
<tr class="memitem:ga1068b73c22d281c74dfbcf512c9df0b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacespot.html#ad566cf6234b8c875958ed4001f959bb4">tgba_explicit_number</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#ga1068b73c22d281c74dfbcf512c9df0b7">tgba_dupexp_dfs</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *aut)</td></tr>
<tr class="memdesc:ga1068b73c22d281c74dfbcf512c9df0b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an explicit automata from all states of <em>aut</em>, numbering states in depth first order as they are processed.  <a href="group__tgba__misc.html#ga1068b73c22d281c74dfbcf512c9df0b7"></a><br/></td></tr>
<tr class="memitem:gafbf62421b9c1da3df47ea92ade8ecdd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1tgba__bdd__concrete.html">tgba_bdd_concrete</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__ltl.html#gafbf62421b9c1da3df47ea92ade8ecdd4">eltl_to_tgba_lacim</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f, <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict)</td></tr>
<tr class="memdesc:gafbf62421b9c1da3df47ea92ade8ecdd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="classspot_1_1tgba__bdd__concrete.html" title="A concrete spot::tgba implemented using BDDs.">spot::tgba_bdd_concrete</a> from an ELTL formula.This is based on the following paper.  <a href="group__tgba__ltl.html#gafbf62421b9c1da3df47ea92ade8ecdd4"></a><br/></td></tr>
<tr class="memitem:ga3aa3b6dd9854c94b6aaabafd4a612de2"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__run.html#ga3aa3b6dd9854c94b6aaabafd4a612de2">print_tgba_run</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, const <a class="el" href="structspot_1_1tgba__run.html">tgba_run</a> *run)</td></tr>
<tr class="memdesc:ga3aa3b6dd9854c94b6aaabafd4a612de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display a <a class="el" href="structspot_1_1tgba__run.html" title="An accepted run, for a tgba.">tgba_run</a>.  <a href="group__tgba__run.html#ga3aa3b6dd9854c94b6aaabafd4a612de2"></a><br/></td></tr>
<tr class="memitem:ga60bd6401d35428aa22bda3388765099b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1tgba.html">tgba</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__run.html#ga60bd6401d35428aa22bda3388765099b">tgba_run_to_tgba</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, const <a class="el" href="structspot_1_1tgba__run.html">tgba_run</a> *run)</td></tr>
<tr class="memdesc:ga60bd6401d35428aa22bda3388765099b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an explicit_tgba corresponding to <em>run</em> (i.e. comparable states are merged).  <a href="group__tgba__run.html#ga60bd6401d35428aa22bda3388765099b"></a><br/></td></tr>
<tr class="memitem:ga9bb3670ecff03df6d792c8a315c3e75c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga9bb3670ecff03df6d792c8a315c3e75c">couvreur99</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, <a class="el" href="classspot_1_1option__map.html">option_map</a> options=<a class="el" href="classspot_1_1option__map.html">option_map</a>(), const <a class="el" href="classspot_1_1numbered__state__heap__factory.html">numbered_state_heap_factory</a> *nshf=<a class="el" href="classspot_1_1numbered__state__heap__hash__map__factory.html#ac9ff2d24e71f763cbd999e09be6aa518">numbered_state_heap_hash_map_factory::instance</a>())</td></tr>
<tr class="memdesc:ga9bb3670ecff03df6d792c8a315c3e75c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the language of an automate is empty.  <a href="group__emptiness__check__algorithms.html#ga9bb3670ecff03df6d792c8a315c3e75c"></a><br/></td></tr>
<tr class="memitem:gae45e3a4c2ba4b8c0609a2afca67eabe8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#gae45e3a4c2ba4b8c0609a2afca67eabe8">explicit_gv04_check</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, <a class="el" href="classspot_1_1option__map.html">option_map</a> o=<a class="el" href="classspot_1_1option__map.html">option_map</a>())</td></tr>
<tr class="memdesc:gae45e3a4c2ba4b8c0609a2afca67eabe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emptiness check based on Geldenhuys and Valmari's TACAS'04 paper.  <a href="group__emptiness__check__algorithms.html#gae45e3a4c2ba4b8c0609a2afca67eabe8"></a><br/></td></tr>
<tr class="memitem:gacedab500bd933852465ef9bc3a094f70"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#gacedab500bd933852465ef9bc3a094f70">count_nondet_states</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *aut)</td></tr>
<tr class="memdesc:gacedab500bd933852465ef9bc3a094f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of non-deterministic states in <em>aut</em>.  <a href="group__tgba__misc.html#gacedab500bd933852465ef9bc3a094f70"></a><br/></td></tr>
<tr class="memitem:gafe8765d12152aff78507476c5a769131"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#gafe8765d12152aff78507476c5a769131">is_deterministic</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *aut)</td></tr>
<tr class="memdesc:gafe8765d12152aff78507476c5a769131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true iff <em>aut</em> is deterministic.  <a href="group__tgba__misc.html#gafe8765d12152aff78507476c5a769131"></a><br/></td></tr>
<tr class="memitem:ga669ef0d3178251f3e1ba66ef5aebaa66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#ga669ef0d3178251f3e1ba66ef5aebaa66">is_weak_scc</a> (<a class="el" href="classspot_1_1scc__map.html">scc_map</a> &amp;map, unsigned scc)</td></tr>
<tr class="memdesc:ga669ef0d3178251f3e1ba66ef5aebaa66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the SCC number <em>scc</em> in <em>map</em> is weak.  <a href="group__tgba__misc.html#ga669ef0d3178251f3e1ba66ef5aebaa66"></a><br/></td></tr>
<tr class="memitem:ga955eb1141519477fda8d09fae2a9cb4a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#ga955eb1141519477fda8d09fae2a9cb4a">lbtt_reachable</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1tgba.html">tgba</a> *g)</td></tr>
<tr class="memdesc:ga955eb1141519477fda8d09fae2a9cb4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print reachable states in LBTT format.  <a href="group__tgba__io.html#ga955eb1141519477fda8d09fae2a9cb4a"></a><br/></td></tr>
<tr class="memitem:gac79329b001b40e290a99168897221290"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1tgba.html">tgba</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#gac79329b001b40e290a99168897221290">lbtt_parse</a> (std::istream &amp;is, std::string &amp;error, <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, <a class="el" href="classspot_1_1ltl_1_1environment.html">ltl::environment</a> &amp;env=<a class="el" href="classspot_1_1ltl_1_1default__environment.html#a6f82853f22c3bf57128a484a28a4d550">ltl::default_environment::instance</a>(), <a class="el" href="classspot_1_1ltl_1_1environment.html">ltl::environment</a> &amp;envacc=<a class="el" href="classspot_1_1ltl_1_1default__environment.html#a6f82853f22c3bf57128a484a28a4d550">ltl::default_environment::instance</a>())</td></tr>
<tr class="memdesc:gac79329b001b40e290a99168897221290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an automaton in LBTT's format.  <a href="group__tgba__io.html#gac79329b001b40e290a99168897221290"></a><br/></td></tr>
<tr class="memitem:gab63f738c24846842339e8c12fd5eb777"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1taa__tgba.html">taa_tgba</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__ltl.html#gab63f738c24846842339e8c12fd5eb777">ltl_to_taa</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f, <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bool refined_rules=false)</td></tr>
<tr class="memdesc:gab63f738c24846842339e8c12fd5eb777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a spot::taa* from an LTL formula.This is based on the following.  <a href="group__tgba__ltl.html#gab63f738c24846842339e8c12fd5eb777"></a><br/></td></tr>
<tr class="memitem:ga9e12e74a9e66d7ae2b96dfb1e11655b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacespot.html#a24df826dd55ad1b8a6fd711c8ab1785e">tgba_explicit_formula</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__ltl.html#ga9e12e74a9e66d7ae2b96dfb1e11655b6">ltl_to_tgba_fm</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f, <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bool exprop=false, bool symb_merge=true, bool branching_postponement=false, bool fair_loop_approx=false, const <a class="el" href="group__ltl__misc.html#ga8347f76c4cd9c56970ba55c8fb40ab1a">ltl::atomic_prop_set</a> *unobs=0, <a class="el" href="classspot_1_1ltl_1_1ltl__simplifier.html">ltl::ltl_simplifier</a> *simplifier=0)</td></tr>
<tr class="memdesc:ga9e12e74a9e66d7ae2b96dfb1e11655b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="classspot_1_1tgba__explicit.html">spot::tgba_explicit</a>* from an LTL formula.This is based on the following paper.  <a href="group__tgba__ltl.html#ga9e12e74a9e66d7ae2b96dfb1e11655b6"></a><br/></td></tr>
<tr class="memitem:ga911db84b8e05185bb50b5eda55efe6b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1tgba__bdd__concrete.html">tgba_bdd_concrete</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__ltl.html#ga911db84b8e05185bb50b5eda55efe6b6">ltl_to_tgba_lacim</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f, <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict)</td></tr>
<tr class="memdesc:ga911db84b8e05185bb50b5eda55efe6b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="classspot_1_1tgba__bdd__concrete.html" title="A concrete spot::tgba implemented using BDDs.">spot::tgba_bdd_concrete</a> from an LTL formula.This is based on the following paper.  <a href="group__tgba__ltl.html#ga911db84b8e05185bb50b5eda55efe6b6"></a><br/></td></tr>
<tr class="memitem:ga392d772bf851002cdda0ca34615aa54b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga392d772bf851002cdda0ca34615aa54b">explicit_magic_search</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, <a class="el" href="classspot_1_1option__map.html">option_map</a> o=<a class="el" href="classspot_1_1option__map.html">option_map</a>())</td></tr>
<tr class="memdesc:ga392d772bf851002cdda0ca34615aa54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>.  <a href="group__emptiness__check__algorithms.html#ga392d772bf851002cdda0ca34615aa54b"></a><br/></td></tr>
<tr class="memitem:gadae7938a96420813bcdabb1b31295294"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#gadae7938a96420813bcdabb1b31295294">bit_state_hashing_magic_search</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, size_t size, <a class="el" href="classspot_1_1option__map.html">option_map</a> o=<a class="el" href="classspot_1_1option__map.html">option_map</a>())</td></tr>
<tr class="memdesc:gadae7938a96420813bcdabb1b31295294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>.  <a href="group__emptiness__check__algorithms.html#gadae7938a96420813bcdabb1b31295294"></a><br/></td></tr>
<tr class="memitem:ga054c1948b6c5076350e44a85ad580403"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga054c1948b6c5076350e44a85ad580403">magic_search</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, <a class="el" href="classspot_1_1option__map.html">option_map</a> o=<a class="el" href="classspot_1_1option__map.html">option_map</a>())</td></tr>
<tr class="memdesc:ga054c1948b6c5076350e44a85ad580403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for the two magic_search implementations.  <a href="group__emptiness__check__algorithms.html#ga054c1948b6c5076350e44a85ad580403"></a><br/></td></tr>
<tr class="memitem:ga1ae7d44542608b4635f0dc05556d3064"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacespot.html#a13bc152377363a78e3ab83a43a6be053">sba_explicit_number</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__reduction.html#ga1ae7d44542608b4635f0dc05556d3064">minimize_monitor</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a)</td></tr>
<tr class="memdesc:ga1ae7d44542608b4635f0dc05556d3064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a minimal deterministic monitor.  <a href="group__tgba__reduction.html#ga1ae7d44542608b4635f0dc05556d3064"></a><br/></td></tr>
<tr class="memitem:ga871114e0c974638ee12deaa87e98f56b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacespot.html#a13bc152377363a78e3ab83a43a6be053">sba_explicit_number</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__reduction.html#ga871114e0c974638ee12deaa87e98f56b">minimize_wdba</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a)</td></tr>
<tr class="memdesc:ga871114e0c974638ee12deaa87e98f56b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimize a BÃ¼chi automaton in the WDBA class.  <a href="group__tgba__reduction.html#ga871114e0c974638ee12deaa87e98f56b"></a><br/></td></tr>
<tr class="memitem:ga4245a82c2be0713e20af9b217ad7b0a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1tgba.html">tgba</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__reduction.html#ga4245a82c2be0713e20af9b217ad7b0a7">minimize_obligation</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *aut_f, const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f=0, const <a class="el" href="classspot_1_1tgba.html">tgba</a> *aut_neg_f=0, bool reject_bigger=false)</td></tr>
<tr class="memdesc:ga4245a82c2be0713e20af9b217ad7b0a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimize an automaton if it represents an obligation property.  <a href="group__tgba__reduction.html#ga4245a82c2be0713e20af9b217ad7b0a7"></a><br/></td></tr>
<tr class="memitem:ga989d3c71e821143e5b33d9f310784d64"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#ga989d3c71e821143e5b33d9f310784d64">never_claim_reachable</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1tgba.html">tgba</a> *g, const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f=0, bool comments=false)</td></tr>
<tr class="memdesc:ga989d3c71e821143e5b33d9f310784d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print reachable states in Spin never claim format.  <a href="group__tgba__io.html#ga989d3c71e821143e5b33d9f310784d64"></a><br/></td></tr>
<tr class="memitem:ga1e0b8aeb36e622ac26a6c540ac17fddc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structspot_1_1tgba__run.html">tgba_run</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__run.html#ga1e0b8aeb36e622ac26a6c540ac17fddc">project_tgba_run</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a_run, const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a_proj, const <a class="el" href="structspot_1_1tgba__run.html">tgba_run</a> *run)</td></tr>
<tr class="memdesc:ga1e0b8aeb36e622ac26a6c540ac17fddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project a <a class="el" href="structspot_1_1tgba__run.html" title="An accepted run, for a tgba.">tgba_run</a> on a tgba.If a <a class="el" href="structspot_1_1tgba__run.html" title="An accepted run, for a tgba.">tgba_run</a> has been generated on a product, or any other on-the-fly algorithm with tgba operands,.  <a href="group__tgba__run.html#ga1e0b8aeb36e622ac26a6c540ac17fddc"></a><br/></td></tr>
<tr class="memitem:gadcf8ba83bd92b5cbf8f5b8f1083a793b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1tgba.html">tgba</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#gadcf8ba83bd92b5cbf8f5b8f1083a793b">random_graph</a> (int n, float d, const <a class="el" href="group__ltl__misc.html#ga8347f76c4cd9c56970ba55c8fb40ab1a">ltl::atomic_prop_set</a> *ap, <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, int n_acc=0, float a=0.1, float t=0.5, <a class="el" href="classspot_1_1ltl_1_1environment.html">ltl::environment</a> *env=&amp;<a class="el" href="classspot_1_1ltl_1_1default__environment.html#a6f82853f22c3bf57128a484a28a4d550">ltl::default_environment::instance</a>())</td></tr>
<tr class="memdesc:gadcf8ba83bd92b5cbf8f5b8f1083a793b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a tgba randomly.  <a href="group__tgba__misc.html#gadcf8ba83bd92b5cbf8f5b8f1083a793b"></a><br/></td></tr>
<tr class="memitem:gabc4ad10830cd80a3237415d28adeee1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structspot_1_1tgba__run.html">tgba_run</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__run.html#gabc4ad10830cd80a3237415d28adeee1b">reduce_run</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, const <a class="el" href="structspot_1_1tgba__run.html">tgba_run</a> *org)</td></tr>
<tr class="memdesc:gabc4ad10830cd80a3237415d28adeee1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce an accepting run.Return a run which is accepting for <em>and</em> that is no longer that <em>org</em>.  <a href="group__tgba__run.html#gabc4ad10830cd80a3237415d28adeee1b"></a><br/></td></tr>
<tr class="memitem:gaa6ffda0ae1ab4b30ea4f4f8303f36929"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1tgba.html">tgba</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__reduction.html#gaa6ffda0ae1ab4b30ea4f4f8303f36929">reduc_tgba_sim</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, int opt=<a class="el" href="group__tgba__reduction.html#gga5bd08ab74b3ab10a27beceaa04d9217aa81a405e18e9bbd601c4183e1c7ff49e1">Reduce_All</a>)</td></tr>
<tr class="memdesc:gaa6ffda0ae1ab4b30ea4f4f8303f36929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify the automaton using a simulation relation.  <a href="group__tgba__reduction.html#gaa6ffda0ae1ab4b30ea4f4f8303f36929"></a><br/></td></tr>
<tr class="memitem:gae2bf747c24d2fb1a06f1a033f67fe6dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__run.html#gae2bf747c24d2fb1a06f1a033f67fe6dc">replay_tgba_run</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, const <a class="el" href="structspot_1_1tgba__run.html">tgba_run</a> *run, bool debug=false)</td></tr>
<tr class="memdesc:gae2bf747c24d2fb1a06f1a033f67fe6dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replay a <a class="el" href="structspot_1_1tgba__run.html" title="An accepted run, for a tgba.">tgba_run</a> on a tgba.This is similar to <a class="el" href="group__tgba__run.html#ga3aa3b6dd9854c94b6aaabafd4a612de2" title="Display a tgba_run.">print_tgba_run()</a>, except that the run is actually replayed on the automaton while it is printed. Doing so makes it possible to display transition annotations (returned by <a class="el" href="classspot_1_1tgba.html#a00272efd8025be669d827658dc121c82" title="Return a possible annotation for the transition pointed to by the iterator.">spot::tgba::transition_annotation()</a>). The output will stop if the run cannot be completed.  <a href="group__tgba__run.html#gae2bf747c24d2fb1a06f1a033f67fe6dc"></a><br/></td></tr>
<tr class="memitem:a8a3357941b87b564d5db84960ac97f24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a8a3357941b87b564d5db84960ac97f24">is_guarantee_automaton</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *aut, const <a class="el" href="classspot_1_1scc__map.html">scc_map</a> *sm=0)</td></tr>
<tr class="memdesc:a8a3357941b87b564d5db84960ac97f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an automaton represents a guarantee property.  <a href="#a8a3357941b87b564d5db84960ac97f24"></a><br/></td></tr>
<tr class="memitem:a674e27c0b7e007eede14c4337b67581c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a674e27c0b7e007eede14c4337b67581c">is_safety_mwdba</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *aut)</td></tr>
<tr class="memdesc:a674e27c0b7e007eede14c4337b67581c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a minimized WDBA represents a safety property.  <a href="#a674e27c0b7e007eede14c4337b67581c"></a><br/></td></tr>
<tr class="memitem:ga5c7f56a5941eb2380676c4ff6706e1c2"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#ga5c7f56a5941eb2380676c4ff6706e1c2">tgba_save_reachable</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1tgba.html">tgba</a> *g)</td></tr>
<tr class="memdesc:ga5c7f56a5941eb2380676c4ff6706e1c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save reachable states in text format.  <a href="group__tgba__io.html#ga5c7f56a5941eb2380676c4ff6706e1c2"></a><br/></td></tr>
<tr class="memitem:ac57eb2b36c82228391e91bfdfd5e896e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structspot_1_1scc__stats.html">scc_stats</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#ac57eb2b36c82228391e91bfdfd5e896e">build_scc_stats</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a)</td></tr>
<tr class="memitem:a3a3040faf1273245a9e256b406d2fcca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structspot_1_1scc__stats.html">scc_stats</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a3a3040faf1273245a9e256b406d2fcca">build_scc_stats</a> (const <a class="el" href="classspot_1_1scc__map.html">scc_map</a> &amp;m)</td></tr>
<tr class="memitem:a773a06917359e059e86d341d62ecbb64"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a773a06917359e059e86d341d62ecbb64">dump_scc_dot</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, std::ostream &amp;out, bool verbose=false)</td></tr>
<tr class="memitem:ac55b8611e3b6da1437248c2c6d0d064a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#ac55b8611e3b6da1437248c2c6d0d064a">dump_scc_dot</a> (const <a class="el" href="classspot_1_1scc__map.html">scc_map</a> &amp;m, std::ostream &amp;out, bool verbose=false)</td></tr>
<tr class="memitem:a0eb62dcb2baeb2717a69966b5f7607d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1tgba.html">tgba</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a0eb62dcb2baeb2717a69966b5f7607d9">scc_filter</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *aut, bool remove_all_useless=false)</td></tr>
<tr class="memdesc:a0eb62dcb2baeb2717a69966b5f7607d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prune unaccepting SCCs and remove superfluous acceptance conditions.  <a href="#a0eb62dcb2baeb2717a69966b5f7607d9"></a><br/></td></tr>
<tr class="memitem:ga8c176368673a0c009dd3e934d57fb492"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga8c176368673a0c009dd3e934d57fb492">explicit_se05_search</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, <a class="el" href="classspot_1_1option__map.html">option_map</a> o=<a class="el" href="classspot_1_1option__map.html">option_map</a>())</td></tr>
<tr class="memdesc:ga8c176368673a0c009dd3e934d57fb492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an emptiness check on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>.  <a href="group__emptiness__check__algorithms.html#ga8c176368673a0c009dd3e934d57fb492"></a><br/></td></tr>
<tr class="memitem:gae822266082cdb9772ce31388a6538cb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#gae822266082cdb9772ce31388a6538cb9">bit_state_hashing_se05_search</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, size_t size, <a class="el" href="classspot_1_1option__map.html">option_map</a> o=<a class="el" href="classspot_1_1option__map.html">option_map</a>())</td></tr>
<tr class="memdesc:gae822266082cdb9772ce31388a6538cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>.  <a href="group__emptiness__check__algorithms.html#gae822266082cdb9772ce31388a6538cb9"></a><br/></td></tr>
<tr class="memitem:ga23a00d19bf7613222e6e41833e515c00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga23a00d19bf7613222e6e41833e515c00">se05</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, <a class="el" href="classspot_1_1option__map.html">option_map</a> o)</td></tr>
<tr class="memdesc:ga23a00d19bf7613222e6e41833e515c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for the two se05 implementations.  <a href="group__emptiness__check__algorithms.html#ga23a00d19bf7613222e6e41833e515c00"></a><br/></td></tr>
<tr class="memitem:gac2172a3be49892bccb7abcf14669c129"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1tgba.html">tgba</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__reduction.html#gac2172a3be49892bccb7abcf14669c129">simulation</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *automaton)</td></tr>
<tr class="memdesc:gac2172a3be49892bccb7abcf14669c129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to reduce the automaton by direct simulation.  <a href="group__tgba__reduction.html#gac2172a3be49892bccb7abcf14669c129"></a><br/></td></tr>
<tr class="memitem:ga5db456bdf40b6425d2a3584ab05bac5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1tgba.html">tgba</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__reduction.html#ga5db456bdf40b6425d2a3584ab05bac5c">cosimulation</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *automaton)</td></tr>
<tr class="memdesc:ga5db456bdf40b6425d2a3584ab05bac5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to reduce the automaton by reverse simulation.  <a href="group__tgba__reduction.html#ga5db456bdf40b6425d2a3584ab05bac5c"></a><br/></td></tr>
<tr class="memitem:ga4cd60f5abe60e3da4a1b788d6e9975b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1tgba.html">tgba</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__reduction.html#ga4cd60f5abe60e3da4a1b788d6e9975b1">iterated_simulations</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *automaton)</td></tr>
<tr class="memdesc:ga4cd60f5abe60e3da4a1b788d6e9975b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate <a class="el" href="group__tgba__reduction.html#gac2172a3be49892bccb7abcf14669c129" title="Attempt to reduce the automaton by direct simulation.">simulation()</a> and <a class="el" href="group__tgba__reduction.html#ga5db456bdf40b6425d2a3584ab05bac5c" title="Attempt to reduce the automaton by reverse simulation.">cosimulation()</a>.  <a href="group__tgba__reduction.html#ga4cd60f5abe60e3da4a1b788d6e9975b1"></a><br/></td></tr>
<tr class="memitem:gaeeb949ca5fa52c1e292e0a7732ef46c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structspot_1_1tgba__statistics.html">tgba_statistics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#gaeeb949ca5fa52c1e292e0a7732ef46c4">stats_reachable</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *g)</td></tr>
<tr class="memdesc:gaeeb949ca5fa52c1e292e0a7732ef46c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute statistics for an automaton.  <a href="group__tgba__misc.html#gaeeb949ca5fa52c1e292e0a7732ef46c4"></a><br/></td></tr>
<tr class="memitem:gaec71c3349daead65b683e5ba99b893cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structspot_1_1tgba__sub__statistics.html">tgba_sub_statistics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#gaec71c3349daead65b683e5ba99b893cf">sub_stats_reachable</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *g)</td></tr>
<tr class="memdesc:gaec71c3349daead65b683e5ba99b893cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute subended statistics for an automaton.  <a href="group__tgba__misc.html#gaec71c3349daead65b683e5ba99b893cf"></a><br/></td></tr>
<tr class="memitem:ga27bc2c8fa49e5a2531b1b92dc6ed7020"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacespot.html#a13bc152377363a78e3ab83a43a6be053">sba_explicit_number</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#ga27bc2c8fa49e5a2531b1b92dc6ed7020">strip_acceptance</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a)</td></tr>
<tr class="memdesc:ga27bc2c8fa49e5a2531b1b92dc6ed7020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate automaton <em>a</em>, removing all acceptance sets.  <a href="group__tgba__misc.html#ga27bc2c8fa49e5a2531b1b92dc6ed7020"></a><br/></td></tr>
<tr class="memitem:ga159e81f9b91f99b2a749185f47924d99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga159e81f9b91f99b2a749185f47924d99">explicit_tau03_search</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, <a class="el" href="classspot_1_1option__map.html">option_map</a> o=<a class="el" href="classspot_1_1option__map.html">option_map</a>())</td></tr>
<tr class="memdesc:ga159e81f9b91f99b2a749185f47924d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>.  <a href="group__emptiness__check__algorithms.html#ga159e81f9b91f99b2a749185f47924d99"></a><br/></td></tr>
<tr class="memitem:ga68f7245733f5fe5a86e6dd416d7746f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga68f7245733f5fe5a86e6dd416d7746f1">explicit_tau03_opt_search</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, <a class="el" href="classspot_1_1option__map.html">option_map</a> o=<a class="el" href="classspot_1_1option__map.html">option_map</a>())</td></tr>
<tr class="memdesc:ga68f7245733f5fe5a86e6dd416d7746f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>.  <a href="group__emptiness__check__algorithms.html#ga68f7245733f5fe5a86e6dd416d7746f1"></a><br/></td></tr>
<tr class="memitem:gab07f6359e41046dd8f1452ce3665e152"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacespot.html#a3ace0ebc1ab16f0766fa681785750794">tgba_explicit_string</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#gab07f6359e41046dd8f1452ce3665e152">tgba_parse</a> (const std::string &amp;filename, <a class="el" href="group__tgba__io.html#ga76b22bb081d5c36378098caa5bf58081">tgba_parse_error_list</a> &amp;error_list, <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, <a class="el" href="classspot_1_1ltl_1_1environment.html">ltl::environment</a> &amp;env=<a class="el" href="classspot_1_1ltl_1_1default__environment.html#a6f82853f22c3bf57128a484a28a4d550">ltl::default_environment::instance</a>(), <a class="el" href="classspot_1_1ltl_1_1environment.html">ltl::environment</a> &amp;envacc=<a class="el" href="classspot_1_1ltl_1_1default__environment.html#a6f82853f22c3bf57128a484a28a4d550">ltl::default_environment::instance</a>(), bool debug=false)</td></tr>
<tr class="memdesc:gab07f6359e41046dd8f1452ce3665e152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="classspot_1_1tgba__explicit.html">spot::tgba_explicit</a> from a text file.  <a href="group__tgba__io.html#gab07f6359e41046dd8f1452ce3665e152"></a><br/></td></tr>
<tr class="memitem:ga95b48c3bd896478c7e22b0d49c39d89c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#ga95b48c3bd896478c7e22b0d49c39d89c">format_tgba_parse_errors</a> (std::ostream &amp;os, const std::string &amp;filename, <a class="el" href="group__tgba__io.html#ga76b22bb081d5c36378098caa5bf58081">tgba_parse_error_list</a> &amp;error_list)</td></tr>
<tr class="memdesc:ga95b48c3bd896478c7e22b0d49c39d89c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format diagnostics produced by <a class="el" href="group__tgba__io.html#gab07f6359e41046dd8f1452ce3665e152" title="Build a spot::tgba_explicit from a text file.">spot::tgba_parse</a>.  <a href="group__tgba__io.html#ga95b48c3bd896478c7e22b0d49c39d89c"></a><br/></td></tr>
<tr class="memitem:afbc3f43caf8b96d8e715661d45e0a2b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1kripke.html">kripke</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#afbc3f43caf8b96d8e715661d45e0a2b0">load_dve2</a> (const std::string &amp;file, <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, const <a class="el" href="group__ltl__misc.html#ga8347f76c4cd9c56970ba55c8fb40ab1a">ltl::atomic_prop_set</a> *to_observe, const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *dead=<a class="el" href="classspot_1_1ltl_1_1constant.html#a343dd7a20e2df06851836a6bd7fc1b90">ltl::constant::true_instance</a>(), int compress=0, bool verbose=true)</td></tr>
<tr class="memitem:a83bcadbb0c347d956021471f8c7d2135"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a83bcadbb0c347d956021471f8c7d2135">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1gspn__exception.html">gspn_exception</a> &amp;e)</td></tr>
<tr class="memitem:ga41573dafc02e8da2283670fa7aefebcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1couvreur99__check.html">couvreur99_check</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__ssp.html#ga41573dafc02e8da2283670fa7aefebcf">couvreur99_check_ssp_semi</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *ssp_automata)</td></tr>
<tr class="memitem:ga9e84d9fcba32903d98fc0a0ebdc73ac1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1couvreur99__check.html">couvreur99_check</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__ssp.html#ga9e84d9fcba32903d98fc0a0ebdc73ac1">couvreur99_check_ssp_shy_semi</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *ssp_automata)</td></tr>
<tr class="memitem:ga4f5db797b2fc8a4b7617a76519114800"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1couvreur99__check.html">couvreur99_check</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__ssp.html#ga4f5db797b2fc8a4b7617a76519114800">couvreur99_check_ssp_shy</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *ssp_automata, bool stack_inclusion=true, bool double_inclusion=false, bool reversed_double_inclusion=false, bool no_decomp=false)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gafa490c8262811858828ad363760d911d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacespot.html#ad566cf6234b8c875958ed4001f959bb4">tgba_explicit_number</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#gafa490c8262811858828ad363760d911d">tgba_powerset</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *aut, <a class="el" href="structspot_1_1power__map.html">power_map</a> &amp;pm)</td></tr>
<tr class="memdesc:gafa490c8262811858828ad363760d911d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a deterministic automaton, ignoring acceptance conditions.This create a deterministic automaton that recognizes the same language as <em>aut</em> would if its acceptance conditions were ignored. This is the classical powerset algorithm.  <a href="group__tgba__misc.html#gafa490c8262811858828ad363760d911d"></a><br/></td></tr>
<tr class="memitem:ga42b9bff1af663f032af02cc8007db6d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacespot.html#ad566cf6234b8c875958ed4001f959bb4">tgba_explicit_number</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#ga42b9bff1af663f032af02cc8007db6d6">tgba_powerset</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *aut)</td></tr>
</table>
<h2>Typedef Documentation</h2>
<a class="anchor" id="a4260b69cfc6b42df1b242d141d250acc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="classspot_1_1bdd__ordered.html">bdd_ordered</a>&gt; <a class="el" href="namespacespot.html#a4260b69cfc6b42df1b242d141d250acc">spot::acc_list_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad049f28e03c2ebe740e5597034fd5c93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;evtgbayy::location, std::string&gt; <a class="el" href="namespacespot.html#ad049f28e03c2ebe740e5597034fd5c93">spot::evtgba_parse_error</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A parse diagnostic with its location. </p>

</div>
</div>
<a class="anchor" id="a90dc0e2318bb80c45893922f42ec44fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;<a class="el" href="namespacespot.html#ad049f28e03c2ebe740e5597034fd5c93">evtgba_parse_error</a>&gt; <a class="el" href="namespacespot.html#a90dc0e2318bb80c45893922f42ec44fe">spot::evtgba_parse_error_list</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A list of parser diagnostics, as filled by parse. </p>

</div>
</div>
<a class="anchor" id="a68ac7577bed0b7af5dd8e45135797759"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;<a class="el" href="classkripkeyy_1_1location.html">kripkeyy::location</a>, std::string&gt; <a class="el" href="namespacespot.html#a68ac7577bed0b7af5dd8e45135797759">spot::kripke_parse_error</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A parse diagnostic with its location. </p>

</div>
</div>
<a class="anchor" id="a429e9facc10a0958d14ff3f94d71b006"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;<a class="el" href="namespacespot.html#a68ac7577bed0b7af5dd8e45135797759">kripke_parse_error</a>&gt; <a class="el" href="namespacespot.html#a429e9facc10a0958d14ff3f94d71b006">spot::kripke_parse_error_list</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A list of parser diagnostics, as filled by parse. </p>

</div>
</div>
<a class="anchor" id="a5f139f442de158fbe3bf9fab3ddee7f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt;<a class="el" href="classspot_1_1rsymbol.html">rsymbol</a>&gt; <a class="el" href="namespacespot.html#a5f139f442de158fbe3bf9fab3ddee7f3">spot::rsymbol_set</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7ce8b43567a8c7e16773717dcf683eb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classspot_1_1explicit__conf.html">explicit_conf</a>&lt;<a class="el" href="classspot_1_1sba__explicit.html">sba_explicit</a>&lt;<a class="el" href="classspot_1_1state__explicit__formula.html">state_explicit_formula</a>&gt;, <a class="el" href="classspot_1_1state__explicit__formula.html">state_explicit_formula</a>&gt; <a class="el" href="namespacespot.html#a7ce8b43567a8c7e16773717dcf683eb3">spot::sba_explicit_formula</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a13bc152377363a78e3ab83a43a6be053"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classspot_1_1explicit__conf.html">explicit_conf</a>&lt;<a class="el" href="classspot_1_1sba__explicit.html">sba_explicit</a>&lt;<a class="el" href="classspot_1_1state__explicit__number.html">state_explicit_number</a>&gt;, <a class="el" href="classspot_1_1state__explicit__number.html">state_explicit_number</a>&gt; <a class="el" href="namespacespot.html#a13bc152377363a78e3ab83a43a6be053">spot::sba_explicit_number</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a118b4701825f7a8860cebf5c0a68eee3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classspot_1_1explicit__conf.html">explicit_conf</a>&lt;<a class="el" href="classspot_1_1sba__explicit.html">sba_explicit</a>&lt;<a class="el" href="classspot_1_1state__explicit__string.html">state_explicit_string</a>&gt;, <a class="el" href="classspot_1_1state__explicit__string.html">state_explicit_string</a>&gt; <a class="el" href="namespacespot.html#a118b4701825f7a8860cebf5c0a68eee3">spot::sba_explicit_string</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5494e2802ca03bd036c523a1c65f3a3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;const <a class="el" href="classspot_1_1saba__state.html">saba_state</a>&gt; <a class="el" href="namespacespot.html#a5494e2802ca03bd036c523a1c65f3a3e">spot::shared_saba_state</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a13a1db95095eccfe0a4ce4a818442fbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;const <a class="el" href="classspot_1_1state.html">state</a>&gt; <a class="el" href="namespacespot.html#a13a1db95095eccfe0a4ce4a818442fbf">spot::shared_state</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab1fe964166144356a185c98ce0bcbde6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt;const <a class="el" href="classspot_1_1symbol.html">symbol</a>*&gt; <a class="el" href="namespacespot.html#ab1fe964166144356a185c98ce0bcbde6">spot::symbol_set</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a24df826dd55ad1b8a6fd711c8ab1785e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classspot_1_1explicit__conf.html">explicit_conf</a>&lt;<a class="el" href="classspot_1_1tgba__explicit.html">tgba_explicit</a>&lt;<a class="el" href="classspot_1_1state__explicit__formula.html">state_explicit_formula</a>&gt;, <a class="el" href="classspot_1_1state__explicit__formula.html">state_explicit_formula</a>&gt; <a class="el" href="namespacespot.html#a24df826dd55ad1b8a6fd711c8ab1785e">spot::tgba_explicit_formula</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad566cf6234b8c875958ed4001f959bb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classspot_1_1explicit__conf.html">explicit_conf</a>&lt;<a class="el" href="classspot_1_1tgba__explicit.html">tgba_explicit</a>&lt;<a class="el" href="classspot_1_1state__explicit__number.html">state_explicit_number</a>&gt;, <a class="el" href="classspot_1_1state__explicit__number.html">state_explicit_number</a>&gt; <a class="el" href="namespacespot.html#ad566cf6234b8c875958ed4001f959bb4">spot::tgba_explicit_number</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3ace0ebc1ab16f0766fa681785750794"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classspot_1_1explicit__conf.html">explicit_conf</a>&lt;<a class="el" href="classspot_1_1tgba__explicit.html">tgba_explicit</a>&lt;<a class="el" href="classspot_1_1state__explicit__string.html">state_explicit_string</a>&gt;, <a class="el" href="classspot_1_1state__explicit__string.html">state_explicit_string</a>&gt; <a class="el" href="namespacespot.html#a3ace0ebc1ab16f0766fa681785750794">spot::tgba_explicit_string</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="aa04818924fa41d2230160b499d95173d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string spot::bdd_format_accset </td>
          <td>(</td>
          <td class="paramtype">const bdd_dict *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format a BDD as a set of acceptance conditions. </p>
<p>This is used when saving a TGBA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dict</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td class="paramname">b</td><td>The BDD to print. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The BDD formated as a string. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9eea881fdb5d8e629db7102fde452ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string spot::bdd_format_formula </td>
          <td>(</td>
          <td class="paramtype">const bdd_dict *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format a BDD as a formula. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dict</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td class="paramname">b</td><td>The BDD to print. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The BDD formated as a string. </dd></dl>

</div>
</div>
<a class="anchor" id="aba342c9d66d191b7ed930e2b02043e7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string spot::bdd_format_sat </td>
          <td>(</td>
          <td class="paramtype">const bdd_dict *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format a BDD as a list of literals. </p>
<p>This assumes that <em>b</em> is a conjunction of literals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dict</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td class="paramname">b</td><td>The BDD to print. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The BDD formated as a string. </dd></dl>

</div>
</div>
<a class="anchor" id="a73d8fa997efd95d08e0d1b9dfa7b7073"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string spot::bdd_format_set </td>
          <td>(</td>
          <td class="paramtype">const bdd_dict *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format a BDD as a set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dict</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td class="paramname">b</td><td>The BDD to print. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The BDD formated as a string. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b659fe265e2014282d3b25db928794b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::bdd_print_acc </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bdd_dict *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a BDD as a list of acceptance conditions. </p>
<p>This is used when saving a TGBA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream. </td></tr>
    <tr><td class="paramname">dict</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td class="paramname">b</td><td>The BDD to print. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The BDD formated as a string. </dd></dl>

</div>
</div>
<a class="anchor" id="aa75a117405f2292f6d80abc2ae930946"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::bdd_print_accset </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bdd_dict *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a BDD as a set of acceptance conditions. </p>
<p>This is used when saving a TGBA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream. </td></tr>
    <tr><td class="paramname">dict</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td class="paramname">b</td><td>The BDD to print. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The BDD formated as a string. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ec151057e33aadb60d2b47ffaa64c24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::bdd_print_dot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bdd_dict *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a BDD as a diagram in dotty format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream. </td></tr>
    <tr><td class="paramname">dict</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td class="paramname">b</td><td>The BDD to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a174c8f965f37e9a26b33c9f76183720f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::bdd_print_formula </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bdd_dict *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a BDD as a formula. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream. </td></tr>
    <tr><td class="paramname">dict</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td class="paramname">b</td><td>The BDD to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a59e91579989d390a3979a5badf302255"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::bdd_print_sat </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bdd_dict *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a BDD as a list of literals. </p>
<p>This assumes that <em>b</em> is a conjunction of literals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream. </td></tr>
    <tr><td class="paramname">dict</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td class="paramname">b</td><td>The BDD to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aca49e9ec778c8a6b38455a68db8d6ece"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::bdd_print_set </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bdd_dict *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a BDD as a set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream. </td></tr>
    <tr><td class="paramname">dict</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td class="paramname">b</td><td>The BDD to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac8434843d2dcb0d99a027e398b01bafe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::bdd_print_table </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bdd_dict *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a BDD as a table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream. </td></tr>
    <tr><td class="paramname">dict</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td class="paramname">b</td><td>The BDD to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aebfbc06108c79ba74f84a838af4f1772"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a>* spot::bdd_to_formula </td>
          <td>(</td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bdd_dict *&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a BDD into a formula. </p>

</div>
</div>
<a class="anchor" id="ac57eb2b36c82228391e91bfdfd5e896e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspot_1_1scc__stats.html">scc_stats</a> spot::build_scc_stats </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3a3040faf1273245a9e256b406d2fcca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspot_1_1scc__stats.html">scc_stats</a> spot::build_scc_stats </td>
          <td>(</td>
          <td class="paramtype">const scc_map &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1c1c9963ce3385c106461526f80e4d7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdd spot::compute_all_acceptance_conditions </td>
          <td>(</td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>neg_acceptance_conditions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute all acceptance conditions from all neg acceptance conditions. </p>

<p>Referenced by <a class="el" href="classspot_1_1explicit__graph.html#a08df7e758b2f74a3327b2fa580522938">spot::explicit_graph&lt; State, tgba &gt;::all_acceptance_conditions()</a>.</p>

</div>
</div>
<a class="anchor" id="acbfcdc0a54e339085eb6c5458c994832"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdd spot::compute_neg_acceptance_conditions </td>
          <td>(</td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>all_acceptance_conditions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute neg acceptance conditions from all acceptance conditions. </p>

<p>Referenced by <a class="el" href="classspot_1_1explicit__graph.html#a8237bac44dabf3ced482b99a65f72530">spot::explicit_graph&lt; State, tgba &gt;::set_acceptance_conditions()</a>.</p>

</div>
</div>
<a class="anchor" id="ae6985cd6c82ba766e2e853f5a1e82e24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spot::display_safra </td>
          <td>(</td>
          <td class="paramtype">const tgba_safra_complement *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produce a dot output of the Safra automaton associated to <em>a</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The <code><a class="el" href="classspot_1_1tgba__safra__complement.html" title="Build a complemented automaton.It creates an automaton that recognizes the negated language of aut...">tgba_safra_complement</a></code> with an intermediate Safra automaton to display </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3ff98345b771b22e0a9b67063676e84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::dotty_reachable </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const evtgba *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print reachable states in dot format. </p>

</div>
</div>
<a class="anchor" id="a6d777a0a353d8c7502742e3fa3b4a5b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::dotty_reachable </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ta *&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a773a06917359e059e86d341d62ecbb64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::dump_scc_dot </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac55b8611e3b6da1437248c2c6d0d064a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::dump_scc_dot </td>
          <td>(</td>
          <td class="paramtype">const scc_map &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9da9924abc8e1cb4086202c87b4213df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spot::enable_utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable UTF-8 output for bdd printers. </p>

</div>
</div>
<a class="anchor" id="a6805befaee0df3f7cb4427d30782f230"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspot_1_1evtgba__explicit.html">evtgba_explicit</a>* spot::evtgba_parse </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">evtgba_parse_error_list &amp;&#160;</td>
          <td class="paramname"><em>error_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a <a class="el" href="classspot_1_1evtgba__explicit.html">spot::evtgba_explicit</a> from a text file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the file to parse. </td></tr>
    <tr><td class="paramname">error_list</td><td>A list that will be filled with parse errors that occured during parsing. </td></tr>
    <tr><td class="paramname">debug</td><td>When true, causes the parser to trace its execution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the evtgba built from <em>filename</em>, or 0 if the file could not be opened.</dd></dl>
<p>Note that the parser usually tries to recover from errors. It can return an non zero value even if it encountered error during the parsing of <em>filename</em>. If you want to make sure <em>filename</em> was parsed succesfully, check <em>error_list</em> for emptiness.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function is not reentrant. </dd></dl>

</div>
</div>
<a class="anchor" id="aade1f7e5b6c685b5393d8a6d3ab7e09d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::evtgba_save_reachable </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const evtgba *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save reachable states in text format. </p>

</div>
</div>
<a class="anchor" id="a7a3b33efec82bd649f01077850ddfc2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="structspot_1_1sccs__set.html">sccs_set</a>* &gt; &gt;* spot::find_paths </td>
          <td>(</td>
          <td class="paramtype">tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scc_map &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a805ae4b750b93c1d2e19d81faa609065"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spot::format_evtgba_parse_errors </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">evtgba_parse_error_list &amp;&#160;</td>
          <td class="paramname"><em>error_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format diagnostics produced by <a class="el" href="namespacespot.html#a6805befaee0df3f7cb4427d30782f230" title="Build a spot::evtgba_explicit from a text file.">spot::evtgba_parse</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Where diagnostics should be output. </td></tr>
    <tr><td class="paramname">filename</td><td>The filename that should appear in the diagnostics. </td></tr>
    <tr><td class="paramname">error_list</td><td>The error list filled by <a class="el" href="group__ltl__io.html#ga38985ad6b8ca53a130115aff8a055036" title="Build a formula from an LTL string.">spot::ltl::parse</a> while parsing <em>ltl_string</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff any diagnostic was output. </dd></dl>

</div>
</div>
<a class="anchor" id="a119f3d265650a37c30f816ad189725ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spot::format_kripke_parse_errors </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kripke_parse_error_list &amp;&#160;</td>
          <td class="paramname"><em>error_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format diagnostics produced by <a class="el" href="namespacespot.html#ad7749e1e9d7c9449aa0c0639f6e7add0">spot::kripke_parse</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Where diagnostics should be output. </td></tr>
    <tr><td class="paramname">filename</td><td>The filename that should appear in the diagnostics. </td></tr>
    <tr><td class="paramname">error_list</td><td>The error list filled by <a class="el" href="group__ltl__io.html#ga38985ad6b8ca53a130115aff8a055036" title="Build a formula from an LTL string.">spot::ltl::parse</a> while parsing <em>ltl_string</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if any diagnostic was output. </dd></dl>

</div>
</div>
<a class="anchor" id="ab6641d7d9896e016376b1c618da92469"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdd spot::formula_to_bdd </td>
          <td>(</td>
          <td class="paramtype">const ltl::formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_dict *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>for_me</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a formula into a BDD. </p>
<p>Convert formula <em>f</em> into a Bdd, using existing variables from <em>d</em>, and registering new one as necessary. <em>for_me</em> is the address to use as owner of the variables used in the BDD. </p>

<p>Referenced by <a class="el" href="classspot_1_1explicit__graph.html#a03bc3ff272a27d629976a99d6e5ff925">spot::explicit_graph&lt; State, tgba &gt;::add_condition()</a>.</p>

</div>
</div>
<a class="anchor" id="a4e83dbca5f5008ab4cac60ee423b905d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;const <a class="el" href="classspot_1_1state.html">state</a>*&gt; spot::get_states_set </td>
          <td>(</td>
          <td class="paramtype">const ta *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute states set for an automaton. </p>

</div>
</div>
<a class="anchor" id="a8a3357941b87b564d5db84960ac97f24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spot::is_guarantee_automaton </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>aut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scc_map *&#160;</td>
          <td class="paramname"><em>sm</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether an automaton represents a guarantee property. </p>
<p>A weak deterministic TGBA represents a guarantee property if any accepting path ends on an accepting state with only one transition that is a self-loop labelled by true.</p>
<p>Note that in the general case, this is only a sufficient condition : some guarantee automata might not be recognized with this check e.g. because of some non-determinism in the automaton. In that case, you should interpret a <code>false</code> return value as "I don't know".</p>
<p>If you apply this function on a weak deterministic TGBA (e.g. after a successful minimization with <a class="el" href="group__tgba__reduction.html#ga4245a82c2be0713e20af9b217ad7b0a7" title="Minimize an automaton if it represents an obligation property.">minimize_obligation()</a>), then the result leaves no doubt: false really means that the automaton is not a guarantee property.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aut</td><td>the automaton to check</td></tr>
    <tr><td class="paramname">sm</td><td>an <a class="el" href="classspot_1_1scc__map.html" title="Build a map of Strongly Connected components in in a TGBA.">scc_map</a> of the automaton if available (it will be built otherwise. If you supply an <a class="el" href="classspot_1_1scc__map.html" title="Build a map of Strongly Connected components in in a TGBA.">scc_map</a> you should call build_map() before passing it to this function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a674e27c0b7e007eede14c4337b67581c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spot::is_safety_mwdba </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>aut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether a minimized WDBA represents a safety property. </p>
<p>A minimized WDBA (as returned by a successful run of <a class="el" href="group__tgba__reduction.html#ga4245a82c2be0713e20af9b217ad7b0a7" title="Minimize an automaton if it represents an obligation property.">minimize_obligation()</a>) represent safety property if it contains only accepting transitions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aut</td><td>the automaton to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad7749e1e9d7c9449aa0c0639f6e7add0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspot_1_1kripke__explicit.html">kripke_explicit</a>* spot::kripke_parse </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kripke_parse_error_list &amp;&#160;</td>
          <td class="paramname"><em>error_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_dict *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ltl::environment &amp;&#160;</td>
          <td class="paramname"><em>env</em> = <code>ltl::default_environment::instance()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afbc3f43caf8b96d8e715661d45e0a2b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspot_1_1kripke.html">kripke</a>* spot::load_dve2 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_dict *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ltl::atomic_prop_set *&#160;</td>
          <td class="paramname"><em>to_observe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ltl::formula *&#160;</td>
          <td class="paramname"><em>dead</em> = <code>ltl::constant::true_instance()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compress</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab35966460c1f984c2db09456bdf08b42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspot_1_1unique__ptr.html">unique_ptr</a>&lt;T&gt; spot::make_unique </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change a pointer into a <a class="el" href="classspot_1_1unique__ptr.html" title="Take ownership of a pointer at its construction, and destroy it at the end of the scope...">unique_ptr</a>. </p>

</div>
</div>
<a class="anchor" id="af2a55d9921bf9eab8f9b410ff0ad0e0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned spot::max_spanning_paths </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; sccs_set * &gt; *&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scc_map &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1a8d0610b61c0a30aad16791b0b73d15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spot::memusage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Total number of pages in use by the program. </p>
<dl class="section return"><dt>Returns</dt><dd>The total number of pages in use by the program if known. -1 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a83bcadbb0c347d956021471f8c7d2135"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gspn_exception &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9f2c6c63ca4916813045c4326c635b93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::saba_dotty_reachable </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const saba *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print reachable states in dot format. </p>

</div>
</div>
<a class="anchor" id="a0eb62dcb2baeb2717a69966b5f7607d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspot_1_1tgba.html">tgba</a>* spot::scc_filter </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>aut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove_all_useless</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prune unaccepting SCCs and remove superfluous acceptance conditions. </p>
<p>This function will explore the SCCs of the automaton and remove dead SCCs (i.e. SCC that are not accepting, and those with no exit path leading to an accepting SCC).</p>
<p>Additionally, this will try to remove useless acceptance conditions. This operation may diminish the number of acceptance condition of the automaton (for instance when two acceptance conditions are always used together we only keep one) but it will never remove all acceptance conditions, even if it would be OK to have zero.</p>
<p>Acceptance conditions on transitions going to non-accepting SCC are all removed. Acceptance conditions going to an accepting SCC and coming from another SCC are only removed if <em>remove_all_useless</em> is set. The default value of <em>remove_all_useless</em> is <code>false</code> because some algorithms (like the degeneralization) will work better if transitions going to an accepting SCC are accepting. </p>

</div>
</div>
<a class="anchor" id="a361af6c0080f2280ac0a884960374bd3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void spot::shared_state_deleter </td>
          <td>(</td>
          <td class="paramtype">state *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classspot_1_1state.html#afa00fb3e8019389e2b6fbec0b5e40ded">spot::state::destroy()</a>.</p>

</div>
</div>
<a class="anchor" id="a9f710ac23d3a22a3a66244d15de62a3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="classspot_1_1tgba.html">tgba</a>*&gt; spot::split_tgba </td>
          <td>(</td>
          <td class="paramtype">tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scc_map &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>split_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3b22a05fb3e16d693b2d80425dfa4500"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspot_1_1evtgba__explicit.html">evtgba_explicit</a>* spot::tgba_to_evtgba </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a tgba into an evtgba. </p>
<p>(This cannot be done on-the-fly because the alphabet of a tgba as unknown beforehand.) </p>

</div>
</div>
</div><!-- contents -->
<hr size="1">
Please <b>comment</b> this page and <b>report errors</b> about it on
<a href="http://spot.lip6.fr/wiki/RefDocComments">the RefDocComments page</a>.
<br><address style="align: right;"><small>
Generated on Sat Oct 27 2012 09:34:33 for spot by <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border=0></a> 1.8.1.2</small></address>
</body>
</html>
