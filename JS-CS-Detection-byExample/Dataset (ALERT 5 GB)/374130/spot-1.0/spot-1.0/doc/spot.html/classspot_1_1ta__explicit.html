<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>spot: spot::ta_explicit Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">spot
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacespot.html">spot</a></li><li class="navelem"><a class="el" href="classspot_1_1ta__explicit.html">ta_explicit</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classspot_1_1ta__explicit-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">spot::ta_explicit Class Reference<div class="ingroups"><a class="el" href="group__ta__representation.html">TA representations</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="taexplicit_8hh_source.html">ta/taexplicit.hh</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for spot::ta_explicit:</div>
<div class="dyncontent">
<div class="center"><img src="classspot_1_1ta__explicit__inherit__graph.png" border="0" usemap="#spot_1_1ta__explicit_inherit__map" alt="Inheritance graph"/></div>
<map name="spot_1_1ta__explicit_inherit__map" id="spot_1_1ta__explicit_inherit__map">
<area shape="rect" id="node2" href="classspot_1_1ta.html" title="A Testing Automaton.The Testing Automata (TA) were introduced by Henri Hansen, Wojciech Penczek and A..." alt="" coords="9,6,204,311"/></map>
</div>
<div class="dynheader">
Collaboration diagram for spot::ta_explicit:</div>
<div class="dyncontent">
<div class="center"><img src="classspot_1_1ta__explicit__coll__graph.png" border="0" usemap="#spot_1_1ta__explicit_coll__map" alt="Collaboration graph"/></div>
<map name="spot_1_1ta__explicit_coll__map" id="spot_1_1ta__explicit_coll__map">
<area shape="rect" id="node2" href="classspot_1_1ta.html" title="A Testing Automaton.The Testing Automata (TA) were introduced by Henri Hansen, Wojciech Penczek and A..." alt="" coords="5,337,200,642"/><area shape="rect" id="node4" href="classspot_1_1tgba.html" title="A Transition&#45;based Generalized Büchi Automaton.The acronym TGBA (Transition&#45;based Generalized Büchi A..." alt="" coords="224,265,429,714"/><area shape="rect" id="node6" href="classspot_1_1state.html" title="Abstract class for states." alt="" coords="448,6,539,151"/><area shape="rect" id="node8" href="classspot_1_1state__ta__explicit.html" title="{spot::state_ta_explicit\n|&#45; tgba_condition_\l&#45; is_initial_state_\l&#45; is_accepting_state_\l&#45; is_livelock_accepting\l_state_\l&#45; transitions_\l&#45; transitions_by_condition\l|+ state_ta_explicit()\l+ compare()\l+ hash()\l+ clone()\l+ destroy()\l+ ~state_ta_explicit()\l+ get_transitions()\l+ get_transitions()\l+ add_transition()\l+ get_tgba_state()\land 10 more...\l}" alt="" coords="453,321,621,658"/></map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af1bc68c8c3cd3f18de560546ff624ea7"><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; <a class="el" href="classspot_1_1state.html">state</a> <br class="typebreak"/>
*, <a class="el" href="structspot_1_1state__ptr__less__than.html">state_ptr_less_than</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta.html#af1bc68c8c3cd3f18de560546ff624ea7">states_set_t</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a13f7c7b73d900f0cae107bf38ecdf443"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__explicit.html#a13f7c7b73d900f0cae107bf38ecdf443">ta_explicit</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *<a class="el" href="classspot_1_1tgba.html">tgba</a>, bdd <a class="el" href="classspot_1_1ta__explicit.html#a0a4f238c1876d503352f15e80940721c">all_acceptance_conditions</a>, <a class="el" href="classspot_1_1state__ta__explicit.html">state_ta_explicit</a> *artificial_initial_state=0, bool own_tgba=false)</td></tr>
<tr class="memitem:a63460eac2315781aefcacc8707d2f65a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1tgba.html">tgba</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__explicit.html#a63460eac2315781aefcacc8707d2f65a">get_tgba</a> () const </td></tr>
<tr class="memitem:a0da605a671217aeac5124d7b89bc6854"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1state__ta__explicit.html">state_ta_explicit</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__explicit.html#a0da605a671217aeac5124d7b89bc6854">add_state</a> (<a class="el" href="classspot_1_1state__ta__explicit.html">state_ta_explicit</a> *s)</td></tr>
<tr class="memitem:a3d52664f1353f4f9fb419f3be6d3bf01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__explicit.html#a3d52664f1353f4f9fb419f3be6d3bf01">add_to_initial_states_set</a> (<a class="el" href="classspot_1_1state.html">state</a> *s, bdd condition=bddfalse)</td></tr>
<tr class="memitem:a1642257587084c97ce5d39da70d501a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__explicit.html#a1642257587084c97ce5d39da70d501a8">create_transition</a> (<a class="el" href="classspot_1_1state__ta__explicit.html">state_ta_explicit</a> *source, bdd condition, bdd acceptance_conditions, <a class="el" href="classspot_1_1state__ta__explicit.html">state_ta_explicit</a> *dest, bool add_at_beginning=false)</td></tr>
<tr class="memitem:a0302fe9864a2de9b3589e4789830e158"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__explicit.html#a0302fe9864a2de9b3589e4789830e158">delete_stuttering_transitions</a> ()</td></tr>
<tr class="memitem:a0505e3e48870a6898efa701b3e452529"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__explicit.html#a0505e3e48870a6898efa701b3e452529">~ta_explicit</a> ()</td></tr>
<tr class="memitem:a829c195d324bf9fd80cabdb883f1beb3"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classspot_1_1ta.html#af1bc68c8c3cd3f18de560546ff624ea7">states_set_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__explicit.html#a829c195d324bf9fd80cabdb883f1beb3">get_initial_states_set</a> () const </td></tr>
<tr class="memdesc:a829c195d324bf9fd80cabdb883f1beb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the initial states set of the automaton.  <a href="#a829c195d324bf9fd80cabdb883f1beb3"></a><br/></td></tr>
<tr class="memitem:a56ff22eacfb314076c3795e29c51bd45"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classspot_1_1ta__succ__iterator.html">ta_succ_iterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__explicit.html#a56ff22eacfb314076c3795e29c51bd45">succ_iter</a> (const <a class="el" href="classspot_1_1state.html">spot::state</a> *s) const </td></tr>
<tr class="memdesc:a56ff22eacfb314076c3795e29c51bd45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator over the successors of <em>state</em>.  <a href="#a56ff22eacfb314076c3795e29c51bd45"></a><br/></td></tr>
<tr class="memitem:ae63d26c7687ae408133aeb95c793a4d5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classspot_1_1ta__succ__iterator.html">ta_succ_iterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__explicit.html#ae63d26c7687ae408133aeb95c793a4d5">succ_iter</a> (const <a class="el" href="classspot_1_1state.html">spot::state</a> *s, bdd condition) const </td></tr>
<tr class="memdesc:ae63d26c7687ae408133aeb95c793a4d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator over the successors of <em>state</em> filtred by the changeset on transitions.  <a href="#ae63d26c7687ae408133aeb95c793a4d5"></a><br/></td></tr>
<tr class="memitem:a2d9f1b65d258892c253750376a758213"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__explicit.html#a2d9f1b65d258892c253750376a758213">get_dict</a> () const </td></tr>
<tr class="memdesc:a2d9f1b65d258892c253750376a758213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dictionary associated to the automaton.  <a href="#a2d9f1b65d258892c253750376a758213"></a><br/></td></tr>
<tr class="memitem:a75d9f86c25fd4a7cd6ababa7467846d2"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__explicit.html#a75d9f86c25fd4a7cd6ababa7467846d2">format_state</a> (const <a class="el" href="classspot_1_1state.html">spot::state</a> *s) const </td></tr>
<tr class="memdesc:a75d9f86c25fd4a7cd6ababa7467846d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format the state as a string for printing.  <a href="#a75d9f86c25fd4a7cd6ababa7467846d2"></a><br/></td></tr>
<tr class="memitem:a908627a9e60708a3c1f5a63f641ff5da"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__explicit.html#a908627a9e60708a3c1f5a63f641ff5da">is_accepting_state</a> (const <a class="el" href="classspot_1_1state.html">spot::state</a> *s) const </td></tr>
<tr class="memdesc:a908627a9e60708a3c1f5a63f641ff5da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <em>s</em> is a Buchi-accepting state, otherwise false.  <a href="#a908627a9e60708a3c1f5a63f641ff5da"></a><br/></td></tr>
<tr class="memitem:a6de8fc9f373578cbc436af5f1d58fa97"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__explicit.html#a6de8fc9f373578cbc436af5f1d58fa97">is_livelock_accepting_state</a> (const <a class="el" href="classspot_1_1state.html">spot::state</a> *s) const </td></tr>
<tr class="memdesc:a6de8fc9f373578cbc436af5f1d58fa97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <em>s</em> is a livelock-accepting state , otherwise false.  <a href="#a6de8fc9f373578cbc436af5f1d58fa97"></a><br/></td></tr>
<tr class="memitem:a1d914fc0d7f5aed14ab92befcda2d668"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__explicit.html#a1d914fc0d7f5aed14ab92befcda2d668">is_initial_state</a> (const <a class="el" href="classspot_1_1state.html">spot::state</a> *s) const </td></tr>
<tr class="memdesc:a1d914fc0d7f5aed14ab92befcda2d668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <em>s</em> is an initial state, otherwise false.  <a href="#a1d914fc0d7f5aed14ab92befcda2d668"></a><br/></td></tr>
<tr class="memitem:a696a3fcfbe853754a3d6402a8ec16f56"><td class="memItemLeft" align="right" valign="top">virtual bdd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__explicit.html#a696a3fcfbe853754a3d6402a8ec16f56">get_state_condition</a> (const <a class="el" href="classspot_1_1state.html">spot::state</a> *s) const </td></tr>
<tr class="memdesc:a696a3fcfbe853754a3d6402a8ec16f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a BDD condition that represents the valuation of atomic propositions in the state <em>s</em>.  <a href="#a696a3fcfbe853754a3d6402a8ec16f56"></a><br/></td></tr>
<tr class="memitem:aa7879d15aae1adf6d25386d381f894f3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__explicit.html#aa7879d15aae1adf6d25386d381f894f3">free_state</a> (const <a class="el" href="classspot_1_1state.html">spot::state</a> *s) const </td></tr>
<tr class="memdesc:aa7879d15aae1adf6d25386d381f894f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a state <em>s</em>.  <a href="#aa7879d15aae1adf6d25386d381f894f3"></a><br/></td></tr>
<tr class="memitem:a7f13f19527ada113bb7748d6f79597f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1state.html">spot::state</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__explicit.html#a7f13f19527ada113bb7748d6f79597f0">get_artificial_initial_state</a> () const </td></tr>
<tr class="memdesc:a7f13f19527ada113bb7748d6f79597f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the artificial initial state set of the automaton. Return 0 if this artificial state is not implemented (in this case, use <code>get_initial_states_set</code>) The aim of adding this state is to have an unique initial state. This artificial initial state have one transition to each real initial state, and this transition is labeled by the corresponding initial condition. (For more details, see the paper cited above)  <a href="#a7f13f19527ada113bb7748d6f79597f0"></a><br/></td></tr>
<tr class="memitem:a2cddd9377c3ffe29e90f8471ac73b91f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__explicit.html#a2cddd9377c3ffe29e90f8471ac73b91f">set_artificial_initial_state</a> (<a class="el" href="classspot_1_1state__ta__explicit.html">state_ta_explicit</a> *s)</td></tr>
<tr class="memitem:a1411684a30a4a7ce1c39cdddc09afa70"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__explicit.html#a1411684a30a4a7ce1c39cdddc09afa70">delete_stuttering_and_hole_successors</a> (<a class="el" href="classspot_1_1state.html">spot::state</a> *s)</td></tr>
<tr class="memitem:ab88290e5a002f7c5d9ea3e2cb67a8738"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1ta.html#af1bc68c8c3cd3f18de560546ff624ea7">ta::states_set_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__explicit.html#ab88290e5a002f7c5d9ea3e2cb67a8738">get_states_set</a> ()</td></tr>
<tr class="memitem:a0a4f238c1876d503352f15e80940721c"><td class="memItemLeft" align="right" valign="top">bdd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__explicit.html#a0a4f238c1876d503352f15e80940721c">all_acceptance_conditions</a> () const </td></tr>
<tr class="memdesc:a0a4f238c1876d503352f15e80940721c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the set of all acceptance conditions used by this automaton.  <a href="#a0a4f238c1876d503352f15e80940721c"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a70646483e6848665b68b4e22e92c6c79"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__explicit.html#a70646483e6848665b68b4e22e92c6c79">ta_explicit</a> (const <a class="el" href="classspot_1_1ta__explicit.html">ta_explicit</a> &amp;other)</td></tr>
<tr class="memitem:a164a5f9c79a0e8b16aae297442233947"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1ta__explicit.html">ta_explicit</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__explicit.html#a164a5f9c79a0e8b16aae297442233947">operator=</a> (const <a class="el" href="classspot_1_1ta__explicit.html">ta_explicit</a> &amp;other)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aa950f9c3015473c975a8afcc41b5d6a0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1tgba.html">tgba</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__explicit.html#aa950f9c3015473c975a8afcc41b5d6a0">tgba_</a></td></tr>
<tr class="memitem:ada4df287a5547e14a185387acd9cc083"><td class="memItemLeft" align="right" valign="top">bdd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__explicit.html#ada4df287a5547e14a185387acd9cc083">all_acceptance_conditions_</a></td></tr>
<tr class="memitem:aa47c1b8e44854afe5fd2dedbf365d724"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1state__ta__explicit.html">state_ta_explicit</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__explicit.html#aa47c1b8e44854afe5fd2dedbf365d724">artificial_initial_state_</a></td></tr>
<tr class="memitem:a87df9c3659ae73dcbd60ec43a7f7cd75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1ta.html#af1bc68c8c3cd3f18de560546ff624ea7">ta::states_set_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__explicit.html#a87df9c3659ae73dcbd60ec43a7f7cd75">states_set_</a></td></tr>
<tr class="memitem:ad735dfe30ccb0d8b0a735349f383bfcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1ta.html#af1bc68c8c3cd3f18de560546ff624ea7">ta::states_set_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__explicit.html#ad735dfe30ccb0d8b0a735349f383bfcc">initial_states_set_</a></td></tr>
<tr class="memitem:a2d63de8cfac477c9676845c98872feb3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta__explicit.html#a2d63de8cfac477c9676845c98872feb3">own_tgba_</a></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Explicit representation of a <a class="el" href="classspot_1_1ta.html" title="A Testing Automaton.The Testing Automata (TA) were introduced by Henri Hansen, Wojciech Penczek and A...">spot::ta</a>. </p>
</div><h2>Member Typedef Documentation</h2>
<a class="anchor" id="af1bc68c8c3cd3f18de560546ff624ea7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt;<a class="el" href="classspot_1_1state.html">state</a>*, <a class="el" href="structspot_1_1state__ptr__less__than.html">state_ptr_less_than</a>&gt; <a class="el" href="classspot_1_1ta.html#af1bc68c8c3cd3f18de560546ff624ea7">spot::ta::states_set_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a13f7c7b73d900f0cae107bf38ecdf443"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spot::ta_explicit::ta_explicit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspot_1_1tgba.html">tgba</a> *&#160;</td>
          <td class="paramname"><em>tgba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>all_acceptance_conditions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classspot_1_1state__ta__explicit.html">state_ta_explicit</a> *&#160;</td>
          <td class="paramname"><em>artificial_initial_state</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>own_tgba</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0505e3e48870a6898efa701b3e452529"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual spot::ta_explicit::~ta_explicit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a70646483e6848665b68b4e22e92c6c79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">spot::ta_explicit::ta_explicit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspot_1_1ta__explicit.html">ta_explicit</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="a0da605a671217aeac5124d7b89bc6854"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspot_1_1state__ta__explicit.html">state_ta_explicit</a>* spot::ta_explicit::add_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classspot_1_1state__ta__explicit.html">state_ta_explicit</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3d52664f1353f4f9fb419f3be6d3bf01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spot::ta_explicit::add_to_initial_states_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classspot_1_1state.html">state</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>condition</em> = <code>bddfalse</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0a4f238c1876d503352f15e80940721c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bdd spot::ta_explicit::all_acceptance_conditions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the set of all acceptance conditions used by this automaton. </p>
<p>The goal of the emptiness check is to ensure that a strongly connected component walks through each of these acceptiong conditions. I.e., the union of the acceptiong conditions of all transition in the SCC should be equal to the result of this function. </p>

<p>Implements <a class="el" href="classspot_1_1ta.html#a06639adf20622dcafaa7a9a3e7f6417f">spot::ta</a>.</p>

<p>References <a class="el" href="classspot_1_1ta__explicit.html#ada4df287a5547e14a185387acd9cc083">all_acceptance_conditions_</a>.</p>

</div>
</div>
<a class="anchor" id="a1642257587084c97ce5d39da70d501a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spot::ta_explicit::create_transition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classspot_1_1state__ta__explicit.html">state_ta_explicit</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>acceptance_conditions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classspot_1_1state__ta__explicit.html">state_ta_explicit</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>add_at_beginning</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1411684a30a4a7ce1c39cdddc09afa70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void spot::ta_explicit::delete_stuttering_and_hole_successors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classspot_1_1state.html">spot::state</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0302fe9864a2de9b3589e4789830e158"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spot::ta_explicit::delete_stuttering_transitions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a75d9f86c25fd4a7cd6ababa7467846d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string spot::ta_explicit::format_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspot_1_1state.html">spot::state</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Format the state as a string for printing. </p>
<p>This formating is the responsability of the automata that owns the state. </p>

<p>Implements <a class="el" href="classspot_1_1ta.html#a075f7fdb44428659a16484170477e77e">spot::ta</a>.</p>

</div>
</div>
<a class="anchor" id="aa7879d15aae1adf6d25386d381f894f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void spot::ta_explicit::free_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspot_1_1state.html">spot::state</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release a state <em>s</em>. </p>

<p>Implements <a class="el" href="classspot_1_1ta.html#a83fe8227b08e5d5ae575fddec620d85c">spot::ta</a>.</p>

</div>
</div>
<a class="anchor" id="a7f13f19527ada113bb7748d6f79597f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspot_1_1state.html">spot::state</a>* spot::ta_explicit::get_artificial_initial_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the artificial initial state set of the automaton. Return 0 if this artificial state is not implemented (in this case, use <code>get_initial_states_set</code>) The aim of adding this state is to have an unique initial state. This artificial initial state have one transition to each real initial state, and this transition is labeled by the corresponding initial condition. (For more details, see the paper cited above) </p>

<p>Reimplemented from <a class="el" href="classspot_1_1ta.html#a5cbd41f6c0e19af83d55816a5fbb2321">spot::ta</a>.</p>

<p>References <a class="el" href="classspot_1_1ta__explicit.html#aa47c1b8e44854afe5fd2dedbf365d724">artificial_initial_state_</a>.</p>

</div>
</div>
<a class="anchor" id="a2d9f1b65d258892c253750376a758213"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a>* spot::ta_explicit::get_dict </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dictionary associated to the automaton. </p>
<p>State are represented as BDDs. The dictionary allows to map BDD variables back to formulae, and vice versa. This is useful when dealing with several automata (which may use the same BDD variable for different formula), or simply when printing. </p>

<p>Implements <a class="el" href="classspot_1_1ta.html#a5b1cf7537d0702b2acc136578895d926">spot::ta</a>.</p>

</div>
</div>
<a class="anchor" id="a829c195d324bf9fd80cabdb883f1beb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classspot_1_1ta.html#af1bc68c8c3cd3f18de560546ff624ea7">states_set_t</a> spot::ta_explicit::get_initial_states_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the initial states set of the automaton. </p>

<p>Implements <a class="el" href="classspot_1_1ta.html#ae847e1d2f986db3bbc7a0d7535155677">spot::ta</a>.</p>

</div>
</div>
<a class="anchor" id="a696a3fcfbe853754a3d6402a8ec16f56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bdd spot::ta_explicit::get_state_condition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspot_1_1state.html">spot::state</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a BDD condition that represents the valuation of atomic propositions in the state <em>s</em>. </p>

<p>Implements <a class="el" href="classspot_1_1ta.html#a807b62b44071746902e7d5e76b7fefad">spot::ta</a>.</p>

</div>
</div>
<a class="anchor" id="ab88290e5a002f7c5d9ea3e2cb67a8738"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspot_1_1ta.html#af1bc68c8c3cd3f18de560546ff624ea7">ta::states_set_t</a> spot::ta_explicit::get_states_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classspot_1_1ta__explicit.html#a87df9c3659ae73dcbd60ec43a7f7cd75">states_set_</a>.</p>

</div>
</div>
<a class="anchor" id="a63460eac2315781aefcacc8707d2f65a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1tgba.html">tgba</a>* spot::ta_explicit::get_tgba </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a908627a9e60708a3c1f5a63f641ff5da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool spot::ta_explicit::is_accepting_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspot_1_1state.html">spot::state</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if <em>s</em> is a Buchi-accepting state, otherwise false. </p>

<p>Implements <a class="el" href="classspot_1_1ta.html#a05398307c3e98a177f7f182b2becb6ee">spot::ta</a>.</p>

</div>
</div>
<a class="anchor" id="a1d914fc0d7f5aed14ab92befcda2d668"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool spot::ta_explicit::is_initial_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspot_1_1state.html">spot::state</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if <em>s</em> is an initial state, otherwise false. </p>

<p>Implements <a class="el" href="classspot_1_1ta.html#a9291b601b2c32aa38c04feeb5f48a703">spot::ta</a>.</p>

</div>
</div>
<a class="anchor" id="a6de8fc9f373578cbc436af5f1d58fa97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool spot::ta_explicit::is_livelock_accepting_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspot_1_1state.html">spot::state</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if <em>s</em> is a livelock-accepting state , otherwise false. </p>

<p>Implements <a class="el" href="classspot_1_1ta.html#a5e2b5e5f1ad31adbc157571d88007b01">spot::ta</a>.</p>

</div>
</div>
<a class="anchor" id="a164a5f9c79a0e8b16aae297442233947"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspot_1_1ta__explicit.html">ta_explicit</a>&amp; spot::ta_explicit::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspot_1_1ta__explicit.html">ta_explicit</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2cddd9377c3ffe29e90f8471ac73b91f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void spot::ta_explicit::set_artificial_initial_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classspot_1_1state__ta__explicit.html">state_ta_explicit</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classspot_1_1ta__explicit.html#aa47c1b8e44854afe5fd2dedbf365d724">artificial_initial_state_</a>.</p>

</div>
</div>
<a class="anchor" id="a56ff22eacfb314076c3795e29c51bd45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classspot_1_1ta__succ__iterator.html">ta_succ_iterator</a>* spot::ta_explicit::succ_iter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspot_1_1state.html">spot::state</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator over the successors of <em>state</em>. </p>
<p>The iterator has been allocated with <code>new</code>. It is the responsability of the caller to <code>delete</code> it when no longer needed. </p>

<p>Implements <a class="el" href="classspot_1_1ta.html#af0b2f71c85c0dd17b850197537a383bc">spot::ta</a>.</p>

</div>
</div>
<a class="anchor" id="ae63d26c7687ae408133aeb95c793a4d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classspot_1_1ta__succ__iterator.html">ta_succ_iterator</a>* spot::ta_explicit::succ_iter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspot_1_1state.html">spot::state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>changeset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator over the successors of <em>state</em> filtred by the changeset on transitions. </p>
<p>The iterator has been allocated with <code>new</code>. It is the responsability of the caller to <code>delete</code> it when no longer needed. </p>

<p>Implements <a class="el" href="classspot_1_1ta.html#af9ebc32d6cc33044f538c25b07eb09bd">spot::ta</a>.</p>

</div>
</div>
<h2>Member Data Documentation</h2>
<a class="anchor" id="ada4df287a5547e14a185387acd9cc083"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bdd spot::ta_explicit::all_acceptance_conditions_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classspot_1_1ta__explicit.html#a0a4f238c1876d503352f15e80940721c">all_acceptance_conditions()</a>.</p>

</div>
</div>
<a class="anchor" id="aa47c1b8e44854afe5fd2dedbf365d724"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspot_1_1state__ta__explicit.html">state_ta_explicit</a>* spot::ta_explicit::artificial_initial_state_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classspot_1_1ta__explicit.html#a7f13f19527ada113bb7748d6f79597f0">get_artificial_initial_state()</a>, and <a class="el" href="classspot_1_1ta__explicit.html#a2cddd9377c3ffe29e90f8471ac73b91f">set_artificial_initial_state()</a>.</p>

</div>
</div>
<a class="anchor" id="ad735dfe30ccb0d8b0a735349f383bfcc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspot_1_1ta.html#af1bc68c8c3cd3f18de560546ff624ea7">ta::states_set_t</a> spot::ta_explicit::initial_states_set_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2d63de8cfac477c9676845c98872feb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool spot::ta_explicit::own_tgba_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a87df9c3659ae73dcbd60ec43a7f7cd75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspot_1_1ta.html#af1bc68c8c3cd3f18de560546ff624ea7">ta::states_set_t</a> spot::ta_explicit::states_set_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classspot_1_1ta__explicit.html#ab88290e5a002f7c5d9ea3e2cb67a8738">get_states_set()</a>.</p>

</div>
</div>
<a class="anchor" id="aa950f9c3015473c975a8afcc41b5d6a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1tgba.html">tgba</a>* spot::ta_explicit::tgba_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ta/<a class="el" href="taexplicit_8hh_source.html">taexplicit.hh</a></li>
</ul>
</div><!-- contents -->
<hr size="1">
Please <b>comment</b> this page and <b>report errors</b> about it on
<a href="http://spot.lip6.fr/wiki/RefDocComments">the RefDocComments page</a>.
<br><address style="align: right;"><small>
Generated on Sat Oct 27 2012 09:34:33 for spot by <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border=0></a> 1.8.1.2</small></address>
</body>
</html>
