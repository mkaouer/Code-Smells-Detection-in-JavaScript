<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>spot: spot::ltl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">spot
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacespot.html">spot</a></li><li class="navelem"><a class="el" href="namespacespot_1_1ltl.html">ltl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">spot::ltl Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacespot_1_1ltl_1_1formula__tree"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl_1_1formula__tree.html">formula_tree</a></td></tr>
<tr class="memdesc:namespacespot_1_1ltl_1_1formula__tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trees representing formulae where atomic propositions are unknown. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1atomic__prop.html">atomic_prop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic propositions.  <a href="classspot_1_1ltl_1_1atomic__prop.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1automatop.html">automatop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automaton operators.  <a href="classspot_1_1ltl_1_1automatop.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1binop.html">binop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary operator.  <a href="classspot_1_1ltl_1_1binop.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1bunop.html">bunop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded unary operator.  <a href="classspot_1_1ltl_1_1bunop.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1constant.html">constant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant (True or False)  <a href="classspot_1_1ltl_1_1constant.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An LTL formula.The only way you can work with a formula is to build a <a class="el" href="structspot_1_1ltl_1_1visitor.html" title="Formula visitorImplementing visitors is the prefered way to traverse a formula, since it does not inv...">spot::ltl::visitor</a> or spot::ltl::const_visitor.  <a href="classspot_1_1ltl_1_1formula.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1ltl_1_1formula__ptr__less__than.html">formula_ptr_less_than</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strict Weak Ordering for <code>const formula*</code>.This is meant to be used as a comparison functor for STL <code>map</code> whose key are of type <code>const formula*</code>.  <a href="structspot_1_1ltl_1_1formula__ptr__less__than.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1ltl_1_1formula__ptr__hash.html">formula_ptr_hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash Function for <code>const formula*</code>.This is meant to be used as a hash functor for Sgi's <code>hash_map</code> whose key are of type <code>const formula*</code>.  <a href="structspot_1_1ltl_1_1formula__ptr__hash.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1multop.html">multop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-operand operators.  <a href="classspot_1_1ltl_1_1multop.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1nfa.html">nfa</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nondeterministic Finite Automata used by automata operators.  <a href="classspot_1_1ltl_1_1nfa.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1succ__iterator.html">succ_iterator</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1ref__formula.html">ref_formula</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted LTL formula.  <a href="classspot_1_1ltl_1_1ref__formula.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1unop.html">unop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary operators.  <a href="classspot_1_1ltl_1_1unop.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1ltl_1_1visitor.html">visitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formula visitorImplementing visitors is the prefered way to traverse a formula, since it does not involve any cast.  <a href="structspot_1_1ltl_1_1visitor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1declarative__environment.html">declarative_environment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A declarative environment.This environment recognizes all atomic propositions that have been previously declared. It will reject other.  <a href="classspot_1_1ltl_1_1declarative__environment.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1default__environment.html">default_environment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A laxist environment.This environment recognizes all atomic propositions.  <a href="classspot_1_1ltl_1_1default__environment.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1environment.html">environment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An environment that describes atomic propositions.  <a href="classspot_1_1ltl_1_1environment.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1ltl__file.html">ltl_file</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read LTL formulae from a file, one by one.  <a href="classspot_1_1ltl_1_1ltl__file.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1clone__visitor.html">clone_visitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone a formula.This visitor is public, because it's convenient to derive from it and override part of its methods. But if you just want the functionality, consider using <a class="el" href="classspot_1_1ltl_1_1formula.html#a22895a0683e2947dd56bd661cb372581" title="clone this node">spot::ltl::formula::clone</a> instead, it is way faster.  <a href="classspot_1_1ltl_1_1clone__visitor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1language__containment__checker.html">language_containment_checker</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1unabbreviate__logic__visitor.html">unabbreviate_logic_visitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone and rewrite a formula to remove most of the abbreviated logical operators.This will rewrite binary operators such as <a class="el" href="classspot_1_1ltl_1_1binop.html#a7c5967c6908151a90ff72f210bfb59a2ac5d2a034f0dd62b98fe785d0372c0c9a">binop::Implies</a>, binop::Equals, and <a class="el" href="classspot_1_1ltl_1_1binop.html#a7c5967c6908151a90ff72f210bfb59a2a71177fc6c4bfbc11a0fd7acceeed1ed5">binop::Xor</a>, using only <a class="el" href="classspot_1_1ltl_1_1unop.html#ab6cd495a942b8c203f547cccb50916bca5c70279f9221ae04c99dfcfb1d8cce21">unop::Not</a>, <a class="el" href="classspot_1_1ltl_1_1multop.html#a7ff9fb342ce923eed135a23285d686feaec9dacb72caa01e417f04a398770b16f">multop::Or</a>, and <a class="el" href="classspot_1_1ltl_1_1multop.html#a7ff9fb342ce923eed135a23285d686fea134bbaa37c9a0db99c61af1f61b7f037">multop::And</a>.  <a href="classspot_1_1ltl_1_1unabbreviate__logic__visitor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1mark__tools.html">mark_tools</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1postfix__visitor.html">postfix_visitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply an algorithm on each node of an AST, during a postfix traversal.Override one or more of the postifix_visitor::doit methods with the algorithm to apply.  <a href="classspot_1_1ltl_1_1postfix__visitor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1random__formula.html">random_formula</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for random formula generators.  <a href="classspot_1_1ltl_1_1random__formula.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1random__ltl.html">random_ltl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate random LTL formulae.This class recursively constructs LTL formulae of a given size. The formulae will use the use atomic propositions from the set of propositions passed to the constructor, in addition to the constant and all LTL operators supported by Spot.  <a href="classspot_1_1ltl_1_1random__ltl.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1random__boolean.html">random_boolean</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate random Boolean formulae.This class recursively constructs Boolean formulae of a given size. The formulae will use the use atomic propositions from the set of propositions passed to the constructor, in addition to the constant and all Boolean operators supported by Spot.  <a href="classspot_1_1ltl_1_1random__boolean.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1random__sere.html">random_sere</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate random SERE.This class recursively constructs SERE of a given size. The formulae will use the use atomic propositions from the set of propositions passed to the constructor, in addition to the constant and all SERE operators supported by Spot.  <a href="classspot_1_1ltl_1_1random__sere.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1random__psl.html">random_psl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate random PSL formulae.This class recursively constructs PSL formulae of a given size. The formulae will use the use atomic propositions from the set of propositions passed to the constructor, in addition to the constant and all PSL operators supported by Spot.  <a href="classspot_1_1ltl_1_1random__psl.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1simplify__f__g__visitor.html">simplify_f_g_visitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace <code>true U f</code> and <code>false R g</code> by <code>F f</code> and <code>G g</code>.  <a href="classspot_1_1ltl_1_1simplify__f__g__visitor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1ltl__simplifier__options.html">ltl_simplifier_options</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1ltl__simplifier.html">ltl_simplifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite or simplify <em>f</em> in various ways.  <a href="classspot_1_1ltl_1_1ltl__simplifier.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1unabbreviate__ltl__visitor.html">unabbreviate_ltl_visitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone and rewrite a formula to remove most of the abbreviated LTL and logical operators.The rewriting performed on logical operator is the same as the one done by <a class="el" href="classspot_1_1ltl_1_1unabbreviate__logic__visitor.html" title="Clone and rewrite a formula to remove most of the abbreviated logical operators.This will rewrite bin...">spot::ltl::unabbreviate_logic_visitor</a>.  <a href="classspot_1_1ltl_1_1unabbreviate__ltl__visitor.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga9bf19c38b4ae7d74e6a9633ed360c147"><td class="memItemLeft" align="right" valign="top">typedef std::pair<br class="typebreak"/>
&lt; <a class="el" href="classltlyy_1_1location.html">ltlyy::location</a>, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga9bf19c38b4ae7d74e6a9633ed360c147">parse_error</a></td></tr>
<tr class="memdesc:ga9bf19c38b4ae7d74e6a9633ed360c147"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parse diagnostic with its location.  <a href="group__ltl__io.html#ga9bf19c38b4ae7d74e6a9633ed360c147"></a><br/></td></tr>
<tr class="memitem:ga9eb0f7867a212f92b0fd64a6ac5a12cd"><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; <a class="el" href="group__ltl__io.html#ga9bf19c38b4ae7d74e6a9633ed360c147">parse_error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga9eb0f7867a212f92b0fd64a6ac5a12cd">parse_error_list</a></td></tr>
<tr class="memdesc:ga9eb0f7867a212f92b0fd64a6ac5a12cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of parser diagnostics, as filled by parse.  <a href="group__ltl__io.html#ga9eb0f7867a212f92b0fd64a6ac5a12cd"></a><br/></td></tr>
<tr class="memitem:ga8347f76c4cd9c56970ba55c8fb40ab1a"><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; const <br class="typebreak"/>
<a class="el" href="classspot_1_1ltl_1_1atomic__prop.html">atomic_prop</a> <br class="typebreak"/>
*, <a class="el" href="structspot_1_1ltl_1_1formula__ptr__less__than.html">formula_ptr_less_than</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__misc.html#ga8347f76c4cd9c56970ba55c8fb40ab1a">atomic_prop_set</a></td></tr>
<tr class="memdesc:ga8347f76c4cd9c56970ba55c8fb40ab1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of atomic propositions.  <a href="group__ltl__misc.html#ga8347f76c4cd9c56970ba55c8fb40ab1a"></a><br/></td></tr>
<tr class="memitem:acb41ffa774442ee155cc23a60c0a78a4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="hash_8hh.html#ad06cc371f5697a73eab4c293546b4dba">Sgi::hash_map</a>&lt; const <br class="typebreak"/>
<a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *, const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> <br class="typebreak"/>
*, <a class="el" href="structspot_1_1ptr__hash.html">ptr_hash</a>&lt; <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#acb41ffa774442ee155cc23a60c0a78a4">snf_cache</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gac9e66395d0e9cb870fa7b1ca208b70ca"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__rewriting.html#gac9e66395d0e9cb870fa7b1ca208b70ca">reduce_options</a> { <br/>
&#160;&#160;<a class="el" href="group__ltl__rewriting.html#ggac9e66395d0e9cb870fa7b1ca208b70caabff3607cc02f12d6756d0244a8f5464a">Reduce_None</a> =  0, 
<a class="el" href="group__ltl__rewriting.html#ggac9e66395d0e9cb870fa7b1ca208b70caab83ef042ab620af2f258a817e95f8f80">Reduce_Basics</a> =  1, 
<a class="el" href="group__ltl__rewriting.html#ggac9e66395d0e9cb870fa7b1ca208b70caa22d75bbadb5b030981574ae49668ad94">Reduce_Syntactic_Implications</a> =  2, 
<a class="el" href="group__ltl__rewriting.html#ggac9e66395d0e9cb870fa7b1ca208b70caaabb627af73b5817a542506be482f396d">Reduce_Eventuality_And_Universality</a> =  4, 
<br/>
&#160;&#160;<a class="el" href="group__ltl__rewriting.html#ggac9e66395d0e9cb870fa7b1ca208b70caa22286d57705e7511f13a75c05ac0a39f">Reduce_Containment_Checks</a> =  8, 
<a class="el" href="group__ltl__rewriting.html#ggac9e66395d0e9cb870fa7b1ca208b70caa0721d15d048b11cfe234f14850dbc9c5">Reduce_Containment_Checks_Stronger</a> =  16, 
<a class="el" href="group__ltl__rewriting.html#ggac9e66395d0e9cb870fa7b1ca208b70caa1629bc689540d42e2f86eea77a6cd275">Reduce_All</a> =  -1U
<br/>
 }</td></tr>
<tr class="memdesc:gac9e66395d0e9cb870fa7b1ca208b70ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for <a class="el" href="group__ltl__rewriting.html#ga75beb5d36830e9a795e96a3a64f032c1" title="Reduce a formula f.">spot::ltl::reduce</a>.  <a href="group__ltl__rewriting.html#gac9e66395d0e9cb870fa7b1ca208b70ca">More...</a><br/></td></tr>
<tr class="memitem:ab49c69f44a36589af8e9d1539d5e4c13"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#ab49c69f44a36589af8e9d1539d5e4c13">relabeling_style</a> { <a class="el" href="namespacespot_1_1ltl.html#ab49c69f44a36589af8e9d1539d5e4c13a5611119d586b70ace29dbf1c4678e6fd">Abc</a>, 
<a class="el" href="namespacespot_1_1ltl.html#ab49c69f44a36589af8e9d1539d5e4c13a92ec2e5d601c09c57173015e51b675cd">Pnn</a>
 }</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6ebb15622f493a6e9d8fe698c4d3af9e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1atomic__prop.html">atomic_prop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#a6ebb15622f493a6e9d8fe698c4d3af9e">is_atomic_prop</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memitem:aec170dbcfc4ed607f2e2c3fb8cb2264e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1binop.html">binop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#aec170dbcfc4ed607f2e2c3fb8cb2264e">is_binop</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:aec170dbcfc4ed607f2e2c3fb8cb2264e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <em>f</em> into a binop.  <a href="#aec170dbcfc4ed607f2e2c3fb8cb2264e"></a><br/></td></tr>
<tr class="memitem:afe008683046960e5c1be4aa9da7e7116"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1binop.html">binop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#afe008683046960e5c1be4aa9da7e7116">is_binop</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f, <a class="el" href="classspot_1_1ltl_1_1binop.html#a7c5967c6908151a90ff72f210bfb59a2">binop::type</a> op)</td></tr>
<tr class="memdesc:afe008683046960e5c1be4aa9da7e7116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <em>f</em> into a binop if it has type <em>op</em>.  <a href="#afe008683046960e5c1be4aa9da7e7116"></a><br/></td></tr>
<tr class="memitem:adeb0b3c086e4840b15469fc7c5ba8ffb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1binop.html">binop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#adeb0b3c086e4840b15469fc7c5ba8ffb">is_binop</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f, <a class="el" href="classspot_1_1ltl_1_1binop.html#a7c5967c6908151a90ff72f210bfb59a2">binop::type</a> op1, <a class="el" href="classspot_1_1ltl_1_1binop.html#a7c5967c6908151a90ff72f210bfb59a2">binop::type</a> op2)</td></tr>
<tr class="memdesc:adeb0b3c086e4840b15469fc7c5ba8ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <em>f</em> into a binop if it has type <em>op1</em> or <em>op2</em>.  <a href="#adeb0b3c086e4840b15469fc7c5ba8ffb"></a><br/></td></tr>
<tr class="memitem:a7f69b252a63c598fb4a8a1cd3a43b54a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1binop.html">binop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#a7f69b252a63c598fb4a8a1cd3a43b54a">is_U</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:a7f69b252a63c598fb4a8a1cd3a43b54a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <em>f</em> into a binop if it is a U.  <a href="#a7f69b252a63c598fb4a8a1cd3a43b54a"></a><br/></td></tr>
<tr class="memitem:af2c3a3b78c2394cb420377732df53643"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1binop.html">binop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#af2c3a3b78c2394cb420377732df53643">is_M</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:af2c3a3b78c2394cb420377732df53643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <em>f</em> into a binop if it is a M.  <a href="#af2c3a3b78c2394cb420377732df53643"></a><br/></td></tr>
<tr class="memitem:a29e64397d9e57f5ef8d91cff0794d430"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1binop.html">binop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#a29e64397d9e57f5ef8d91cff0794d430">is_R</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:a29e64397d9e57f5ef8d91cff0794d430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <em>f</em> into a binop if it is a R.  <a href="#a29e64397d9e57f5ef8d91cff0794d430"></a><br/></td></tr>
<tr class="memitem:a99c281102d5b23a2d24079cf66c8facd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1binop.html">binop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#a99c281102d5b23a2d24079cf66c8facd">is_W</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:a99c281102d5b23a2d24079cf66c8facd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <em>f</em> into a binop if it is a W.  <a href="#a99c281102d5b23a2d24079cf66c8facd"></a><br/></td></tr>
<tr class="memitem:a87876bf8eb00438107b391a6db369146"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1bunop.html">bunop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#a87876bf8eb00438107b391a6db369146">is_bunop</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:a87876bf8eb00438107b391a6db369146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <em>f</em> into a bunop.  <a href="#a87876bf8eb00438107b391a6db369146"></a><br/></td></tr>
<tr class="memitem:add6ce0b867fb1a665da9a97fc622367e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1bunop.html">bunop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#add6ce0b867fb1a665da9a97fc622367e">is_bunop</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f, <a class="el" href="classspot_1_1ltl_1_1bunop.html#a752881b5f4c82ab3d4172af81308f6d7">bunop::type</a> op)</td></tr>
<tr class="memdesc:add6ce0b867fb1a665da9a97fc622367e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <em>f</em> into a bunop if it has type <em>op</em>.  <a href="#add6ce0b867fb1a665da9a97fc622367e"></a><br/></td></tr>
<tr class="memitem:a28aede25875d04c53587f8ddaec2e033"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1bunop.html">bunop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#a28aede25875d04c53587f8ddaec2e033">is_Star</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:a28aede25875d04c53587f8ddaec2e033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <em>f</em> into a bunop if it is a Star.  <a href="#a28aede25875d04c53587f8ddaec2e033"></a><br/></td></tr>
<tr class="memitem:a51d0620bc2a141cf443a7dc73f9d7237"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1bunop.html">bunop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#a51d0620bc2a141cf443a7dc73f9d7237">is_KleenStar</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:a51d0620bc2a141cf443a7dc73f9d7237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <em>f</em> into a bunop if it is a Star[0..].  <a href="#a51d0620bc2a141cf443a7dc73f9d7237"></a><br/></td></tr>
<tr class="memitem:a3ef6c967bc0d99bc8eab1c81d7a7eab1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1constant.html">constant</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#a3ef6c967bc0d99bc8eab1c81d7a7eab1">is_constant</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:a3ef6c967bc0d99bc8eab1c81d7a7eab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <em>f</em> into a constant.  <a href="#a3ef6c967bc0d99bc8eab1c81d7a7eab1"></a><br/></td></tr>
<tr class="memitem:a5ebe7a0005ae56f57d6e085eddb453e1"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#a5ebe7a0005ae56f57d6e085eddb453e1">print_formula_props</a> (std::ostream &amp;out, const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f, bool abbreviated=false)</td></tr>
<tr class="memdesc:a5ebe7a0005ae56f57d6e085eddb453e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the properties of formula <em>f</em> on stream <em>out</em>.  <a href="#a5ebe7a0005ae56f57d6e085eddb453e1"></a><br/></td></tr>
<tr class="memitem:a53b023ef17f12698ac0721875482a394"><td class="memItemLeft" align="right" valign="top">std::list&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#a53b023ef17f12698ac0721875482a394">list_formula_props</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:a53b023ef17f12698ac0721875482a394"><td class="mdescLeft">&#160;</td><td class="mdescRight">List the properties of formula <em>f</em>.  <a href="#a53b023ef17f12698ac0721875482a394"></a><br/></td></tr>
<tr class="memitem:acf7f6187f2e0beb266738615ee380e5a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1multop.html">multop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#acf7f6187f2e0beb266738615ee380e5a">is_multop</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:acf7f6187f2e0beb266738615ee380e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <em>f</em> into a multop.  <a href="#acf7f6187f2e0beb266738615ee380e5a"></a><br/></td></tr>
<tr class="memitem:a72cf9d5651a25c79009864a5bb93deff"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1multop.html">multop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#a72cf9d5651a25c79009864a5bb93deff">is_multop</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f, <a class="el" href="classspot_1_1ltl_1_1multop.html#a7ff9fb342ce923eed135a23285d686fe">multop::type</a> op)</td></tr>
<tr class="memdesc:a72cf9d5651a25c79009864a5bb93deff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <em>f</em> into a multop if it has type <em>op</em>.  <a href="#a72cf9d5651a25c79009864a5bb93deff"></a><br/></td></tr>
<tr class="memitem:aa7830e6d2f0f4684e769df785ef8c9d8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1multop.html">multop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#aa7830e6d2f0f4684e769df785ef8c9d8">is_multop</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f, <a class="el" href="classspot_1_1ltl_1_1multop.html#a7ff9fb342ce923eed135a23285d686fe">multop::type</a> op1, <a class="el" href="classspot_1_1ltl_1_1multop.html#a7ff9fb342ce923eed135a23285d686fe">multop::type</a> op2)</td></tr>
<tr class="memdesc:aa7830e6d2f0f4684e769df785ef8c9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <em>f</em> into a multop if it has type <em>op1</em> or <em>op2</em>.  <a href="#aa7830e6d2f0f4684e769df785ef8c9d8"></a><br/></td></tr>
<tr class="memitem:aa208803abec5d0085c1f635909f44cdb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1multop.html">multop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#aa208803abec5d0085c1f635909f44cdb">is_And</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:aa208803abec5d0085c1f635909f44cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <em>f</em> into a multop if it is an And.  <a href="#aa208803abec5d0085c1f635909f44cdb"></a><br/></td></tr>
<tr class="memitem:a89dd541d50e9f0882cf9a879e3d0e2cc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1multop.html">multop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#a89dd541d50e9f0882cf9a879e3d0e2cc">is_AndRat</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:a89dd541d50e9f0882cf9a879e3d0e2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <em>f</em> into a multop if it is an AndRat.  <a href="#a89dd541d50e9f0882cf9a879e3d0e2cc"></a><br/></td></tr>
<tr class="memitem:a20f7e738f8c27a3d296b519b8c8e3796"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1multop.html">multop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#a20f7e738f8c27a3d296b519b8c8e3796">is_AndNLM</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:a20f7e738f8c27a3d296b519b8c8e3796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <em>f</em> into a multop if it is an AndNLM.  <a href="#a20f7e738f8c27a3d296b519b8c8e3796"></a><br/></td></tr>
<tr class="memitem:a0ffb29ec0246eedf10abe95544bacfc5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1multop.html">multop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#a0ffb29ec0246eedf10abe95544bacfc5">is_Or</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:a0ffb29ec0246eedf10abe95544bacfc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <em>f</em> into a multop if it is an Or.  <a href="#a0ffb29ec0246eedf10abe95544bacfc5"></a><br/></td></tr>
<tr class="memitem:a684d629d37b85ad8b66f32cb29e1c1e6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1multop.html">multop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#a684d629d37b85ad8b66f32cb29e1c1e6">is_OrRat</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:a684d629d37b85ad8b66f32cb29e1c1e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <em>f</em> into a multop if it is an OrRat.  <a href="#a684d629d37b85ad8b66f32cb29e1c1e6"></a><br/></td></tr>
<tr class="memitem:a7db8010a9f32fbca50cd9075e2ba8473"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1multop.html">multop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#a7db8010a9f32fbca50cd9075e2ba8473">is_Concat</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:a7db8010a9f32fbca50cd9075e2ba8473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <em>f</em> into a multop if it is a Concat.  <a href="#a7db8010a9f32fbca50cd9075e2ba8473"></a><br/></td></tr>
<tr class="memitem:a67a179752351bf2d4e1e6df19013413a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1multop.html">multop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#a67a179752351bf2d4e1e6df19013413a">is_Fusion</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:a67a179752351bf2d4e1e6df19013413a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <em>f</em> into a multop if it is a Fusion.  <a href="#a67a179752351bf2d4e1e6df19013413a"></a><br/></td></tr>
<tr class="memitem:ab5ba210cfb0a509be848ca2f9ea1d755"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1unop.html">unop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#ab5ba210cfb0a509be848ca2f9ea1d755">is_unop</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:ab5ba210cfb0a509be848ca2f9ea1d755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <em>f</em> into a unop.  <a href="#ab5ba210cfb0a509be848ca2f9ea1d755"></a><br/></td></tr>
<tr class="memitem:abc75bf92dfd70c0a414db946cc05d469"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1unop.html">unop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#abc75bf92dfd70c0a414db946cc05d469">is_unop</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f, <a class="el" href="classspot_1_1ltl_1_1unop.html#ab6cd495a942b8c203f547cccb50916bc">unop::type</a> op)</td></tr>
<tr class="memdesc:abc75bf92dfd70c0a414db946cc05d469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <em>f</em> into a unop if it has type <em>op</em>.  <a href="#abc75bf92dfd70c0a414db946cc05d469"></a><br/></td></tr>
<tr class="memitem:a3ca8bd47d984aaf3d8a758a0ee0ff436"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1unop.html">unop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#a3ca8bd47d984aaf3d8a758a0ee0ff436">is_Not</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:a3ca8bd47d984aaf3d8a758a0ee0ff436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <em>f</em> into a unop if it is a Not.  <a href="#a3ca8bd47d984aaf3d8a758a0ee0ff436"></a><br/></td></tr>
<tr class="memitem:a599464ed25bf27b8a37b8a201bca64d1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1unop.html">unop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#a599464ed25bf27b8a37b8a201bca64d1">is_X</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:a599464ed25bf27b8a37b8a201bca64d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <em>f</em> into a unop if it is a X.  <a href="#a599464ed25bf27b8a37b8a201bca64d1"></a><br/></td></tr>
<tr class="memitem:aa08bd62932d13cfad5aacde4dded31b2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1unop.html">unop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#aa08bd62932d13cfad5aacde4dded31b2">is_F</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:aa08bd62932d13cfad5aacde4dded31b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <em>f</em> into a unop if it is a F.  <a href="#aa08bd62932d13cfad5aacde4dded31b2"></a><br/></td></tr>
<tr class="memitem:a10e49587fe0e60b0229eb08c372d98fc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1unop.html">unop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#a10e49587fe0e60b0229eb08c372d98fc">is_G</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:a10e49587fe0e60b0229eb08c372d98fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <em>f</em> into a unop if it is a G.  <a href="#a10e49587fe0e60b0229eb08c372d98fc"></a><br/></td></tr>
<tr class="memitem:a1d0cc2d86dc01d7bef528fcbfbf784a6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1unop.html">unop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#a1d0cc2d86dc01d7bef528fcbfbf784a6">is_GF</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:a1d0cc2d86dc01d7bef528fcbfbf784a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <em>f</em> into a unop if has the form GF(...).  <a href="#a1d0cc2d86dc01d7bef528fcbfbf784a6"></a><br/></td></tr>
<tr class="memitem:a08a5e79c0220c641b8bfe8a9252f2cbd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1unop.html">unop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#a08a5e79c0220c641b8bfe8a9252f2cbd">is_FG</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:a08a5e79c0220c641b8bfe8a9252f2cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <em>f</em> into a unop if has the form FG(...).  <a href="#a08a5e79c0220c641b8bfe8a9252f2cbd"></a><br/></td></tr>
<tr class="memitem:ga38985ad6b8ca53a130115aff8a055036"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga38985ad6b8ca53a130115aff8a055036">parse</a> (const std::string &amp;ltl_string, <a class="el" href="group__ltl__io.html#ga9eb0f7867a212f92b0fd64a6ac5a12cd">parse_error_list</a> &amp;error_list, <a class="el" href="classspot_1_1ltl_1_1environment.html">environment</a> &amp;env=<a class="el" href="classspot_1_1ltl_1_1default__environment.html#a6f82853f22c3bf57128a484a28a4d550">default_environment::instance</a>(), bool debug=false, bool lenient=false)</td></tr>
<tr class="memdesc:ga38985ad6b8ca53a130115aff8a055036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a formula from an LTL string.  <a href="group__ltl__io.html#ga38985ad6b8ca53a130115aff8a055036"></a><br/></td></tr>
<tr class="memitem:ga996c2f45174a66ee4ab85958900a1417"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga996c2f45174a66ee4ab85958900a1417">parse_boolean</a> (const std::string &amp;ltl_string, <a class="el" href="group__ltl__io.html#ga9eb0f7867a212f92b0fd64a6ac5a12cd">parse_error_list</a> &amp;error_list, <a class="el" href="classspot_1_1ltl_1_1environment.html">environment</a> &amp;env=<a class="el" href="classspot_1_1ltl_1_1default__environment.html#a6f82853f22c3bf57128a484a28a4d550">default_environment::instance</a>(), bool debug=false, bool lenient=false)</td></tr>
<tr class="memdesc:ga996c2f45174a66ee4ab85958900a1417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a Boolean formula from a string.  <a href="group__ltl__io.html#ga996c2f45174a66ee4ab85958900a1417"></a><br/></td></tr>
<tr class="memitem:ga127ae53eca0defd994401f3919e2a0d2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga127ae53eca0defd994401f3919e2a0d2">parse_lbt</a> (const std::string &amp;ltl_string, <a class="el" href="group__ltl__io.html#ga9eb0f7867a212f92b0fd64a6ac5a12cd">parse_error_list</a> &amp;error_list, <a class="el" href="classspot_1_1ltl_1_1environment.html">environment</a> &amp;env=<a class="el" href="classspot_1_1ltl_1_1default__environment.html#a6f82853f22c3bf57128a484a28a4d550">default_environment::instance</a>(), bool debug=false)</td></tr>
<tr class="memdesc:ga127ae53eca0defd994401f3919e2a0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a formula from an LTL string in LBT's format.  <a href="group__ltl__io.html#ga127ae53eca0defd994401f3919e2a0d2"></a><br/></td></tr>
<tr class="memitem:ga6a393a2f2a36d1f4aad872cb12ae76bf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga6a393a2f2a36d1f4aad872cb12ae76bf">parse_sere</a> (const std::string &amp;sere_string, <a class="el" href="group__ltl__io.html#ga9eb0f7867a212f92b0fd64a6ac5a12cd">parse_error_list</a> &amp;error_list, <a class="el" href="classspot_1_1ltl_1_1environment.html">environment</a> &amp;env=<a class="el" href="classspot_1_1ltl_1_1default__environment.html#a6f82853f22c3bf57128a484a28a4d550">default_environment::instance</a>(), bool debug=false, bool lenient=false)</td></tr>
<tr class="memdesc:ga6a393a2f2a36d1f4aad872cb12ae76bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a formula from a string representing a SERE.  <a href="group__ltl__io.html#ga6a393a2f2a36d1f4aad872cb12ae76bf"></a><br/></td></tr>
<tr class="memitem:ga5535f3e1304089c8c6e13f564920ce00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga5535f3e1304089c8c6e13f564920ce00">format_parse_errors</a> (std::ostream &amp;os, const std::string &amp;input_string, const <a class="el" href="group__ltl__io.html#ga9eb0f7867a212f92b0fd64a6ac5a12cd">parse_error_list</a> &amp;error_list)</td></tr>
<tr class="memdesc:ga5535f3e1304089c8c6e13f564920ce00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format diagnostics produced by <a class="el" href="group__ltl__io.html#ga38985ad6b8ca53a130115aff8a055036" title="Build a formula from an LTL string.">spot::ltl::parse</a> or spot::ltl::ratexp.  <a href="group__ltl__io.html#ga5535f3e1304089c8c6e13f564920ce00"></a><br/></td></tr>
<tr class="memitem:ga8fb520dd0b7b2ca3d828ea6cdfaf49b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga8fb520dd0b7b2ca3d828ea6cdfaf49b6">fix_utf8_locations</a> (const std::string &amp;ltl_string, <a class="el" href="group__ltl__io.html#ga9eb0f7867a212f92b0fd64a6ac5a12cd">parse_error_list</a> &amp;error_list)</td></tr>
<tr class="memdesc:ga8fb520dd0b7b2ca3d828ea6cdfaf49b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fix location of diagnostics assuming the input is utf8.  <a href="group__ltl__io.html#ga8fb520dd0b7b2ca3d828ea6cdfaf49b6"></a><br/></td></tr>
<tr class="memitem:ga335fb11ef18d07a729b03ee76719ead4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ltl__misc.html#ga8347f76c4cd9c56970ba55c8fb40ab1a">atomic_prop_set</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__misc.html#ga335fb11ef18d07a729b03ee76719ead4">atomic_prop_collect</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f, <a class="el" href="group__ltl__misc.html#ga8347f76c4cd9c56970ba55c8fb40ab1a">atomic_prop_set</a> *s=0)</td></tr>
<tr class="memdesc:ga335fb11ef18d07a729b03ee76719ead4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the set of atomic propositions occurring in a formula.  <a href="group__ltl__misc.html#ga335fb11ef18d07a729b03ee76719ead4"></a><br/></td></tr>
<tr class="memitem:ga34d27c315e9f6a09e7909066ab0f081f"><td class="memItemLeft" align="right" valign="top">bdd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__misc.html#ga34d27c315e9f6a09e7909066ab0f081f">atomic_prop_collect_as_bdd</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f, const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a)</td></tr>
<tr class="memdesc:ga34d27c315e9f6a09e7909066ab0f081f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the set of atomic propositions occurring in a formula, as a BDD.  <a href="group__ltl__misc.html#ga34d27c315e9f6a09e7909066ab0f081f"></a><br/></td></tr>
<tr class="memitem:ga4cbd1bf9c7d993d9fe093578b30712a6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__essential.html#ga4cbd1bf9c7d993d9fe093578b30712a6">clone</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:ga4cbd1bf9c7d993d9fe093578b30712a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone a formula.  <a href="group__ltl__essential.html#ga4cbd1bf9c7d993d9fe093578b30712a6"></a><br/></td></tr>
<tr class="memitem:a15bfcd6e1d7b386f8afa1cc785894ba2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#a15bfcd6e1d7b386f8afa1cc785894ba2">reduce_tau03</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f, bool stronger=true)</td></tr>
<tr class="memdesc:a15bfcd6e1d7b386f8afa1cc785894ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce a formula using language containment relationships.  <a href="#a15bfcd6e1d7b386f8afa1cc785894ba2"></a><br/></td></tr>
<tr class="memitem:ga7dfba082e4a6aca346befcc46f87e358"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__essential.html#ga7dfba082e4a6aca346befcc46f87e358">destroy</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:ga7dfba082e4a6aca346befcc46f87e358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a formula.  <a href="group__ltl__essential.html#ga7dfba082e4a6aca346befcc46f87e358"></a><br/></td></tr>
<tr class="memitem:ga7e27d31b2209954c1d57d3b8b5224473"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga7e27d31b2209954c1d57d3b8b5224473">dotty</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:ga7e27d31b2209954c1d57d3b8b5224473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a formula tree using dot's syntax.  <a href="group__ltl__io.html#ga7e27d31b2209954c1d57d3b8b5224473"></a><br/></td></tr>
<tr class="memitem:gaaf316635f1320fa38885fa89e23e2098"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#gaaf316635f1320fa38885fa89e23e2098">dump</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:gaaf316635f1320fa38885fa89e23e2098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a formula tree.  <a href="group__ltl__io.html#gaaf316635f1320fa38885fa89e23e2098"></a><br/></td></tr>
<tr class="memitem:ga49b892ff2e4d9aec61c271959460ad12"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga49b892ff2e4d9aec61c271959460ad12">to_lbt_string</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f, std::ostream &amp;os)</td></tr>
<tr class="memdesc:ga49b892ff2e4d9aec61c271959460ad12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output an LTL formula as a string in LBT's format.  <a href="group__ltl__io.html#ga49b892ff2e4d9aec61c271959460ad12"></a><br/></td></tr>
<tr class="memitem:gae7e461087003b093571f87640dab9045"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#gae7e461087003b093571f87640dab9045">to_lbt_string</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:gae7e461087003b093571f87640dab9045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output an LTL formula as a string in LBT's format.  <a href="group__ltl__io.html#gae7e461087003b093571f87640dab9045"></a><br/></td></tr>
<tr class="memitem:gabf324b4e946522d1b4caf3ce003ec903"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__misc.html#gabf324b4e946522d1b4caf3ce003ec903">length</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:gabf324b4e946522d1b4caf3ce003ec903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the length of a formula.The length of a formula is the number of atomic propositions, constants, and operators (logical and temporal) occurring in the formula. <a class="el" href="classspot_1_1ltl_1_1multop.html" title="Multi-operand operators.">spot::ltl::multop</a> instances with n arguments count for n-1; for instance <code>a | b | c</code> has length 5, even if there is only as single <code>|</code> node internally.  <a href="group__ltl__misc.html#gabf324b4e946522d1b4caf3ce003ec903"></a><br/></td></tr>
<tr class="memitem:ga72b56983a73048f0a303323fd4463fbf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__misc.html#ga72b56983a73048f0a303323fd4463fbf">length_boolone</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:ga72b56983a73048f0a303323fd4463fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the length of a formula, squashing Boolean formulaeThis is similar to <a class="el" href="group__ltl__misc.html#gabf324b4e946522d1b4caf3ce003ec903" title="Compute the length of a formula.The length of a formula is the number of atomic propositions, constants, and operators (logical and temporal) occurring in the formula. spot::ltl::multop instances with n arguments count for n-1; for instance a | b | c has length 5, even if there is only as single | node internally.">spot::ltl::length()</a>, except all Boolean formulae are assumed to have length one.  <a href="group__ltl__misc.html#ga72b56983a73048f0a303323fd4463fbf"></a><br/></td></tr>
<tr class="memitem:ga802942a9f38ff14be3466c6a00705c9e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__rewriting.html#ga802942a9f38ff14be3466c6a00705c9e">unabbreviate_logic</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:ga802942a9f38ff14be3466c6a00705c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone and rewrite a formula to remove most of the abbreviated logical operators.This will rewrite binary operators such as <a class="el" href="classspot_1_1ltl_1_1binop.html#a7c5967c6908151a90ff72f210bfb59a2ac5d2a034f0dd62b98fe785d0372c0c9a">binop::Implies</a>, binop::Equals, and <a class="el" href="classspot_1_1ltl_1_1binop.html#a7c5967c6908151a90ff72f210bfb59a2a71177fc6c4bfbc11a0fd7acceeed1ed5">binop::Xor</a>, using only <a class="el" href="classspot_1_1ltl_1_1unop.html#ab6cd495a942b8c203f547cccb50916bca5c70279f9221ae04c99dfcfb1d8cce21">unop::Not</a>, <a class="el" href="classspot_1_1ltl_1_1multop.html#a7ff9fb342ce923eed135a23285d686feaec9dacb72caa01e417f04a398770b16f">multop::Or</a>, and <a class="el" href="classspot_1_1ltl_1_1multop.html#a7ff9fb342ce923eed135a23285d686fea134bbaa37c9a0db99c61af1f61b7f037">multop::And</a>.  <a href="group__ltl__rewriting.html#ga802942a9f38ff14be3466c6a00705c9e"></a><br/></td></tr>
<tr class="memitem:ga493ea666b2b7bea9b18d5ee9db2969b2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__rewriting.html#ga493ea666b2b7bea9b18d5ee9db2969b2">negative_normal_form</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f, bool negated=false)</td></tr>
<tr class="memdesc:ga493ea666b2b7bea9b18d5ee9db2969b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the negative normal form of <em>f</em>.All negations of the formula are pushed in front of the atomic propositions.  <a href="group__ltl__rewriting.html#ga493ea666b2b7bea9b18d5ee9db2969b2"></a><br/></td></tr>
<tr class="memitem:ga75beb5d36830e9a795e96a3a64f032c1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__rewriting.html#ga75beb5d36830e9a795e96a3a64f032c1">reduce</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f, int opt=<a class="el" href="group__ltl__rewriting.html#ggac9e66395d0e9cb870fa7b1ca208b70caa1629bc689540d42e2f86eea77a6cd275">Reduce_All</a>)</td></tr>
<tr class="memdesc:ga75beb5d36830e9a795e96a3a64f032c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce a formula <em>f</em>.  <a href="group__ltl__rewriting.html#ga75beb5d36830e9a795e96a3a64f032c1"></a><br/></td></tr>
<tr class="memitem:ga3210a9b433640efe1ef74e0da6c678e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__misc.html#ga3210a9b433640efe1ef74e0da6c678e5">is_eventual</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:ga3210a9b433640efe1ef74e0da6c678e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a formula is a pure eventuality.Pure eventuality formulae are defined in.  <a href="group__ltl__misc.html#ga3210a9b433640efe1ef74e0da6c678e5"></a><br/></td></tr>
<tr class="memitem:ga10c79e8a8c5b58fa77cbb6dab5857083"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__misc.html#ga10c79e8a8c5b58fa77cbb6dab5857083">is_universal</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:ga10c79e8a8c5b58fa77cbb6dab5857083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a formula is purely universal.Purely universal formulae are defined in.  <a href="group__ltl__misc.html#ga10c79e8a8c5b58fa77cbb6dab5857083"></a><br/></td></tr>
<tr class="memitem:ga27c4d86c1432210a1e02a1fcd3fec2c3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__rewriting.html#ga27c4d86c1432210a1e02a1fcd3fec2c3">relabel</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f, <a class="el" href="namespacespot_1_1ltl.html#ab49c69f44a36589af8e9d1539d5e4c13">relabeling_style</a> style)</td></tr>
<tr class="memdesc:ga27c4d86c1432210a1e02a1fcd3fec2c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relabel the atomic proposition in a formula.  <a href="group__ltl__rewriting.html#ga27c4d86c1432210a1e02a1fcd3fec2c3"></a><br/></td></tr>
<tr class="memitem:ga900c80d1bc18bc999de94de19aafa6ad"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__rewriting.html#ga900c80d1bc18bc999de94de19aafa6ad">simplify_f_g</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:ga900c80d1bc18bc999de94de19aafa6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace <code>true U f</code> and <code>false R g</code> by <code>F f</code> and <code>G g</code>.  <a href="group__ltl__rewriting.html#ga900c80d1bc18bc999de94de19aafa6ad"></a><br/></td></tr>
<tr class="memitem:acc1cf3cb0551cfab387565570fa21ebf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#acc1cf3cb0551cfab387565570fa21ebf">star_normal_form</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *sere, <a class="el" href="namespacespot_1_1ltl.html#acb41ffa774442ee155cc23a60c0a78a4">snf_cache</a> *cache=0)</td></tr>
<tr class="memitem:ga0f6fa636f033da650016c836d6c94215"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga0f6fa636f033da650016c836d6c94215">to_string</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f, std::ostream &amp;os, bool full_parent=false, bool ratexp=false)</td></tr>
<tr class="memdesc:ga0f6fa636f033da650016c836d6c94215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a formula as a string which is parsable unless the formula contains automaton operators (used in ELTL formulae).  <a href="group__ltl__io.html#ga0f6fa636f033da650016c836d6c94215"></a><br/></td></tr>
<tr class="memitem:ga41c884625ab680e8b8e3f2c60d58fd0e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga41c884625ab680e8b8e3f2c60d58fd0e">to_string</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f, bool full_parent=false, bool ratexp=false)</td></tr>
<tr class="memdesc:ga41c884625ab680e8b8e3f2c60d58fd0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a formula as a string which is parsable unless the formula contains automaton operators (used in ELTL formulae).  <a href="group__ltl__io.html#ga41c884625ab680e8b8e3f2c60d58fd0e"></a><br/></td></tr>
<tr class="memitem:ga839a34e0b8a9261d039177a3546f5501"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga839a34e0b8a9261d039177a3546f5501">to_utf8_string</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f, std::ostream &amp;os, bool full_parent=false, bool ratexp=false)</td></tr>
<tr class="memdesc:ga839a34e0b8a9261d039177a3546f5501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a formula as an utf8 string which is parsable unless the formula contains automaton operators (used in ELTL formulae).  <a href="group__ltl__io.html#ga839a34e0b8a9261d039177a3546f5501"></a><br/></td></tr>
<tr class="memitem:ga2cd5cc7892c33dfbedafe28e102f0834"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga2cd5cc7892c33dfbedafe28e102f0834">to_utf8_string</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f, bool full_parent=false, bool ratexp=false)</td></tr>
<tr class="memdesc:ga2cd5cc7892c33dfbedafe28e102f0834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a formula as an utf8 string which is parsable unless the formula contains automaton operators (used in ELTL formulae).  <a href="group__ltl__io.html#ga2cd5cc7892c33dfbedafe28e102f0834"></a><br/></td></tr>
<tr class="memitem:ga0a8dd6d9bb385a69fabea697df9be925"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga0a8dd6d9bb385a69fabea697df9be925">to_spin_string</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f, std::ostream &amp;os, bool full_parent=false)</td></tr>
<tr class="memdesc:ga0a8dd6d9bb385a69fabea697df9be925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a formula as a string parsable by Spin.  <a href="group__ltl__io.html#ga0a8dd6d9bb385a69fabea697df9be925"></a><br/></td></tr>
<tr class="memitem:ga62c230f1cb3170370c25d8bffb4ea141"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga62c230f1cb3170370c25d8bffb4ea141">to_spin_string</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f, bool full_parent=false)</td></tr>
<tr class="memdesc:ga62c230f1cb3170370c25d8bffb4ea141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a formula into a string parsable by Spin.  <a href="group__ltl__io.html#ga62c230f1cb3170370c25d8bffb4ea141"></a><br/></td></tr>
<tr class="memitem:ga91c4e60cf307d560694b163676ec2c6a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga91c4e60cf307d560694b163676ec2c6a">to_wring_string</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f, std::ostream &amp;os)</td></tr>
<tr class="memdesc:ga91c4e60cf307d560694b163676ec2c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a formula as a string parsable by Wring.  <a href="group__ltl__io.html#ga91c4e60cf307d560694b163676ec2c6a"></a><br/></td></tr>
<tr class="memitem:gab337644a8e96528226e22cf166dc0977"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#gab337644a8e96528226e22cf166dc0977">to_wring_string</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:gab337644a8e96528226e22cf166dc0977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a formula into a string parsable by Wring.  <a href="group__ltl__io.html#gab337644a8e96528226e22cf166dc0977"></a><br/></td></tr>
<tr class="memitem:aa20f1c7fe556be8d3864b12c09efc2bb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#aa20f1c7fe556be8d3864b12c09efc2bb">unabbreviate_ltl</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:aa20f1c7fe556be8d3864b12c09efc2bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone and rewrite a formula to remove most of the abbreviated LTL and logical operators.  <a href="#aa20f1c7fe556be8d3864b12c09efc2bb"></a><br/></td></tr>
<tr class="memitem:ga133f7bfb31a5e4a1e98be27edad69217"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__rewriting.html#ga133f7bfb31a5e4a1e98be27edad69217">unabbreviate_wm</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr class="memdesc:ga133f7bfb31a5e4a1e98be27edad69217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite a formula to remove the W and M operators.  <a href="group__ltl__rewriting.html#ga133f7bfb31a5e4a1e98be27edad69217"></a><br/></td></tr>
</table>
<h2>Typedef Documentation</h2>
<a class="anchor" id="acb41ffa774442ee155cc23a60c0a78a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="hash_8hh.html#ad06cc371f5697a73eab4c293546b4dba">Sgi::hash_map</a>&lt;const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a>*, const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a>*, <a class="el" href="structspot_1_1ptr__hash.html">ptr_hash</a>&lt;<a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a>&gt; &gt; <a class="el" href="namespacespot_1_1ltl.html#acb41ffa774442ee155cc23a60c0a78a4">spot::ltl::snf_cache</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ab49c69f44a36589af8e9d1539d5e4c13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacespot_1_1ltl.html#ab49c69f44a36589af8e9d1539d5e4c13">spot::ltl::relabeling_style</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ab49c69f44a36589af8e9d1539d5e4c13a5611119d586b70ace29dbf1c4678e6fd"></a>Abc</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab49c69f44a36589af8e9d1539d5e4c13a92ec2e5d601c09c57173015e51b675cd"></a>Pnn</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="aa208803abec5d0085c1f635909f44cdb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1multop.html">multop</a>* spot::ltl::is_And </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast <em>f</em> into a multop if it is an And. </p>
<p>Return 0 otherwise. </p>

<p>References <a class="el" href="classspot_1_1ltl_1_1multop.html#a7ff9fb342ce923eed135a23285d686fea134bbaa37c9a0db99c61af1f61b7f037">spot::ltl::multop::And</a>, and <a class="el" href="namespacespot_1_1ltl.html#acf7f6187f2e0beb266738615ee380e5a">is_multop()</a>.</p>

</div>
</div>
<a class="anchor" id="a20f7e738f8c27a3d296b519b8c8e3796"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1multop.html">multop</a>* spot::ltl::is_AndNLM </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast <em>f</em> into a multop if it is an AndNLM. </p>
<p>Return 0 otherwise. </p>

<p>References <a class="el" href="classspot_1_1ltl_1_1multop.html#a7ff9fb342ce923eed135a23285d686fea32cd0b92ca6ea6101c2a5f1a6065c60f">spot::ltl::multop::AndNLM</a>, and <a class="el" href="namespacespot_1_1ltl.html#acf7f6187f2e0beb266738615ee380e5a">is_multop()</a>.</p>

</div>
</div>
<a class="anchor" id="a89dd541d50e9f0882cf9a879e3d0e2cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1multop.html">multop</a>* spot::ltl::is_AndRat </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast <em>f</em> into a multop if it is an AndRat. </p>
<p>Return 0 otherwise. </p>

<p>References <a class="el" href="classspot_1_1ltl_1_1multop.html#a7ff9fb342ce923eed135a23285d686fea5117bcfb94cd6b43d6e2f2eeb8b3cea4">spot::ltl::multop::AndRat</a>, and <a class="el" href="namespacespot_1_1ltl.html#acf7f6187f2e0beb266738615ee380e5a">is_multop()</a>.</p>

</div>
</div>
<a class="anchor" id="a6ebb15622f493a6e9d8fe698c4d3af9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1atomic__prop.html">atomic_prop</a>* spot::ltl::is_atomic_prop </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classspot_1_1ltl_1_1formula.html#ac82808aaf6b4c6b35989fec75f13654ba64397ddd71f78b2e7508f79cae0b5622">spot::ltl::formula::AtomicProp</a>, and <a class="el" href="classspot_1_1ltl_1_1formula.html#a23536bf52c04989ad8b31f7089f5a292">spot::ltl::formula::kind()</a>.</p>

</div>
</div>
<a class="anchor" id="aec170dbcfc4ed607f2e2c3fb8cb2264e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1binop.html">binop</a>* spot::ltl::is_binop </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast <em>f</em> into a binop. </p>
<p>Cast <em>f</em> into a binop iff it is a binop instance. Return 0 otherwise. This is faster than <code>dynamic_cast</code>. </p>

<p>References <a class="el" href="classspot_1_1ltl_1_1formula.html#ac82808aaf6b4c6b35989fec75f13654bae811e3074fd4bde9b2f8732d5a7a381c">spot::ltl::formula::BinOp</a>, and <a class="el" href="classspot_1_1ltl_1_1formula.html#a23536bf52c04989ad8b31f7089f5a292">spot::ltl::formula::kind()</a>.</p>

<p>Referenced by <a class="el" href="namespacespot_1_1ltl.html#afe008683046960e5c1be4aa9da7e7116">is_binop()</a>, <a class="el" href="namespacespot_1_1ltl.html#af2c3a3b78c2394cb420377732df53643">is_M()</a>, <a class="el" href="namespacespot_1_1ltl.html#a29e64397d9e57f5ef8d91cff0794d430">is_R()</a>, <a class="el" href="namespacespot_1_1ltl.html#a7f69b252a63c598fb4a8a1cd3a43b54a">is_U()</a>, and <a class="el" href="namespacespot_1_1ltl.html#a99c281102d5b23a2d24079cf66c8facd">is_W()</a>.</p>

</div>
</div>
<a class="anchor" id="afe008683046960e5c1be4aa9da7e7116"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1binop.html">binop</a>* spot::ltl::is_binop </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="common__post_8hh.html#af865e462fa1ed9c1b7ebe3da56da5a68">binop::type</a>&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast <em>f</em> into a binop if it has type <em>op</em>. </p>
<p>Cast <em>f</em> into a binop iff it is a unop instance with operator <em>op</em>. Returns 0 otherwise. </p>

<p>References <a class="el" href="namespacespot_1_1ltl.html#aec170dbcfc4ed607f2e2c3fb8cb2264e">is_binop()</a>.</p>

</div>
</div>
<a class="anchor" id="adeb0b3c086e4840b15469fc7c5ba8ffb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1binop.html">binop</a>* spot::ltl::is_binop </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="common__post_8hh.html#af865e462fa1ed9c1b7ebe3da56da5a68">binop::type</a>&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="common__post_8hh.html#af865e462fa1ed9c1b7ebe3da56da5a68">binop::type</a>&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast <em>f</em> into a binop if it has type <em>op1</em> or <em>op2</em>. </p>
<p>Cast <em>f</em> into a binop iff it is a unop instance with operator <em>op1</em> or <em>op2</em>. Returns 0 otherwise. </p>

<p>References <a class="el" href="namespacespot_1_1ltl.html#aec170dbcfc4ed607f2e2c3fb8cb2264e">is_binop()</a>.</p>

</div>
</div>
<a class="anchor" id="a87876bf8eb00438107b391a6db369146"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1bunop.html">bunop</a>* spot::ltl::is_bunop </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast <em>f</em> into a bunop. </p>
<p>Cast <em>f</em> into a bunop iff it is a bunop instance. Return 0 otherwise. This is faster than <code>dynamic_cast</code>. </p>

<p>References <a class="el" href="classspot_1_1ltl_1_1formula.html#ac82808aaf6b4c6b35989fec75f13654ba414031ca5ab4eef5eac25eb37990c89b">spot::ltl::formula::BUnOp</a>, and <a class="el" href="classspot_1_1ltl_1_1formula.html#a23536bf52c04989ad8b31f7089f5a292">spot::ltl::formula::kind()</a>.</p>

<p>Referenced by <a class="el" href="namespacespot_1_1ltl.html#add6ce0b867fb1a665da9a97fc622367e">is_bunop()</a>, and <a class="el" href="namespacespot_1_1ltl.html#a28aede25875d04c53587f8ddaec2e033">is_Star()</a>.</p>

</div>
</div>
<a class="anchor" id="add6ce0b867fb1a665da9a97fc622367e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1bunop.html">bunop</a>* spot::ltl::is_bunop </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="common__post_8hh.html#af865e462fa1ed9c1b7ebe3da56da5a68">bunop::type</a>&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast <em>f</em> into a bunop if it has type <em>op</em>. </p>
<p>Cast <em>f</em> into a bunop iff it is a bunop instance with operator <em>op</em>. Returns 0 otherwise. </p>

<p>References <a class="el" href="namespacespot_1_1ltl.html#a87876bf8eb00438107b391a6db369146">is_bunop()</a>.</p>

</div>
</div>
<a class="anchor" id="a7db8010a9f32fbca50cd9075e2ba8473"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1multop.html">multop</a>* spot::ltl::is_Concat </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast <em>f</em> into a multop if it is a Concat. </p>
<p>Return 0 otherwise. </p>

<p>References <a class="el" href="classspot_1_1ltl_1_1multop.html#a7ff9fb342ce923eed135a23285d686fea9c9f297e12ffadb1afbbffe87ecfb00f">spot::ltl::multop::Concat</a>, and <a class="el" href="namespacespot_1_1ltl.html#acf7f6187f2e0beb266738615ee380e5a">is_multop()</a>.</p>

</div>
</div>
<a class="anchor" id="a3ef6c967bc0d99bc8eab1c81d7a7eab1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1constant.html">constant</a>* spot::ltl::is_constant </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast <em>f</em> into a constant. </p>
<p>Cast <em>f</em> into a constant iff it is a constant instance. Return 0 otherwise. This is faster than <code>dynamic_cast</code>. </p>

<p>References <a class="el" href="classspot_1_1ltl_1_1formula.html#ac82808aaf6b4c6b35989fec75f13654ba923c681db289ce26c9d30c8e2cd4bc04">spot::ltl::formula::Constant</a>, and <a class="el" href="classspot_1_1ltl_1_1formula.html#a23536bf52c04989ad8b31f7089f5a292">spot::ltl::formula::kind()</a>.</p>

</div>
</div>
<a class="anchor" id="aa08bd62932d13cfad5aacde4dded31b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1unop.html">unop</a>* spot::ltl::is_F </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast <em>f</em> into a unop if it is a F. </p>
<p>Return 0 otherwise. </p>

<p>References <a class="el" href="classspot_1_1ltl_1_1unop.html#ab6cd495a942b8c203f547cccb50916bca22dc60c18bb1140957d534dab87a8e82">spot::ltl::unop::F</a>, and <a class="el" href="namespacespot_1_1ltl.html#ab5ba210cfb0a509be848ca2f9ea1d755">is_unop()</a>.</p>

<p>Referenced by <a class="el" href="namespacespot_1_1ltl.html#a08a5e79c0220c641b8bfe8a9252f2cbd">is_FG()</a>, and <a class="el" href="namespacespot_1_1ltl.html#a1d0cc2d86dc01d7bef528fcbfbf784a6">is_GF()</a>.</p>

</div>
</div>
<a class="anchor" id="a08a5e79c0220c641b8bfe8a9252f2cbd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1unop.html">unop</a>* spot::ltl::is_FG </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast <em>f</em> into a unop if has the form FG(...). </p>
<p>Return 0 otherwise. </p>

<p>References <a class="el" href="namespacespot_1_1ltl.html#aa08bd62932d13cfad5aacde4dded31b2">is_F()</a>, and <a class="el" href="namespacespot_1_1ltl.html#a10e49587fe0e60b0229eb08c372d98fc">is_G()</a>.</p>

</div>
</div>
<a class="anchor" id="a67a179752351bf2d4e1e6df19013413a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1multop.html">multop</a>* spot::ltl::is_Fusion </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast <em>f</em> into a multop if it is a Fusion. </p>
<p>Return 0 otherwise. </p>

<p>References <a class="el" href="classspot_1_1ltl_1_1multop.html#a7ff9fb342ce923eed135a23285d686fea941feb30221218a6276ee457cf2037d9">spot::ltl::multop::Fusion</a>, and <a class="el" href="namespacespot_1_1ltl.html#acf7f6187f2e0beb266738615ee380e5a">is_multop()</a>.</p>

</div>
</div>
<a class="anchor" id="a10e49587fe0e60b0229eb08c372d98fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1unop.html">unop</a>* spot::ltl::is_G </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast <em>f</em> into a unop if it is a G. </p>
<p>Return 0 otherwise. </p>

<p>References <a class="el" href="classspot_1_1ltl_1_1unop.html#ab6cd495a942b8c203f547cccb50916bcafe9a76cee45f8e8d6f3d970f526090bb">spot::ltl::unop::G</a>, and <a class="el" href="namespacespot_1_1ltl.html#ab5ba210cfb0a509be848ca2f9ea1d755">is_unop()</a>.</p>

<p>Referenced by <a class="el" href="namespacespot_1_1ltl.html#a08a5e79c0220c641b8bfe8a9252f2cbd">is_FG()</a>, and <a class="el" href="namespacespot_1_1ltl.html#a1d0cc2d86dc01d7bef528fcbfbf784a6">is_GF()</a>.</p>

</div>
</div>
<a class="anchor" id="a1d0cc2d86dc01d7bef528fcbfbf784a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1unop.html">unop</a>* spot::ltl::is_GF </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast <em>f</em> into a unop if has the form GF(...). </p>
<p>Return 0 otherwise. </p>

<p>References <a class="el" href="namespacespot_1_1ltl.html#aa08bd62932d13cfad5aacde4dded31b2">is_F()</a>, and <a class="el" href="namespacespot_1_1ltl.html#a10e49587fe0e60b0229eb08c372d98fc">is_G()</a>.</p>

</div>
</div>
<a class="anchor" id="a51d0620bc2a141cf443a7dc73f9d7237"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1bunop.html">bunop</a>* spot::ltl::is_KleenStar </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast <em>f</em> into a bunop if it is a Star[0..]. </p>
<p>Return 0 otherwise. </p>

<p>References <a class="el" href="namespacespot_1_1ltl.html#a28aede25875d04c53587f8ddaec2e033">is_Star()</a>, and <a class="el" href="classspot_1_1ltl_1_1bunop.html#a6997bea0ac1c24ad395f89845de18f00">spot::ltl::bunop::unbounded</a>.</p>

</div>
</div>
<a class="anchor" id="af2c3a3b78c2394cb420377732df53643"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1binop.html">binop</a>* spot::ltl::is_M </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast <em>f</em> into a binop if it is a M. </p>
<p>Return 0 otherwise. </p>

<p>References <a class="el" href="namespacespot_1_1ltl.html#aec170dbcfc4ed607f2e2c3fb8cb2264e">is_binop()</a>, and <a class="el" href="classspot_1_1ltl_1_1binop.html#a7c5967c6908151a90ff72f210bfb59a2aeca825f59e0628f120869c38c1332432">spot::ltl::binop::M</a>.</p>

</div>
</div>
<a class="anchor" id="acf7f6187f2e0beb266738615ee380e5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1multop.html">multop</a>* spot::ltl::is_multop </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast <em>f</em> into a multop. </p>
<p>Cast <em>f</em> into a multop iff it is a multop instance. Return 0 otherwise. This is faster than <code>dynamic_cast</code>. </p>

<p>References <a class="el" href="classspot_1_1ltl_1_1formula.html#a23536bf52c04989ad8b31f7089f5a292">spot::ltl::formula::kind()</a>, and <a class="el" href="classspot_1_1ltl_1_1formula.html#ac82808aaf6b4c6b35989fec75f13654ba418b6a238689281b64e9a62c9a1511c7">spot::ltl::formula::MultOp</a>.</p>

<p>Referenced by <a class="el" href="namespacespot_1_1ltl.html#aa208803abec5d0085c1f635909f44cdb">is_And()</a>, <a class="el" href="namespacespot_1_1ltl.html#a20f7e738f8c27a3d296b519b8c8e3796">is_AndNLM()</a>, <a class="el" href="namespacespot_1_1ltl.html#a89dd541d50e9f0882cf9a879e3d0e2cc">is_AndRat()</a>, <a class="el" href="namespacespot_1_1ltl.html#a7db8010a9f32fbca50cd9075e2ba8473">is_Concat()</a>, <a class="el" href="namespacespot_1_1ltl.html#a67a179752351bf2d4e1e6df19013413a">is_Fusion()</a>, <a class="el" href="namespacespot_1_1ltl.html#a72cf9d5651a25c79009864a5bb93deff">is_multop()</a>, <a class="el" href="namespacespot_1_1ltl.html#a0ffb29ec0246eedf10abe95544bacfc5">is_Or()</a>, and <a class="el" href="namespacespot_1_1ltl.html#a684d629d37b85ad8b66f32cb29e1c1e6">is_OrRat()</a>.</p>

</div>
</div>
<a class="anchor" id="a72cf9d5651a25c79009864a5bb93deff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1multop.html">multop</a>* spot::ltl::is_multop </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="common__post_8hh.html#af865e462fa1ed9c1b7ebe3da56da5a68">multop::type</a>&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast <em>f</em> into a multop if it has type <em>op</em>. </p>
<p>Cast <em>f</em> into a multop iff it is a multop instance with operator <em>op</em>. Returns 0 otherwise. </p>

<p>References <a class="el" href="namespacespot_1_1ltl.html#acf7f6187f2e0beb266738615ee380e5a">is_multop()</a>.</p>

</div>
</div>
<a class="anchor" id="aa7830e6d2f0f4684e769df785ef8c9d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1multop.html">multop</a>* spot::ltl::is_multop </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="common__post_8hh.html#af865e462fa1ed9c1b7ebe3da56da5a68">multop::type</a>&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="common__post_8hh.html#af865e462fa1ed9c1b7ebe3da56da5a68">multop::type</a>&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast <em>f</em> into a multop if it has type <em>op1</em> or <em>op2</em>. </p>
<p>Cast <em>f</em> into a multop iff it is a multop instance with operator <em>op1</em> or <em>op2</em>. Returns 0 otherwise. </p>

<p>References <a class="el" href="namespacespot_1_1ltl.html#acf7f6187f2e0beb266738615ee380e5a">is_multop()</a>.</p>

</div>
</div>
<a class="anchor" id="a3ca8bd47d984aaf3d8a758a0ee0ff436"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1unop.html">unop</a>* spot::ltl::is_Not </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast <em>f</em> into a unop if it is a Not. </p>
<p>Return 0 otherwise. </p>

<p>References <a class="el" href="namespacespot_1_1ltl.html#ab5ba210cfb0a509be848ca2f9ea1d755">is_unop()</a>, and <a class="el" href="classspot_1_1ltl_1_1unop.html#ab6cd495a942b8c203f547cccb50916bca5c70279f9221ae04c99dfcfb1d8cce21">spot::ltl::unop::Not</a>.</p>

</div>
</div>
<a class="anchor" id="a0ffb29ec0246eedf10abe95544bacfc5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1multop.html">multop</a>* spot::ltl::is_Or </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast <em>f</em> into a multop if it is an Or. </p>
<p>Return 0 otherwise. </p>

<p>References <a class="el" href="namespacespot_1_1ltl.html#acf7f6187f2e0beb266738615ee380e5a">is_multop()</a>, and <a class="el" href="classspot_1_1ltl_1_1multop.html#a7ff9fb342ce923eed135a23285d686feaec9dacb72caa01e417f04a398770b16f">spot::ltl::multop::Or</a>.</p>

</div>
</div>
<a class="anchor" id="a684d629d37b85ad8b66f32cb29e1c1e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1multop.html">multop</a>* spot::ltl::is_OrRat </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast <em>f</em> into a multop if it is an OrRat. </p>
<p>Return 0 otherwise. </p>

<p>References <a class="el" href="namespacespot_1_1ltl.html#acf7f6187f2e0beb266738615ee380e5a">is_multop()</a>, and <a class="el" href="classspot_1_1ltl_1_1multop.html#a7ff9fb342ce923eed135a23285d686fea099197189237ac474d3b9e49f4a3b5ab">spot::ltl::multop::OrRat</a>.</p>

</div>
</div>
<a class="anchor" id="a29e64397d9e57f5ef8d91cff0794d430"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1binop.html">binop</a>* spot::ltl::is_R </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast <em>f</em> into a binop if it is a R. </p>
<p>Return 0 otherwise. </p>

<p>References <a class="el" href="namespacespot_1_1ltl.html#aec170dbcfc4ed607f2e2c3fb8cb2264e">is_binop()</a>, and <a class="el" href="classspot_1_1ltl_1_1binop.html#a7c5967c6908151a90ff72f210bfb59a2a2912f480a149c4899b9f61f1a5975c38">spot::ltl::binop::R</a>.</p>

</div>
</div>
<a class="anchor" id="a28aede25875d04c53587f8ddaec2e033"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1bunop.html">bunop</a>* spot::ltl::is_Star </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast <em>f</em> into a bunop if it is a Star. </p>
<p>Return 0 otherwise. </p>

<p>References <a class="el" href="namespacespot_1_1ltl.html#a87876bf8eb00438107b391a6db369146">is_bunop()</a>, and <a class="el" href="classspot_1_1ltl_1_1bunop.html#a752881b5f4c82ab3d4172af81308f6d7acf3c226bac2d73f711f18a6a384c70b6">spot::ltl::bunop::Star</a>.</p>

<p>Referenced by <a class="el" href="namespacespot_1_1ltl.html#a51d0620bc2a141cf443a7dc73f9d7237">is_KleenStar()</a>.</p>

</div>
</div>
<a class="anchor" id="a7f69b252a63c598fb4a8a1cd3a43b54a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1binop.html">binop</a>* spot::ltl::is_U </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast <em>f</em> into a binop if it is a U. </p>
<p>Return 0 otherwise. </p>

<p>References <a class="el" href="namespacespot_1_1ltl.html#aec170dbcfc4ed607f2e2c3fb8cb2264e">is_binop()</a>, and <a class="el" href="classspot_1_1ltl_1_1binop.html#a7c5967c6908151a90ff72f210bfb59a2ab01994b5e43401a5cf70fc7ef1599119">spot::ltl::binop::U</a>.</p>

</div>
</div>
<a class="anchor" id="ab5ba210cfb0a509be848ca2f9ea1d755"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1unop.html">unop</a>* spot::ltl::is_unop </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast <em>f</em> into a unop. </p>
<p>Cast <em>f</em> into a unop iff it is a unop instance. Return 0 otherwise. This is faster than <code>dynamic_cast</code>. </p>

<p>References <a class="el" href="classspot_1_1ltl_1_1formula.html#a23536bf52c04989ad8b31f7089f5a292">spot::ltl::formula::kind()</a>, and <a class="el" href="classspot_1_1ltl_1_1formula.html#ac82808aaf6b4c6b35989fec75f13654baf8c23a94e780d218b21c8493fd1e2ccf">spot::ltl::formula::UnOp</a>.</p>

<p>Referenced by <a class="el" href="namespacespot_1_1ltl.html#aa08bd62932d13cfad5aacde4dded31b2">is_F()</a>, <a class="el" href="namespacespot_1_1ltl.html#a10e49587fe0e60b0229eb08c372d98fc">is_G()</a>, <a class="el" href="namespacespot_1_1ltl.html#a3ca8bd47d984aaf3d8a758a0ee0ff436">is_Not()</a>, <a class="el" href="namespacespot_1_1ltl.html#abc75bf92dfd70c0a414db946cc05d469">is_unop()</a>, and <a class="el" href="namespacespot_1_1ltl.html#a599464ed25bf27b8a37b8a201bca64d1">is_X()</a>.</p>

</div>
</div>
<a class="anchor" id="abc75bf92dfd70c0a414db946cc05d469"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1unop.html">unop</a>* spot::ltl::is_unop </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="common__post_8hh.html#af865e462fa1ed9c1b7ebe3da56da5a68">unop::type</a>&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast <em>f</em> into a unop if it has type <em>op</em>. </p>
<p>Cast <em>f</em> into a unop iff it is a unop instance with operator <em>op</em>. Returns 0 otherwise. </p>

<p>References <a class="el" href="namespacespot_1_1ltl.html#ab5ba210cfb0a509be848ca2f9ea1d755">is_unop()</a>.</p>

</div>
</div>
<a class="anchor" id="a99c281102d5b23a2d24079cf66c8facd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1binop.html">binop</a>* spot::ltl::is_W </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast <em>f</em> into a binop if it is a W. </p>
<p>Return 0 otherwise. </p>

<p>References <a class="el" href="namespacespot_1_1ltl.html#aec170dbcfc4ed607f2e2c3fb8cb2264e">is_binop()</a>, and <a class="el" href="classspot_1_1ltl_1_1binop.html#a7c5967c6908151a90ff72f210bfb59a2a1838d447207f27c06df827716ae393b6">spot::ltl::binop::W</a>.</p>

</div>
</div>
<a class="anchor" id="a599464ed25bf27b8a37b8a201bca64d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1unop.html">unop</a>* spot::ltl::is_X </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast <em>f</em> into a unop if it is a X. </p>
<p>Return 0 otherwise. </p>

<p>References <a class="el" href="namespacespot_1_1ltl.html#ab5ba210cfb0a509be848ca2f9ea1d755">is_unop()</a>, and <a class="el" href="classspot_1_1ltl_1_1unop.html#ab6cd495a942b8c203f547cccb50916bca710394e09b867640d569b71577db1a36">spot::ltl::unop::X</a>.</p>

</div>
</div>
<a class="anchor" id="a53b023ef17f12698ac0721875482a394"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;std::string&gt; spot::ltl::list_formula_props </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List the properties of formula <em>f</em>. </p>

</div>
</div>
<a class="anchor" id="a5ebe7a0005ae56f57d6e085eddb453e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::ltl::print_formula_props </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abbreviated</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the properties of formula <em>f</em> on stream <em>out</em>. </p>

</div>
</div>
<a class="anchor" id="a15bfcd6e1d7b386f8afa1cc785894ba2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a>* spot::ltl::reduce_tau03 </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stronger</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce a formula using language containment relationships. </p>
<pre class="fragment">The method is taken from table 4.1 in
@verbatim 
</pre><p> ///{ tauriainen.03.a83, /// author = {Heikki Tauriainen}, /// title = {On Translating Linear Temporal Logic into Alternating and /// Nondeterministic Automata}, /// institution = {Helsinki University of Technology, Laboratory for /// Theoretical Computer Science}, /// address = {Espoo, Finland}, /// month = dec, /// number = {A83}, /// pages = {132}, /// type = {Research Report}, /// year = {2003}, /// note = {Reprint of Licentiate's thesis} ///} ///  </p>
<pre class="fragment">(The "dagged" cells in the tables are not handled here.)

If \a stronger is set, additional rules are used to further
reduce some U, R, and X usages.

\xrefitem deprecated 2.</pre> 
</div>
</div>
<a class="anchor" id="acc1cf3cb0551cfab387565570fa21ebf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a>* spot::ltl::star_normal_form </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>sere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">snf_cache *&#160;</td>
          <td class="paramname"><em>cache</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper to rewrite a sere in Star Normal Form.

This should only be called on children of a Star operator.  It
corresponds to the EÂ° operation defined in the following
paper.

@verbatim 
</pre><p> /// { bruggeman.96.tcs, /// author = {Anne Br{"u}ggemann-Klein}, /// title = {Regular Expressions into Finite Automata}, /// journal = {Theoretical Computer Science}, /// year = {1996}, /// volume = {120}, /// pages = {87&ndash;98} /// } ///  </p>
<pre class="fragment">\param sere the SERE to rewrite
\param cache an optional cache  </pre> 
</div>
</div>
<a class="anchor" id="aa20f1c7fe556be8d3864b12c09efc2bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a>* spot::ltl::unabbreviate_ltl </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clone and rewrite a formula to remove most of the abbreviated LTL and logical operators. </p>
<p>The rewriting performed on logical operator is the same as the one done by <a class="el" href="group__ltl__rewriting.html#ga802942a9f38ff14be3466c6a00705c9e" title="Clone and rewrite a formula to remove most of the abbreviated logical operators.This will rewrite bin...">spot::ltl::unabbreviate_logic</a>.</p>
<p>This will also rewrite unary operators such as <a class="el" href="classspot_1_1ltl_1_1unop.html#ab6cd495a942b8c203f547cccb50916bca22dc60c18bb1140957d534dab87a8e82">unop::F</a>, and <a class="el" href="classspot_1_1ltl_1_1unop.html#ab6cd495a942b8c203f547cccb50916bcafe9a76cee45f8e8d6f3d970f526090bb">unop::G</a>, using only <a class="el" href="classspot_1_1ltl_1_1binop.html#a7c5967c6908151a90ff72f210bfb59a2ab01994b5e43401a5cf70fc7ef1599119">binop::U</a>, and <a class="el" href="classspot_1_1ltl_1_1binop.html#a7c5967c6908151a90ff72f210bfb59a2a2912f480a149c4899b9f61f1a5975c38">binop::R</a>. </p>

</div>
</div>
</div><!-- contents -->
<hr size="1">
Please <b>comment</b> this page and <b>report errors</b> about it on
<a href="http://spot.lip6.fr/wiki/RefDocComments">the RefDocComments page</a>.
<br><address style="align: right;"><small>
Generated on Sat Oct 27 2012 09:34:34 for spot by <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border=0></a> 1.8.1.2</small></address>
</body>
</html>
