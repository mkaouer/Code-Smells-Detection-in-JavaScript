<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>spot: Translating LTL formulae into TGBA</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">spot
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Translating LTL formulae into TGBA</div>  </div>
<div class="ingroups"><a class="el" href="group__tgba__algorithms.html">TGBA algorithms</a></div></div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gafbf62421b9c1da3df47ea92ade8ecdd4"><td class="memItemLeft" align="right" valign="top">tgba_bdd_concrete *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__ltl.html#gafbf62421b9c1da3df47ea92ade8ecdd4">spot::eltl_to_tgba_lacim</a> (const ltl::formula *f, bdd_dict *dict)</td></tr>
<tr class="memdesc:gafbf62421b9c1da3df47ea92ade8ecdd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="classspot_1_1tgba__bdd__concrete.html" title="A concrete spot::tgba implemented using BDDs.">spot::tgba_bdd_concrete</a> from an ELTL formula.This is based on the following paper.  <a href="#gafbf62421b9c1da3df47ea92ade8ecdd4"></a><br/></td></tr>
<tr class="memitem:gab63f738c24846842339e8c12fd5eb777"><td class="memItemLeft" align="right" valign="top">taa_tgba *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__ltl.html#gab63f738c24846842339e8c12fd5eb777">spot::ltl_to_taa</a> (const ltl::formula *f, bdd_dict *dict, bool refined_rules=false)</td></tr>
<tr class="memdesc:gab63f738c24846842339e8c12fd5eb777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a spot::taa* from an LTL formula.This is based on the following.  <a href="#gab63f738c24846842339e8c12fd5eb777"></a><br/></td></tr>
<tr class="memitem:ga9e12e74a9e66d7ae2b96dfb1e11655b6"><td class="memItemLeft" align="right" valign="top">tgba_explicit_formula *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__ltl.html#ga9e12e74a9e66d7ae2b96dfb1e11655b6">spot::ltl_to_tgba_fm</a> (const ltl::formula *f, bdd_dict *dict, bool exprop=false, bool symb_merge=true, bool branching_postponement=false, bool fair_loop_approx=false, const ltl::atomic_prop_set *unobs=0, ltl::ltl_simplifier *simplifier=0)</td></tr>
<tr class="memdesc:ga9e12e74a9e66d7ae2b96dfb1e11655b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="classspot_1_1tgba__explicit.html">spot::tgba_explicit</a>* from an LTL formula.This is based on the following paper.  <a href="#ga9e12e74a9e66d7ae2b96dfb1e11655b6"></a><br/></td></tr>
<tr class="memitem:ga911db84b8e05185bb50b5eda55efe6b6"><td class="memItemLeft" align="right" valign="top">tgba_bdd_concrete *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__ltl.html#ga911db84b8e05185bb50b5eda55efe6b6">spot::ltl_to_tgba_lacim</a> (const ltl::formula *f, bdd_dict *dict)</td></tr>
<tr class="memdesc:ga911db84b8e05185bb50b5eda55efe6b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="classspot_1_1tgba__bdd__concrete.html" title="A concrete spot::tgba implemented using BDDs.">spot::tgba_bdd_concrete</a> from an LTL formula.This is based on the following paper.  <a href="#ga911db84b8e05185bb50b5eda55efe6b6"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<h2>Function Documentation</h2>
<a class="anchor" id="gafbf62421b9c1da3df47ea92ade8ecdd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tgba_bdd_concrete* spot::eltl_to_tgba_lacim </td>
          <td>(</td>
          <td class="paramtype">const ltl::formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_dict *&#160;</td>
          <td class="paramname"><em>dict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a <a class="el" href="classspot_1_1tgba__bdd__concrete.html" title="A concrete spot::tgba implemented using BDDs.">spot::tgba_bdd_concrete</a> from an ELTL formula.This is based on the following paper. </p>
<pre class="fragment">@verbatim 
</pre><p> /// { couvreur.00.lacim, /// author = {Jean-Michel Couvreur}, /// title = {Un point de vue symbolique sur la logique temporelle /// lin{\'e}aire}, /// booktitle = {Actes du Colloque LaCIM 2000}, /// month = {August}, /// year = {2000}, /// pages = {131&ndash;140}, /// volume = {27}, /// series = {Publications du LaCIM}, /// publisher = {Universit{\'e} du Qu{\'e}bec {`a} Montr{\'e}al}, /// editor = {Pierre Leroux} /// } ///  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to translate into an automaton. </td></tr>
    <tr><td class="paramname">dict</td><td>The <a class="el" href="classspot_1_1bdd__dict.html" title="Map BDD variables to formulae.">spot::bdd_dict</a> the constructed automata should use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classspot_1_1tgba__bdd__concrete.html" title="A concrete spot::tgba implemented using BDDs.">spot::tgba_bdd_concrete</a> that recognizes the language of <em>f</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="gab63f738c24846842339e8c12fd5eb777"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">taa_tgba* spot::ltl_to_taa </td>
          <td>(</td>
          <td class="paramtype">const ltl::formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_dict *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>refined_rules</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a spot::taa* from an LTL formula.This is based on the following. </p>
<pre class="fragment">@verbatim 
</pre><p> /// {HUT-TCS-A104, /// address = {Espoo, Finland}, /// author = {Heikki Tauriainen}, /// month = {September}, /// note = {Doctoral dissertation}, /// number = {A104}, /// pages = {xii+229}, /// title = {Automata and Linear Temporal Logic: Translations /// with Transition-Based Acceptance}, /// type = {Research Report}, /// year = {2006} /// } ///  </p>
<pre class="fragment">\param f The formula to translate into an automaton.
\param dict The spot::bdd_dict the constructed automata should use.
\param refined_rules If this parameter is set, refined rules are used.
\return A spot::taa that recognizes the language of \a f.  </pre> 
</div>
</div>
<a class="anchor" id="ga9e12e74a9e66d7ae2b96dfb1e11655b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tgba_explicit_formula* spot::ltl_to_tgba_fm </td>
          <td>(</td>
          <td class="paramtype">const ltl::formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_dict *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exprop</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>symb_merge</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>branching_postponement</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fair_loop_approx</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ltl::atomic_prop_set *&#160;</td>
          <td class="paramname"><em>unobs</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ltl::ltl_simplifier *&#160;</td>
          <td class="paramname"><em>simplifier</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a <a class="el" href="classspot_1_1tgba__explicit.html">spot::tgba_explicit</a>* from an LTL formula.This is based on the following paper. </p>
<pre class="fragment">@verbatim 
</pre><p> /// {couvreur.99.fm, /// author = {Jean-Michel Couvreur}, /// title = {On-the-fly Verification of Temporal Logic}, /// pages = {253&ndash;271}, /// editor = {Jeannette M. Wing and Jim Woodcock and Jim Davies}, /// booktitle = {Proceedings of the World Congress on Formal Methods in the /// Development of Computing Systems (FM'99)}, /// publisher = {Springer-Verlag}, /// series = {Lecture Notes in Computer Science}, /// volume = {1708}, /// year = {1999}, /// address = {Toulouse, France}, /// month = {September}, /// isbn = {3-540-66587-0} /// } ///  </p>
<pre class="fragment">\param f The formula to translate into an automaton.

\param dict The spot::bdd_dict the constructed automata should use.

\param exprop When set, the algorithm will consider all properties
combinations possible on each state, in an attempt to reduce
the non-determinism.  The automaton will have the same size as
without this option, but because the transition will be more
deterministic, the product automaton will be smaller (or, at worse,
equal).

\param symb_merge When false, states with the same symbolic
representation (these are equivalent formulae) will not be
merged.

\param branching_postponement When set, several transitions leaving
from the same state with the same label (i.e., condition + acceptance
conditions) will be merged.  This correspond to an optimization
described in the following paper.
@verbatim 
</pre><p> /// { sebastiani.03.charme, /// author = {Roberto Sebastiani and Stefano Tonetta}, /// title = {"More Deterministic" vs. "Smaller" B{"u}chi Automata for /// Efficient LTL Model Checking}, /// booktitle = {Proceedings for the 12th Advanced Research Working /// Conference on Correct Hardware Design and Verification /// Methods (CHARME'03)}, /// pages = {126&ndash;140}, /// year = {2003}, /// editor = {G. Goos and J. Hartmanis and J. van Leeuwen}, /// volume = {2860}, /// series = {Lectures Notes in Computer Science}, /// month = {October}, /// publisher = {Springer-Verlag} /// } ///  </p>
<pre class="fragment">\param fair_loop_approx When set, a really simple characterization of
unstable state is used to suppress all acceptance conditions from
incoming transitions.

\param unobs When non-zero, the atomic propositions in the LTL formula
are interpreted as events that exclude each other.  The events in the
formula are observable events, and \c unobs can be filled with
additional unobservable events.

\param simpl If this parameter is set, the LTL formulae representing
each state of the automaton will be simplified
before computing the successor.  \a simpl should be configured
for the type of reduction you want, see spot::ltl::ltl_simplifier.
This idea is taken from the following paper.
@verbatim 
</pre><p> /// { thirioux.02.fmics, /// author = {Xavier Thirioux}, /// title = {Simple and Efficient Translation from {LTL} Formulas to /// {B"u}chi Automata}, /// booktitle = {Proceedings of the 7th International ERCIM Workshop in /// Formal Methods for Industrial Critical Systems (FMICS'02)}, /// series = {Electronic Notes in Theoretical Computer Science}, /// volume = {66(2)}, /// publisher = {Elsevier}, /// editor = {Rance Cleaveland and Hubert Garavel}, /// year = {2002}, /// month = jul, /// address = {M{\'a}laga, Spain} /// } ///  </p>
<pre class="fragment">\return A spot::tgba_explicit that recognizes the language of \a f.  </pre> 
</div>
</div>
<a class="anchor" id="ga911db84b8e05185bb50b5eda55efe6b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tgba_bdd_concrete* spot::ltl_to_tgba_lacim </td>
          <td>(</td>
          <td class="paramtype">const ltl::formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_dict *&#160;</td>
          <td class="paramname"><em>dict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a <a class="el" href="classspot_1_1tgba__bdd__concrete.html" title="A concrete spot::tgba implemented using BDDs.">spot::tgba_bdd_concrete</a> from an LTL formula.This is based on the following paper. </p>
<pre class="fragment">@verbatim 
</pre><p> /// { couvreur.00.lacim, /// author = {Jean-Michel Couvreur}, /// title = {Un point de vue symbolique sur la logique temporelle /// lin{\'e}aire}, /// booktitle = {Actes du Colloque LaCIM 2000}, /// month = {August}, /// year = {2000}, /// pages = {131&ndash;140}, /// volume = {27}, /// series = {Publications du LaCIM}, /// publisher = {Universit{\'e} du Qu{\'e}bec {`a} Montr{\'e}al}, /// editor = {Pierre Leroux} /// } ///  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to translate into an automaton. </td></tr>
    <tr><td class="paramname">dict</td><td>The <a class="el" href="classspot_1_1bdd__dict.html" title="Map BDD variables to formulae.">spot::bdd_dict</a> the constructed automata should use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classspot_1_1tgba__bdd__concrete.html" title="A concrete spot::tgba implemented using BDDs.">spot::tgba_bdd_concrete</a> that recognizes the language of <em>f</em>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr size="1">
Please <b>comment</b> this page and <b>report errors</b> about it on
<a href="http://spot.lip6.fr/wiki/RefDocComments">the RefDocComments page</a>.
<br><address style="align: right;"><small>
Generated on Sat Oct 27 2012 09:34:33 for spot by <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border=0></a> 1.8.1.2</small></address>
</body>
</html>
