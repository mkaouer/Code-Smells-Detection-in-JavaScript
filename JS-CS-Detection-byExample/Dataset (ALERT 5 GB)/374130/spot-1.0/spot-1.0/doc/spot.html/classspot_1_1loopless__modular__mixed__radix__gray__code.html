<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>spot: spot::loopless_modular_mixed_radix_gray_code Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">spot
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacespot.html">spot</a></li><li class="navelem"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html">loopless_modular_mixed_radix_gray_code</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classspot_1_1loopless__modular__mixed__radix__gray__code-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">spot::loopless_modular_mixed_radix_gray_code Class Reference<div class="ingroups"><a class="el" href="group__misc__tools.html">Miscellaneous helper algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Loopless modular mixed radix Gray code iteration.This class is based on the loopless modular mixed radix gray code algorithm described in exercise 77 of "The Art of Computer
     Programming", Pre-Fascicle 2A (Draft of section 7.2.1.1: generating all n-tuples) by Donald E. Knuth.  
 <a href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="modgray_8hh_source.html">misc/modgray.hh</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for spot::loopless_modular_mixed_radix_gray_code:</div>
<div class="dyncontent">
<div class="center"><img src="classspot_1_1loopless__modular__mixed__radix__gray__code__coll__graph.png" border="0" usemap="#spot_1_1loopless__modular__mixed__radix__gray__code_coll__map" alt="Collaboration graph"/></div>
<map name="spot_1_1loopless__modular__mixed__radix__gray__code_coll__map" id="spot_1_1loopless__modular__mixed__radix__gray__code_coll__map">
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a565b6c52e7b37b83bb829095e11c69c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a565b6c52e7b37b83bb829095e11c69c9">loopless_modular_mixed_radix_gray_code</a> (int n)</td></tr>
<tr class="memitem:a53934ac1621f8bd1c55ef9ccbf9e4a11"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a53934ac1621f8bd1c55ef9ccbf9e4a11">~loopless_modular_mixed_radix_gray_code</a> ()</td></tr>
<tr><td colspan="2"><div class="groupHeader">iteration over an element in a tuple</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The class does not know how to modify the elements of the tuple (Knuth's a<sub>j</sub>s). These changes are therefore abstracted using the <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#af1aab585098500e6acb78675967ef530" title="Reset aj to its initial value.">a_first()</a>, <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#ad2299afa2a00ff9cc5f202b9854bdf4d" title="Advance aj to its next value.">a_next()</a>, and <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#aed1aa03144c6dcb46e13c38b5c51a260" title="Whether aj is on its last value.">a_last()</a> abstract functions. These need to be implemented in subclasses as appropriate. </p>
</div></td></tr>
<tr class="memitem:af1aab585098500e6acb78675967ef530"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#af1aab585098500e6acb78675967ef530">a_first</a> (int j)=0</td></tr>
<tr class="memdesc:af1aab585098500e6acb78675967ef530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset a<sub>j</sub> to its initial value.  <a href="#af1aab585098500e6acb78675967ef530"></a><br/></td></tr>
<tr class="memitem:ad2299afa2a00ff9cc5f202b9854bdf4d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#ad2299afa2a00ff9cc5f202b9854bdf4d">a_next</a> (int j)=0</td></tr>
<tr class="memdesc:ad2299afa2a00ff9cc5f202b9854bdf4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance a<sub>j</sub> to its next value.  <a href="#ad2299afa2a00ff9cc5f202b9854bdf4d"></a><br/></td></tr>
<tr class="memitem:aed1aa03144c6dcb46e13c38b5c51a260"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#aed1aa03144c6dcb46e13c38b5c51a260">a_last</a> (int j) const =0</td></tr>
<tr class="memdesc:aed1aa03144c6dcb46e13c38b5c51a260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a<sub>j</sub> is on its last value.  <a href="#aed1aa03144c6dcb46e13c38b5c51a260"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">iteration over all the tuples</div></td></tr>
<tr class="memitem:a9c918e8524bdeb3e3a80054becbd30df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a9c918e8524bdeb3e3a80054becbd30df">first</a> ()</td></tr>
<tr class="memdesc:a9c918e8524bdeb3e3a80054becbd30df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the iteration to the first tuple.  <a href="#a9c918e8524bdeb3e3a80054becbd30df"></a><br/></td></tr>
<tr class="memitem:a98269cadd64926b5cf408cc4ab0ed2a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a98269cadd64926b5cf408cc4ab0ed2a5">last</a> () const </td></tr>
<tr class="memdesc:a98269cadd64926b5cf408cc4ab0ed2a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this the last tuple.  <a href="#a98269cadd64926b5cf408cc4ab0ed2a5"></a><br/></td></tr>
<tr class="memitem:a60dcf75008df5bbab91533ee6ac03297"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a60dcf75008df5bbab91533ee6ac03297">done</a> () const </td></tr>
<tr class="memdesc:a60dcf75008df5bbab91533ee6ac03297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether all tuple have been explored.  <a href="#a60dcf75008df5bbab91533ee6ac03297"></a><br/></td></tr>
<tr class="memitem:a5ef37d3a269687be631a65769ad209b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a5ef37d3a269687be631a65769ad209b9">next</a> ()</td></tr>
<tr class="memdesc:a5ef37d3a269687be631a65769ad209b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update one item of the tuple and return its position.  <a href="#a5ef37d3a269687be631a65769ad209b9"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2551f357ca1be741bc5300d06a4c3b63"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a2551f357ca1be741bc5300d06a4c3b63">n_</a></td></tr>
<tr class="memitem:a01d93ad137b3a2368270ec3779e32eee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a01d93ad137b3a2368270ec3779e32eee">done_</a></td></tr>
<tr class="memitem:a68e9eea9d2632d66f2ef1042f2d27b68"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a68e9eea9d2632d66f2ef1042f2d27b68">a_</a></td></tr>
<tr class="memitem:a6f86e8454e331df5b4aacf5eef3f41ef"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a6f86e8454e331df5b4aacf5eef3f41ef">f_</a></td></tr>
<tr class="memitem:aa8342a062c7d6845b4473c0617bb4552"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#aa8342a062c7d6845b4473c0617bb4552">m_</a></td></tr>
<tr class="memitem:a3dfc0ecaeaf71747a972ce8339d63e50"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a3dfc0ecaeaf71747a972ce8339d63e50">s_</a></td></tr>
<tr class="memitem:a7c8c0adbecfdb2060d4696cf2bbf799e"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a7c8c0adbecfdb2060d4696cf2bbf799e">non_one_radixes_</a></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Loopless modular mixed radix Gray code iteration.</p>
<p>This class is based on the loopless modular mixed radix gray code algorithm described in exercise 77 of "The Art of Computer
     Programming", Pre-Fascicle 2A (Draft of section 7.2.1.1: generating all n-tuples) by Donald E. Knuth. </p>
<pre class="fragment"> The idea is to enumerate the set of all n-tuples
 (a&lt;sub&gt;0&lt;/sub&gt;,a&lt;sub&gt;1&lt;/sub&gt;,...,a&lt;sub&gt;n-1&lt;/sub&gt;) where each
 a&lt;sub&gt;j&lt;/sub&gt; range over a distinct set (this is the &lt;i&gt;mixed
 radix&lt;/i&gt; part), so that only one a&lt;sub&gt;j&lt;/sub&gt; changes between
 two successive tuples of the iteration (that is the &lt;i&gt;Gray
 code&lt;/i&gt; part), and that this changes occurs always in the same
 direction, cycling over the set a&lt;sub&gt;j&lt;/sub&gt; must cover (i.e.,
 &lt;i&gt;modular&lt;/i&gt;).  The algorithm is &lt;i&gt;loopless&lt;/i&gt; in that
 computing the next tuple done without any loop, i.e., in
 constant time.

 This class does not need to know the type of the a&lt;sub&gt;j&lt;/sub&gt;,
 it will handle them indirectly through three methods: a_first(),
 a_next(), and a_last().  These methods need to be implemented
 in a subclass for the particular type of a&lt;sub&gt;j&lt;/sub&gt; at hand.

 The class itself offers four functions to control the iteration
 over the set of all the (a&lt;sub&gt;0&lt;/sub&gt;,a&lt;sub&gt;1&lt;/sub&gt;,...,
 a&lt;sub&gt;n-1&lt;/sub&gt;) tuples: first(), next(), last(), and done().
 These functions are usually used as follows:
 @code 
</pre><p> for (g.first(); !g.<a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a60dcf75008df5bbab91533ee6ac03297" title="Whether all tuple have been explored.">done()</a>; g.next()) use the tuple  How to use the tuple of course depends on the way it as been stored in the subclass.</p>
<p>Finally, let's mention two differences between this algorithm and the one in Knuth's book. This version of the algorithm does not need to know the radixes (i.e., the size of set of each a<sub>j</sub>) beforehand: it will discover them on-the-fly when a_last(j) first return true. It will also work with a<sub>j</sub> that cannot be changed. (This is achieved by reindexing the elements through <code>non_one_radixes_</code>, to consider only the elements with a non-singleton range.) </p>
</div><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a565b6c52e7b37b83bb829095e11c69c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spot::loopless_modular_mixed_radix_gray_code::loopless_modular_mixed_radix_gray_code </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The size of the tuples to enumerate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a53934ac1621f8bd1c55ef9ccbf9e4a11"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual spot::loopless_modular_mixed_radix_gray_code::~loopless_modular_mixed_radix_gray_code </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="af1aab585098500e6acb78675967ef530"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void spot::loopless_modular_mixed_radix_gray_code::a_first </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset a<sub>j</sub> to its initial value. </p>

</div>
</div>
<a class="anchor" id="aed1aa03144c6dcb46e13c38b5c51a260"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool spot::loopless_modular_mixed_radix_gray_code::a_last </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether a<sub>j</sub> is on its last value. </p>

</div>
</div>
<a class="anchor" id="ad2299afa2a00ff9cc5f202b9854bdf4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void spot::loopless_modular_mixed_radix_gray_code::a_next </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advance a<sub>j</sub> to its next value. </p>
<p>This will never be called if a_last(j) is true. </p>

</div>
</div>
<a class="anchor" id="a60dcf75008df5bbab91533ee6ac03297"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool spot::loopless_modular_mixed_radix_gray_code::done </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether all tuple have been explored. </p>

<p>References <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a01d93ad137b3a2368270ec3779e32eee">done_</a>.</p>

</div>
</div>
<a class="anchor" id="a9c918e8524bdeb3e3a80054becbd30df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spot::loopless_modular_mixed_radix_gray_code::first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the iteration to the first tuple. </p>
<p>This must be called before calling any of <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a5ef37d3a269687be631a65769ad209b9" title="Update one item of the tuple and return its position.">next()</a>, <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a98269cadd64926b5cf408cc4ab0ed2a5" title="Whether this the last tuple.">last()</a>, or <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a60dcf75008df5bbab91533ee6ac03297" title="Whether all tuple have been explored.">done()</a>. </p>

</div>
</div>
<a class="anchor" id="a98269cadd64926b5cf408cc4ab0ed2a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool spot::loopless_modular_mixed_radix_gray_code::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether this the last tuple. </p>
<p>At this point it is still OK to call <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a5ef37d3a269687be631a65769ad209b9" title="Update one item of the tuple and return its position.">next()</a>, and then <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a60dcf75008df5bbab91533ee6ac03297" title="Whether all tuple have been explored.">done()</a> will become true. </p>

<p>References <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a6f86e8454e331df5b4aacf5eef3f41ef">f_</a>, and <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a2551f357ca1be741bc5300d06a4c3b63">n_</a>.</p>

</div>
</div>
<a class="anchor" id="a5ef37d3a269687be631a65769ad209b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spot::loopless_modular_mixed_radix_gray_code::next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update one item of the tuple and return its position. </p>
<p><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a5ef37d3a269687be631a65769ad209b9" title="Update one item of the tuple and return its position.">next()</a> should never be called if <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a60dcf75008df5bbab91533ee6ac03297" title="Whether all tuple have been explored.">done()</a> is true. If it is called on the last tuple (i.e., <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a98269cadd64926b5cf408cc4ab0ed2a5" title="Whether this the last tuple.">last()</a> is true), it will return -1. Otherwise it will update one a<sub>j</sub> of the tuple through one the a<sub>j</sub> handling functions, and return j. </p>

</div>
</div>
<h2>Member Data Documentation</h2>
<a class="anchor" id="a68e9eea9d2632d66f2ef1042f2d27b68"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* spot::loopless_modular_mixed_radix_gray_code::a_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a01d93ad137b3a2368270ec3779e32eee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool spot::loopless_modular_mixed_radix_gray_code::done_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a60dcf75008df5bbab91533ee6ac03297">done()</a>.</p>

</div>
</div>
<a class="anchor" id="a6f86e8454e331df5b4aacf5eef3f41ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* spot::loopless_modular_mixed_radix_gray_code::f_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a98269cadd64926b5cf408cc4ab0ed2a5">last()</a>.</p>

</div>
</div>
<a class="anchor" id="aa8342a062c7d6845b4473c0617bb4552"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* spot::loopless_modular_mixed_radix_gray_code::m_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2551f357ca1be741bc5300d06a4c3b63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int spot::loopless_modular_mixed_radix_gray_code::n_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a98269cadd64926b5cf408cc4ab0ed2a5">last()</a>.</p>

</div>
</div>
<a class="anchor" id="a7c8c0adbecfdb2060d4696cf2bbf799e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* spot::loopless_modular_mixed_radix_gray_code::non_one_radixes_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3dfc0ecaeaf71747a972ce8339d63e50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* spot::loopless_modular_mixed_radix_gray_code::s_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>misc/<a class="el" href="modgray_8hh_source.html">modgray.hh</a></li>
</ul>
</div><!-- contents -->
<hr size="1">
Please <b>comment</b> this page and <b>report errors</b> about it on
<a href="http://spot.lip6.fr/wiki/RefDocComments">the RefDocComments page</a>.
<br><address style="align: right;"><small>
Generated on Sat Oct 27 2012 09:34:33 for spot by <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border=0></a> 1.8.1.2</small></address>
</body>
</html>
