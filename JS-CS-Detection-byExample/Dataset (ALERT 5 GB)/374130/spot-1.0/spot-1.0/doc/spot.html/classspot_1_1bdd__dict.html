<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>spot: spot::bdd_dict Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">spot
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacespot.html">spot</a></li><li class="navelem"><a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classspot_1_1bdd__dict-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">spot::bdd_dict Class Reference<div class="ingroups"><a class="el" href="group__tgba__essentials.html">Essential TGBA types</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Map BDD variables to formulae.  
 <a href="classspot_1_1bdd__dict.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="bdddict_8hh_source.html">tgba/bdddict.hh</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for spot::bdd_dict:</div>
<div class="dyncontent">
<div class="center"><img src="classspot_1_1bdd__dict__inherit__graph.png" border="0" usemap="#spot_1_1bdd__dict_inherit__map" alt="Inheritance graph"/></div>
<map name="spot_1_1bdd__dict_inherit__map" id="spot_1_1bdd__dict_inherit__map">
<area shape="rect" id="node2" href="classspot_1_1bdd__allocator.html" title="Manage ranges of variables." alt="" coords="25,265,169,442"/><area shape="rect" id="node4" href="classspot_1_1free__list.html" title="Manage list of free integers." alt="" coords="35,6,160,215"/></map>
</div>
<div class="dynheader">
Collaboration diagram for spot::bdd_dict:</div>
<div class="dyncontent">
<div class="center"><img src="classspot_1_1bdd__dict__coll__graph.png" border="0" usemap="#spot_1_1bdd__dict_coll__map" alt="Collaboration graph"/></div>
<map name="spot_1_1bdd__dict_coll__map" id="spot_1_1bdd__dict_coll__map">
<area shape="rect" id="node2" href="classspot_1_1bdd__allocator.html" title="Manage ranges of variables." alt="" coords="25,265,169,442"/><area shape="rect" id="node4" href="classspot_1_1free__list.html" title="Manage list of free integers." alt="" coords="35,6,160,215"/></map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict_1_1anon__free__list.html">anon_free_list</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1bdd__dict_1_1bdd__info.html">bdd_info</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afc6a898f172c6e90a19c4a85da9bbff6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#afc6a898f172c6e90a19c4a85da9bbff6">var_type</a> { <br/>
&#160;&#160;<a class="el" href="classspot_1_1bdd__dict.html#afc6a898f172c6e90a19c4a85da9bbff6a3f82e03445f8367a00259465b12c6139">anon</a> =  0, 
<a class="el" href="classspot_1_1bdd__dict.html#afc6a898f172c6e90a19c4a85da9bbff6a47ba5912c7d3b8f51ea03cc885c26d4a">now</a>, 
<a class="el" href="classspot_1_1bdd__dict.html#afc6a898f172c6e90a19c4a85da9bbff6a480d3c059c89672bc5f6d48fb1335e8c">next</a>, 
<a class="el" href="classspot_1_1bdd__dict.html#afc6a898f172c6e90a19c4a85da9bbff6aa7285afea37b218e4a0e33609101fd76">var</a>, 
<br/>
&#160;&#160;<a class="el" href="classspot_1_1bdd__dict.html#afc6a898f172c6e90a19c4a85da9bbff6aba32cf3601484b8e31e7012534d7a089">acc</a>
<br/>
 }</td></tr>
<tr class="memitem:a5bd5f592056f364fdd862a3e0de9fd22"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; const <br class="typebreak"/>
<a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#a5bd5f592056f364fdd862a3e0de9fd22">fv_map</a></td></tr>
<tr class="memdesc:a5bd5f592056f364fdd862a3e0de9fd22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formula-to-BDD-variable maps.  <a href="#a5bd5f592056f364fdd862a3e0de9fd22"></a><br/></td></tr>
<tr class="memitem:ad0b9e89c7a60caad9e5786c82a15e0ee"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; int, const <br class="typebreak"/>
<a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#ad0b9e89c7a60caad9e5786c82a15e0ee">vf_map</a></td></tr>
<tr class="memdesc:ad0b9e89c7a60caad9e5786c82a15e0ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">BDD-variable-to-formula maps.  <a href="#ad0b9e89c7a60caad9e5786c82a15e0ee"></a><br/></td></tr>
<tr class="memitem:a015d330da101dd646875b8ed1613a2d6"><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; const void * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#a015d330da101dd646875b8ed1613a2d6">ref_set</a></td></tr>
<tr class="memdesc:a015d330da101dd646875b8ed1613a2d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">BDD-variable reference counts.  <a href="#a015d330da101dd646875b8ed1613a2d6"></a><br/></td></tr>
<tr class="memitem:aae899f4798d4177a007304f8cb6a7967"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="structspot_1_1bdd__dict_1_1bdd__info.html">bdd_info</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#aae899f4798d4177a007304f8cb6a7967">bdd_info_map</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad2076425544919476f16812e2c9cc242"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#ad2076425544919476f16812e2c9cc242">bdd_dict</a> ()</td></tr>
<tr class="memitem:af6f03983c2f4647cf0a192d5868c1b14"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#af6f03983c2f4647cf0a192d5868c1b14">~bdd_dict</a> ()</td></tr>
<tr class="memitem:a6095afcbbb4fbe67066d51169e80d333"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#a6095afcbbb4fbe67066d51169e80d333">register_proposition</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f, const void *for_me)</td></tr>
<tr class="memdesc:a6095afcbbb4fbe67066d51169e80d333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an atomic proposition.  <a href="#a6095afcbbb4fbe67066d51169e80d333"></a><br/></td></tr>
<tr class="memitem:abb99eed0b49ffba5229af45ef7c1e05f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#abb99eed0b49ffba5229af45ef7c1e05f">register_propositions</a> (bdd f, const void *for_me)</td></tr>
<tr class="memdesc:abb99eed0b49ffba5229af45ef7c1e05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register BDD variables as atomic propositions.  <a href="#abb99eed0b49ffba5229af45ef7c1e05f"></a><br/></td></tr>
<tr class="memitem:ac5b0d292aafacbfbbd233080fe4a4ad0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#ac5b0d292aafacbfbbd233080fe4a4ad0">register_state</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f, const void *for_me)</td></tr>
<tr class="memdesc:ac5b0d292aafacbfbbd233080fe4a4ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a couple of Now/Next variables.  <a href="#ac5b0d292aafacbfbbd233080fe4a4ad0"></a><br/></td></tr>
<tr class="memitem:abb27e26e93d99e046dbe9e9d0cb21485"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#abb27e26e93d99e046dbe9e9d0cb21485">register_acceptance_variable</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f, const void *for_me)</td></tr>
<tr class="memdesc:abb27e26e93d99e046dbe9e9d0cb21485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an atomic proposition.  <a href="#abb27e26e93d99e046dbe9e9d0cb21485"></a><br/></td></tr>
<tr class="memitem:abebfcb644db70ac9368ff316317059a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#abebfcb644db70ac9368ff316317059a3">register_clone_acc</a> (int <a class="el" href="classspot_1_1bdd__dict.html#afc6a898f172c6e90a19c4a85da9bbff6aa7285afea37b218e4a0e33609101fd76">var</a>, const void *for_me)</td></tr>
<tr class="memdesc:abebfcb644db70ac9368ff316317059a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone an acceptance variable VAR for FOR_ME.  <a href="#abebfcb644db70ac9368ff316317059a3"></a><br/></td></tr>
<tr class="memitem:ac4e496809f4027831aed7457fc8b7f3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#ac4e496809f4027831aed7457fc8b7f3a">register_acceptance_variables</a> (bdd f, const void *for_me)</td></tr>
<tr class="memdesc:ac4e496809f4027831aed7457fc8b7f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register BDD variables as acceptance variables.  <a href="#ac4e496809f4027831aed7457fc8b7f3a"></a><br/></td></tr>
<tr class="memitem:ae9584f1914c0f5dad897e60f5d560bb9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#ae9584f1914c0f5dad897e60f5d560bb9">oneacc_to_formula</a> (bdd oneacc) const </td></tr>
<tr class="memdesc:ae9584f1914c0f5dad897e60f5d560bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert one acceptance condition into the associated formula.  <a href="#ae9584f1914c0f5dad897e60f5d560bb9"></a><br/></td></tr>
<tr class="memitem:ad1f021480a019e739c54c8e107b27939"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#ad1f021480a019e739c54c8e107b27939">oneacc_to_formula</a> (int <a class="el" href="classspot_1_1bdd__dict.html#afc6a898f172c6e90a19c4a85da9bbff6aa7285afea37b218e4a0e33609101fd76">var</a>) const </td></tr>
<tr class="memdesc:ad1f021480a019e739c54c8e107b27939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert one acceptance condition into the associated formula.  <a href="#ad1f021480a019e739c54c8e107b27939"></a><br/></td></tr>
<tr class="memitem:a7075f190e5d3a4face68a7a6e129eb95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#a7075f190e5d3a4face68a7a6e129eb95">register_anonymous_variables</a> (int n, const void *for_me)</td></tr>
<tr class="memdesc:a7075f190e5d3a4face68a7a6e129eb95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register anonymous BDD variables.  <a href="#a7075f190e5d3a4face68a7a6e129eb95"></a><br/></td></tr>
<tr class="memitem:af7e1e37179f390322da4d4cbf134b282"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#af7e1e37179f390322da4d4cbf134b282">register_all_variables_of</a> (const void *from_other, const void *for_me)</td></tr>
<tr class="memdesc:af7e1e37179f390322da4d4cbf134b282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate the variable usage of another object.  <a href="#af7e1e37179f390322da4d4cbf134b282"></a><br/></td></tr>
<tr class="memitem:a64b9d9dcc789312a700519388faf40e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#a64b9d9dcc789312a700519388faf40e8">unregister_all_my_variables</a> (const void *me)</td></tr>
<tr class="memdesc:a64b9d9dcc789312a700519388faf40e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release all variables used by an object.  <a href="#a64b9d9dcc789312a700519388faf40e8"></a><br/></td></tr>
<tr class="memitem:aa502521a61d81107e8c7ce5fab09ed7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#aa502521a61d81107e8c7ce5fab09ed7c">unregister_variable</a> (int <a class="el" href="classspot_1_1bdd__dict.html#afc6a898f172c6e90a19c4a85da9bbff6aa7285afea37b218e4a0e33609101fd76">var</a>, const void *me)</td></tr>
<tr class="memdesc:aa502521a61d81107e8c7ce5fab09ed7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a variable used by <em>me</em>.  <a href="#aa502521a61d81107e8c7ce5fab09ed7c"></a><br/></td></tr>
<tr class="memitem:ad5ce6572f9b85f7996f391276ea024f0"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#ad5ce6572f9b85f7996f391276ea024f0">dump</a> (std::ostream &amp;os) const </td></tr>
<tr class="memdesc:ad5ce6572f9b85f7996f391276ea024f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump all variables for debugging.  <a href="#ad5ce6572f9b85f7996f391276ea024f0"></a><br/></td></tr>
<tr class="memitem:a24d18da7cfd50865e23c32195e13f4d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#a24d18da7cfd50865e23c32195e13f4d4">assert_emptiness</a> () const </td></tr>
<tr class="memdesc:a24d18da7cfd50865e23c32195e13f4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure the dictionary is empty.  <a href="#a24d18da7cfd50865e23c32195e13f4d4"></a><br/></td></tr>
<tr class="memitem:a7b566c8e4046fe012d20e60ed4c058e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__allocator.html#a7b566c8e4046fe012d20e60ed4c058e9">allocate_variables</a> (int n)</td></tr>
<tr class="memdesc:a7b566c8e4046fe012d20e60ed4c058e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate <em>n</em> BDD variables.  <a href="#a7b566c8e4046fe012d20e60ed4c058e9"></a><br/></td></tr>
<tr class="memitem:a12efeee5e8c5786d814996cab0ec3097"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__allocator.html#a12efeee5e8c5786d814996cab0ec3097">release_variables</a> (int base, int n)</td></tr>
<tr class="memdesc:a12efeee5e8c5786d814996cab0ec3097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release <em>n</em> BDD variables starting at <em>base</em>.  <a href="#a12efeee5e8c5786d814996cab0ec3097"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0676f051e8333759c46e01e8a602eeaf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#a0676f051e8333759c46e01e8a602eeaf">is_registered_proposition</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f, const void *by_me)</td></tr>
<tr class="memitem:a91c13eeb02e0bddcbe0360a05f3dec05"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#a91c13eeb02e0bddcbe0360a05f3dec05">is_registered_state</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f, const void *by_me)</td></tr>
<tr class="memitem:a42a9f018f9b52e89b383b9dd722f80d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#a42a9f018f9b52e89b383b9dd722f80d1">is_registered_acceptance_variable</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f, const void *by_me)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1ca5ce94f2ce0de339fc7f59f1d0c2ff"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__allocator.html#a1ca5ce94f2ce0de339fc7f59f1d0c2ff">initialize</a> ()</td></tr>
<tr class="memdesc:a1ca5ce94f2ce0de339fc7f59f1d0c2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the BDD library.  <a href="#a1ca5ce94f2ce0de339fc7f59f1d0c2ff"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af654f827c195d9a47fb733a7c6341aae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1bdd__dict.html#a5bd5f592056f364fdd862a3e0de9fd22">fv_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#af654f827c195d9a47fb733a7c6341aae">now_map</a></td></tr>
<tr class="memdesc:af654f827c195d9a47fb733a7c6341aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps formulae to "Now" BDD variables.  <a href="#af654f827c195d9a47fb733a7c6341aae"></a><br/></td></tr>
<tr class="memitem:a9f47535b3c6ca438bb58975a240d783f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1bdd__dict.html#a5bd5f592056f364fdd862a3e0de9fd22">fv_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#a9f47535b3c6ca438bb58975a240d783f">var_map</a></td></tr>
<tr class="memdesc:a9f47535b3c6ca438bb58975a240d783f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps atomic propositions to BDD variables.  <a href="#a9f47535b3c6ca438bb58975a240d783f"></a><br/></td></tr>
<tr class="memitem:adea537e22c5889d908170b17ab8e8fd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1bdd__dict.html#a5bd5f592056f364fdd862a3e0de9fd22">fv_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#adea537e22c5889d908170b17ab8e8fd0">acc_map</a></td></tr>
<tr class="memdesc:adea537e22c5889d908170b17ab8e8fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps acceptance conditions to BDD variables.  <a href="#adea537e22c5889d908170b17ab8e8fd0"></a><br/></td></tr>
<tr class="memitem:a8358c623b5fe26e74d167e10d2033a92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1bdd__dict.html#aae899f4798d4177a007304f8cb6a7967">bdd_info_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#a8358c623b5fe26e74d167e10d2033a92">bdd_map</a></td></tr>
<tr class="memitem:a1ecc1ea5dd6b7cf1d89d7add2cd056de"><td class="memItemLeft" align="right" valign="top">bddPair *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#a1ecc1ea5dd6b7cf1d89d7add2cd056de">next_to_now</a></td></tr>
<tr class="memdesc:a1ecc1ea5dd6b7cf1d89d7add2cd056de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map Next variables to Now variables.  <a href="#a1ecc1ea5dd6b7cf1d89d7add2cd056de"></a><br/></td></tr>
<tr class="memitem:a27dd24fcedeb14ccc72df82be8588a41"><td class="memItemLeft" align="right" valign="top">bddPair *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#a27dd24fcedeb14ccc72df82be8588a41">now_to_next</a></td></tr>
<tr class="memdesc:a27dd24fcedeb14ccc72df82be8588a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map Now variables to Next variables.  <a href="#a27dd24fcedeb14ccc72df82be8588a41"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:ac2fa5711429e22d62e36d2298b8662c4"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; const void <br class="typebreak"/>
*, <a class="el" href="classspot_1_1bdd__dict_1_1anon__free__list.html">anon_free_list</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#ac2fa5711429e22d62e36d2298b8662c4">free_anonymous_list_of_type</a></td></tr>
<tr class="memdesc:ac2fa5711429e22d62e36d2298b8662c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of unused anonymous variable number for each automaton.  <a href="#ac2fa5711429e22d62e36d2298b8662c4"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:afc4bf1881835873c99827d4d42d63dd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1bdd__dict.html#ac2fa5711429e22d62e36d2298b8662c4">free_anonymous_list_of_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#afc4bf1881835873c99827d4d42d63dd7">free_anonymous_list_of</a></td></tr>
<tr class="memitem:a3736ca5090949c9fb93745544b95daab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__allocator.html#a3736ca5090949c9fb93745544b95daab">lvarnum</a></td></tr>
<tr class="memdesc:a3736ca5090949c9fb93745544b95daab"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of variables in use in this allocator.  <a href="#a3736ca5090949c9fb93745544b95daab"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a3916225a141645c15fa4d53848ef4f5e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__allocator.html#a3916225a141645c15fa4d53848ef4f5e">initialized</a></td></tr>
<tr class="memdesc:a3916225a141645c15fa4d53848ef4f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the BDD library has been initialized.  <a href="#a3916225a141645c15fa4d53848ef4f5e"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a0b647287ae4a25e1d72273a289eedbe6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#a0b647287ae4a25e1d72273a289eedbe6">bdd_dict</a> (const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> &amp;other)</td></tr>
<tr class="memitem:adc2ce6e1df9d89f44c51a2430d61270a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#adc2ce6e1df9d89f44c51a2430d61270a">operator=</a> (const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> &amp;other)</td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Map BDD variables to formulae. </p>
<p>The BDD library uses integers to designate Boolean variables in its decision diagrams. This class is used to map such integers to objects actually used in Spot. These objects are usually atomic propositions, but they can also be acceptance conditions, or "Now/Next" variables (although the latter should be eventually removed). </p>
</div><h2>Member Typedef Documentation</h2>
<a class="anchor" id="aae899f4798d4177a007304f8cb6a7967"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="structspot_1_1bdd__dict_1_1bdd__info.html">bdd_info</a>&gt; <a class="el" href="classspot_1_1bdd__dict.html#aae899f4798d4177a007304f8cb6a7967">spot::bdd_dict::bdd_info_map</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac2fa5711429e22d62e36d2298b8662c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;const void*, <a class="el" href="classspot_1_1bdd__dict_1_1anon__free__list.html">anon_free_list</a>&gt; <a class="el" href="classspot_1_1bdd__dict.html#ac2fa5711429e22d62e36d2298b8662c4">spot::bdd_dict::free_anonymous_list_of_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of unused anonymous variable number for each automaton. </p>

</div>
</div>
<a class="anchor" id="a5bd5f592056f364fdd862a3e0de9fd22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a>*, int&gt; <a class="el" href="classspot_1_1bdd__dict.html#a5bd5f592056f364fdd862a3e0de9fd22">spot::bdd_dict::fv_map</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formula-to-BDD-variable maps. </p>

</div>
</div>
<a class="anchor" id="a015d330da101dd646875b8ed1613a2d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt;const void*&gt; <a class="el" href="classspot_1_1bdd__dict.html#a015d330da101dd646875b8ed1613a2d6">spot::bdd_dict::ref_set</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>BDD-variable reference counts. </p>

</div>
</div>
<a class="anchor" id="ad0b9e89c7a60caad9e5786c82a15e0ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;int, const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a>*&gt; <a class="el" href="classspot_1_1bdd__dict.html#ad0b9e89c7a60caad9e5786c82a15e0ee">spot::bdd_dict::vf_map</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>BDD-variable-to-formula maps. </p>

</div>
</div>
<h2>Member Enumeration Documentation</h2>
<a class="anchor" id="afc6a898f172c6e90a19c4a85da9bbff6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classspot_1_1bdd__dict.html#afc6a898f172c6e90a19c4a85da9bbff6">spot::bdd_dict::var_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="afc6a898f172c6e90a19c4a85da9bbff6a3f82e03445f8367a00259465b12c6139"></a>anon</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afc6a898f172c6e90a19c4a85da9bbff6a47ba5912c7d3b8f51ea03cc885c26d4a"></a>now</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afc6a898f172c6e90a19c4a85da9bbff6a480d3c059c89672bc5f6d48fb1335e8c"></a>next</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afc6a898f172c6e90a19c4a85da9bbff6aa7285afea37b218e4a0e33609101fd76"></a>var</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afc6a898f172c6e90a19c4a85da9bbff6aba32cf3601484b8e31e7012534d7a089"></a>acc</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad2076425544919476f16812e2c9cc242"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spot::bdd_dict::bdd_dict </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af6f03983c2f4647cf0a192d5868c1b14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spot::bdd_dict::~bdd_dict </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0b647287ae4a25e1d72273a289eedbe6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">spot::bdd_dict::bdd_dict </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="a7b566c8e4046fe012d20e60ed4c058e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int spot::bdd_allocator::allocate_variables </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate <em>n</em> BDD variables. </p>

</div>
</div>
<a class="anchor" id="a24d18da7cfd50865e23c32195e13f4d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spot::bdd_dict::assert_emptiness </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make sure the dictionary is empty. </p>
<p>This will print diagnostics and abort if the dictionary is not empty. Use for debugging. </p>

</div>
</div>
<a class="anchor" id="ad5ce6572f9b85f7996f391276ea024f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::bdd_dict::dump </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump all variables for debugging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ca5ce94f2ce0de339fc7f59f1d0c2ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void spot::bdd_allocator::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the BDD library. </p>

</div>
</div>
<a class="anchor" id="a42a9f018f9b52e89b383b9dd722f80d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spot::bdd_dict::is_registered_acceptance_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>by_me</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classspot_1_1explicit__graph.html#ad008dd540c46610a706e4d69fbe72ba1">spot::explicit_graph&lt; State, tgba &gt;::has_acceptance_condition()</a>.</p>

</div>
</div>
<a class="anchor" id="a0676f051e8333759c46e01e8a602eeaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spot::bdd_dict::is_registered_proposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>by_me</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether formula <em>f</em> has already been registered by <em>by_me</em>. </p>

</div>
</div>
<a class="anchor" id="a91c13eeb02e0bddcbe0360a05f3dec05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spot::bdd_dict::is_registered_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>by_me</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae9584f1914c0f5dad897e60f5d560bb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a>* spot::bdd_dict::oneacc_to_formula </td>
          <td>(</td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>oneacc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert one acceptance condition into the associated formula. </p>
<p>This version accepts a conjunction of Acc variables, in which only one must be positive. This positive variable will be converted back into the associated formula.</p>
<p>The returned formula is not cloned, and is valid until the BDD variable used in <em>oneacc</em> are unregistered. </p>

</div>
</div>
<a class="anchor" id="ad1f021480a019e739c54c8e107b27939"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a>* spot::bdd_dict::oneacc_to_formula </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert one acceptance condition into the associated formula. </p>
<p>This version takes the number of a BDD variable that must has been returned by a call to <a class="el" href="classspot_1_1bdd__dict.html#abb27e26e93d99e046dbe9e9d0cb21485" title="Register an atomic proposition.">register_acceptance_variable()</a>.</p>
<p>The returned formula is not cloned, and is valid until the BDD variable <em>var</em> is unregistered. </p>

</div>
</div>
<a class="anchor" id="adc2ce6e1df9d89f44c51a2430d61270a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a>&amp; spot::bdd_dict::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abb27e26e93d99e046dbe9e9d0cb21485"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spot::bdd_dict::register_acceptance_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>for_me</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an atomic proposition. </p>
<p>Return (and maybe allocate) a BDD variable designating an acceptance set associated to formula <em>f</em>. The <em>for_me</em> argument should point to the object using this BDD variable, this is used for reference counting. It is perfectly safe to call this function several time with the same arguments.</p>
<dl class="section return"><dt>Returns</dt><dd>The variable number. Use bdd_ithvar() or bdd_nithvar() to convert this to a BDD. </dd></dl>

<p>Referenced by <a class="el" href="classspot_1_1taa__tgba__labelled.html#ad0950b337cb8d754cca4cea51a6cee26">spot::taa_tgba_labelled&lt; std::string, string_hash &gt;::add_acceptance_condition()</a>, and <a class="el" href="classspot_1_1explicit__graph.html#a0de8362b0ac23b5989550b2ea16ce43e">spot::explicit_graph&lt; State, tgba &gt;::declare_acceptance_condition()</a>.</p>

</div>
</div>
<a class="anchor" id="ac4e496809f4027831aed7457fc8b7f3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spot::bdd_dict::register_acceptance_variables </td>
          <td>(</td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>for_me</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register BDD variables as acceptance variables. </p>
<p>Register all variables occurring in <em>f</em> as acceptance variables used by <em>for_me</em>. This assumes that these acceptance variables are already known from the dictionary (i.e., they have already been registered by <a class="el" href="classspot_1_1bdd__dict.html#abb27e26e93d99e046dbe9e9d0cb21485" title="Register an atomic proposition.">register_acceptance_variable()</a> for another automaton). </p>

<p>Referenced by <a class="el" href="classspot_1_1explicit__graph.html#ad36ec6dd37dbbb1b1f64ad6b9d22e35f">spot::explicit_graph&lt; State, tgba &gt;::add_acceptance_conditions()</a>, <a class="el" href="classspot_1_1explicit__graph.html#a6ed023d767a97f41836787123cd82dce">spot::explicit_graph&lt; State, tgba &gt;::copy_acceptance_conditions_of()</a>, and <a class="el" href="classspot_1_1explicit__graph.html#a8237bac44dabf3ced482b99a65f72530">spot::explicit_graph&lt; State, tgba &gt;::set_acceptance_conditions()</a>.</p>

</div>
</div>
<a class="anchor" id="af7e1e37179f390322da4d4cbf134b282"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spot::bdd_dict::register_all_variables_of </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>from_other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>for_me</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate the variable usage of another object. </p>
<p>This tells this dictionary that the <em>for_me</em> object will be using the same BDD variables as the <em>from_other</em> objects. This ensure that the variables won't be freed when <em>from_other</em> is deleted if <em>from_other</em> is still alive. </p>

</div>
</div>
<a class="anchor" id="a7075f190e5d3a4face68a7a6e129eb95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spot::bdd_dict::register_anonymous_variables </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>for_me</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register anonymous BDD variables. </p>
<p>Return (and maybe allocate) <em>n</em> consecutive BDD variables which will be used only by <em>for_me</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>The variable number. Use bdd_ithvar() or bdd_nithvar() to convert this to a BDD. </dd></dl>

</div>
</div>
<a class="anchor" id="abebfcb644db70ac9368ff316317059a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spot::bdd_dict::register_clone_acc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>for_me</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clone an acceptance variable VAR for FOR_ME. </p>
<p>This is used in products TGBAs when both operands share the same acceptance variables but they need to be distinguished in the result. </p>

</div>
</div>
<a class="anchor" id="a6095afcbbb4fbe67066d51169e80d333"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spot::bdd_dict::register_proposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>for_me</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an atomic proposition. </p>
<p>Return (and maybe allocate) a BDD variable designating formula <em>f</em>. The <em>for_me</em> argument should point to the object using this BDD variable, this is used for reference counting. It is perfectly safe to call this function several time with the same arguments.</p>
<dl class="section return"><dt>Returns</dt><dd>The variable number. Use bdd_ithvar() or bdd_nithvar() to convert this to a BDD. </dd></dl>

</div>
</div>
<a class="anchor" id="abb99eed0b49ffba5229af45ef7c1e05f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spot::bdd_dict::register_propositions </td>
          <td>(</td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>for_me</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register BDD variables as atomic propositions. </p>
<p>Register all variables occurring in <em>f</em> as atomic propositions used by <em>for_me</em>. This assumes that these atomic propositions are already known from the dictionary (i.e., they have already been registered by <a class="el" href="classspot_1_1bdd__dict.html#a6095afcbbb4fbe67066d51169e80d333" title="Register an atomic proposition.">register_proposition()</a> for another automaton). </p>

<p>Referenced by <a class="el" href="classspot_1_1explicit__graph.html#abc0817f65d9694dea39dde4f87a05808">spot::explicit_graph&lt; State, tgba &gt;::add_conditions()</a>.</p>

</div>
</div>
<a class="anchor" id="ac5b0d292aafacbfbbd233080fe4a4ad0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spot::bdd_dict::register_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>for_me</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a couple of Now/Next variables. </p>
<p>Return (and maybe allocate) two BDD variables for a state associated to formula <em>f</em>. The <em>for_me</em> argument should point to the object using this BDD variable, this is used for reference counting. It is perfectly safe to call this function several time with the same arguments.</p>
<dl class="section return"><dt>Returns</dt><dd>The first variable number. Add one to get the second variable. Use bdd_ithvar() or bdd_nithvar() to convert this to a BDD. </dd></dl>

</div>
</div>
<a class="anchor" id="a12efeee5e8c5786d814996cab0ec3097"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void spot::bdd_allocator::release_variables </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release <em>n</em> BDD variables starting at <em>base</em>. </p>

</div>
</div>
<a class="anchor" id="a64b9d9dcc789312a700519388faf40e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spot::bdd_dict::unregister_all_my_variables </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>me</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release all variables used by an object. </p>
<p>Usually called in the destructor if <em>me</em>. </p>

<p>Referenced by <a class="el" href="classspot_1_1explicit__graph.html#a686bf7e2dc9bcbedc143df5ba2968140">spot::explicit_graph&lt; State, tgba &gt;::~explicit_graph()</a>.</p>

</div>
</div>
<a class="anchor" id="aa502521a61d81107e8c7ce5fab09ed7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spot::bdd_dict::unregister_variable </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>me</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a variable used by <em>me</em>. </p>

</div>
</div>
<h2>Member Data Documentation</h2>
<a class="anchor" id="adea537e22c5889d908170b17ab8e8fd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspot_1_1bdd__dict.html#a5bd5f592056f364fdd862a3e0de9fd22">fv_map</a> spot::bdd_dict::acc_map</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps acceptance conditions to BDD variables. </p>

<p>Referenced by <a class="el" href="classspot_1_1taa__tgba__labelled.html#ad0950b337cb8d754cca4cea51a6cee26">spot::taa_tgba_labelled&lt; std::string, string_hash &gt;::add_acceptance_condition()</a>, and <a class="el" href="classspot_1_1explicit__graph.html#aecfd009b99ef9476ae1632383bc85e91">spot::explicit_graph&lt; State, tgba &gt;::get_acceptance_condition()</a>.</p>

</div>
</div>
<a class="anchor" id="a8358c623b5fe26e74d167e10d2033a92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspot_1_1bdd__dict.html#aae899f4798d4177a007304f8cb6a7967">bdd_info_map</a> spot::bdd_dict::bdd_map</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afc4bf1881835873c99827d4d42d63dd7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspot_1_1bdd__dict.html#ac2fa5711429e22d62e36d2298b8662c4">free_anonymous_list_of_type</a> spot::bdd_dict::free_anonymous_list_of</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3916225a141645c15fa4d53848ef4f5e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool spot::bdd_allocator::initialized</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the BDD library has been initialized. </p>

</div>
</div>
<a class="anchor" id="a3736ca5090949c9fb93745544b95daab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int spot::bdd_allocator::lvarnum</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number of variables in use in this allocator. </p>

</div>
</div>
<a class="anchor" id="a1ecc1ea5dd6b7cf1d89d7add2cd056de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bddPair* spot::bdd_dict::next_to_now</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map Next variables to Now variables. </p>
<p>Use with BuDDy's bdd_replace() function. </p>

</div>
</div>
<a class="anchor" id="af654f827c195d9a47fb733a7c6341aae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspot_1_1bdd__dict.html#a5bd5f592056f364fdd862a3e0de9fd22">fv_map</a> spot::bdd_dict::now_map</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps formulae to "Now" BDD variables. </p>

</div>
</div>
<a class="anchor" id="a27dd24fcedeb14ccc72df82be8588a41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bddPair* spot::bdd_dict::now_to_next</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map Now variables to Next variables. </p>
<p>Use with BuDDy's bdd_replace() function. </p>

</div>
</div>
<a class="anchor" id="a9f47535b3c6ca438bb58975a240d783f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspot_1_1bdd__dict.html#a5bd5f592056f364fdd862a3e0de9fd22">fv_map</a> spot::bdd_dict::var_map</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps atomic propositions to BDD variables. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>tgba/<a class="el" href="bdddict_8hh_source.html">bdddict.hh</a></li>
</ul>
</div><!-- contents -->
<hr size="1">
Please <b>comment</b> this page and <b>report errors</b> about it on
<a href="http://spot.lip6.fr/wiki/RefDocComments">the RefDocComments page</a>.
<br><address style="align: right;"><small>
Generated on Sat Oct 27 2012 09:34:33 for spot by <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border=0></a> 1.8.1.2</small></address>
</body>
</html>
