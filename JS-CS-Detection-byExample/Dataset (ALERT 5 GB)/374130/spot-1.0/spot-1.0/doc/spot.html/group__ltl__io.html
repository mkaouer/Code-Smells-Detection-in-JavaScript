<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>spot: Input/Output of LTL formulae</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">spot
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Input/Output of LTL formulae</div>  </div>
<div class="ingroups"><a class="el" href="group__ltl__algorithm.html">Algorithms for LTL formulae</a></div></div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1ltl__file.html">spot::ltl::ltl_file</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read LTL formulae from a file, one by one.  <a href="classspot_1_1ltl_1_1ltl__file.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1random__formula.html">spot::ltl::random_formula</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for random formula generators.  <a href="classspot_1_1ltl_1_1random__formula.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1random__ltl.html">spot::ltl::random_ltl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate random LTL formulae.This class recursively constructs LTL formulae of a given size. The formulae will use the use atomic propositions from the set of propositions passed to the constructor, in addition to the constant and all LTL operators supported by Spot.  <a href="classspot_1_1ltl_1_1random__ltl.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1random__boolean.html">spot::ltl::random_boolean</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate random Boolean formulae.This class recursively constructs Boolean formulae of a given size. The formulae will use the use atomic propositions from the set of propositions passed to the constructor, in addition to the constant and all Boolean operators supported by Spot.  <a href="classspot_1_1ltl_1_1random__boolean.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1random__sere.html">spot::ltl::random_sere</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate random SERE.This class recursively constructs SERE of a given size. The formulae will use the use atomic propositions from the set of propositions passed to the constructor, in addition to the constant and all SERE operators supported by Spot.  <a href="classspot_1_1ltl_1_1random__sere.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1random__psl.html">spot::ltl::random_psl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate random PSL formulae.This class recursively constructs PSL formulae of a given size. The formulae will use the use atomic propositions from the set of propositions passed to the constructor, in addition to the constant and all PSL operators supported by Spot.  <a href="classspot_1_1ltl_1_1random__psl.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf0c33c18fcffd60a2c676bdc6b5214de"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; std::string, <br class="typebreak"/>
std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#gaf0c33c18fcffd60a2c676bdc6b5214de">spot::eltl::spair</a></td></tr>
<tr class="memitem:ga502251e9b247bf1f614b151254048b2e"><td class="memItemLeft" align="right" valign="top">typedef std::pair<br class="typebreak"/>
&lt; <a class="el" href="classeltlyy_1_1location.html">eltlyy::location</a>, spair &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga502251e9b247bf1f614b151254048b2e">spot::eltl::parse_error</a></td></tr>
<tr class="memdesc:ga502251e9b247bf1f614b151254048b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parse diagnostic &lt;location, &lt;file, message&gt;&gt;.  <a href="#ga502251e9b247bf1f614b151254048b2e"></a><br/></td></tr>
<tr class="memitem:ga017167786b87df9a15ec651897ed5cb0"><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; parse_error &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga017167786b87df9a15ec651897ed5cb0">spot::eltl::parse_error_list</a></td></tr>
<tr class="memdesc:ga017167786b87df9a15ec651897ed5cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of parser diagnostics, as filled by parse.  <a href="#ga017167786b87df9a15ec651897ed5cb0"></a><br/></td></tr>
<tr class="memitem:ga9bf19c38b4ae7d74e6a9633ed360c147"><td class="memItemLeft" align="right" valign="top">typedef std::pair<br class="typebreak"/>
&lt; <a class="el" href="classltlyy_1_1location.html">ltlyy::location</a>, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga9bf19c38b4ae7d74e6a9633ed360c147">spot::ltl::parse_error</a></td></tr>
<tr class="memdesc:ga9bf19c38b4ae7d74e6a9633ed360c147"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parse diagnostic with its location.  <a href="#ga9bf19c38b4ae7d74e6a9633ed360c147"></a><br/></td></tr>
<tr class="memitem:ga9eb0f7867a212f92b0fd64a6ac5a12cd"><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; parse_error &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga9eb0f7867a212f92b0fd64a6ac5a12cd">spot::ltl::parse_error_list</a></td></tr>
<tr class="memdesc:ga9eb0f7867a212f92b0fd64a6ac5a12cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of parser diagnostics, as filled by parse.  <a href="#ga9eb0f7867a212f92b0fd64a6ac5a12cd"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa412b16e3eaa3d209baf83cb6e697161"><td class="memItemLeft" align="right" valign="top">const formula *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#gaa412b16e3eaa3d209baf83cb6e697161">spot::eltl::parse_file</a> (const std::string &amp;filename, parse_error_list &amp;error_list, environment &amp;env=default_environment::instance(), bool debug=false)</td></tr>
<tr class="memdesc:gaa412b16e3eaa3d209baf83cb6e697161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a formula from a text file.  <a href="#gaa412b16e3eaa3d209baf83cb6e697161"></a><br/></td></tr>
<tr class="memitem:gaf7928088c7a4d788cbef32258bb4875e"><td class="memItemLeft" align="right" valign="top">const formula *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#gaf7928088c7a4d788cbef32258bb4875e">spot::eltl::parse_string</a> (const std::string &amp;eltl_string, parse_error_list &amp;error_list, environment &amp;env=default_environment::instance(), bool debug=false)</td></tr>
<tr class="memdesc:gaf7928088c7a4d788cbef32258bb4875e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a formula from an ELTL string.  <a href="#gaf7928088c7a4d788cbef32258bb4875e"></a><br/></td></tr>
<tr class="memitem:ga12db416891d2b540640c434afd0e5859"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga12db416891d2b540640c434afd0e5859">spot::eltl::format_parse_errors</a> (std::ostream &amp;os, parse_error_list &amp;error_list)</td></tr>
<tr class="memdesc:ga12db416891d2b540640c434afd0e5859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format diagnostics produced by spot::eltl::parse.  <a href="#ga12db416891d2b540640c434afd0e5859"></a><br/></td></tr>
<tr class="memitem:ga38985ad6b8ca53a130115aff8a055036"><td class="memItemLeft" align="right" valign="top">const formula *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga38985ad6b8ca53a130115aff8a055036">spot::ltl::parse</a> (const std::string &amp;ltl_string, parse_error_list &amp;error_list, environment &amp;env=default_environment::instance(), bool debug=false, bool lenient=false)</td></tr>
<tr class="memdesc:ga38985ad6b8ca53a130115aff8a055036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a formula from an LTL string.  <a href="#ga38985ad6b8ca53a130115aff8a055036"></a><br/></td></tr>
<tr class="memitem:ga996c2f45174a66ee4ab85958900a1417"><td class="memItemLeft" align="right" valign="top">const formula *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga996c2f45174a66ee4ab85958900a1417">spot::ltl::parse_boolean</a> (const std::string &amp;ltl_string, parse_error_list &amp;error_list, environment &amp;env=default_environment::instance(), bool debug=false, bool lenient=false)</td></tr>
<tr class="memdesc:ga996c2f45174a66ee4ab85958900a1417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a Boolean formula from a string.  <a href="#ga996c2f45174a66ee4ab85958900a1417"></a><br/></td></tr>
<tr class="memitem:ga127ae53eca0defd994401f3919e2a0d2"><td class="memItemLeft" align="right" valign="top">const formula *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga127ae53eca0defd994401f3919e2a0d2">spot::ltl::parse_lbt</a> (const std::string &amp;ltl_string, parse_error_list &amp;error_list, environment &amp;env=default_environment::instance(), bool debug=false)</td></tr>
<tr class="memdesc:ga127ae53eca0defd994401f3919e2a0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a formula from an LTL string in LBT's format.  <a href="#ga127ae53eca0defd994401f3919e2a0d2"></a><br/></td></tr>
<tr class="memitem:ga6a393a2f2a36d1f4aad872cb12ae76bf"><td class="memItemLeft" align="right" valign="top">const formula *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga6a393a2f2a36d1f4aad872cb12ae76bf">spot::ltl::parse_sere</a> (const std::string &amp;sere_string, parse_error_list &amp;error_list, environment &amp;env=default_environment::instance(), bool debug=false, bool lenient=false)</td></tr>
<tr class="memdesc:ga6a393a2f2a36d1f4aad872cb12ae76bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a formula from a string representing a SERE.  <a href="#ga6a393a2f2a36d1f4aad872cb12ae76bf"></a><br/></td></tr>
<tr class="memitem:ga5535f3e1304089c8c6e13f564920ce00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga5535f3e1304089c8c6e13f564920ce00">spot::ltl::format_parse_errors</a> (std::ostream &amp;os, const std::string &amp;input_string, const parse_error_list &amp;error_list)</td></tr>
<tr class="memdesc:ga5535f3e1304089c8c6e13f564920ce00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format diagnostics produced by <a class="el" href="group__ltl__io.html#ga38985ad6b8ca53a130115aff8a055036" title="Build a formula from an LTL string.">spot::ltl::parse</a> or spot::ltl::ratexp.  <a href="#ga5535f3e1304089c8c6e13f564920ce00"></a><br/></td></tr>
<tr class="memitem:ga8fb520dd0b7b2ca3d828ea6cdfaf49b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga8fb520dd0b7b2ca3d828ea6cdfaf49b6">spot::ltl::fix_utf8_locations</a> (const std::string &amp;ltl_string, parse_error_list &amp;error_list)</td></tr>
<tr class="memdesc:ga8fb520dd0b7b2ca3d828ea6cdfaf49b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fix location of diagnostics assuming the input is utf8.  <a href="#ga8fb520dd0b7b2ca3d828ea6cdfaf49b6"></a><br/></td></tr>
<tr class="memitem:ga7e27d31b2209954c1d57d3b8b5224473"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga7e27d31b2209954c1d57d3b8b5224473">spot::ltl::dotty</a> (std::ostream &amp;os, const formula *f)</td></tr>
<tr class="memdesc:ga7e27d31b2209954c1d57d3b8b5224473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a formula tree using dot's syntax.  <a href="#ga7e27d31b2209954c1d57d3b8b5224473"></a><br/></td></tr>
<tr class="memitem:gaaf316635f1320fa38885fa89e23e2098"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#gaaf316635f1320fa38885fa89e23e2098">spot::ltl::dump</a> (std::ostream &amp;os, const formula *f)</td></tr>
<tr class="memdesc:gaaf316635f1320fa38885fa89e23e2098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a formula tree.  <a href="#gaaf316635f1320fa38885fa89e23e2098"></a><br/></td></tr>
<tr class="memitem:ga49b892ff2e4d9aec61c271959460ad12"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga49b892ff2e4d9aec61c271959460ad12">spot::ltl::to_lbt_string</a> (const formula *f, std::ostream &amp;os)</td></tr>
<tr class="memdesc:ga49b892ff2e4d9aec61c271959460ad12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output an LTL formula as a string in LBT's format.  <a href="#ga49b892ff2e4d9aec61c271959460ad12"></a><br/></td></tr>
<tr class="memitem:gae7e461087003b093571f87640dab9045"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#gae7e461087003b093571f87640dab9045">spot::ltl::to_lbt_string</a> (const formula *f)</td></tr>
<tr class="memdesc:gae7e461087003b093571f87640dab9045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output an LTL formula as a string in LBT's format.  <a href="#gae7e461087003b093571f87640dab9045"></a><br/></td></tr>
<tr class="memitem:ga0f6fa636f033da650016c836d6c94215"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga0f6fa636f033da650016c836d6c94215">spot::ltl::to_string</a> (const formula *f, std::ostream &amp;os, bool full_parent=false, bool ratexp=false)</td></tr>
<tr class="memdesc:ga0f6fa636f033da650016c836d6c94215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a formula as a string which is parsable unless the formula contains automaton operators (used in ELTL formulae).  <a href="#ga0f6fa636f033da650016c836d6c94215"></a><br/></td></tr>
<tr class="memitem:ga41c884625ab680e8b8e3f2c60d58fd0e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga41c884625ab680e8b8e3f2c60d58fd0e">spot::ltl::to_string</a> (const formula *f, bool full_parent=false, bool ratexp=false)</td></tr>
<tr class="memdesc:ga41c884625ab680e8b8e3f2c60d58fd0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a formula as a string which is parsable unless the formula contains automaton operators (used in ELTL formulae).  <a href="#ga41c884625ab680e8b8e3f2c60d58fd0e"></a><br/></td></tr>
<tr class="memitem:ga839a34e0b8a9261d039177a3546f5501"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga839a34e0b8a9261d039177a3546f5501">spot::ltl::to_utf8_string</a> (const formula *f, std::ostream &amp;os, bool full_parent=false, bool ratexp=false)</td></tr>
<tr class="memdesc:ga839a34e0b8a9261d039177a3546f5501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a formula as an utf8 string which is parsable unless the formula contains automaton operators (used in ELTL formulae).  <a href="#ga839a34e0b8a9261d039177a3546f5501"></a><br/></td></tr>
<tr class="memitem:ga2cd5cc7892c33dfbedafe28e102f0834"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga2cd5cc7892c33dfbedafe28e102f0834">spot::ltl::to_utf8_string</a> (const formula *f, bool full_parent=false, bool ratexp=false)</td></tr>
<tr class="memdesc:ga2cd5cc7892c33dfbedafe28e102f0834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a formula as an utf8 string which is parsable unless the formula contains automaton operators (used in ELTL formulae).  <a href="#ga2cd5cc7892c33dfbedafe28e102f0834"></a><br/></td></tr>
<tr class="memitem:ga0a8dd6d9bb385a69fabea697df9be925"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga0a8dd6d9bb385a69fabea697df9be925">spot::ltl::to_spin_string</a> (const formula *f, std::ostream &amp;os, bool full_parent=false)</td></tr>
<tr class="memdesc:ga0a8dd6d9bb385a69fabea697df9be925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a formula as a string parsable by Spin.  <a href="#ga0a8dd6d9bb385a69fabea697df9be925"></a><br/></td></tr>
<tr class="memitem:ga62c230f1cb3170370c25d8bffb4ea141"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga62c230f1cb3170370c25d8bffb4ea141">spot::ltl::to_spin_string</a> (const formula *f, bool full_parent=false)</td></tr>
<tr class="memdesc:ga62c230f1cb3170370c25d8bffb4ea141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a formula into a string parsable by Spin.  <a href="#ga62c230f1cb3170370c25d8bffb4ea141"></a><br/></td></tr>
<tr class="memitem:ga91c4e60cf307d560694b163676ec2c6a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga91c4e60cf307d560694b163676ec2c6a">spot::ltl::to_wring_string</a> (const formula *f, std::ostream &amp;os)</td></tr>
<tr class="memdesc:ga91c4e60cf307d560694b163676ec2c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a formula as a string parsable by Wring.  <a href="#ga91c4e60cf307d560694b163676ec2c6a"></a><br/></td></tr>
<tr class="memitem:gab337644a8e96528226e22cf166dc0977"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#gab337644a8e96528226e22cf166dc0977">spot::ltl::to_wring_string</a> (const formula *f)</td></tr>
<tr class="memdesc:gab337644a8e96528226e22cf166dc0977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a formula into a string parsable by Wring.  <a href="#gab337644a8e96528226e22cf166dc0977"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<h2>Typedef Documentation</h2>
<a class="anchor" id="ga9bf19c38b4ae7d74e6a9633ed360c147"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;<a class="el" href="classltlyy_1_1location.html">ltlyy::location</a>, std::string&gt; <a class="el" href="group__ltl__io.html#ga9bf19c38b4ae7d74e6a9633ed360c147">spot::ltl::parse_error</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A parse diagnostic with its location. </p>

</div>
</div>
<a class="anchor" id="ga502251e9b247bf1f614b151254048b2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;<a class="el" href="classeltlyy_1_1location.html">eltlyy::location</a>, spair&gt; <a class="el" href="group__ltl__io.html#ga502251e9b247bf1f614b151254048b2e">spot::eltl::parse_error</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A parse diagnostic &lt;location, &lt;file, message&gt;&gt;. </p>

</div>
</div>
<a class="anchor" id="ga9eb0f7867a212f92b0fd64a6ac5a12cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;parse_error&gt; <a class="el" href="group__ltl__io.html#ga9eb0f7867a212f92b0fd64a6ac5a12cd">spot::ltl::parse_error_list</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A list of parser diagnostics, as filled by parse. </p>

</div>
</div>
<a class="anchor" id="ga017167786b87df9a15ec651897ed5cb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;parse_error&gt; <a class="el" href="group__ltl__io.html#ga017167786b87df9a15ec651897ed5cb0">spot::eltl::parse_error_list</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A list of parser diagnostics, as filled by parse. </p>

</div>
</div>
<a class="anchor" id="gaf0c33c18fcffd60a2c676bdc6b5214de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;std::string, std::string&gt; <a class="el" href="group__ltl__io.html#gaf0c33c18fcffd60a2c676bdc6b5214de">spot::eltl::spair</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="ga7e27d31b2209954c1d57d3b8b5224473"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::ltl::dotty </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a formula tree using dot's syntax. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The stream where it should be output. </td></tr>
    <tr><td class="paramname">f</td><td>The formula to translate.</td></tr>
  </table>
  </dd>
</dl>
<p><code>dot</code> is part of the GraphViz package <a href="http://www.research.att.com/sw/tools/graphviz/">http://www.research.att.com/sw/tools/graphviz/</a> </p>

</div>
</div>
<a class="anchor" id="gaaf316635f1320fa38885fa89e23e2098"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::ltl::dump </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a formula tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The stream where it should be output. </td></tr>
    <tr><td class="paramname">f</td><td>The formula to dump.</td></tr>
  </table>
  </dd>
</dl>
<p>This is useful to display a formula when debugging. </p>

</div>
</div>
<a class="anchor" id="ga8fb520dd0b7b2ca3d828ea6cdfaf49b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spot::ltl::fix_utf8_locations </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ltl_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parse_error_list &amp;&#160;</td>
          <td class="paramname"><em>error_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fix location of diagnostics assuming the input is utf8. </p>
<p>The <a class="el" href="group__ltl__io.html#ga38985ad6b8ca53a130115aff8a055036" title="Build a formula from an LTL string.">spot::ltl::parse()</a> and <a class="el" href="group__ltl__io.html#ga6a393a2f2a36d1f4aad872cb12ae76bf" title="Build a formula from a string representing a SERE.">spot::ltl::parse_sere()</a> function return a parse_error_list that contain locations specified at the byte level. Although these parser recognize some utf8 characters they only work byte by byte and will report positions by counting byte.</p>
<p>This function fixes the positions returned by the parser to look correct when the string is interpreted as a utf8-encoded string.</p>
<p>It is invalid to call this function on a string that is not valid utf8.</p>
<p>You should NOT call this function before calling <a class="el" href="group__ltl__io.html#ga5535f3e1304089c8c6e13f564920ce00" title="Format diagnostics produced by spot::ltl::parse or spot::ltl::ratexp.">spot::ltl::format_parse_errors()</a> because it is already called inside if needed. You may need this function only if you want to write your own error reporting code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_string</td><td>The string that were parsed. </td></tr>
    <tr><td class="paramname">error_list</td><td>The error list filled by <a class="el" href="group__ltl__io.html#ga38985ad6b8ca53a130115aff8a055036" title="Build a formula from an LTL string.">spot::ltl::parse</a> or <a class="el" href="group__ltl__io.html#ga6a393a2f2a36d1f4aad872cb12ae76bf" title="Build a formula from a string representing a SERE.">spot::ltl::parse_sere</a> while parsing <em>input_string</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga12db416891d2b540640c434afd0e5859"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spot::eltl::format_parse_errors </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parse_error_list &amp;&#160;</td>
          <td class="paramname"><em>error_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format diagnostics produced by spot::eltl::parse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Where diagnostics should be output. </td></tr>
    <tr><td class="paramname">error_list</td><td>The error list filled by spot::eltl::parse while parsing <em>eltl_string</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff any diagnostic was output. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5535f3e1304089c8c6e13f564920ce00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spot::ltl::format_parse_errors </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const parse_error_list &amp;&#160;</td>
          <td class="paramname"><em>error_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format diagnostics produced by <a class="el" href="group__ltl__io.html#ga38985ad6b8ca53a130115aff8a055036" title="Build a formula from an LTL string.">spot::ltl::parse</a> or spot::ltl::ratexp. </p>
<p>If the string is utf8 encoded, <a class="el" href="group__ltl__io.html#ga8fb520dd0b7b2ca3d828ea6cdfaf49b6" title="Fix location of diagnostics assuming the input is utf8.">spot::ltl::fix_utf8_locations()</a> will be used to report correct utf8 locations (assuming the output is utf8 aware). Nonetheless, the supplied <em>error_list</em> will not be modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Where diagnostics should be output. </td></tr>
    <tr><td class="paramname">input_string</td><td>The string that were parsed. </td></tr>
    <tr><td class="paramname">error_list</td><td>The error list filled by <a class="el" href="group__ltl__io.html#ga38985ad6b8ca53a130115aff8a055036" title="Build a formula from an LTL string.">spot::ltl::parse</a> or <a class="el" href="group__ltl__io.html#ga6a393a2f2a36d1f4aad872cb12ae76bf" title="Build a formula from a string representing a SERE.">spot::ltl::parse_sere</a> while parsing <em>input_string</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff any diagnostic was output. </dd></dl>

</div>
</div>
<a class="anchor" id="ga38985ad6b8ca53a130115aff8a055036"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const formula* spot::ltl::parse </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ltl_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parse_error_list &amp;&#160;</td>
          <td class="paramname"><em>error_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">environment &amp;&#160;</td>
          <td class="paramname"><em>env</em> = <code>default_environment::instance()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lenient</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a formula from an LTL string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ltl_string</td><td>The string to parse. </td></tr>
    <tr><td class="paramname">error_list</td><td>A list that will be filled with parse errors that occured during parsing. </td></tr>
    <tr><td class="paramname">env</td><td>The environment into which parsing should take place. </td></tr>
    <tr><td class="paramname">debug</td><td>When true, causes the parser to trace its execution. </td></tr>
    <tr><td class="paramname">lenient</td><td>When true, parenthesized blocks that cannot be parsed as subformulas will be considered as atomic propositions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the formula built from <em>ltl_string</em>, or 0 if the input was unparsable.</dd></dl>
<p>Note that the parser usually tries to recover from errors. It can return a non zero value even if it encountered error during the parsing of <em>ltl_string</em>. If you want to make sure <em>ltl_string</em> was parsed succesfully, check <em>error_list</em> for emptiness.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function is not reentrant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga996c2f45174a66ee4ab85958900a1417"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const formula* spot::ltl::parse_boolean </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ltl_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parse_error_list &amp;&#160;</td>
          <td class="paramname"><em>error_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">environment &amp;&#160;</td>
          <td class="paramname"><em>env</em> = <code>default_environment::instance()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lenient</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a Boolean formula from a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ltl_string</td><td>The string to parse. </td></tr>
    <tr><td class="paramname">error_list</td><td>A list that will be filled with parse errors that occured during parsing. </td></tr>
    <tr><td class="paramname">env</td><td>The environment into which parsing should take place. </td></tr>
    <tr><td class="paramname">debug</td><td>When true, causes the parser to trace its execution. </td></tr>
    <tr><td class="paramname">lenient</td><td>When true, parenthesized blocks that cannot be parsed as subformulas will be considered as atomic propositions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the formula built from <em>ltl_string</em>, or 0 if the input was unparsable.</dd></dl>
<p>Note that the parser usually tries to recover from errors. It can return a non zero value even if it encountered error during the parsing of <em>ltl_string</em>. If you want to make sure <em>ltl_string</em> was parsed succesfully, check <em>error_list</em> for emptiness.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function is not reentrant. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa412b16e3eaa3d209baf83cb6e697161"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const formula* spot::eltl::parse_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parse_error_list &amp;&#160;</td>
          <td class="paramname"><em>error_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">environment &amp;&#160;</td>
          <td class="paramname"><em>env</em> = <code>default_environment::instance()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a formula from a text file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the file to parse. </td></tr>
    <tr><td class="paramname">error_list</td><td>A list that will be filled with parse errors that occured during parsing. </td></tr>
    <tr><td class="paramname">env</td><td>The environment into which parsing should take place. </td></tr>
    <tr><td class="paramname">debug</td><td>When true, causes the parser to trace its execution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the tgba built from <em>filename</em>, or 0 if the file could not be opened.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is not reentrant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga127ae53eca0defd994401f3919e2a0d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const formula* spot::ltl::parse_lbt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ltl_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parse_error_list &amp;&#160;</td>
          <td class="paramname"><em>error_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">environment &amp;&#160;</td>
          <td class="paramname"><em>env</em> = <code>default_environment::instance()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a formula from an LTL string in LBT's format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ltl_string</td><td>The string to parse. </td></tr>
    <tr><td class="paramname">error_list</td><td>A list that will be filled with parse errors that occured during parsing. </td></tr>
    <tr><td class="paramname">env</td><td>The environment into which parsing should take place. </td></tr>
    <tr><td class="paramname">debug</td><td>When true, causes the parser to trace its execution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the formula built from <em>ltl_string</em>, or 0 if the input was unparsable.</dd></dl>
<p>Note that the parser usually tries to recover from errors. It can return an non zero value even if it encountered error during the parsing of <em>ltl_string</em>. If you want to make sure <em>ltl_string</em> was parsed succesfully, check <em>error_list</em> for emptiness.</p>
<p>The LBT syntax, also used by the lbtt and scheck tools, is extended to support W, and M operators (as done in lbtt), and double-quoted atomic propositions that do not start with 'p'.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function is not reentrant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6a393a2f2a36d1f4aad872cb12ae76bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const formula* spot::ltl::parse_sere </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sere_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parse_error_list &amp;&#160;</td>
          <td class="paramname"><em>error_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">environment &amp;&#160;</td>
          <td class="paramname"><em>env</em> = <code>default_environment::instance()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lenient</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a formula from a string representing a SERE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sere_string</td><td>The string to parse. </td></tr>
    <tr><td class="paramname">error_list</td><td>A list that will be filled with parse errors that occured during parsing. </td></tr>
    <tr><td class="paramname">env</td><td>The environment into which parsing should take place. </td></tr>
    <tr><td class="paramname">debug</td><td>When true, causes the parser to trace its execution. </td></tr>
    <tr><td class="paramname">lenient</td><td>When true, parenthesized blocks that cannot be parsed as subformulas will be considered as atomic propositions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the formula built from <em>sere_string</em>, or 0 if the input was unparsable.</dd></dl>
<p>Note that the parser usually tries to recover from errors. It can return an non zero value even if it encountered error during the parsing of <em>ltl_string</em>. If you want to make sure <em>ltl_string</em> was parsed succesfully, check <em>error_list</em> for emptiness.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function is not reentrant. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf7928088c7a4d788cbef32258bb4875e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const formula* spot::eltl::parse_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>eltl_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parse_error_list &amp;&#160;</td>
          <td class="paramname"><em>error_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">environment &amp;&#160;</td>
          <td class="paramname"><em>env</em> = <code>default_environment::instance()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a formula from an ELTL string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eltl_string</td><td>The string to parse. </td></tr>
    <tr><td class="paramname">error_list</td><td>A list that will be filled with parse errors that occured during parsing. </td></tr>
    <tr><td class="paramname">env</td><td>The environment into which parsing should take place. </td></tr>
    <tr><td class="paramname">debug</td><td>When true, causes the parser to trace its execution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the formula built from <em>eltl_string</em>, or 0 if the input was unparsable.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is not reentrant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga49b892ff2e4d9aec61c271959460ad12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::ltl::to_lbt_string </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output an LTL formula as a string in LBT's format. </p>
<p>The formula must be an LTL formula (ELTL and PSL operators are not supported). The M and W operator will be output as-is, because this is accepted by LBTT, however if you plan to use the output with other tools, you should probably rewrite these two operators using <a class="el" href="group__ltl__rewriting.html#ga133f7bfb31a5e4a1e98be27edad69217" title="Rewrite a formula to remove the W and M operators.">unabbreviate_wm()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to translate. </td></tr>
    <tr><td class="paramname">os</td><td>The stream where it should be output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae7e461087003b093571f87640dab9045"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string spot::ltl::to_lbt_string </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output an LTL formula as a string in LBT's format. </p>
<p>The formula must be an LTL formula (ELTL and PSL operators are not supported). The M and W operator will be output as-is, because this is accepted by LBTT, however if you plan to use the output with other tools, you should probably rewrite these two operators using <a class="el" href="group__ltl__rewriting.html#ga133f7bfb31a5e4a1e98be27edad69217" title="Rewrite a formula to remove the W and M operators.">unabbreviate_wm()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to translate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0a8dd6d9bb385a69fabea697df9be925"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::ltl::to_spin_string </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full_parent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output a formula as a string parsable by Spin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to translate. </td></tr>
    <tr><td class="paramname">os</td><td>The stream where it should be output. </td></tr>
    <tr><td class="paramname">full_parent</td><td>Whether or not the string should by fully parenthesized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga62c230f1cb3170370c25d8bffb4ea141"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string spot::ltl::to_spin_string </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full_parent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a formula into a string parsable by Spin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to translate. </td></tr>
    <tr><td class="paramname">full_parent</td><td>Whether or not the string should by fully parenthesized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0f6fa636f033da650016c836d6c94215"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::ltl::to_string </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full_parent</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ratexp</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output a formula as a string which is parsable unless the formula contains automaton operators (used in ELTL formulae). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to translate. </td></tr>
    <tr><td class="paramname">os</td><td>The stream where it should be output. </td></tr>
    <tr><td class="paramname">full_parent</td><td>Whether or not the string should by fully parenthesized. </td></tr>
    <tr><td class="paramname">ratexp</td><td>Whether we are printing a SERE. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga41c884625ab680e8b8e3f2c60d58fd0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string spot::ltl::to_string </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full_parent</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ratexp</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output a formula as a string which is parsable unless the formula contains automaton operators (used in ELTL formulae). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to translate. </td></tr>
    <tr><td class="paramname">full_parent</td><td>Whether or not the string should by fully parenthesized. </td></tr>
    <tr><td class="paramname">ratexp</td><td>Whether we are printing a SERE. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga839a34e0b8a9261d039177a3546f5501"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::ltl::to_utf8_string </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full_parent</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ratexp</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output a formula as an utf8 string which is parsable unless the formula contains automaton operators (used in ELTL formulae). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to translate. </td></tr>
    <tr><td class="paramname">os</td><td>The stream where it should be output. </td></tr>
    <tr><td class="paramname">full_parent</td><td>Whether or not the string should by fully parenthesized. </td></tr>
    <tr><td class="paramname">ratexp</td><td>Whether we are printing a SERE. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classspot_1_1explicit__conf_3_01graph_00_01state__explicit__formula_01_4.html#ad54c02290b86799682eb2a92ab47d98f">spot::explicit_conf&lt; graph, state_explicit_formula &gt;::enable_utf8()</a>, and <a class="el" href="classspot_1_1explicit__conf_3_01graph_00_01state__explicit__formula_01_4.html#ad7b05501a9eb3b5ed6ab7fad73d32b7f">spot::explicit_conf&lt; graph, state_explicit_formula &gt;::to_utf8_string()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2cd5cc7892c33dfbedafe28e102f0834"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string spot::ltl::to_utf8_string </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full_parent</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ratexp</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output a formula as an utf8 string which is parsable unless the formula contains automaton operators (used in ELTL formulae). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to translate. </td></tr>
    <tr><td class="paramname">full_parent</td><td>Whether or not the string should by fully parenthesized. </td></tr>
    <tr><td class="paramname">ratexp</td><td>Whether we are printing a SERE. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga91c4e60cf307d560694b163676ec2c6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::ltl::to_wring_string </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output a formula as a string parsable by Wring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to translate. </td></tr>
    <tr><td class="paramname">os</td><td>The stream where it should be output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab337644a8e96528226e22cf166dc0977"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string spot::ltl::to_wring_string </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a formula into a string parsable by Wring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to translate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<hr size="1">
Please <b>comment</b> this page and <b>report errors</b> about it on
<a href="http://spot.lip6.fr/wiki/RefDocComments">the RefDocComments page</a>.
<br><address style="align: right;"><small>
Generated on Sat Oct 27 2012 09:34:33 for spot by <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border=0></a> 1.8.1.2</small></address>
</body>
</html>
