<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>spot: Miscellaneous algorithms on TGBA</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">spot
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Miscellaneous algorithms on TGBA</div>  </div>
<div class="ingroups"><a class="el" href="group__tgba__algorithms.html">TGBA algorithms</a></div></div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bfs__steps.html">spot::bfs_steps</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a BFS in a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> to compute a <a class="el" href="structspot_1_1tgba__run.html#a992869805fc5a8c3146e77309be61312">tgba_run::steps</a>.This class should be used to compute the shortest path between a state of a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> and the first transition or state that matches some conditions.  <a href="classspot_1_1bfs__steps.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1tgba__statistics.html">spot::tgba_statistics</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1tgba__sub__statistics.html">spot::tgba_sub_statistics</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1printable__formula.html">spot::printable_formula</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1stat__printer.html">spot::stat_printer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints various statistics about a TGBA  <a href="classspot_1_1stat__printer.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7bf747ce302af354c18a28799016dc42"><td class="memItemLeft" align="right" valign="top">sba *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#ga7bf747ce302af354c18a28799016dc42">spot::degeneralize</a> (const tgba *a)</td></tr>
<tr class="memdesc:ga7bf747ce302af354c18a28799016dc42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Degeneralize a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> into an equivalent sba with only one acceptance condition.  <a href="#ga7bf747ce302af354c18a28799016dc42"></a><br/></td></tr>
<tr class="memitem:ga482c19d4b66ca51b15b1b5a0c51d114d"><td class="memItemLeft" align="right" valign="top">tgba_explicit_number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#ga482c19d4b66ca51b15b1b5a0c51d114d">spot::tgba_dupexp_bfs</a> (const tgba *aut)</td></tr>
<tr class="memdesc:ga482c19d4b66ca51b15b1b5a0c51d114d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an explicit automata from all states of <em>aut</em>, numbering states in bread first order as they are processed.  <a href="#ga482c19d4b66ca51b15b1b5a0c51d114d"></a><br/></td></tr>
<tr class="memitem:ga1068b73c22d281c74dfbcf512c9df0b7"><td class="memItemLeft" align="right" valign="top">tgba_explicit_number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#ga1068b73c22d281c74dfbcf512c9df0b7">spot::tgba_dupexp_dfs</a> (const tgba *aut)</td></tr>
<tr class="memdesc:ga1068b73c22d281c74dfbcf512c9df0b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an explicit automata from all states of <em>aut</em>, numbering states in depth first order as they are processed.  <a href="#ga1068b73c22d281c74dfbcf512c9df0b7"></a><br/></td></tr>
<tr class="memitem:gacedab500bd933852465ef9bc3a094f70"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#gacedab500bd933852465ef9bc3a094f70">spot::count_nondet_states</a> (const tgba *aut)</td></tr>
<tr class="memdesc:gacedab500bd933852465ef9bc3a094f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of non-deterministic states in <em>aut</em>.  <a href="#gacedab500bd933852465ef9bc3a094f70"></a><br/></td></tr>
<tr class="memitem:gafe8765d12152aff78507476c5a769131"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#gafe8765d12152aff78507476c5a769131">spot::is_deterministic</a> (const tgba *aut)</td></tr>
<tr class="memdesc:gafe8765d12152aff78507476c5a769131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true iff <em>aut</em> is deterministic.  <a href="#gafe8765d12152aff78507476c5a769131"></a><br/></td></tr>
<tr class="memitem:ga669ef0d3178251f3e1ba66ef5aebaa66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#ga669ef0d3178251f3e1ba66ef5aebaa66">spot::is_weak_scc</a> (scc_map &amp;map, unsigned scc)</td></tr>
<tr class="memdesc:ga669ef0d3178251f3e1ba66ef5aebaa66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the SCC number <em>scc</em> in <em>map</em> is weak.  <a href="#ga669ef0d3178251f3e1ba66ef5aebaa66"></a><br/></td></tr>
<tr class="memitem:gadcf8ba83bd92b5cbf8f5b8f1083a793b"><td class="memItemLeft" align="right" valign="top">tgba *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#gadcf8ba83bd92b5cbf8f5b8f1083a793b">spot::random_graph</a> (int n, float d, const ltl::atomic_prop_set *ap, bdd_dict *dict, int n_acc=0, float a=0.1, float t=0.5, ltl::environment *env=&amp;ltl::default_environment::instance())</td></tr>
<tr class="memdesc:gadcf8ba83bd92b5cbf8f5b8f1083a793b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a tgba randomly.  <a href="#gadcf8ba83bd92b5cbf8f5b8f1083a793b"></a><br/></td></tr>
<tr class="memitem:gaeeb949ca5fa52c1e292e0a7732ef46c4"><td class="memItemLeft" align="right" valign="top">tgba_statistics&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#gaeeb949ca5fa52c1e292e0a7732ef46c4">spot::stats_reachable</a> (const tgba *g)</td></tr>
<tr class="memdesc:gaeeb949ca5fa52c1e292e0a7732ef46c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute statistics for an automaton.  <a href="#gaeeb949ca5fa52c1e292e0a7732ef46c4"></a><br/></td></tr>
<tr class="memitem:gaec71c3349daead65b683e5ba99b893cf"><td class="memItemLeft" align="right" valign="top">tgba_sub_statistics&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#gaec71c3349daead65b683e5ba99b893cf">spot::sub_stats_reachable</a> (const tgba *g)</td></tr>
<tr class="memdesc:gaec71c3349daead65b683e5ba99b893cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute subended statistics for an automaton.  <a href="#gaec71c3349daead65b683e5ba99b893cf"></a><br/></td></tr>
<tr class="memitem:ga27bc2c8fa49e5a2531b1b92dc6ed7020"><td class="memItemLeft" align="right" valign="top">sba_explicit_number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#ga27bc2c8fa49e5a2531b1b92dc6ed7020">spot::strip_acceptance</a> (const tgba *a)</td></tr>
<tr class="memdesc:ga27bc2c8fa49e5a2531b1b92dc6ed7020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate automaton <em>a</em>, removing all acceptance sets.  <a href="#ga27bc2c8fa49e5a2531b1b92dc6ed7020"></a><br/></td></tr>
<tr class="memitem:gafa490c8262811858828ad363760d911d"><td class="memItemLeft" align="right" valign="top">tgba_explicit_number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#gafa490c8262811858828ad363760d911d">spot::tgba_powerset</a> (const tgba *aut, power_map &amp;pm)</td></tr>
<tr class="memdesc:gafa490c8262811858828ad363760d911d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a deterministic automaton, ignoring acceptance conditions.This create a deterministic automaton that recognizes the same language as <em>aut</em> would if its acceptance conditions were ignored. This is the classical powerset algorithm.  <a href="#gafa490c8262811858828ad363760d911d"></a><br/></td></tr>
<tr class="memitem:ga42b9bff1af663f032af02cc8007db6d6"><td class="memItemLeft" align="right" valign="top">tgba_explicit_number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#ga42b9bff1af663f032af02cc8007db6d6">spot::tgba_powerset</a> (const tgba *aut)</td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<h2>Function Documentation</h2>
<a class="anchor" id="gacedab500bd933852465ef9bc3a094f70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned spot::count_nondet_states </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>aut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of non-deterministic states in <em>aut</em>. </p>
<p>The automaton is deterministic if it has 0 nondeterministic states, but it is more efficient to call <a class="el" href="group__tgba__misc.html#gafe8765d12152aff78507476c5a769131" title="Return true iff aut is deterministic.">is_deterministic()</a> if you do not care about the number of nondeterministic states. </p>

</div>
</div>
<a class="anchor" id="ga7bf747ce302af354c18a28799016dc42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sba* spot::degeneralize </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Degeneralize a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> into an equivalent sba with only one acceptance condition. </p>
<p>This algorithms will build a new explicit automaton that has at most (N+1) times the number of states of the original automaton.</p>
<p>If you want to build a degeneralized automaton on-the-fly, see <a class="el" href="classspot_1_1tgba__sba__proxy.html" title="Degeneralize a spot::tgba on the fly, producing an SBA.This class acts as a proxy in front of a spot:...">spot::tgba_sba_proxy</a> or <a class="el" href="classspot_1_1tgba__tba__proxy.html" title="Degeneralize a spot::tgba on the fly, producing a TBA.This class acts as a proxy in front of a spot::...">spot::tgba_tba_proxy</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classspot_1_1tgba__sba__proxy.html" title="Degeneralize a spot::tgba on the fly, producing an SBA.This class acts as a proxy in front of a spot:...">tgba_sba_proxy</a>, <a class="el" href="classspot_1_1tgba__tba__proxy.html" title="Degeneralize a spot::tgba on the fly, producing a TBA.This class acts as a proxy in front of a spot::...">tgba_tba_proxy</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafe8765d12152aff78507476c5a769131"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spot::is_deterministic </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>aut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true iff <em>aut</em> is deterministic. </p>
<p>This function is more efficient than <a class="el" href="group__tgba__misc.html#gacedab500bd933852465ef9bc3a094f70" title="Count the number of non-deterministic states in aut.">count_nondet_states()</a> when the automaton is nondeterministic, because it can return before the entire automaton has been explored. </p>

</div>
</div>
<a class="anchor" id="ga669ef0d3178251f3e1ba66ef5aebaa66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spot::is_weak_scc </td>
          <td>(</td>
          <td class="paramtype">scc_map &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>scc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the SCC number <em>scc</em> in <em>map</em> is weak. </p>
<p>An SCC is weak if either its cycles are all accepting, or they are all non-accepting.</p>
<p>The <a class="el" href="classspot_1_1scc__map.html" title="Build a map of Strongly Connected components in in a TGBA.">scc_map</a> <em>map</em> should have been built already. The absence of accepting cycle is easy to check (the <a class="el" href="classspot_1_1scc__map.html" title="Build a map of Strongly Connected components in in a TGBA.">scc_map</a> can tell whether the SCC is non-accepting already). Similarly, an SCC in which all transitions belong to all acceptance sets is necessarily weak. For other accepting SCCs, this function enumerates all cycles in the given SCC (it stops if it find a non-accepting cycle). </p>

</div>
</div>
<a class="anchor" id="gadcf8ba83bd92b5cbf8f5b8f1083a793b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tgba* spot::random_graph </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ltl::atomic_prop_set *&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_dict *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_acc</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em> = <code>0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>t</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ltl::environment *&#160;</td>
          <td class="paramname"><em>env</em> = <code>&amp;ltl::default_environment::instance()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a tgba randomly. </p>
<pre class="fragment">\param n The number of states wanted in the automata (&gt;0).  All states
         will be connected, and there will be no dead state.
\param d The density of the automata.  This is the probability
         (between 0.0 and 1.0), to add a transition between two
         states.  All states have at least one outgoing transition,
         so \a d is considered only when adding the remaining transition.
         A density of 1 means all states will be connected to each other.
\param ap The list of atomic property that should label the transition.
\param dict The bdd_dict to used for this automata.
\param n_acc The number of acceptance sets to use.
         If this number is non null, then there is no guarantee
         that the generated graph contains an accepting cycle (raise
         the value of \a a to improve the chances).
\param a The probability (between 0.0 and 1.0) that a transition belongs
         to an acceptance set.
\param t The probability (between 0.0 and 1.0) that an atomic proposition
         is true.
\param env The environment in which to declare the acceptance conditions.

This algorithms is adapted from the one in Fig 6.2 page 48 of
@verbatim 
</pre><p> /// { tauriainen.00.a66, /// author = {Heikki Tauriainen}, /// title = {Automated Testing of {B"u}chi Automata Translators for /// {L}inear {T}emporal {L}ogic}, /// address = {Espoo, Finland}, /// institution = {Helsinki University of Technology, Laboratory for /// Theoretical Computer Science}, /// number = {A66}, /// year = {2000}, /// url = {<a href="http://citeseer.nj.nec.com/tauriainen00automated.html">http://citeseer.nj.nec.com/tauriainen00automated.html</a>}, /// type = {Research Report}, /// note = {Reprint of Master's thesis} /// } ///  </p>
<pre class="fragment">Although the intent is similar, there are some differences with
between the above published algorithm and this implementation .
First labels are on transitions, and acceptance conditions are
generated too.  Second, the number of successors of a node is
chosen in \form#0 following a normal distribution with mean
</pre><p> <img class="formulaInl" alt="$1+(n-1)d$" src="form_1.png"/> and variance <img class="formulaInl" alt="$(n-1)d(1-d)$" src="form_2.png"/>. (This is less accurate, but faster than considering all possible <em>n</em> successors one by one.) </p>

</div>
</div>
<a class="anchor" id="gaeeb949ca5fa52c1e292e0a7732ef46c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tgba_statistics spot::stats_reachable </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute statistics for an automaton. </p>

</div>
</div>
<a class="anchor" id="ga27bc2c8fa49e5a2531b1b92dc6ed7020"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sba_explicit_number* spot::strip_acceptance </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate automaton <em>a</em>, removing all acceptance sets. </p>
<p>This is equivalent to marking all states/transitions as accepting. </p>

</div>
</div>
<a class="anchor" id="gaec71c3349daead65b683e5ba99b893cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tgba_sub_statistics spot::sub_stats_reachable </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute subended statistics for an automaton. </p>

</div>
</div>
<a class="anchor" id="ga482c19d4b66ca51b15b1b5a0c51d114d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tgba_explicit_number* spot::tgba_dupexp_bfs </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>aut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build an explicit automata from all states of <em>aut</em>, numbering states in bread first order as they are processed. </p>

</div>
</div>
<a class="anchor" id="ga1068b73c22d281c74dfbcf512c9df0b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tgba_explicit_number* spot::tgba_dupexp_dfs </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>aut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build an explicit automata from all states of <em>aut</em>, numbering states in depth first order as they are processed. </p>

</div>
</div>
<a class="anchor" id="gafa490c8262811858828ad363760d911d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tgba_explicit_number* spot::tgba_powerset </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>aut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">power_map &amp;&#160;</td>
          <td class="paramname"><em>pm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a deterministic automaton, ignoring acceptance conditions.This create a deterministic automaton that recognizes the same language as <em>aut</em> would if its acceptance conditions were ignored. This is the classical powerset algorithm. </p>
<p>If <em>pm</em> is supplied it will be filled with the set of original states associated to each state of the deterministic automaton. </p>

</div>
</div>
<a class="anchor" id="ga42b9bff1af663f032af02cc8007db6d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tgba_explicit_number* spot::tgba_powerset </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>aut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<hr size="1">
Please <b>comment</b> this page and <b>report errors</b> about it on
<a href="http://spot.lip6.fr/wiki/RefDocComments">the RefDocComments page</a>.
<br><address style="align: right;"><small>
Generated on Sat Oct 27 2012 09:34:33 for spot by <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border=0></a> 1.8.1.2</small></address>
</body>
</html>
