<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>spot: Miscellaneous helper algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">spot
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Miscellaneous helper algorithms</div>  </div>
</div><!--header-->
<div class="contents">

<p>Whether a word is bare.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__hash__funcs"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hash__funcs.html">Hashing functions</a></td></tr>
<tr class="memitem:group__random"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__random.html">Random functions</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__allocator.html">spot::bdd_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manage ranges of variables.  <a href="classspot_1_1bdd__allocator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1bdd__less__than.html">spot::bdd_less_than</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison functor for BDDs.  <a href="structspot_1_1bdd__less__than.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1bdd__hash.html">spot::bdd_hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor for BDDs.  <a href="structspot_1_1bdd__hash.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1free__list.html">spot::free_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manage list of free integers.  <a href="classspot_1_1free__list.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1char__ptr__less__than.html">spot::char_ptr_less_than</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strict Weak Ordering for <code>char*</code>.This is meant to be used as a comparison functor for STL <code>map</code> whose key are of type <code>const char*</code>.  <a href="structspot_1_1char__ptr__less__than.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1minato__isop.html">spot::minato_isop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an irredundant sum-of-products (ISOP) form of a BDD function.This algorithm implements a derecursived version the Minato-Morreale algorithm presented in the following paper.  <a href="classspot_1_1minato__isop.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html">spot::loopless_modular_mixed_radix_gray_code</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loopless modular mixed radix Gray code iteration.This class is based on the loopless modular mixed radix gray code algorithm described in exercise 77 of "The Art of Computer
     Programming", Pre-Fascicle 2A (Draft of section 7.2.1.1: generating all n-tuples) by Donald E. Knuth.  <a href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1option__map.html">spot::option_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manage a map of options.Each option is defined by a string and is associated to an integer value.  <a href="classspot_1_1option__map.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1time__info.html">spot::time_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure to record elapsed time in clock ticks.  <a href="structspot_1_1time__info.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1timer.html">spot::timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A timekeeper that accumulate interval of time.  <a href="classspot_1_1timer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1timer__map.html">spot::timer_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map of timer, where each timer has a name.  <a href="classspot_1_1timer__map.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaae6fadac6a2f91d7b8e27b3eb6ad647e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#gaae6fadac6a2f91d7b8e27b3eb6ad647e">spot::is_bare_word</a> (const char *str)</td></tr>
<tr class="memitem:ga4731f21b7b43332b5c7b5bc63c6d67e6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#ga4731f21b7b43332b5c7b5bc63c6d67e6">spot::quote_unless_bare_word</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga4731f21b7b43332b5c7b5bc63c6d67e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double-quote words that are not bare.  <a href="#ga4731f21b7b43332b5c7b5bc63c6d67e6"></a><br/></td></tr>
<tr class="memitem:ga84a8b196e2ec651f0fd039c70c7ff6cb"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#ga84a8b196e2ec651f0fd039c70c7ff6cb">spot::escape_str</a> (std::ostream &amp;os, const std::string &amp;str)</td></tr>
<tr class="memdesc:ga84a8b196e2ec651f0fd039c70c7ff6cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape characters <code>"</code>, <code>\</code>, and <code>\n</code> in <em>str</em>.  <a href="#ga84a8b196e2ec651f0fd039c70c7ff6cb"></a><br/></td></tr>
<tr class="memitem:gad4b0b4fae7b93db7d704a5fef6e021c6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#gad4b0b4fae7b93db7d704a5fef6e021c6">spot::escape_str</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:gad4b0b4fae7b93db7d704a5fef6e021c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape characters <code>"</code>, <code>\</code>, and <code>\n</code> in <em>str</em>.  <a href="#gad4b0b4fae7b93db7d704a5fef6e021c6"></a><br/></td></tr>
<tr class="memitem:ga3f3dad2e940fa844eeccda24e9386608"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#ga3f3dad2e940fa844eeccda24e9386608">spot::trim</a> (std::string &amp;str)</td></tr>
<tr class="memdesc:ga3f3dad2e940fa844eeccda24e9386608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove spaces at the front and back of <em>str</em>.  <a href="#ga3f3dad2e940fa844eeccda24e9386608"></a><br/></td></tr>
<tr class="memitem:ga5253b7b9fd60f3285091b39a1f1b815d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#ga5253b7b9fd60f3285091b39a1f1b815d">spot::int_array_array_compress2</a> (const int *array, size_t n, int *dest, size_t &amp;dest_size)</td></tr>
<tr class="memdesc:ga5253b7b9fd60f3285091b39a1f1b815d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress an int array of size <em>n</em> into a int array.  <a href="#ga5253b7b9fd60f3285091b39a1f1b815d"></a><br/></td></tr>
<tr class="memitem:gaed78e6934b190995ba5a162ad0e76560"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#gaed78e6934b190995ba5a162ad0e76560">spot::int_array_array_decompress2</a> (const int *array, size_t array_size, int *res, size_t size)</td></tr>
<tr class="memdesc:gaed78e6934b190995ba5a162ad0e76560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uncompress an int array of size <em>array_size</em> into a int array of size <em>size</em>.  <a href="#gaed78e6934b190995ba5a162ad0e76560"></a><br/></td></tr>
<tr class="memitem:ga86ac44d535ef8f28e5d81a2edf907065"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#ga86ac44d535ef8f28e5d81a2edf907065">spot::int_vector_vector_compress</a> (const std::vector&lt; int &gt; &amp;input, std::vector&lt; unsigned int &gt; &amp;output)</td></tr>
<tr class="memdesc:ga86ac44d535ef8f28e5d81a2edf907065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress an int vector into a vector of unsigned int.  <a href="#ga86ac44d535ef8f28e5d81a2edf907065"></a><br/></td></tr>
<tr class="memitem:gade72f3d754ef89b594db989893ee3e7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#gade72f3d754ef89b594db989893ee3e7b">spot::int_vector_vector_decompress</a> (const std::vector&lt; unsigned int &gt; &amp;array, std::vector&lt; int &gt; &amp;output, size_t size)</td></tr>
<tr class="memdesc:gade72f3d754ef89b594db989893ee3e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uncompress a vector of unsigned int into a vector of size <em>size</em>.  <a href="#gade72f3d754ef89b594db989893ee3e7b"></a><br/></td></tr>
<tr class="memitem:gae8556060f7963410dd8c52d2426d7269"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned int &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#gae8556060f7963410dd8c52d2426d7269">spot::int_array_vector_compress</a> (const int *array, size_t n)</td></tr>
<tr class="memdesc:gae8556060f7963410dd8c52d2426d7269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress an int array if size <em>n</em> into a vector of unsigned int.  <a href="#gae8556060f7963410dd8c52d2426d7269"></a><br/></td></tr>
<tr class="memitem:ga6c161d70b36c5637b6511f2192f2d9bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#ga6c161d70b36c5637b6511f2192f2d9bf">spot::int_vector_array_decompress</a> (const std::vector&lt; unsigned int &gt; *array, int *res, size_t size)</td></tr>
<tr class="memdesc:ga6c161d70b36c5637b6511f2192f2d9bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uncompress a vector of unsigned int into an int array of size <em>size</em>.  <a href="#ga6c161d70b36c5637b6511f2192f2d9bf"></a><br/></td></tr>
<tr class="memitem:ga72a6bb80b592f562634a6bd8aedd9ff6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#ga72a6bb80b592f562634a6bd8aedd9ff6">spot::int_array_array_compress</a> (const int *array, size_t n, int *dest, size_t &amp;dest_size)</td></tr>
<tr class="memdesc:ga72a6bb80b592f562634a6bd8aedd9ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress an int array of size <em>n</em> into a int array.  <a href="#ga72a6bb80b592f562634a6bd8aedd9ff6"></a><br/></td></tr>
<tr class="memitem:gad595c02553de6187297d09d2b47c995c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#gad595c02553de6187297d09d2b47c995c">spot::int_array_array_decompress</a> (const int *array, size_t array_size, int *res, size_t size)</td></tr>
<tr class="memdesc:gad595c02553de6187297d09d2b47c995c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uncompress an int array of size <em>array_size</em> into a int array of size <em>size</em>.  <a href="#gad595c02553de6187297d09d2b47c995c"></a><br/></td></tr>
<tr class="memitem:ga85c83eb1d18703782d129dbe4a518fca"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#ga85c83eb1d18703782d129dbe4a518fca">spot::version</a> ()</td></tr>
<tr class="memdesc:ga85c83eb1d18703782d129dbe4a518fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Spot's version.  <a href="#ga85c83eb1d18703782d129dbe4a518fca"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<p>Whether a word is bare. </p>
<p>Bare words should start with a letter or an underscore, and consist solely of alphanumeric characters and underscores. </p>
<h2>Function Documentation</h2>
<a class="anchor" id="ga84a8b196e2ec651f0fd039c70c7ff6cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::escape_str </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Escape characters <code>"</code>, <code>\</code>, and <code>\n</code> in <em>str</em>. </p>

</div>
</div>
<a class="anchor" id="gad4b0b4fae7b93db7d704a5fef6e021c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string spot::escape_str </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Escape characters <code>"</code>, <code>\</code>, and <code>\n</code> in <em>str</em>. </p>

</div>
</div>
<a class="anchor" id="ga72a6bb80b592f562634a6bd8aedd9ff6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spot::int_array_array_compress </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>dest_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compress an int array of size <em>n</em> into a int array. </p>
<p>The destination array should be at least <em>dest_size</em> large An assert will be triggered if <em>dest_size</em> is too small. On return, <em>dest_size</em> will be set to the actually number of int filled in <em>dest</em> </p>

</div>
</div>
<a class="anchor" id="ga5253b7b9fd60f3285091b39a1f1b815d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spot::int_array_array_compress2 </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>dest_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compress an int array of size <em>n</em> into a int array. </p>
<p>The destination array should be at least <em>dest_size</em> large An assert will be triggered if <em>dest_size</em> is too small. On return, <em>dest_size</em> will be set to the actually number of int filled in <em>dest</em> </p>

</div>
</div>
<a class="anchor" id="gad595c02553de6187297d09d2b47c995c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spot::int_array_array_decompress </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>array_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uncompress an int array of size <em>array_size</em> into a int array of size <em>size</em>. </p>
<p><em>size</em> must be the exact expected size of uncompressed array. </p>

</div>
</div>
<a class="anchor" id="gaed78e6934b190995ba5a162ad0e76560"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spot::int_array_array_decompress2 </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>array_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uncompress an int array of size <em>array_size</em> into a int array of size <em>size</em>. </p>
<p><em>size</em> must be the exact expected size of uncompressed array. </p>

</div>
</div>
<a class="anchor" id="gae8556060f7963410dd8c52d2426d7269"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;unsigned int&gt;* spot::int_array_vector_compress </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compress an int array if size <em>n</em> into a vector of unsigned int. </p>

</div>
</div>
<a class="anchor" id="ga6c161d70b36c5637b6511f2192f2d9bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spot::int_vector_array_decompress </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uncompress a vector of unsigned int into an int array of size <em>size</em>. </p>
<p><em>size</em> must be the exact expected size of uncompressed array. </p>

</div>
</div>
<a class="anchor" id="ga86ac44d535ef8f28e5d81a2edf907065"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spot::int_vector_vector_compress </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compress an int vector into a vector of unsigned int. </p>

</div>
</div>
<a class="anchor" id="gade72f3d754ef89b594db989893ee3e7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spot::int_vector_vector_decompress </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uncompress a vector of unsigned int into a vector of size <em>size</em>. </p>
<p><em>size</em> must be the exact expected size of uncompressed array. </p>

</div>
</div>
<a class="anchor" id="gaae6fadac6a2f91d7b8e27b3eb6ad647e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spot::is_bare_word </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4731f21b7b43332b5c7b5bc63c6d67e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string spot::quote_unless_bare_word </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Double-quote words that are not bare. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__misc__tools.html#gaae6fadac6a2f91d7b8e27b3eb6ad647e">is_bare_word</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3f3dad2e940fa844eeccda24e9386608"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spot::trim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove spaces at the front and back of <em>str</em>. </p>

</div>
</div>
<a class="anchor" id="ga85c83eb1d18703782d129dbe4a518fca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spot::version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return Spot's version. </p>

</div>
</div>
</div><!-- contents -->
<hr size="1">
Please <b>comment</b> this page and <b>report errors</b> about it on
<a href="http://spot.lip6.fr/wiki/RefDocComments">the RefDocComments page</a>.
<br><address style="align: right;"><small>
Generated on Sat Oct 27 2012 09:34:33 for spot by <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border=0></a> 1.8.1.2</small></address>
</body>
</html>
