#!/bin/sh
# -*- coding: utf-8 -*-
# Copyright (C) 2010, 2011, 2012, 2013, 2014 Laboratoire de Recherche
# et Développement de l'Epita (LRDE).
#
# This file is part of Spot, a model checking library.
#
# Spot is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# Spot is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


. ./defs

set -e

cat >input <<EOF
never {
T2_init:
if
:: (1) -> goto T2_init
:: (p1 && p0) -> goto T1
fi;
T1:
if
:: (p1 && (! p0)) -> goto accept_all
:: !(p1) -> goto T1
:: ! (p1) -> goto T2_init
fi;
accept_all:
skip
}
EOF

run 0 ../ltl2tgba -XN input > stdout

cat >expected <<EOF
digraph G {
  0 [label="", style=invis, height=0]
  0 -> 1
  1 [label="T2_init"]
  1 -> 1 [label="1\n"]
  1 -> 2 [label="p0 & p1\n"]
  2 [label="T1"]
  2 -> 3 [label="p1 & !p0\n"]
  2 -> 2 [label="!p1\n"]
  2 -> 1 [label="!p1\n"]
  3 [label="accept_all", peripheries=2]
  3 -> 3 [label="1\n{Acc[1]}"]
}
EOF

# Sort out some possible inversions in the output.
# (The order is not guaranteed by SPOT.)
sed -e 's/!p0 & p1/p1 \& !p0/g' -e 's/p1 & p0/p0 \& p1/g' stdout \
    > tmp_ && mv tmp_ stdout
diff stdout expected

rm input stdout expected


# Same test, but with the newer syntax output since Spin 6.24
cat >input <<EOF
never {
T2_init:
do
:: (1) -> goto T2_init
:: (p1 && p0) -> goto T1
od;
T1:
do
:: atomic { (p1 && (! p0)) -> assert(!(p1 && (! p0))) }
:: !(p1) -> goto T1
:: ! (p1) -> goto T2_init
od;
}
EOF

run 0 ../ltl2tgba -XN input > stdout

cat >expected <<EOF
digraph G {
  0 [label="", style=invis, height=0]
  0 -> 1
  1 [label="T2_init"]
  1 -> 1 [label="1\n"]
  1 -> 2 [label="p0 & p1\n"]
  2 [label="T1"]
  2 -> 3 [label="p1 & !p0\n"]
  2 -> 2 [label="!p1\n"]
  2 -> 1 [label="!p1\n"]
  3 [label="accept_all", peripheries=2]
  3 -> 3 [label="1\n{Acc[1]}"]
}
EOF

# Sort out some possible inversions in the output.
# (The order is not guaranteed by SPOT.)
sed -e 's/!p0 & p1/p1 \& !p0/g' -e 's/p1 & p0/p0 \& p1/g' stdout \
    > tmp_ && mv tmp_ stdout
diff stdout expected

rm input stdout expected


# Unparenthesed disjunction
cat >input <<EOF
never { /* p0 || p1  */
accept_init:
        if
        :: (p1) && (p0) -> goto accept_all
        :: (p1) && !(p0) -> goto accept_all
        fi;
accept_all:
        skip
}
EOF
run 0 ../ltl2tgba -XN input > stdout

cat >expected <<EOF
digraph G {
  0 [label="", style=invis, height=0]
  0 -> 1
  1 [label="accept_init", peripheries=2]
  1 -> 2 [label="p1\n{Acc[1]}"]
  2 [label="accept_all", peripheries=2]
  2 -> 2 [label="1\n{Acc[1]}"]
}
EOF

diff stdout expected

rm input stdout expected

# Test broken guards in input
cat >input <<EOF
never {
T2_init:
if
:: (1) -> goto T2_init
:: (p1 && ) -> goto T1
fi;
T1:
if
:: (p1 && ! p0)) -> goto accept_all
:: (p1) -> goto T1
fi;
accept_all:
skip
}
EOF

# We used to catch the following error:
#   input:5.11: syntax error, unexpected closing parenthesis
#   input:5.8-9: missing right operand for "and operator"
# but since the guard parser is more lenient, we just assume
# that "p1 && " is an atomic property.

run 2 ../ltl2tgba -XN input > stdout 2>stderr
cat >expected <<\EOF
input:9.16: syntax error, unexpected $undefined, expecting fi or ':'
EOF
grep input: stderr >> stderrfilt
diff stderrfilt expected


# This output from MoDeLLa was not property parsed by Spot because of
# the missing parentheses around p0.  Report from František Blahoudek.
cat >input <<EOF
never{
T0_init:
	if
	:: true -> goto T1
	:: p0 -> goto T2
	fi;
T1:
	if
	:: true -> goto T1
	:: p0 -> goto accept_T3
	fi;
T2:
	if
	:: p0 -> goto accept_T3
	fi;
accept_T3:
	if
	:: p0 -> goto T2
	fi;
}
EOF
cat >expected<<EOF
transitions: 6
states: 4
EOF

run 0 ../ltl2tgba -ks -XN input > output
diff output expected


cat >formulae<<EOF
a
FG a
X false
(G a) U X b
(a U b) U (c U d)
true
(Ga && XXXX!a)
"a > b" U "process@foo"
GF("(a + b) == 42" U "process@foo")
EOF
while read f
do
    run 0 ../ltl2tgba -b -f "!($f)" > f.tgba
    sf=`../../bin/ltlfilt -sf "$f"`
    if test -n "$SPIN"; then
        # Old spin versions cannot parse formulas such as ((a + b) == 42).
	if $SPIN -f "$sf" > f.spin; then
	  run 0 ../ltl2tgba -E -Pf.tgba -XN f.spin
        fi
    fi
    case $f in
      *\"*);;
      *)
      if test -n "$LTL2BA"; then
	  $LTL2BA -f "$sf" > f.ltl2ba
	  run 0 ../ltl2tgba -E -Pf.tgba -XN f.ltl2ba
      fi
    esac
    run 0 ../ltl2tgba -DS -NN -f "$f" > f.spot
    # Make sure there is no `!x' occurring in the
    # output.  Because `x' is usually #define'd, we
    # should use `!(x)' in guards.
    grep '![^(].*->' f.spot && exit 1
    run 0 ../ltl2tgba -E -Pf.tgba -XN f.spot
done  <formulae
