<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>spot: Miscellaneous algorithms on TGBA</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">spot
   &#160;<span id="projectnumber">1.2.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Miscellaneous algorithms on TGBA<div class="ingroups"><a class="el" href="group__tgba__algorithms.html">TGBA algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bfs__steps.html">spot::bfs_steps</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a BFS in a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton. ">spot::tgba</a> to compute a tgba_run::steps.  <a href="classspot_1_1bfs__steps.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1tgba__statistics.html">spot::tgba_statistics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1tgba__sub__statistics.html">spot::tgba_sub_statistics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1printable__formula.html">spot::printable_formula</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1stat__printer.html">spot::stat_printer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints various statistics about a TGBA  <a href="classspot_1_1stat__printer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac5a739396d459336fb13a45957a2090a"><td class="memItemLeft" align="right" valign="top">SPOT_API sba *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#gac5a739396d459336fb13a45957a2090a">spot::degeneralize</a> (const tgba *a, bool use_z_lvl=true, bool use_cust_acc_orders=false, int use_lvl_cache=1, bool skip_levels=true)</td></tr>
<tr class="memdesc:gac5a739396d459336fb13a45957a2090a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Degeneralize a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton. ">spot::tgba</a> into an equivalent sba with only one acceptance condition.  <a href="#gac5a739396d459336fb13a45957a2090a">More...</a><br/></td></tr>
<tr class="separator:gac5a739396d459336fb13a45957a2090a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61782f7db3ae1ca82378ffaae95ce2fa"><td class="memItemLeft" align="right" valign="top">SPOT_API tgba_explicit_number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#ga61782f7db3ae1ca82378ffaae95ce2fa">spot::tgba_dupexp_bfs</a> (const tgba *aut)</td></tr>
<tr class="memdesc:ga61782f7db3ae1ca82378ffaae95ce2fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an explicit automata from all states of <em>aut</em>, numbering states in bread first order as they are processed.  <a href="#ga61782f7db3ae1ca82378ffaae95ce2fa">More...</a><br/></td></tr>
<tr class="separator:ga61782f7db3ae1ca82378ffaae95ce2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3492f1f085f2c2ca7508f4673405f22b"><td class="memItemLeft" align="right" valign="top">SPOT_API tgba_explicit_number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#ga3492f1f085f2c2ca7508f4673405f22b">spot::tgba_dupexp_dfs</a> (const tgba *aut)</td></tr>
<tr class="memdesc:ga3492f1f085f2c2ca7508f4673405f22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an explicit automata from all states of <em>aut</em>, numbering states in depth first order as they are processed.  <a href="#ga3492f1f085f2c2ca7508f4673405f22b">More...</a><br/></td></tr>
<tr class="separator:ga3492f1f085f2c2ca7508f4673405f22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a04fc4e9913deb9c42e01e27ee436d6"><td class="memItemLeft" align="right" valign="top">SPOT_API tgba_explicit_number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#ga7a04fc4e9913deb9c42e01e27ee436d6">spot::tgba_dupexp_bfs</a> (const tgba *aut, std::map&lt; const state *, const state *, state_ptr_less_than &gt; &amp;relation)</td></tr>
<tr class="memdesc:ga7a04fc4e9913deb9c42e01e27ee436d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an explicit automata from all states of <em>aut</em>, numbering states in bread first order as they are processed.  <a href="#ga7a04fc4e9913deb9c42e01e27ee436d6">More...</a><br/></td></tr>
<tr class="separator:ga7a04fc4e9913deb9c42e01e27ee436d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b61b3e71348077d0ec8bbabc97599d5"><td class="memItemLeft" align="right" valign="top">SPOT_API tgba_explicit_number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#ga0b61b3e71348077d0ec8bbabc97599d5">spot::tgba_dupexp_dfs</a> (const tgba *aut, std::map&lt; const state *, const state *, state_ptr_less_than &gt; &amp;relation)</td></tr>
<tr class="memdesc:ga0b61b3e71348077d0ec8bbabc97599d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an explicit automata from all states of <em>aut</em>, numbering states in depth first order as they are processed.  <a href="#ga0b61b3e71348077d0ec8bbabc97599d5">More...</a><br/></td></tr>
<tr class="separator:ga0b61b3e71348077d0ec8bbabc97599d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fc0abdbe1820c80126aab752d5b1349"><td class="memItemLeft" align="right" valign="top">SPOT_API unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#ga6fc0abdbe1820c80126aab752d5b1349">spot::count_nondet_states</a> (const tgba *aut)</td></tr>
<tr class="memdesc:ga6fc0abdbe1820c80126aab752d5b1349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of non-deterministic states in <em>aut</em>.  <a href="#ga6fc0abdbe1820c80126aab752d5b1349">More...</a><br/></td></tr>
<tr class="separator:ga6fc0abdbe1820c80126aab752d5b1349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9b9a1dc7e3a28d6994d0ff4bc4ab82a"><td class="memItemLeft" align="right" valign="top">SPOT_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#gaa9b9a1dc7e3a28d6994d0ff4bc4ab82a">spot::is_deterministic</a> (const tgba *aut)</td></tr>
<tr class="memdesc:gaa9b9a1dc7e3a28d6994d0ff4bc4ab82a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true iff <em>aut</em> is deterministic.  <a href="#gaa9b9a1dc7e3a28d6994d0ff4bc4ab82a">More...</a><br/></td></tr>
<tr class="separator:gaa9b9a1dc7e3a28d6994d0ff4bc4ab82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf73d9eea80cd34b6dc29adaf314229a"><td class="memItemLeft" align="right" valign="top">SPOT_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#gacf73d9eea80cd34b6dc29adaf314229a">spot::is_complete</a> (const tgba *aut)</td></tr>
<tr class="memdesc:gacf73d9eea80cd34b6dc29adaf314229a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true iff <em>aut</em> is complete.  <a href="#gacf73d9eea80cd34b6dc29adaf314229a">More...</a><br/></td></tr>
<tr class="separator:gacf73d9eea80cd34b6dc29adaf314229a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacedc6cf8955616fc8002a2d3249efb30"><td class="memItemLeft" align="right" valign="top">SPOT_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#gacedc6cf8955616fc8002a2d3249efb30">spot::is_inherently_weak_scc</a> (scc_map &amp;map, unsigned scc)</td></tr>
<tr class="memdesc:gacedc6cf8955616fc8002a2d3249efb30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the SCC number <em>scc</em> in <em>map</em> is inherently weak.  <a href="#gacedc6cf8955616fc8002a2d3249efb30">More...</a><br/></td></tr>
<tr class="separator:gacedc6cf8955616fc8002a2d3249efb30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dcb54c0ecf6dad403d6e3457448fdf4"><td class="memItemLeft" align="right" valign="top">SPOT_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#ga2dcb54c0ecf6dad403d6e3457448fdf4">spot::is_weak_scc</a> (scc_map &amp;map, unsigned scc)</td></tr>
<tr class="memdesc:ga2dcb54c0ecf6dad403d6e3457448fdf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the SCC number <em>scc</em> in <em>map</em> is weak.  <a href="#ga2dcb54c0ecf6dad403d6e3457448fdf4">More...</a><br/></td></tr>
<tr class="separator:ga2dcb54c0ecf6dad403d6e3457448fdf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4110dc986c069b0ad42df9ba548238b7"><td class="memItemLeft" align="right" valign="top">SPOT_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#ga4110dc986c069b0ad42df9ba548238b7">spot::is_complete_scc</a> (scc_map &amp;map, unsigned scc)</td></tr>
<tr class="memdesc:ga4110dc986c069b0ad42df9ba548238b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the SCC number <em>scc</em> in <em>map</em> is complete.  <a href="#ga4110dc986c069b0ad42df9ba548238b7">More...</a><br/></td></tr>
<tr class="separator:ga4110dc986c069b0ad42df9ba548238b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d3b37479f9996c6e157cacb31be05e9"><td class="memItemLeft" align="right" valign="top">SPOT_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#ga9d3b37479f9996c6e157cacb31be05e9">spot::is_syntactic_weak_scc</a> (scc_map &amp;map, unsigned scc)</td></tr>
<tr class="memdesc:ga9d3b37479f9996c6e157cacb31be05e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the SCC number <em>scc</em> in <em>map</em> is syntactically weak.  <a href="#ga9d3b37479f9996c6e157cacb31be05e9">More...</a><br/></td></tr>
<tr class="separator:ga9d3b37479f9996c6e157cacb31be05e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3344a5400ec32f1aaa0f003f91634a39"><td class="memItemLeft" align="right" valign="top">SPOT_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#ga3344a5400ec32f1aaa0f003f91634a39">spot::is_syntactic_terminal_scc</a> (scc_map &amp;map, unsigned scc)</td></tr>
<tr class="memdesc:ga3344a5400ec32f1aaa0f003f91634a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the SCC number <em>scc</em> in <em>map</em> is syntactically terminal.  <a href="#ga3344a5400ec32f1aaa0f003f91634a39">More...</a><br/></td></tr>
<tr class="separator:ga3344a5400ec32f1aaa0f003f91634a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4b0c59e5185aa88c984fc0be55cc90e"><td class="memItemLeft" align="right" valign="top">SPOT_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#gac4b0c59e5185aa88c984fc0be55cc90e">spot::is_terminal_scc</a> (scc_map &amp;map, unsigned scc)</td></tr>
<tr class="memdesc:gac4b0c59e5185aa88c984fc0be55cc90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the SCC number <em>scc</em> in <em>map</em> is terminal.  <a href="#gac4b0c59e5185aa88c984fc0be55cc90e">More...</a><br/></td></tr>
<tr class="separator:gac4b0c59e5185aa88c984fc0be55cc90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafc01af4b4688e144f4f04ef0a7c59f0"><td class="memItemLeft" align="right" valign="top">SPOT_API tgba *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#gaafc01af4b4688e144f4f04ef0a7c59f0">spot::random_graph</a> (int n, float d, const ltl::atomic_prop_set *ap, bdd_dict *dict, int n_acc=0, float a=0.1, float t=0.5, ltl::environment *env=&amp;ltl::default_environment::instance())</td></tr>
<tr class="memdesc:gaafc01af4b4688e144f4f04ef0a7c59f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a tgba randomly.  <a href="#gaafc01af4b4688e144f4f04ef0a7c59f0">More...</a><br/></td></tr>
<tr class="separator:gaafc01af4b4688e144f4f04ef0a7c59f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc41419bd3f2ec839eca737554115928"><td class="memItemLeft" align="right" valign="top">SPOT_API tgba_statistics&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#gafc41419bd3f2ec839eca737554115928">spot::stats_reachable</a> (const tgba *g)</td></tr>
<tr class="memdesc:gafc41419bd3f2ec839eca737554115928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute statistics for an automaton.  <a href="#gafc41419bd3f2ec839eca737554115928">More...</a><br/></td></tr>
<tr class="separator:gafc41419bd3f2ec839eca737554115928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb1db3d41f0de65c2d6b93cb46225096"><td class="memItemLeft" align="right" valign="top">SPOT_API tgba_sub_statistics&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#gaeb1db3d41f0de65c2d6b93cb46225096">spot::sub_stats_reachable</a> (const tgba *g)</td></tr>
<tr class="memdesc:gaeb1db3d41f0de65c2d6b93cb46225096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute subended statistics for an automaton.  <a href="#gaeb1db3d41f0de65c2d6b93cb46225096">More...</a><br/></td></tr>
<tr class="separator:gaeb1db3d41f0de65c2d6b93cb46225096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bf67a06f0f4abcb9ac3f8313b6aa1f2"><td class="memItemLeft" align="right" valign="top">SPOT_API sba_explicit_number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#ga5bf67a06f0f4abcb9ac3f8313b6aa1f2">spot::strip_acceptance</a> (const tgba *a)</td></tr>
<tr class="memdesc:ga5bf67a06f0f4abcb9ac3f8313b6aa1f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate automaton <em>a</em>, removing all acceptance sets.  <a href="#ga5bf67a06f0f4abcb9ac3f8313b6aa1f2">More...</a><br/></td></tr>
<tr class="separator:ga5bf67a06f0f4abcb9ac3f8313b6aa1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d72068a20bcf5b2c8b4bd53bb6d993d"><td class="memItemLeft" align="right" valign="top">SPOT_API tgba *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#ga4d72068a20bcf5b2c8b4bd53bb6d993d">spot::stutterize</a> (const tgba *a, bdd atomic_propositions)</td></tr>
<tr class="memdesc:ga4d72068a20bcf5b2c8b4bd53bb6d993d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a state-labeled tgba with self-loops on each state.  <a href="#ga4d72068a20bcf5b2c8b4bd53bb6d993d">More...</a><br/></td></tr>
<tr class="separator:ga4d72068a20bcf5b2c8b4bd53bb6d993d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20c27a27db7186d6fb164ee21ffc0471"><td class="memItemLeft" align="right" valign="top">SPOT_API tgba_explicit_number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#ga20c27a27db7186d6fb164ee21ffc0471">spot::tgba_powerset</a> (const tgba *aut, power_map &amp;pm, bool merge=true)</td></tr>
<tr class="memdesc:ga20c27a27db7186d6fb164ee21ffc0471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a deterministic automaton, ignoring acceptance conditions.  <a href="#ga20c27a27db7186d6fb164ee21ffc0471">More...</a><br/></td></tr>
<tr class="separator:ga20c27a27db7186d6fb164ee21ffc0471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6103074f38e1a71d3454bb0d309d3777"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6103074f38e1a71d3454bb0d309d3777"></a>
SPOT_API tgba_explicit_number *&#160;</td><td class="memItemRight" valign="bottom"><b>spot::tgba_powerset</b> (const tgba *aut)</td></tr>
<tr class="separator:ga6103074f38e1a71d3454bb0d309d3777"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga6fc0abdbe1820c80126aab752d5b1349"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API unsigned spot::count_nondet_states </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>aut</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of non-deterministic states in <em>aut</em>. </p>
<p>The automaton is deterministic if it has 0 nondeterministic states, but it is more efficient to call <a class="el" href="group__tgba__misc.html#gaa9b9a1dc7e3a28d6994d0ff4bc4ab82a" title="Return true iff aut is deterministic. ">is_deterministic()</a> if you do not care about the number of nondeterministic states. </p>

</div>
</div>
<a class="anchor" id="gac5a739396d459336fb13a45957a2090a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API sba* spot::degeneralize </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_z_lvl</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_cust_acc_orders</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>use_lvl_cache</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skip_levels</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Degeneralize a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton. ">spot::tgba</a> into an equivalent sba with only one acceptance condition. </p>
<p>This algorithms will build a new explicit automaton that has at most (N+1) times the number of states of the original automaton.</p>
<p>If you want to build a degeneralized automaton on-the-fly, see <a class="el" href="classspot_1_1tgba__sba__proxy.html" title="Degeneralize a spot::tgba on the fly, producing an SBA. ">spot::tgba_sba_proxy</a> or <a class="el" href="classspot_1_1tgba__tba__proxy.html" title="Degeneralize a spot::tgba on the fly, producing a TBA. ">spot::tgba_tba_proxy</a>.</p>
<p>When <em>use_z_lvl</em> is set, the level of the degeneralized automaton is reset everytime an accepting SCC is exited. If <em>use_cust_acc_orders</em> is set, the degeneralization will compute a custom acceptance order for each SCC (this option is disabled by default because our benchmarks show that it usually does more harm than good). If <em>use_lvl_cache</em> is set, everytime an SCC is entered on a state that as already been associated to some level elsewhere, reuse that level (set it to 2 to keep the smallest number, 3 to keep the largest level, and 1 to keep the first level found).</p>
<p>Any of these three options will cause the SCCs of the automaton <em>a</em> to be computed prior to its actual degeneralization.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classspot_1_1tgba__sba__proxy.html" title="Degeneralize a spot::tgba on the fly, producing an SBA. ">tgba_sba_proxy</a>, <a class="el" href="classspot_1_1tgba__tba__proxy.html" title="Degeneralize a spot::tgba on the fly, producing a TBA. ">tgba_tba_proxy</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gacf73d9eea80cd34b6dc29adaf314229a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API bool spot::is_complete </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>aut</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true iff <em>aut</em> is complete. </p>
<p>An automaton is complete if its translation relation is total, i.e., each state as a successor for any possible configuration. </p>

</div>
</div>
<a class="anchor" id="ga4110dc986c069b0ad42df9ba548238b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API bool spot::is_complete_scc </td>
          <td>(</td>
          <td class="paramtype">scc_map &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>scc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the SCC number <em>scc</em> in <em>map</em> is complete. </p>
<p>An SCC is complete iff for all states and all label there exists a transition that stays into this SCC.</p>
<p>The <a class="el" href="classspot_1_1scc__map.html" title="Build a map of Strongly Connected components in in a TGBA. ">scc_map</a> <em>map</em> should have been built already. </p>

</div>
</div>
<a class="anchor" id="gaa9b9a1dc7e3a28d6994d0ff4bc4ab82a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API bool spot::is_deterministic </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>aut</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true iff <em>aut</em> is deterministic. </p>
<p>This function is more efficient than <a class="el" href="group__tgba__misc.html#ga6fc0abdbe1820c80126aab752d5b1349" title="Count the number of non-deterministic states in aut. ">count_nondet_states()</a> when the automaton is nondeterministic, because it can return before the entire automaton has been explored. </p>

</div>
</div>
<a class="anchor" id="gacedc6cf8955616fc8002a2d3249efb30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API bool spot::is_inherently_weak_scc </td>
          <td>(</td>
          <td class="paramtype">scc_map &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>scc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the SCC number <em>scc</em> in <em>map</em> is inherently weak. </p>
<p>An SCC is inherently weak if either its cycles are all accepting, or they are all non-accepting.</p>
<p>Note the terminal SCCs are also inherently weak with that definition.</p>
<p>The <a class="el" href="classspot_1_1scc__map.html" title="Build a map of Strongly Connected components in in a TGBA. ">scc_map</a> <em>map</em> should have been built already. The absence of accepting cycle is easy to check (the <a class="el" href="classspot_1_1scc__map.html" title="Build a map of Strongly Connected components in in a TGBA. ">scc_map</a> can tell whether the SCC is non-accepting already). Similarly, an SCC in which all transitions belong to all acceptance sets is necessarily weak. For other accepting SCCs, this function enumerates all cycles in the given SCC (it stops if it find a non-accepting cycle). </p>

</div>
</div>
<a class="anchor" id="ga3344a5400ec32f1aaa0f003f91634a39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API bool spot::is_syntactic_terminal_scc </td>
          <td>(</td>
          <td class="paramtype">scc_map &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>scc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the SCC number <em>scc</em> in <em>map</em> is syntactically terminal. </p>
<p>This works only on tgba whose labels are formulas. An SCC is syntactically terminal if one of its states is labeled by a syntactic-guarantee formula.</p>
<p>The <a class="el" href="classspot_1_1scc__map.html" title="Build a map of Strongly Connected components in in a TGBA. ">scc_map</a> <em>map</em> should have been built already. </p>

</div>
</div>
<a class="anchor" id="ga9d3b37479f9996c6e157cacb31be05e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API bool spot::is_syntactic_weak_scc </td>
          <td>(</td>
          <td class="paramtype">scc_map &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>scc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the SCC number <em>scc</em> in <em>map</em> is syntactically weak. </p>
<p>This works only on tgba whose labels are formulas. An SCC is syntactically weak if one of its states is labeled by a syntactic-persistence formula.</p>
<p>The <a class="el" href="classspot_1_1scc__map.html" title="Build a map of Strongly Connected components in in a TGBA. ">scc_map</a> <em>map</em> should have been built already. </p>

</div>
</div>
<a class="anchor" id="gac4b0c59e5185aa88c984fc0be55cc90e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API bool spot::is_terminal_scc </td>
          <td>(</td>
          <td class="paramtype">scc_map &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>scc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the SCC number <em>scc</em> in <em>map</em> is terminal. </p>
<p>An SCC is terminal if it is weak, complete, and accepting.</p>
<p>The <a class="el" href="classspot_1_1scc__map.html" title="Build a map of Strongly Connected components in in a TGBA. ">scc_map</a> <em>map</em> should have been built already. </p>

</div>
</div>
<a class="anchor" id="ga2dcb54c0ecf6dad403d6e3457448fdf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API bool spot::is_weak_scc </td>
          <td>(</td>
          <td class="paramtype">scc_map &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>scc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the SCC number <em>scc</em> in <em>map</em> is weak. </p>
<p>An SCC is weak if its non-accepting, or if all its transition are fully accepting (i.e., the belong to all acceptance sets).</p>
<p>Note that terminal SCCs are also weak with that definition.</p>
<p>The <a class="el" href="classspot_1_1scc__map.html" title="Build a map of Strongly Connected components in in a TGBA. ">scc_map</a> <em>map</em> should have been built already. </p>

</div>
</div>
<a class="anchor" id="gaafc01af4b4688e144f4f04ef0a7c59f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API tgba* spot::random_graph </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ltl::atomic_prop_set *&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_dict *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_acc</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em> = <code>0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>t</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ltl::environment *&#160;</td>
          <td class="paramname"><em>env</em> = <code>&amp;ltl::default_environment::instance()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a tgba randomly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of states wanted in the automata (&gt;0). All states will be connected, and there will be no dead state. </td></tr>
    <tr><td class="paramname">d</td><td>The density of the automata. This is the probability (between 0.0 and 1.0), to add a transition between two states. All states have at least one outgoing transition, so <em>d</em> is considered only when adding the remaining transition. A density of 1 means all states will be connected to each other. </td></tr>
    <tr><td class="paramname">ap</td><td>The list of atomic property that should label the transition. </td></tr>
    <tr><td class="paramname">dict</td><td>The <a class="el" href="classspot_1_1bdd__dict.html" title="Map BDD variables to formulae. ">bdd_dict</a> to used for this automata. </td></tr>
    <tr><td class="paramname">n_acc</td><td>The number of acceptance sets to use. If this number is non null, then there is no guarantee that the generated graph contains an accepting cycle (raise the value of <em>a</em> to improve the chances). </td></tr>
    <tr><td class="paramname">a</td><td>The probability (between 0.0 and 1.0) that a transition belongs to an acceptance set. </td></tr>
    <tr><td class="paramname">t</td><td>The probability (between 0.0 and 1.0) that an atomic proposition is true. </td></tr>
    <tr><td class="paramname">env</td><td>The environment in which to declare the acceptance conditions.</td></tr>
  </table>
  </dd>
</dl>
<p>This algorithms is adapted from the one in Fig 6.2 page 48 of </p>
<pre class="fragment">@TechReport{      tauriainen.00.a66,
  author        = {Heikki Tauriainen},
  title   = {Automated Testing of {B\"u}chi Automata Translators for
                  {L}inear {T}emporal {L}ogic},
  address       = {Espoo, Finland},
  institution = {Helsinki University of Technology, Laboratory for
                  Theoretical Computer Science},
  number        = {A66},
  year  = {2000},
  url   = {http://citeseer.nj.nec.com/tauriainen00automated.html},
  type  = {Research Report},
  note  = {Reprint of Master's thesis}
}
</pre><p> Although the intent is similar, there are some differences between the above published algorithm and this implementation. First labels are on transitions, and acceptance conditions are generated too. Second, the number of successors of a node is chosen in <img class="formulaInl" alt="$[1,n]$" src="form_0.png"/> following a normal distribution with mean <img class="formulaInl" alt="$1+(n-1)d$" src="form_1.png"/> and variance <img class="formulaInl" alt="$(n-1)d(1-d)$" src="form_2.png"/>. (This is less accurate, but faster than considering all possible <em>n</em> successors one by one.) </p>

</div>
</div>
<a class="anchor" id="gafc41419bd3f2ec839eca737554115928"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API tgba_statistics spot::stats_reachable </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>g</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute statistics for an automaton. </p>

</div>
</div>
<a class="anchor" id="ga5bf67a06f0f4abcb9ac3f8313b6aa1f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API sba_explicit_number* spot::strip_acceptance </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate automaton <em>a</em>, removing all acceptance sets. </p>
<p>This is equivalent to marking all states/transitions as accepting. </p>

</div>
</div>
<a class="anchor" id="ga4d72068a20bcf5b2c8b4bd53bb6d993d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API tgba* spot::stutterize </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>atomic_propositions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a state-labeled tgba with self-loops on each state. </p>
<p>Essentially, any transition (src, l, dst) of the input automaton is rewritten into ((src, ?), l, (dst, l)) and each state (x,l) is given a self-loop ((x, l), l, (x, l)). The only exception is it initial state: it is given a false label and no self-loop.</p>
<p>The consequence of this transformation is that the output language includes the input language. If the input language is stutter-invariant, then the two language are identical. This can be used to check the stutter-invariance of some formula. </p>

</div>
</div>
<a class="anchor" id="gaeb1db3d41f0de65c2d6b93cb46225096"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API tgba_sub_statistics spot::sub_stats_reachable </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>g</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute subended statistics for an automaton. </p>

</div>
</div>
<a class="anchor" id="ga61782f7db3ae1ca82378ffaae95ce2fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API tgba_explicit_number* spot::tgba_dupexp_bfs </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>aut</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build an explicit automata from all states of <em>aut</em>, numbering states in bread first order as they are processed. </p>

</div>
</div>
<a class="anchor" id="ga7a04fc4e9913deb9c42e01e27ee436d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API tgba_explicit_number* spot::tgba_dupexp_bfs </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>aut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; const state *, const state *, state_ptr_less_than &gt; &amp;&#160;</td>
          <td class="paramname"><em>relation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build an explicit automata from all states of <em>aut</em>, numbering states in bread first order as they are processed. </p>

</div>
</div>
<a class="anchor" id="ga3492f1f085f2c2ca7508f4673405f22b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API tgba_explicit_number* spot::tgba_dupexp_dfs </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>aut</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build an explicit automata from all states of <em>aut</em>, numbering states in depth first order as they are processed. </p>

</div>
</div>
<a class="anchor" id="ga0b61b3e71348077d0ec8bbabc97599d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API tgba_explicit_number* spot::tgba_dupexp_dfs </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>aut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; const state *, const state *, state_ptr_less_than &gt; &amp;&#160;</td>
          <td class="paramname"><em>relation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build an explicit automata from all states of <em>aut</em>, numbering states in depth first order as they are processed. </p>

</div>
</div>
<a class="anchor" id="ga20c27a27db7186d6fb164ee21ffc0471"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API tgba_explicit_number* spot::tgba_powerset </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>aut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">power_map &amp;&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>merge</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a deterministic automaton, ignoring acceptance conditions. </p>
<p>This create a deterministic automaton that recognizes the same language as <em>aut</em> would if its acceptance conditions were ignored. This is the classical powerset algorithm.</p>
<p>If <em>pm</em> is supplied it will be filled with the set of original states associated to each state of the deterministic automaton. The <em>merge</em> argument can be set to false to prevent merging of transitions. </p>

</div>
</div>
</div><!-- contents -->
<hr size="1">
Please direct any <b>question</b>, <b>comment</b>, or <b>bug report</b> to the Spot mailing list at <a href="mailto:spot@lrde.epita.fr">spot@lrde.epita.fr</a>.
<br><address style="align: right;"><small>
Generated on Thu Aug 21 2014 17:41:53 for spot by <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border=0></a> 1.8.4</small></address>
</body>
</html>
