<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>spot: Emptiness-check algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">spot
   &#160;<span id="projectnumber">1.2.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Emptiness-check algorithms<div class="ingroups"><a class="el" href="group__emptiness__check.html">Emptiness-checks</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1couvreur99__check.html">spot::couvreur99_check</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of the Couvreur99 emptiness-check algorithm.  <a href="classspot_1_1couvreur99__check.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1couvreur99__check__shy.html">spot::couvreur99_check_shy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A version of <a class="el" href="classspot_1_1couvreur99__check.html" title="An implementation of the Couvreur99 emptiness-check algorithm. ">spot::couvreur99_check</a> that tries to visit known states first.  <a href="classspot_1_1couvreur99__check__shy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4dfc3881988710d697245055407c14da"><td class="memItemLeft" align="right" valign="top">SPOT_API emptiness_check *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga4dfc3881988710d697245055407c14da">spot::couvreur99</a> (const tgba *a, option_map options=option_map(), const numbered_state_heap_factory *nshf=numbered_state_heap_hash_map_factory::instance())</td></tr>
<tr class="memdesc:ga4dfc3881988710d697245055407c14da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the language of an automate is empty.  <a href="#ga4dfc3881988710d697245055407c14da">More...</a><br/></td></tr>
<tr class="separator:ga4dfc3881988710d697245055407c14da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03ee089d344d508e71f91d5eb845b798"><td class="memItemLeft" align="right" valign="top">SPOT_API emptiness_check *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga03ee089d344d508e71f91d5eb845b798">spot::explicit_gv04_check</a> (const tgba *a, option_map o=option_map())</td></tr>
<tr class="memdesc:ga03ee089d344d508e71f91d5eb845b798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emptiness check based on Geldenhuys and Valmari's TACAS'04 paper.  <a href="#ga03ee089d344d508e71f91d5eb845b798">More...</a><br/></td></tr>
<tr class="separator:ga03ee089d344d508e71f91d5eb845b798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab986a45098e3d57d97c8a8d3172c1f12"><td class="memItemLeft" align="right" valign="top">SPOT_API emptiness_check *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#gab986a45098e3d57d97c8a8d3172c1f12">spot::explicit_magic_search</a> (const tgba *a, option_map o=option_map())</td></tr>
<tr class="memdesc:gab986a45098e3d57d97c8a8d3172c1f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton. ">spot::tgba</a> automaton <em>a</em>.  <a href="#gab986a45098e3d57d97c8a8d3172c1f12">More...</a><br/></td></tr>
<tr class="separator:gab986a45098e3d57d97c8a8d3172c1f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2d7c16261d9b057e9ae981b6a036218"><td class="memItemLeft" align="right" valign="top">SPOT_API emptiness_check *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#gae2d7c16261d9b057e9ae981b6a036218">spot::bit_state_hashing_magic_search</a> (const tgba *a, size_t size, option_map o=option_map())</td></tr>
<tr class="memdesc:gae2d7c16261d9b057e9ae981b6a036218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton. ">spot::tgba</a> automaton <em>a</em>.  <a href="#gae2d7c16261d9b057e9ae981b6a036218">More...</a><br/></td></tr>
<tr class="separator:gae2d7c16261d9b057e9ae981b6a036218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62ae5da8c13b07d2123295c9bc203580"><td class="memItemLeft" align="right" valign="top">SPOT_API emptiness_check *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga62ae5da8c13b07d2123295c9bc203580">spot::magic_search</a> (const tgba *a, option_map o=option_map())</td></tr>
<tr class="memdesc:ga62ae5da8c13b07d2123295c9bc203580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for the two magic_search implementations.  <a href="#ga62ae5da8c13b07d2123295c9bc203580">More...</a><br/></td></tr>
<tr class="separator:ga62ae5da8c13b07d2123295c9bc203580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc300b4d5924172eb418aee4b2d5c5a6"><td class="memItemLeft" align="right" valign="top">SPOT_API emptiness_check *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#gadc300b4d5924172eb418aee4b2d5c5a6">spot::explicit_se05_search</a> (const tgba *a, option_map o=option_map())</td></tr>
<tr class="memdesc:gadc300b4d5924172eb418aee4b2d5c5a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an emptiness check on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton. ">spot::tgba</a> automaton <em>a</em>.  <a href="#gadc300b4d5924172eb418aee4b2d5c5a6">More...</a><br/></td></tr>
<tr class="separator:gadc300b4d5924172eb418aee4b2d5c5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90fb6bff7456fae04c6afe8ccad28e6e"><td class="memItemLeft" align="right" valign="top">SPOT_API emptiness_check *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga90fb6bff7456fae04c6afe8ccad28e6e">spot::bit_state_hashing_se05_search</a> (const tgba *a, size_t size, option_map o=option_map())</td></tr>
<tr class="memdesc:ga90fb6bff7456fae04c6afe8ccad28e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton. ">spot::tgba</a> automaton <em>a</em>.  <a href="#ga90fb6bff7456fae04c6afe8ccad28e6e">More...</a><br/></td></tr>
<tr class="separator:ga90fb6bff7456fae04c6afe8ccad28e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga268e8d25071258132088b0962a9c16ea"><td class="memItemLeft" align="right" valign="top">SPOT_API emptiness_check *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga268e8d25071258132088b0962a9c16ea">spot::se05</a> (const tgba *a, option_map o)</td></tr>
<tr class="memdesc:ga268e8d25071258132088b0962a9c16ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for the two se05 implementations.  <a href="#ga268e8d25071258132088b0962a9c16ea">More...</a><br/></td></tr>
<tr class="separator:ga268e8d25071258132088b0962a9c16ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea13787a2be1af9a5b7cec845e822d3b"><td class="memItemLeft" align="right" valign="top">SPOT_API emptiness_check *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#gaea13787a2be1af9a5b7cec845e822d3b">spot::explicit_tau03_search</a> (const tgba *a, option_map o=option_map())</td></tr>
<tr class="memdesc:gaea13787a2be1af9a5b7cec845e822d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton. ">spot::tgba</a> automaton <em>a</em>.  <a href="#gaea13787a2be1af9a5b7cec845e822d3b">More...</a><br/></td></tr>
<tr class="separator:gaea13787a2be1af9a5b7cec845e822d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeaeb31458d4987caeb5409bb0e15520"><td class="memItemLeft" align="right" valign="top">SPOT_API emptiness_check *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#gadeaeb31458d4987caeb5409bb0e15520">spot::explicit_tau03_opt_search</a> (const tgba *a, option_map o=option_map())</td></tr>
<tr class="memdesc:gadeaeb31458d4987caeb5409bb0e15520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton. ">spot::tgba</a> automaton <em>a</em>.  <a href="#gadeaeb31458d4987caeb5409bb0e15520">More...</a><br/></td></tr>
<tr class="separator:gadeaeb31458d4987caeb5409bb0e15520"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gae2d7c16261d9b057e9ae981b6a036218"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API emptiness_check* spot::bit_state_hashing_magic_search </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">option_map&#160;</td>
          <td class="paramname"><em>o</em> = <code>option_map()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton. ">spot::tgba</a> automaton <em>a</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The automaton <em>a</em> must have at most one acceptance condition (i.e. it is a TBA).</dd></dl>
<p>During the visit of <em>a</em>, the returned checker does not store explicitely the traversed states but uses the bit-state hashing technic presented in:</p>
<pre class="fragment">@book{Holzmann91,
   author = {G.J. Holzmann},
   title = {Design and Validation of Computer Protocols},
   publisher = {Prentice-Hall},
   address = {Englewood Cliffs, New Jersey},
   year = {1991}
}
</pre><p> Consequently, the detection of an acceptence cycle is not ensured.</p>
<p>The size of the heap is limited to <br/>
 size bytes.</p>
<p>The implemented algorithm is the same as the one of spot::explicit_magic_search.</p>
<dl class="section see"><dt>See Also</dt><dd>spot::explicit_magic_search </dd></dl>

</div>
</div>
<a class="anchor" id="ga90fb6bff7456fae04c6afe8ccad28e6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API emptiness_check* spot::bit_state_hashing_se05_search </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">option_map&#160;</td>
          <td class="paramname"><em>o</em> = <code>option_map()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton. ">spot::tgba</a> automaton <em>a</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The automaton <em>a</em> must have at most one acceptance condition (i.e. it is a TBA).</dd></dl>
<p>During the visit of <em>a</em>, the returned checker does not store explicitely the traversed states but uses the bit-state hashing technic presented in:</p>
<pre class="fragment">@book{Holzmann91,
   author = {G.J. Holzmann},
   title = {Design and Validation of Computer Protocols},
   publisher = {Prentice-Hall},
   address = {Englewood Cliffs, New Jersey},
   year = {1991}
}
</pre><p> Consequently, the detection of an acceptence cycle is not ensured.</p>
<p>The size of the heap is limited to <br/>
 size bytes.</p>
<p>The implemented algorithm is the same as the one of spot::explicit_se05_search.</p>
<dl class="section see"><dt>See Also</dt><dd>spot::explicit_se05_search </dd></dl>

</div>
</div>
<a class="anchor" id="ga4dfc3881988710d697245055407c14da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API emptiness_check* spot::couvreur99 </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">option_map&#160;</td>
          <td class="paramname"><em>options</em> = <code>option_map()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const numbered_state_heap_factory *&#160;</td>
          <td class="paramname"><em>nshf</em> = <code>numbered_state_heap_hash_map_factory::instance()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the language of an automate is empty. </p>
<p>This is based on the following paper. </p>
<pre class="fragment">@InProceedings{couvreur.99.fm,
  author    = {Jean-Michel Couvreur},
  title     = {On-the-fly Verification of Temporal Logic},
  pages     = {253--271},
  editor    = {Jeannette M. Wing and Jim Woodcock and Jim Davies},
  booktitle = {Proceedings of the World Congress on Formal Methods in
               the Development of Computing Systems (FM'99)},
  publisher = {Springer-Verlag},
  series    = {Lecture Notes in Computer Science},
  volume    = {1708},
  year      = {1999},
  address   = {Toulouse, France},
  month     = {September},
  isbn      = {3-540-66587-0}
}
</pre><p> A recursive definition of the algorithm would look as follows, but the implementation is of course not recursive. (<code>&lt;Sigma, Q, delta, q, F&gt;</code> is the automaton to check, H is an associative array mapping each state to its positive DFS order or 0 if it is dead, SCC is and ACC are two stacks.)</p>
<pre class="fragment">check(&lt;Sigma, Q, delta, q, F&gt;, H, SCC, ACC)
  if q is not in H   // new state
      H[q] = H.size + 1
      SCC.push(&lt;H[q], {}&gt;)
      forall &lt;a, s&gt; : &lt;q, _, a, s&gt; in delta
          ACC.push(a)
          res = check(&lt;Sigma, Q, delta, s, F&gt;, H, SCC, ACC)
          if res
              return res
      &lt;n, _&gt; = SCC.top()
      if n = H[q]
          SCC.pop()
          mark_reachable_states_as_dead(&lt;Sigma, Q, delta, q, F&gt;, H$)
      return 0
  else
      if H[q] = 0 // dead state
          ACC.pop()
          return true
      else // state in stack: merge SCC
          all = {}
          do
              &lt;n, a&gt; = SCC.pop()
              all = all union a union { ACC.pop() }
          until n &lt;= H[q]
          SCC.push(&lt;n, all&gt;)
          if all != F
              return 0
          return new emptiness_check_result(necessary data)
</pre><p> check() returns 0 iff the automaton's language is empty. It returns an instance of <a class="el" href="classspot_1_1emptiness__check__result.html" title="The result of an emptiness check. ">emptiness_check_result</a>. If the automaton accept a word. (Use <a class="el" href="classspot_1_1emptiness__check__result.html#a909ae24b5e8454cb966d320e997570ab" title="Return a run accepted by the automata passed to the emptiness check. ">emptiness_check_result::accepting_run()</a> to extract an accepting run.)</p>
<p>There are two variants of this algorithm: <a class="el" href="classspot_1_1couvreur99__check.html" title="An implementation of the Couvreur99 emptiness-check algorithm. ">spot::couvreur99_check</a> and <a class="el" href="classspot_1_1couvreur99__check__shy.html" title="A version of spot::couvreur99_check that tries to visit known states first. ">spot::couvreur99_check_shy</a>. They differ in their memory usage, the number for successors computed before they are used and the way the depth first search is directed.</p>
<p><a class="el" href="classspot_1_1couvreur99__check.html" title="An implementation of the Couvreur99 emptiness-check algorithm. ">spot::couvreur99_check</a> performs a straightforward depth first search. The DFS stacks store tgba_succ_iterators, so that only the iterators which really are explored are computed.</p>
<p><a class="el" href="classspot_1_1couvreur99__check__shy.html" title="A version of spot::couvreur99_check that tries to visit known states first. ">spot::couvreur99_check_shy</a> tries to explore successors which are visited states first. this helps to merge SCCs and generally helps to produce shorter counter-examples. However this algorithm cannot stores unprocessed successors as tgba_succ_iterators: it must compute all successors of a state at once in order to decide which to explore first, and must keep a list of all unexplored successors in its DFS stack.</p>
<p>The <a class="el" href="group__emptiness__check__algorithms.html#ga4dfc3881988710d697245055407c14da" title="Check whether the language of an automate is empty. ">couvreur99()</a> function is a wrapper around these two flavors of the algorithm. <em>options</em> is an option map that specifies which algorithms should be used, and how.</p>
<p>The following options are available. </p>
<ul>
<li><code>"shy"</code> : if non zero, then <a class="el" href="classspot_1_1couvreur99__check__shy.html" title="A version of spot::couvreur99_check that tries to visit known states first. ">spot::couvreur99_check_shy</a> is used, otherwise (and by default) <a class="el" href="classspot_1_1couvreur99__check.html" title="An implementation of the Couvreur99 emptiness-check algorithm. ">spot::couvreur99_check</a> is used.</li>
</ul>
<ul>
<li><code>"poprem"</code> : specifies how the algorithm should handle the destruction of non-accepting maximal strongly connected components. If <code>poprem</code> is non null, the algorithm will keep a list of all states of a SCC that are fully processed and should be removed once the MSCC is popped. If <code>poprem</code> is null (the default), the MSCC will be traversed again (i.e. generating the successors of the root recursively) for deletion. This is a choice between memory and speed.</li>
</ul>
<ul>
<li><code>"group"</code> : this options is used only by <a class="el" href="classspot_1_1couvreur99__check__shy.html" title="A version of spot::couvreur99_check that tries to visit known states first. ">spot::couvreur99_check_shy</a>. If non null (the default), the successors of all the states that belong to the same SCC will be considered when choosing a successor. Otherwise, only the successor of the topmost state on the DFS stack are considered. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga03ee089d344d508e71f91d5eb845b798"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API emptiness_check* spot::explicit_gv04_check </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">option_map&#160;</td>
          <td class="paramname"><em>o</em> = <code>option_map()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emptiness check based on Geldenhuys and Valmari's TACAS'04 paper. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The automaton <em>a</em> must have at most one acceptance condition.</dd></dl>
<p>The original algorithm, coming from the following paper, has only been slightly modified to work on transition-based automata. </p>
<pre class="fragment">@InProceedings{geldenhuys.04.tacas,
  author  = {Jaco Geldenhuys and Antti Valmari},
  title   = {Tarjan's Algorithm Makes On-the-Fly {LTL} Verification
            More Efficient},
  booktitle = {Proceedings of the 10th International Conference on Tools
            and Algorithms for the Construction and Analysis of Systems
            (TACAS'04)},
  editor  = {Kurt Jensen and Andreas Podelski},
  pages   = {205--219},
  year    = {2004},
  publisher = {Springer-Verlag},
  series  = {Lecture Notes in Computer Science},
  volume  = {2988},
  isbn    = {3-540-21299-X}
}
</pre> 
</div>
</div>
<a class="anchor" id="gab986a45098e3d57d97c8a8d3172c1f12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API emptiness_check* spot::explicit_magic_search </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">option_map&#160;</td>
          <td class="paramname"><em>o</em> = <code>option_map()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton. ">spot::tgba</a> automaton <em>a</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The automaton <em>a</em> must have at most one acceptance condition (i.e. it is a TBA).</dd></dl>
<p>During the visit of <em>a</em>, the returned checker stores explicitely all the traversed states. The method <em>check()</em> of the checker can be called several times (until it returns a null pointer) to enumerate all the visited acceptance paths. The implemented algorithm is the following:</p>
<pre class="fragment">procedure check ()
begin
  call dfs_blue(s0);
end;

procedure dfs_blue (s)
begin
  s.color = blue;
  for all t in post(s) do
    if t.color == white then
      call dfs_blue(t);
    end if;
    if (the edge (s,t) is accepting) then
      target = s;
      call dfs_red(t);
    end if;
  end for;
end;

procedure dfs_red(s)
begin
  s.color = red;
  if s == target then
    report cycle
  end if;
  for all t in post(s) do
    if t.color == blue then
      call dfs_red(t);
    end if;
  end for;
end;
</pre><p> This algorithm is an adaptation to TBA of the one (which deals with accepting states) presented in</p>
<pre class="fragment"> Article{         courcoubetis.92.fmsd,
   author        = {Costas Courcoubetis and Moshe Y. Vardi and Pierre
                   Wolper and Mihalis Yannakakis},
   title         = {Memory-Efficient Algorithm for the Verification of
                   Temporal Properties},
   journal       = {Formal Methods in System Design},
   pages         = {275--288},
   year          = {1992},
   volume        = {1}
 }
</pre> <dl class="bug"><dt><b><a class="el" href="bug.html#_bug000001">Bug:</a></b></dt><dd>The name is misleading. Magic-search is the algorithm from <code>godefroid.93.pstv</code>, not <code>courcoubetis.92.fmsd</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gadc300b4d5924172eb418aee4b2d5c5a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API emptiness_check* spot::explicit_se05_search </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">option_map&#160;</td>
          <td class="paramname"><em>o</em> = <code>option_map()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an emptiness check on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton. ">spot::tgba</a> automaton <em>a</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The automaton <em>a</em> must have at most one acceptance condition (i.e. it is a TBA).</dd></dl>
<p>During the visit of <em>a</em>, the returned checker stores explicitely all the traversed states. The method <em>check()</em> of the checker can be called several times (until it returns a null pointer) to enumerate all the visited accepting paths. The implemented algorithm is an optimization of spot::explicit_magic_search and is the following:</p>
<pre class="fragment">procedure check ()
begin
  call dfs_blue(s0);
end;

procedure dfs_blue (s)
begin
  s.color = cyan;
  for all t in post(s) do
    if t.color == white then
      call dfs_blue(t);
    else if t.color == cyan and
            (the edge (s,t) is accepting or
             (it exists a predecessor p of s in st_blue and s != t and
             the arc between p and s is accepting)) then
      report cycle;
    end if;
    if the edge (s,t) is accepting then
      call dfs_red(t);
    end if;
  end for;
  s.color = blue;
end;

procedure dfs_red(s)
begin
  if s.color == cyan then
    report cycle;
  end if;
  s.color = red;
  for all t in post(s) do
    if t.color == blue then
      call dfs_red(t);
    end if;
  end for;
end;
</pre><p> It is an adaptation to TBA of the one presented in </p>
<pre class="fragment">  @techreport{SE04,
    author = {Stefan Schwoon and Javier Esparza},
    institution = {Universit{\"a}t Stuttgart, Fakult\"at Informatik,
    Elektrotechnik und Informationstechnik},
    month = {November},
    number = {2004/06},
    title = {A Note on On-The-Fly Verification Algorithms},
    year = {2004},
    url =
{http://www.fmi.uni-stuttgart.de/szs/publications/info/schwoosn.SE04.shtml}
  }</pre> <dl class="section see"><dt>See Also</dt><dd>spot::explicit_magic_search </dd></dl>

</div>
</div>
<a class="anchor" id="gadeaeb31458d4987caeb5409bb0e15520"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API emptiness_check* spot::explicit_tau03_opt_search </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">option_map&#160;</td>
          <td class="paramname"><em>o</em> = <code>option_map()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton. ">spot::tgba</a> automaton <em>a</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The automaton <em>a</em> must have at least one acceptance condition.</dd></dl>
<p>During the visit of <em>a</em>, the returned checker stores explicitely all the traversed states. The implemented algorithm is the following:</p>
<pre class="fragment">procedure check ()
begin
  weight = 0; // the null vector
  call dfs_blue(s0);
end;

procedure dfs_blue (s)
begin
  s.color = cyan;
  s.acc = emptyset;
  s.weight = weight;
  for all t in post(s) do
    let (s, l, a, t) be the edge from s to t;
    if t.color == white then
      for all b in a do
        weight[b] = weight[b] + 1;
      end for;
      call dfs_blue(t);
      for all b in a do
        weight[b] = weight[b] - 1;
      end for;
    end if;
    Acc = s.acc U a;
    if t.color == cyan &amp;&amp;
              (Acc U support(weight - t.weight) U t.acc) == all_acc then
      report a cycle;
    else if Acc not included in t.acc then
      t.acc := t.acc U Acc;
      call dfs_red(t, Acc);
    end if;
  end for;
  s.color = blue;
end;

procedure dfs_red(s, Acc)
begin
  for all t in post(s) do
    let (s, l, a, t) be the edge from s to t;
    if t.color == cyan &amp;&amp;
                (Acc U support(weight - t.weight) U t.acc) == all_acc then
      report a cycle;
    else if t.color != white and Acc not included in t.acc then
      t.acc := t.acc U Acc;
      call dfs_red(t, Acc);
    end if;
  end for;
end;
</pre><p> This algorithm is a generalisation to TGBA of the one implemented in spot::explicit_se05_search. It is based on the acceptance set labelling of states used in spot::explicit_tau03_search. Moreover, it introduce a slight optimisation based on vectors of integers counting for each acceptance condition how many time the condition has been visited in the path stored in the blue stack. Such a vector is associated to each state of this stack. </p>

</div>
</div>
<a class="anchor" id="gaea13787a2be1af9a5b7cec845e822d3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API emptiness_check* spot::explicit_tau03_search </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">option_map&#160;</td>
          <td class="paramname"><em>o</em> = <code>option_map()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton. ">spot::tgba</a> automaton <em>a</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The automaton <em>a</em> must have at least one acceptance condition.</dd></dl>
<p>During the visit of <em>a</em>, the returned checker stores explicitely all the traversed states. The implemented algorithm is the following:</p>
<pre class="fragment">procedure check ()
begin
  call dfs_blue(s0);
end;

procedure dfs_blue (s)
begin
  s.color = blue;
  s.acc = emptyset;
  for all t in post(s) do
    if t.color == white then
      call dfs_blue(t);
    end if;
  end for;
  for all t in post(s) do
    let (s, l, a, t) be the edge from s to t;
    if s.acc U a not included in t.acc then
      call dfs_red(t, a U s.acc);
    end if;
  end for;
  if s.acc == all_acc then
    report a cycle;
  end if;
end;

procedure dfs_red(s, A)
begin
  s.acc = s.acc U A;
  for all t in post(s) do
    if t.color != white and A not included in t.acc then
      call dfs_red(t, A);
    end if;
  end for;
end;
</pre><p> This algorithm is the one presented in</p>
<pre class="fragment">@techreport{HUT-TCS-A83,
   address = {Espoo, Finland},
   author = {Heikki Tauriainen},
   institution = {Helsinki University of Technology, Laboratory for
   Theoretical Computer Science},
   month = {December},
   number = {A83},
   pages = {132},
   title = {On Translating Linear Temporal Logic into Alternating and
   Nondeterministic Automata},
   type = {Research Report},
   year = {2003},
   url = {http://www.tcs.hut.fi/Publications/info/bibdb.HUT-TCS-A83.shtml}
}
</pre> 
</div>
</div>
<a class="anchor" id="ga62ae5da8c13b07d2123295c9bc203580"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API emptiness_check* spot::magic_search </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">option_map&#160;</td>
          <td class="paramname"><em>o</em> = <code>option_map()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for the two magic_search implementations. </p>
<p>This wrapper calls explicit_magic_search_search() or <a class="el" href="group__emptiness__check__algorithms.html#gae2d7c16261d9b057e9ae981b6a036218" title="Returns an emptiness checker on the spot::tgba automaton a. ">bit_state_hashing_magic_search()</a> according to the <code>"bsh"</code> option in the <code><a class="el" href="classspot_1_1option__map.html" title="Manage a map of options. ">option_map</a></code>. If <code>"bsh"</code> is set and non null, its value is used as the size of the hash map. </p>

</div>
</div>
<a class="anchor" id="ga268e8d25071258132088b0962a9c16ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API emptiness_check* spot::se05 </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">option_map&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for the two se05 implementations. </p>
<p>This wrapper calls <a class="el" href="group__emptiness__check__algorithms.html#gadc300b4d5924172eb418aee4b2d5c5a6" title="Returns an emptiness check on the spot::tgba automaton a. ">explicit_se05_search()</a> or <a class="el" href="group__emptiness__check__algorithms.html#ga90fb6bff7456fae04c6afe8ccad28e6e" title="Returns an emptiness checker on the spot::tgba automaton a. ">bit_state_hashing_se05_search()</a> according to the <code>"bsh"</code> option in the <code><a class="el" href="classspot_1_1option__map.html" title="Manage a map of options. ">option_map</a></code>. If <code>"bsh"</code> is set and non null, its value is used as the size of the hash map. </p>

</div>
</div>
</div><!-- contents -->
<hr size="1">
Please direct any <b>question</b>, <b>comment</b>, or <b>bug report</b> to the Spot mailing list at <a href="mailto:spot@lrde.epita.fr">spot@lrde.epita.fr</a>.
<br><address style="align: right;"><small>
Generated on Thu Aug 21 2014 17:41:53 for spot by <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border=0></a> 1.8.4</small></address>
</body>
</html>
