<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>spot: spot::ta Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">spot
   &#160;<span id="projectnumber">1.2.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>spot</b></li><li class="navelem"><a class="el" href="classspot_1_1ta.html">ta</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classspot_1_1ta-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">spot::ta Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__ta__essentials.html">Essential TA types</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A Testing Automaton.  
 <a href="classspot_1_1ta.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ta_8hh_source.html">ta/ta.hh</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for spot::ta:</div>
<div class="dyncontent">
<div class="center"><img src="classspot_1_1ta__inherit__graph.png" border="0" usemap="#spot_1_1ta_inherit__map" alt="Inheritance graph"/></div>
<map name="spot_1_1ta_inherit__map" id="spot_1_1ta_inherit__map">
<area shape="rect" id="node3" href="classspot_1_1ta__explicit.html" title="{spot::ta_explicit\n||+ ta_explicit()\l+ get_tgba()\l+ add_state()\l+ add_to_initial_states_set()\l+ create_transition()\l+ delete_stuttering_transitions()\l+ ~ta_explicit()\l+ get_initial_states_set()\l+ succ_iter()\l+ succ_iter()\land 12 more...\l}" alt="" coords="5,462,211,773"/><area shape="rect" id="node5" href="classspot_1_1ta__product.html" title="A lazy product between a Testing automaton and a Kripke structure. (States are computed on the fly..." alt="" coords="235,451,400,783"/></map>
</div>
<div class="dynheader">
Collaboration diagram for spot::ta:</div>
<div class="dyncontent">
<div class="center"><img src="classspot_1_1ta__coll__graph.png" border="0" usemap="#spot_1_1ta_coll__map" alt="Collaboration graph"/></div>
<map name="spot_1_1ta_coll__map" id="spot_1_1ta_coll__map">
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af1bc68c8c3cd3f18de560546ff624ea7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1bc68c8c3cd3f18de560546ff624ea7"></a>
typedef std::set&lt; <a class="el" href="classspot_1_1state.html">state</a> <br class="typebreak"/>
*, <a class="el" href="structspot_1_1state__ptr__less__than.html">state_ptr_less_than</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>states_set_t</b></td></tr>
<tr class="separator:af1bc68c8c3cd3f18de560546ff624ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae847e1d2f986db3bbc7a0d7535155677"><td class="memItemLeft" align="right" valign="top">virtual const states_set_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta.html#ae847e1d2f986db3bbc7a0d7535155677">get_initial_states_set</a> () const =0</td></tr>
<tr class="memdesc:ae847e1d2f986db3bbc7a0d7535155677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the initial states set of the automaton.  <a href="#ae847e1d2f986db3bbc7a0d7535155677">More...</a><br/></td></tr>
<tr class="separator:ae847e1d2f986db3bbc7a0d7535155677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbd41f6c0e19af83d55816a5fbb2321"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classspot_1_1state.html">spot::state</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta.html#a5cbd41f6c0e19af83d55816a5fbb2321">get_artificial_initial_state</a> () const </td></tr>
<tr class="memdesc:a5cbd41f6c0e19af83d55816a5fbb2321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the artificial initial state set of the automaton. Return 0 if this artificial state is not implemented (in this case, use <code>get_initial_states_set</code>) The aim of adding this state is to have an unique initial state. This artificial initial state have one transition to each real initial state, and this transition is labeled by the corresponding initial condition. (For more details, see the paper cited above)  <a href="#a5cbd41f6c0e19af83d55816a5fbb2321">More...</a><br/></td></tr>
<tr class="separator:a5cbd41f6c0e19af83d55816a5fbb2321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b2f71c85c0dd17b850197537a383bc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classspot_1_1ta__succ__iterator.html">ta_succ_iterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta.html#af0b2f71c85c0dd17b850197537a383bc">succ_iter</a> (const <a class="el" href="classspot_1_1state.html">spot::state</a> *<a class="el" href="classspot_1_1state.html">state</a>) const =0</td></tr>
<tr class="memdesc:af0b2f71c85c0dd17b850197537a383bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator over the successors of <em>state</em>.  <a href="#af0b2f71c85c0dd17b850197537a383bc">More...</a><br/></td></tr>
<tr class="separator:af0b2f71c85c0dd17b850197537a383bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ebc32d6cc33044f538c25b07eb09bd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classspot_1_1ta__succ__iterator.html">ta_succ_iterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta.html#af9ebc32d6cc33044f538c25b07eb09bd">succ_iter</a> (const <a class="el" href="classspot_1_1state.html">spot::state</a> *<a class="el" href="classspot_1_1state.html">state</a>, bdd changeset) const =0</td></tr>
<tr class="memdesc:af9ebc32d6cc33044f538c25b07eb09bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator over the successors of <em>state</em> filtred by the changeset on transitions.  <a href="#af9ebc32d6cc33044f538c25b07eb09bd">More...</a><br/></td></tr>
<tr class="separator:af9ebc32d6cc33044f538c25b07eb09bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1cf7537d0702b2acc136578895d926"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta.html#a5b1cf7537d0702b2acc136578895d926">get_dict</a> () const =0</td></tr>
<tr class="memdesc:a5b1cf7537d0702b2acc136578895d926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dictionary associated to the automaton.  <a href="#a5b1cf7537d0702b2acc136578895d926">More...</a><br/></td></tr>
<tr class="separator:a5b1cf7537d0702b2acc136578895d926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075f7fdb44428659a16484170477e77e"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta.html#a075f7fdb44428659a16484170477e77e">format_state</a> (const <a class="el" href="classspot_1_1state.html">spot::state</a> *s) const =0</td></tr>
<tr class="memdesc:a075f7fdb44428659a16484170477e77e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format the state as a string for printing.  <a href="#a075f7fdb44428659a16484170477e77e">More...</a><br/></td></tr>
<tr class="separator:a075f7fdb44428659a16484170477e77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05398307c3e98a177f7f182b2becb6ee"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta.html#a05398307c3e98a177f7f182b2becb6ee">is_accepting_state</a> (const <a class="el" href="classspot_1_1state.html">spot::state</a> *s) const =0</td></tr>
<tr class="memdesc:a05398307c3e98a177f7f182b2becb6ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <em>s</em> is a Buchi-accepting state, otherwise false.  <a href="#a05398307c3e98a177f7f182b2becb6ee">More...</a><br/></td></tr>
<tr class="separator:a05398307c3e98a177f7f182b2becb6ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2b5e5f1ad31adbc157571d88007b01"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta.html#a5e2b5e5f1ad31adbc157571d88007b01">is_livelock_accepting_state</a> (const <a class="el" href="classspot_1_1state.html">spot::state</a> *s) const =0</td></tr>
<tr class="memdesc:a5e2b5e5f1ad31adbc157571d88007b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <em>s</em> is a livelock-accepting state , otherwise false.  <a href="#a5e2b5e5f1ad31adbc157571d88007b01">More...</a><br/></td></tr>
<tr class="separator:a5e2b5e5f1ad31adbc157571d88007b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9291b601b2c32aa38c04feeb5f48a703"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta.html#a9291b601b2c32aa38c04feeb5f48a703">is_initial_state</a> (const <a class="el" href="classspot_1_1state.html">spot::state</a> *s) const =0</td></tr>
<tr class="memdesc:a9291b601b2c32aa38c04feeb5f48a703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <em>s</em> is an initial state, otherwise false.  <a href="#a9291b601b2c32aa38c04feeb5f48a703">More...</a><br/></td></tr>
<tr class="separator:a9291b601b2c32aa38c04feeb5f48a703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807b62b44071746902e7d5e76b7fefad"><td class="memItemLeft" align="right" valign="top">virtual bdd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta.html#a807b62b44071746902e7d5e76b7fefad">get_state_condition</a> (const <a class="el" href="classspot_1_1state.html">spot::state</a> *s) const =0</td></tr>
<tr class="memdesc:a807b62b44071746902e7d5e76b7fefad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a BDD condition that represents the valuation of atomic propositions in the state <em>s</em>.  <a href="#a807b62b44071746902e7d5e76b7fefad">More...</a><br/></td></tr>
<tr class="separator:a807b62b44071746902e7d5e76b7fefad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fe8227b08e5d5ae575fddec620d85c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta.html#a83fe8227b08e5d5ae575fddec620d85c">free_state</a> (const <a class="el" href="classspot_1_1state.html">spot::state</a> *s) const =0</td></tr>
<tr class="memdesc:a83fe8227b08e5d5ae575fddec620d85c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a state <em>s</em>.  <a href="#a83fe8227b08e5d5ae575fddec620d85c">More...</a><br/></td></tr>
<tr class="separator:a83fe8227b08e5d5ae575fddec620d85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06639adf20622dcafaa7a9a3e7f6417f"><td class="memItemLeft" align="right" valign="top">virtual bdd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ta.html#a06639adf20622dcafaa7a9a3e7f6417f">all_acceptance_conditions</a> () const =0</td></tr>
<tr class="memdesc:a06639adf20622dcafaa7a9a3e7f6417f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the set of all acceptance conditions used by this automaton (for Generalized form: Transition-based Generalized Testing Automata).  <a href="#a06639adf20622dcafaa7a9a3e7f6417f">More...</a><br/></td></tr>
<tr class="separator:a06639adf20622dcafaa7a9a3e7f6417f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A Testing Automaton. </p>
<p>The Testing Automata (TA) were introduced by Henri Hansen, Wojciech Penczek and Antti Valmari in "Stuttering-insensitive automata for on-the-fly detection of livelock
properties" In Proc. of FMICSÃ02, vol. 66(2) of Electronic Notes in Theoretical Computer Science.Elsevier.</p>
<p>While a TGBA automaton observes the value of the atomic propositions, the basic idea of TA is to detect the changes in these values; if a valuation does not change between two consecutive valuations of an execution, the TA stay in the same state. A TA transition <code></code>(s,k,d) is labeled by a "changeset" <code>k:</code> i.e. the set of atomic propositions that change between states <code>s</code> and <code>d</code>, if the changeset is empty then the transition is called stuttering transition. To detect execution that ends by stuttering in the same TA state, a new kind of acceptance states is introduced: "livelock-acceptance states" (in addition to the standard Buchi-acceptance states).</p>
<p>Browsing such automaton can be achieved using two functions: <code>get_initial_states_set</code> or <code>get_artificial_initial_state</code>, and <code>succ_iter</code>. The former returns the initial state(s) while the latter lists the successor states of any state (filtred by "changeset").</p>
<p>Note that although this is a transition-based automata, we never represent transitions! Transition informations are obtained by querying the iterator over the successors of a state. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a06639adf20622dcafaa7a9a3e7f6417f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bdd spot::ta::all_acceptance_conditions </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the set of all acceptance conditions used by this automaton (for Generalized form: Transition-based Generalized Testing Automata). </p>
<p>The goal of the emptiness check is to ensure that a strongly connected component walks through each of these acceptiong conditions. I.e., the union of the acceptiong conditions of all transition in the SCC should be equal to the result of this function. </p>

<p>Implemented in <a class="el" href="classspot_1_1ta__product.html#a92e05f856dea6407fb13a385bc41e202">spot::ta_product</a>, and <a class="el" href="classspot_1_1ta__explicit.html#a0a4f238c1876d503352f15e80940721c">spot::ta_explicit</a>.</p>

</div>
</div>
<a class="anchor" id="a075f7fdb44428659a16484170477e77e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string spot::ta::format_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspot_1_1state.html">spot::state</a> *&#160;</td>
          <td class="paramname"><em>s</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Format the state as a string for printing. </p>
<p>This formating is the responsability of the automata that owns the state. </p>

<p>Implemented in <a class="el" href="classspot_1_1ta__product.html#a4e33014ad5446206c2d213daaf86ef9a">spot::ta_product</a>, and <a class="el" href="classspot_1_1ta__explicit.html#a75d9f86c25fd4a7cd6ababa7467846d2">spot::ta_explicit</a>.</p>

</div>
</div>
<a class="anchor" id="a83fe8227b08e5d5ae575fddec620d85c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void spot::ta::free_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspot_1_1state.html">spot::state</a> *&#160;</td>
          <td class="paramname"><em>s</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release a state <em>s</em>. </p>

<p>Implemented in <a class="el" href="classspot_1_1ta__product.html#ab5d98a9265409d846c8ac85fde9f2ff2">spot::ta_product</a>, and <a class="el" href="classspot_1_1ta__explicit.html#aa7879d15aae1adf6d25386d381f894f3">spot::ta_explicit</a>.</p>

</div>
</div>
<a class="anchor" id="a5cbd41f6c0e19af83d55816a5fbb2321"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classspot_1_1state.html">spot::state</a>* spot::ta::get_artificial_initial_state </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the artificial initial state set of the automaton. Return 0 if this artificial state is not implemented (in this case, use <code>get_initial_states_set</code>) The aim of adding this state is to have an unique initial state. This artificial initial state have one transition to each real initial state, and this transition is labeled by the corresponding initial condition. (For more details, see the paper cited above) </p>

<p>Reimplemented in <a class="el" href="classspot_1_1ta__explicit.html#a7f13f19527ada113bb7748d6f79597f0">spot::ta_explicit</a>.</p>

</div>
</div>
<a class="anchor" id="a5b1cf7537d0702b2acc136578895d926"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a>* spot::ta::get_dict </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dictionary associated to the automaton. </p>
<p>State are represented as BDDs. The dictionary allows to map BDD variables back to formulae, and vice versa. This is useful when dealing with several automata (which may use the same BDD variable for different formula), or simply when printing. </p>

<p>Implemented in <a class="el" href="classspot_1_1ta__product.html#acea792a98272b138671d47dfbef04805">spot::ta_product</a>, and <a class="el" href="classspot_1_1ta__explicit.html#a2d9f1b65d258892c253750376a758213">spot::ta_explicit</a>.</p>

</div>
</div>
<a class="anchor" id="ae847e1d2f986db3bbc7a0d7535155677"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const states_set_t spot::ta::get_initial_states_set </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the initial states set of the automaton. </p>

<p>Implemented in <a class="el" href="classspot_1_1ta__product.html#abb252ecb9029cfddfcad6bc4e9e98bb9">spot::ta_product</a>, and <a class="el" href="classspot_1_1ta__explicit.html#a829c195d324bf9fd80cabdb883f1beb3">spot::ta_explicit</a>.</p>

</div>
</div>
<a class="anchor" id="a807b62b44071746902e7d5e76b7fefad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bdd spot::ta::get_state_condition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspot_1_1state.html">spot::state</a> *&#160;</td>
          <td class="paramname"><em>s</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a BDD condition that represents the valuation of atomic propositions in the state <em>s</em>. </p>

<p>Implemented in <a class="el" href="classspot_1_1ta__product.html#a60defd29b185e0042c197f732c4e25c6">spot::ta_product</a>, and <a class="el" href="classspot_1_1ta__explicit.html#a696a3fcfbe853754a3d6402a8ec16f56">spot::ta_explicit</a>.</p>

</div>
</div>
<a class="anchor" id="a05398307c3e98a177f7f182b2becb6ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool spot::ta::is_accepting_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspot_1_1state.html">spot::state</a> *&#160;</td>
          <td class="paramname"><em>s</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if <em>s</em> is a Buchi-accepting state, otherwise false. </p>

<p>Implemented in <a class="el" href="classspot_1_1ta__product.html#ab9c5f0fbc7c6ce5f721c280537386c75">spot::ta_product</a>, and <a class="el" href="classspot_1_1ta__explicit.html#a908627a9e60708a3c1f5a63f641ff5da">spot::ta_explicit</a>.</p>

</div>
</div>
<a class="anchor" id="a9291b601b2c32aa38c04feeb5f48a703"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool spot::ta::is_initial_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspot_1_1state.html">spot::state</a> *&#160;</td>
          <td class="paramname"><em>s</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if <em>s</em> is an initial state, otherwise false. </p>

<p>Implemented in <a class="el" href="classspot_1_1ta__product.html#abefe2a449db42357241e2aefd8b52934">spot::ta_product</a>, and <a class="el" href="classspot_1_1ta__explicit.html#a1d914fc0d7f5aed14ab92befcda2d668">spot::ta_explicit</a>.</p>

</div>
</div>
<a class="anchor" id="a5e2b5e5f1ad31adbc157571d88007b01"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool spot::ta::is_livelock_accepting_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspot_1_1state.html">spot::state</a> *&#160;</td>
          <td class="paramname"><em>s</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if <em>s</em> is a livelock-accepting state , otherwise false. </p>

<p>Implemented in <a class="el" href="classspot_1_1ta__product.html#af6a40ce841dbb319f5ee9d6467344943">spot::ta_product</a>, and <a class="el" href="classspot_1_1ta__explicit.html#a6de8fc9f373578cbc436af5f1d58fa97">spot::ta_explicit</a>.</p>

</div>
</div>
<a class="anchor" id="af0b2f71c85c0dd17b850197537a383bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classspot_1_1ta__succ__iterator.html">ta_succ_iterator</a>* spot::ta::succ_iter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspot_1_1state.html">spot::state</a> *&#160;</td>
          <td class="paramname"><em>state</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator over the successors of <em>state</em>. </p>
<p>The iterator has been allocated with <code>new</code>. It is the responsability of the caller to <code>delete</code> it when no longer needed. </p>

<p>Implemented in <a class="el" href="classspot_1_1ta__product.html#aba95be080867af93d7c3cd4f3e8ffedb">spot::ta_product</a>, and <a class="el" href="classspot_1_1ta__explicit.html#a56ff22eacfb314076c3795e29c51bd45">spot::ta_explicit</a>.</p>

</div>
</div>
<a class="anchor" id="af9ebc32d6cc33044f538c25b07eb09bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classspot_1_1ta__succ__iterator.html">ta_succ_iterator</a>* spot::ta::succ_iter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspot_1_1state.html">spot::state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>changeset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator over the successors of <em>state</em> filtred by the changeset on transitions. </p>
<p>The iterator has been allocated with <code>new</code>. It is the responsability of the caller to <code>delete</code> it when no longer needed. </p>

<p>Implemented in <a class="el" href="classspot_1_1ta__product.html#a700b77deec59337ac426796f2f94c453">spot::ta_product</a>, and <a class="el" href="classspot_1_1ta__explicit.html#ae63d26c7687ae408133aeb95c793a4d5">spot::ta_explicit</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ta/<a class="el" href="ta_8hh_source.html">ta.hh</a></li>
</ul>
</div><!-- contents -->
<hr size="1">
Please direct any <b>question</b>, <b>comment</b>, or <b>bug report</b> to the Spot mailing list at <a href="mailto:spot@lrde.epita.fr">spot@lrde.epita.fr</a>.
<br><address style="align: right;"><small>
Generated on Thu Aug 21 2014 17:41:53 for spot by <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border=0></a> 1.8.4</small></address>
</body>
</html>
