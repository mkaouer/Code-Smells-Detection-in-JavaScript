<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>spot: spot::bdd_dict Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">spot
   &#160;<span id="projectnumber">1.2.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>spot</b></li><li class="navelem"><a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classspot_1_1bdd__dict-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">spot::bdd_dict Class Reference<div class="ingroups"><a class="el" href="group__tgba__essentials.html">Essential TGBA types</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Map BDD variables to formulae.  
 <a href="classspot_1_1bdd__dict.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="bdddict_8hh_source.html">tgba/bdddict.hh</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for spot::bdd_dict:</div>
<div class="dyncontent">
<div class="center"><img src="classspot_1_1bdd__dict__coll__graph.png" border="0" usemap="#spot_1_1bdd__dict_coll__map" alt="Collaboration graph"/></div>
<map name="spot_1_1bdd__dict_coll__map" id="spot_1_1bdd__dict_coll__map">
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1bdd__dict_1_1bdd__info.html">bdd_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afc6a898f172c6e90a19c4a85da9bbff6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>var_type</b> { <br/>
&#160;&#160;<b>anon</b> = 0, 
<b>now</b>, 
<b>next</b>, 
<b>var</b>, 
<br/>
&#160;&#160;<b>acc</b>
<br/>
 }</td></tr>
<tr class="separator:afc6a898f172c6e90a19c4a85da9bbff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd5f592056f364fdd862a3e0de9fd22"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; const <br class="typebreak"/>
<a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#a5bd5f592056f364fdd862a3e0de9fd22">fv_map</a></td></tr>
<tr class="memdesc:a5bd5f592056f364fdd862a3e0de9fd22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formula-to-BDD-variable maps.  <a href="#a5bd5f592056f364fdd862a3e0de9fd22">More...</a><br/></td></tr>
<tr class="separator:a5bd5f592056f364fdd862a3e0de9fd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b9e89c7a60caad9e5786c82a15e0ee"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; int, const <br class="typebreak"/>
<a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#ad0b9e89c7a60caad9e5786c82a15e0ee">vf_map</a></td></tr>
<tr class="memdesc:ad0b9e89c7a60caad9e5786c82a15e0ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">BDD-variable-to-formula maps.  <a href="#ad0b9e89c7a60caad9e5786c82a15e0ee">More...</a><br/></td></tr>
<tr class="separator:ad0b9e89c7a60caad9e5786c82a15e0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015d330da101dd646875b8ed1613a2d6"><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; const void * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#a015d330da101dd646875b8ed1613a2d6">ref_set</a></td></tr>
<tr class="memdesc:a015d330da101dd646875b8ed1613a2d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">BDD-variable reference counts.  <a href="#a015d330da101dd646875b8ed1613a2d6">More...</a><br/></td></tr>
<tr class="separator:a015d330da101dd646875b8ed1613a2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae899f4798d4177a007304f8cb6a7967"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae899f4798d4177a007304f8cb6a7967"></a>
typedef std::vector&lt; <a class="el" href="structspot_1_1bdd__dict_1_1bdd__info.html">bdd_info</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>bdd_info_map</b></td></tr>
<tr class="separator:aae899f4798d4177a007304f8cb6a7967"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af6f03983c2f4647cf0a192d5868c1b14"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#af6f03983c2f4647cf0a192d5868c1b14">~bdd_dict</a> ()</td></tr>
<tr class="memdesc:af6f03983c2f4647cf0a192d5868c1b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the BDD dict.  <a href="#af6f03983c2f4647cf0a192d5868c1b14">More...</a><br/></td></tr>
<tr class="separator:af6f03983c2f4647cf0a192d5868c1b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6095afcbbb4fbe67066d51169e80d333"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#a6095afcbbb4fbe67066d51169e80d333">register_proposition</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f, const void *for_me)</td></tr>
<tr class="memdesc:a6095afcbbb4fbe67066d51169e80d333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an atomic proposition.  <a href="#a6095afcbbb4fbe67066d51169e80d333">More...</a><br/></td></tr>
<tr class="separator:a6095afcbbb4fbe67066d51169e80d333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb99eed0b49ffba5229af45ef7c1e05f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#abb99eed0b49ffba5229af45ef7c1e05f">register_propositions</a> (bdd f, const void *for_me)</td></tr>
<tr class="memdesc:abb99eed0b49ffba5229af45ef7c1e05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register BDD variables as atomic propositions.  <a href="#abb99eed0b49ffba5229af45ef7c1e05f">More...</a><br/></td></tr>
<tr class="separator:abb99eed0b49ffba5229af45ef7c1e05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b0d292aafacbfbbd233080fe4a4ad0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#ac5b0d292aafacbfbbd233080fe4a4ad0">register_state</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f, const void *for_me)</td></tr>
<tr class="memdesc:ac5b0d292aafacbfbbd233080fe4a4ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a couple of Now/Next variables.  <a href="#ac5b0d292aafacbfbbd233080fe4a4ad0">More...</a><br/></td></tr>
<tr class="separator:ac5b0d292aafacbfbbd233080fe4a4ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb27e26e93d99e046dbe9e9d0cb21485"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#abb27e26e93d99e046dbe9e9d0cb21485">register_acceptance_variable</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f, const void *for_me)</td></tr>
<tr class="memdesc:abb27e26e93d99e046dbe9e9d0cb21485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an atomic proposition.  <a href="#abb27e26e93d99e046dbe9e9d0cb21485">More...</a><br/></td></tr>
<tr class="separator:abb27e26e93d99e046dbe9e9d0cb21485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abebfcb644db70ac9368ff316317059a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#abebfcb644db70ac9368ff316317059a3">register_clone_acc</a> (int var, const void *for_me)</td></tr>
<tr class="memdesc:abebfcb644db70ac9368ff316317059a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone an acceptance variable VAR for FOR_ME.  <a href="#abebfcb644db70ac9368ff316317059a3">More...</a><br/></td></tr>
<tr class="separator:abebfcb644db70ac9368ff316317059a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e496809f4027831aed7457fc8b7f3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#ac4e496809f4027831aed7457fc8b7f3a">register_acceptance_variables</a> (bdd f, const void *for_me)</td></tr>
<tr class="memdesc:ac4e496809f4027831aed7457fc8b7f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register BDD variables as acceptance variables.  <a href="#ac4e496809f4027831aed7457fc8b7f3a">More...</a><br/></td></tr>
<tr class="separator:ac4e496809f4027831aed7457fc8b7f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9584f1914c0f5dad897e60f5d560bb9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#ae9584f1914c0f5dad897e60f5d560bb9">oneacc_to_formula</a> (bdd oneacc) const </td></tr>
<tr class="memdesc:ae9584f1914c0f5dad897e60f5d560bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert one acceptance condition into the associated formula.  <a href="#ae9584f1914c0f5dad897e60f5d560bb9">More...</a><br/></td></tr>
<tr class="separator:ae9584f1914c0f5dad897e60f5d560bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f021480a019e739c54c8e107b27939"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#ad1f021480a019e739c54c8e107b27939">oneacc_to_formula</a> (int var) const </td></tr>
<tr class="memdesc:ad1f021480a019e739c54c8e107b27939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert one acceptance condition into the associated formula.  <a href="#ad1f021480a019e739c54c8e107b27939">More...</a><br/></td></tr>
<tr class="separator:ad1f021480a019e739c54c8e107b27939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7075f190e5d3a4face68a7a6e129eb95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#a7075f190e5d3a4face68a7a6e129eb95">register_anonymous_variables</a> (int n, const void *for_me)</td></tr>
<tr class="memdesc:a7075f190e5d3a4face68a7a6e129eb95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register anonymous BDD variables.  <a href="#a7075f190e5d3a4face68a7a6e129eb95">More...</a><br/></td></tr>
<tr class="separator:a7075f190e5d3a4face68a7a6e129eb95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e1e37179f390322da4d4cbf134b282"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#af7e1e37179f390322da4d4cbf134b282">register_all_variables_of</a> (const void *from_other, const void *for_me)</td></tr>
<tr class="memdesc:af7e1e37179f390322da4d4cbf134b282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate the variable usage of another object.  <a href="#af7e1e37179f390322da4d4cbf134b282">More...</a><br/></td></tr>
<tr class="separator:af7e1e37179f390322da4d4cbf134b282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b9d9dcc789312a700519388faf40e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#a64b9d9dcc789312a700519388faf40e8">unregister_all_my_variables</a> (const void *me)</td></tr>
<tr class="memdesc:a64b9d9dcc789312a700519388faf40e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release all variables used by an object.  <a href="#a64b9d9dcc789312a700519388faf40e8">More...</a><br/></td></tr>
<tr class="separator:a64b9d9dcc789312a700519388faf40e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb388a1a6f76ca01af640f26958cb37b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#abb388a1a6f76ca01af640f26958cb37b">unregister_all_typed_variables</a> (var_type type, const void *me)</td></tr>
<tr class="memdesc:abb388a1a6f76ca01af640f26958cb37b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release all variables of a given type, used by an object.  <a href="#abb388a1a6f76ca01af640f26958cb37b">More...</a><br/></td></tr>
<tr class="separator:abb388a1a6f76ca01af640f26958cb37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa502521a61d81107e8c7ce5fab09ed7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#aa502521a61d81107e8c7ce5fab09ed7c">unregister_variable</a> (int var, const void *me)</td></tr>
<tr class="memdesc:aa502521a61d81107e8c7ce5fab09ed7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a variable used by <em>me</em>.  <a href="#aa502521a61d81107e8c7ce5fab09ed7c">More...</a><br/></td></tr>
<tr class="separator:aa502521a61d81107e8c7ce5fab09ed7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ce6572f9b85f7996f391276ea024f0"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#ad5ce6572f9b85f7996f391276ea024f0">dump</a> (std::ostream &amp;os) const </td></tr>
<tr class="memdesc:ad5ce6572f9b85f7996f391276ea024f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump all variables for debugging.  <a href="#ad5ce6572f9b85f7996f391276ea024f0">More...</a><br/></td></tr>
<tr class="separator:ad5ce6572f9b85f7996f391276ea024f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d18da7cfd50865e23c32195e13f4d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#a24d18da7cfd50865e23c32195e13f4d4">assert_emptiness</a> () const </td></tr>
<tr class="memdesc:a24d18da7cfd50865e23c32195e13f4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure the dictionary is empty.  <a href="#a24d18da7cfd50865e23c32195e13f4d4">More...</a><br/></td></tr>
<tr class="separator:a24d18da7cfd50865e23c32195e13f4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0676f051e8333759c46e01e8a602eeaf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#a0676f051e8333759c46e01e8a602eeaf">is_registered_proposition</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f, const void *by_me)</td></tr>
<tr class="separator:a0676f051e8333759c46e01e8a602eeaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c13eeb02e0bddcbe0360a05f3dec05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91c13eeb02e0bddcbe0360a05f3dec05"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_registered_state</b> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f, const void *by_me)</td></tr>
<tr class="separator:a91c13eeb02e0bddcbe0360a05f3dec05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a9f018f9b52e89b383b9dd722f80d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42a9f018f9b52e89b383b9dd722f80d1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_registered_acceptance_variable</b> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f, const void *by_me)</td></tr>
<tr class="separator:a42a9f018f9b52e89b383b9dd722f80d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af654f827c195d9a47fb733a7c6341aae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1bdd__dict.html#a5bd5f592056f364fdd862a3e0de9fd22">fv_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#af654f827c195d9a47fb733a7c6341aae">now_map</a></td></tr>
<tr class="memdesc:af654f827c195d9a47fb733a7c6341aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps formulae to "Now" BDD variables.  <a href="#af654f827c195d9a47fb733a7c6341aae">More...</a><br/></td></tr>
<tr class="separator:af654f827c195d9a47fb733a7c6341aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f47535b3c6ca438bb58975a240d783f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1bdd__dict.html#a5bd5f592056f364fdd862a3e0de9fd22">fv_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#a9f47535b3c6ca438bb58975a240d783f">var_map</a></td></tr>
<tr class="memdesc:a9f47535b3c6ca438bb58975a240d783f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps atomic propositions to BDD variables.  <a href="#a9f47535b3c6ca438bb58975a240d783f">More...</a><br/></td></tr>
<tr class="separator:a9f47535b3c6ca438bb58975a240d783f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea537e22c5889d908170b17ab8e8fd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1bdd__dict.html#a5bd5f592056f364fdd862a3e0de9fd22">fv_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#adea537e22c5889d908170b17ab8e8fd0">acc_map</a></td></tr>
<tr class="memdesc:adea537e22c5889d908170b17ab8e8fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps acceptance conditions to BDD variables.  <a href="#adea537e22c5889d908170b17ab8e8fd0">More...</a><br/></td></tr>
<tr class="separator:adea537e22c5889d908170b17ab8e8fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8358c623b5fe26e74d167e10d2033a92"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8358c623b5fe26e74d167e10d2033a92"></a>
bdd_info_map&#160;</td><td class="memItemRight" valign="bottom"><b>bdd_map</b></td></tr>
<tr class="separator:a8358c623b5fe26e74d167e10d2033a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ecc1ea5dd6b7cf1d89d7add2cd056de"><td class="memItemLeft" align="right" valign="top">bddPair *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#a1ecc1ea5dd6b7cf1d89d7add2cd056de">next_to_now</a></td></tr>
<tr class="memdesc:a1ecc1ea5dd6b7cf1d89d7add2cd056de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map Next variables to Now variables.  <a href="#a1ecc1ea5dd6b7cf1d89d7add2cd056de">More...</a><br/></td></tr>
<tr class="separator:a1ecc1ea5dd6b7cf1d89d7add2cd056de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27dd24fcedeb14ccc72df82be8588a41"><td class="memItemLeft" align="right" valign="top">bddPair *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html#a27dd24fcedeb14ccc72df82be8588a41">now_to_next</a></td></tr>
<tr class="memdesc:a27dd24fcedeb14ccc72df82be8588a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map Now variables to Next variables.  <a href="#a27dd24fcedeb14ccc72df82be8588a41">More...</a><br/></td></tr>
<tr class="separator:a27dd24fcedeb14ccc72df82be8588a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Map BDD variables to formulae. </p>
<p>The BDD library uses integers to designate Boolean variables in its decision diagrams. This class is used to map such integers to objects actually used in Spot. These objects are usually atomic propositions, but they can also be acceptance conditions, or "Now/Next" variables (although the latter should be eventually removed).</p>
<p>When a BDD variable is registered using a <a class="el" href="classspot_1_1bdd__dict.html" title="Map BDD variables to formulae. ">bdd_dict</a>, it is always associated to a "user" (or "owner") object. This is done by supplying the <a class="el" href="classspot_1_1bdd__dict.html" title="Map BDD variables to formulae. ">bdd_dict</a> with a pointer to the intended user of the variable. When the user object dies, it should release the BDD variables it was using by calling (for instance) <a class="el" href="classspot_1_1bdd__dict.html#a64b9d9dcc789312a700519388faf40e8" title="Release all variables used by an object. ">unregister_all_my_variables()</a>, giving the same pointer. Variables can also by unregistered one by one using <a class="el" href="classspot_1_1bdd__dict.html#aa502521a61d81107e8c7ce5fab09ed7c" title="Release a variable used by me. ">unregister_variable()</a>. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a5bd5f592056f364fdd862a3e0de9fd22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a>*, int&gt; <a class="el" href="classspot_1_1bdd__dict.html#a5bd5f592056f364fdd862a3e0de9fd22">spot::bdd_dict::fv_map</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formula-to-BDD-variable maps. </p>

</div>
</div>
<a class="anchor" id="a015d330da101dd646875b8ed1613a2d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt;const void*&gt; <a class="el" href="classspot_1_1bdd__dict.html#a015d330da101dd646875b8ed1613a2d6">spot::bdd_dict::ref_set</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>BDD-variable reference counts. </p>

</div>
</div>
<a class="anchor" id="ad0b9e89c7a60caad9e5786c82a15e0ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;int, const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a>*&gt; <a class="el" href="classspot_1_1bdd__dict.html#ad0b9e89c7a60caad9e5786c82a15e0ee">spot::bdd_dict::vf_map</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>BDD-variable-to-formula maps. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af6f03983c2f4647cf0a192d5868c1b14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spot::bdd_dict::~bdd_dict </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the BDD dict. </p>
<p>This always calls <a class="el" href="classspot_1_1bdd__dict.html#a24d18da7cfd50865e23c32195e13f4d4" title="Make sure the dictionary is empty. ">assert_emptiness()</a> to diagnose cases where variables have not been unregistered. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a24d18da7cfd50865e23c32195e13f4d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spot::bdd_dict::assert_emptiness </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make sure the dictionary is empty. </p>
<p>This will print diagnostics if the dictionary is not empty. Use for debugging. This is called automatically by the destructor. When Spot is compiled in development mode (i.e., with <code>./configure &ndash;enable-devel</code>), this function will abort if the dictionary is not empty.</p>
<p>The errors detected by this function usually indicate missing calls to <a class="el" href="classspot_1_1bdd__dict.html#aa502521a61d81107e8c7ce5fab09ed7c" title="Release a variable used by me. ">unregister_variable()</a> or <a class="el" href="classspot_1_1bdd__dict.html#a64b9d9dcc789312a700519388faf40e8" title="Release all variables used by an object. ">unregister_all_my_variables()</a>. </p>

</div>
</div>
<a class="anchor" id="ad5ce6572f9b85f7996f391276ea024f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::bdd_dict::dump </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump all variables for debugging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0676f051e8333759c46e01e8a602eeaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spot::bdd_dict::is_registered_proposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>by_me</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether formula <em>f</em> has already been registered by <em>by_me</em>. </p>

</div>
</div>
<a class="anchor" id="ae9584f1914c0f5dad897e60f5d560bb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a>* spot::bdd_dict::oneacc_to_formula </td>
          <td>(</td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>oneacc</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert one acceptance condition into the associated formula. </p>
<p>This version accepts a conjunction of Acc variables, in which only one must be positive. This positive variable will be converted back into the associated formula.</p>
<p>The returned formula is not cloned, and is valid until the BDD variable used in <em>oneacc</em> are unregistered. </p>

</div>
</div>
<a class="anchor" id="ad1f021480a019e739c54c8e107b27939"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a>* spot::bdd_dict::oneacc_to_formula </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>var</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert one acceptance condition into the associated formula. </p>
<p>This version takes the number of a BDD variable that must has been returned by a call to <a class="el" href="classspot_1_1bdd__dict.html#abb27e26e93d99e046dbe9e9d0cb21485" title="Register an atomic proposition. ">register_acceptance_variable()</a>.</p>
<p>The returned formula is not cloned, and is valid until the BDD variable <em>var</em> is unregistered. </p>

</div>
</div>
<a class="anchor" id="abb27e26e93d99e046dbe9e9d0cb21485"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spot::bdd_dict::register_acceptance_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>for_me</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an atomic proposition. </p>
<p>Return (and maybe allocate) a BDD variable designating an acceptance set associated to formula <em>f</em>. The <em>for_me</em> argument should point to the object using this BDD variable, this is used for reference counting. It is perfectly safe to call this function several time with the same arguments.</p>
<dl class="section return"><dt>Returns</dt><dd>The variable number. Use bdd_ithvar() or bdd_nithvar() to convert this to a BDD. </dd></dl>

</div>
</div>
<a class="anchor" id="ac4e496809f4027831aed7457fc8b7f3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spot::bdd_dict::register_acceptance_variables </td>
          <td>(</td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>for_me</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register BDD variables as acceptance variables. </p>
<p>Register all variables occurring in <em>f</em> as acceptance variables used by <em>for_me</em>. This assumes that these acceptance variables are already known from the dictionary (i.e., they have already been registered by <a class="el" href="classspot_1_1bdd__dict.html#abb27e26e93d99e046dbe9e9d0cb21485" title="Register an atomic proposition. ">register_acceptance_variable()</a> for another automaton). </p>

</div>
</div>
<a class="anchor" id="af7e1e37179f390322da4d4cbf134b282"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spot::bdd_dict::register_all_variables_of </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>from_other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>for_me</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate the variable usage of another object. </p>
<p>This tells this dictionary that the <em>for_me</em> object will be using the same BDD variables as the <em>from_other</em> objects. This ensure that the variables won't be freed when <em>from_other</em> is deleted if <em>from_other</em> is still alive. </p>

</div>
</div>
<a class="anchor" id="a7075f190e5d3a4face68a7a6e129eb95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spot::bdd_dict::register_anonymous_variables </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>for_me</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register anonymous BDD variables. </p>
<p>Return (and maybe allocate) <em>n</em> consecutive BDD variables which will be used only by <em>for_me</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>The variable number. Use bdd_ithvar() or bdd_nithvar() to convert this to a BDD. </dd></dl>

</div>
</div>
<a class="anchor" id="abebfcb644db70ac9368ff316317059a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spot::bdd_dict::register_clone_acc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>for_me</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clone an acceptance variable VAR for FOR_ME. </p>
<p>This is used in products TGBAs when both operands share the same acceptance variables but they need to be distinguished in the result. </p>

</div>
</div>
<a class="anchor" id="a6095afcbbb4fbe67066d51169e80d333"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spot::bdd_dict::register_proposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>for_me</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an atomic proposition. </p>
<p>Return (and maybe allocate) a BDD variable designating formula <em>f</em>. The <em>for_me</em> argument should point to the object using this BDD variable, this is used for reference counting. It is perfectly safe to call this function several time with the same arguments.</p>
<dl class="section return"><dt>Returns</dt><dd>The variable number. Use bdd_ithvar() or bdd_nithvar() to convert this to a BDD. </dd></dl>

</div>
</div>
<a class="anchor" id="abb99eed0b49ffba5229af45ef7c1e05f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spot::bdd_dict::register_propositions </td>
          <td>(</td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>for_me</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register BDD variables as atomic propositions. </p>
<p>Register all variables occurring in <em>f</em> as atomic propositions used by <em>for_me</em>. This assumes that these atomic propositions are already known from the dictionary (i.e., they have already been registered by <a class="el" href="classspot_1_1bdd__dict.html#a6095afcbbb4fbe67066d51169e80d333" title="Register an atomic proposition. ">register_proposition()</a> for another automaton). </p>

</div>
</div>
<a class="anchor" id="ac5b0d292aafacbfbbd233080fe4a4ad0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spot::bdd_dict::register_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>for_me</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a couple of Now/Next variables. </p>
<p>Return (and maybe allocate) two BDD variables for a state associated to formula <em>f</em>. The <em>for_me</em> argument should point to the object using this BDD variable, this is used for reference counting. It is perfectly safe to call this function several time with the same arguments.</p>
<dl class="section return"><dt>Returns</dt><dd>The first variable number. Add one to get the second variable. Use bdd_ithvar() or bdd_nithvar() to convert this to a BDD. </dd></dl>

</div>
</div>
<a class="anchor" id="a64b9d9dcc789312a700519388faf40e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spot::bdd_dict::unregister_all_my_variables </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>me</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release all variables used by an object. </p>
<p>Usually called in the destructor if <em>me</em>. </p>

</div>
</div>
<a class="anchor" id="abb388a1a6f76ca01af640f26958cb37b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spot::bdd_dict::unregister_all_typed_variables </td>
          <td>(</td>
          <td class="paramtype">var_type&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>me</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release all variables of a given type, used by an object. </p>

</div>
</div>
<a class="anchor" id="aa502521a61d81107e8c7ce5fab09ed7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spot::bdd_dict::unregister_variable </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>me</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a variable used by <em>me</em>. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="adea537e22c5889d908170b17ab8e8fd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspot_1_1bdd__dict.html#a5bd5f592056f364fdd862a3e0de9fd22">fv_map</a> spot::bdd_dict::acc_map</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps acceptance conditions to BDD variables. </p>

</div>
</div>
<a class="anchor" id="a1ecc1ea5dd6b7cf1d89d7add2cd056de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bddPair* spot::bdd_dict::next_to_now</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map Next variables to Now variables. </p>
<p>Use with BuDDy's bdd_replace() function. </p>

</div>
</div>
<a class="anchor" id="af654f827c195d9a47fb733a7c6341aae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspot_1_1bdd__dict.html#a5bd5f592056f364fdd862a3e0de9fd22">fv_map</a> spot::bdd_dict::now_map</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps formulae to "Now" BDD variables. </p>

</div>
</div>
<a class="anchor" id="a27dd24fcedeb14ccc72df82be8588a41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bddPair* spot::bdd_dict::now_to_next</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map Now variables to Next variables. </p>
<p>Use with BuDDy's bdd_replace() function. </p>

</div>
</div>
<a class="anchor" id="a9f47535b3c6ca438bb58975a240d783f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspot_1_1bdd__dict.html#a5bd5f592056f364fdd862a3e0de9fd22">fv_map</a> spot::bdd_dict::var_map</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps atomic propositions to BDD variables. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>tgba/<a class="el" href="bdddict_8hh_source.html">bdddict.hh</a></li>
</ul>
</div><!-- contents -->
<hr size="1">
Please direct any <b>question</b>, <b>comment</b>, or <b>bug report</b> to the Spot mailing list at <a href="mailto:spot@lrde.epita.fr">spot@lrde.epita.fr</a>.
<br><address style="align: right;"><small>
Generated on Thu Aug 21 2014 17:41:53 for spot by <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border=0></a> 1.8.4</small></address>
</body>
</html>
