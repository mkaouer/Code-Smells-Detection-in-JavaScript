<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>spot: Input/Output of LTL formulae</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">spot
   &#160;<span id="projectnumber">1.2.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Input/Output of LTL formulae<div class="ingroups"><a class="el" href="group__ltl__algorithm.html">Algorithms for LTL formulae</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1ltl__file.html">spot::ltl::ltl_file</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read LTL formulae from a file, one by one.  <a href="classspot_1_1ltl_1_1ltl__file.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1random__formula.html">spot::ltl::random_formula</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for random formula generators.  <a href="classspot_1_1ltl_1_1random__formula.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1random__ltl.html">spot::ltl::random_ltl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate random LTL formulae.  <a href="classspot_1_1ltl_1_1random__ltl.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1random__boolean.html">spot::ltl::random_boolean</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate random Boolean formulae.  <a href="classspot_1_1ltl_1_1random__boolean.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1random__sere.html">spot::ltl::random_sere</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate random SERE.  <a href="classspot_1_1ltl_1_1random__sere.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1random__psl.html">spot::ltl::random_psl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate random PSL formulae.  <a href="classspot_1_1ltl_1_1random__psl.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf0c33c18fcffd60a2c676bdc6b5214de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf0c33c18fcffd60a2c676bdc6b5214de"></a>
typedef std::pair&lt; std::string, <br class="typebreak"/>
std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>spot::eltl::spair</b></td></tr>
<tr class="separator:gaf0c33c18fcffd60a2c676bdc6b5214de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22bfe02649dde06a6eba252ed16a6ff1"><td class="memItemLeft" align="right" valign="top">typedef std::pair<br class="typebreak"/>
&lt; spot::location, spair &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga22bfe02649dde06a6eba252ed16a6ff1">spot::eltl::parse_error</a></td></tr>
<tr class="memdesc:ga22bfe02649dde06a6eba252ed16a6ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parse diagnostic &lt;location, &lt;file, message&gt;&gt;.  <a href="#ga22bfe02649dde06a6eba252ed16a6ff1">More...</a><br/></td></tr>
<tr class="separator:ga22bfe02649dde06a6eba252ed16a6ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga017167786b87df9a15ec651897ed5cb0"><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; parse_error &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga017167786b87df9a15ec651897ed5cb0">spot::eltl::parse_error_list</a></td></tr>
<tr class="memdesc:ga017167786b87df9a15ec651897ed5cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of parser diagnostics, as filled by parse.  <a href="#ga017167786b87df9a15ec651897ed5cb0">More...</a><br/></td></tr>
<tr class="separator:ga017167786b87df9a15ec651897ed5cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9d5ceb0eb2188cf2db664032f86d392"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; location, <br class="typebreak"/>
std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#gad9d5ceb0eb2188cf2db664032f86d392">spot::ltl::parse_error</a></td></tr>
<tr class="memdesc:gad9d5ceb0eb2188cf2db664032f86d392"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parse diagnostic with its location.  <a href="#gad9d5ceb0eb2188cf2db664032f86d392">More...</a><br/></td></tr>
<tr class="separator:gad9d5ceb0eb2188cf2db664032f86d392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9eb0f7867a212f92b0fd64a6ac5a12cd"><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; parse_error &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga9eb0f7867a212f92b0fd64a6ac5a12cd">spot::ltl::parse_error_list</a></td></tr>
<tr class="memdesc:ga9eb0f7867a212f92b0fd64a6ac5a12cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of parser diagnostics, as filled by parse.  <a href="#ga9eb0f7867a212f92b0fd64a6ac5a12cd">More...</a><br/></td></tr>
<tr class="separator:ga9eb0f7867a212f92b0fd64a6ac5a12cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa1b344ecd592830c46ddc0b5414f2967"><td class="memItemLeft" align="right" valign="top">SPOT_API const formula *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#gaa1b344ecd592830c46ddc0b5414f2967">spot::eltl::parse_file</a> (const std::string &amp;filename, parse_error_list &amp;error_list, environment &amp;env=default_environment::instance(), bool debug=false)</td></tr>
<tr class="memdesc:gaa1b344ecd592830c46ddc0b5414f2967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a formula from a text file.  <a href="#gaa1b344ecd592830c46ddc0b5414f2967">More...</a><br/></td></tr>
<tr class="separator:gaa1b344ecd592830c46ddc0b5414f2967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b21d7e34c784bc290f23fe80fcd38c4"><td class="memItemLeft" align="right" valign="top">SPOT_API const formula *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga0b21d7e34c784bc290f23fe80fcd38c4">spot::eltl::parse_string</a> (const std::string &amp;eltl_string, parse_error_list &amp;error_list, environment &amp;env=default_environment::instance(), bool debug=false)</td></tr>
<tr class="memdesc:ga0b21d7e34c784bc290f23fe80fcd38c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a formula from an ELTL string.  <a href="#ga0b21d7e34c784bc290f23fe80fcd38c4">More...</a><br/></td></tr>
<tr class="separator:ga0b21d7e34c784bc290f23fe80fcd38c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d6d5997acc20b7f078b92a7f7209675"><td class="memItemLeft" align="right" valign="top">SPOT_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga9d6d5997acc20b7f078b92a7f7209675">spot::eltl::format_parse_errors</a> (std::ostream &amp;os, parse_error_list &amp;error_list)</td></tr>
<tr class="memdesc:ga9d6d5997acc20b7f078b92a7f7209675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format diagnostics produced by spot::eltl::parse.  <a href="#ga9d6d5997acc20b7f078b92a7f7209675">More...</a><br/></td></tr>
<tr class="separator:ga9d6d5997acc20b7f078b92a7f7209675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd1c74572de8d1addfe5f45a239a01cb"><td class="memItemLeft" align="right" valign="top">SPOT_API const formula *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#gacd1c74572de8d1addfe5f45a239a01cb">spot::ltl::parse</a> (const std::string &amp;ltl_string, parse_error_list &amp;error_list, environment &amp;env=default_environment::instance(), bool debug=false, bool lenient=false)</td></tr>
<tr class="memdesc:gacd1c74572de8d1addfe5f45a239a01cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a formula from an LTL string.  <a href="#gacd1c74572de8d1addfe5f45a239a01cb">More...</a><br/></td></tr>
<tr class="separator:gacd1c74572de8d1addfe5f45a239a01cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e3c68fad68a6d23ab1c03ff8e0dba65"><td class="memItemLeft" align="right" valign="top">SPOT_API const formula *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga8e3c68fad68a6d23ab1c03ff8e0dba65">spot::ltl::parse_boolean</a> (const std::string &amp;ltl_string, parse_error_list &amp;error_list, environment &amp;env=default_environment::instance(), bool debug=false, bool lenient=false)</td></tr>
<tr class="memdesc:ga8e3c68fad68a6d23ab1c03ff8e0dba65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a Boolean formula from a string.  <a href="#ga8e3c68fad68a6d23ab1c03ff8e0dba65">More...</a><br/></td></tr>
<tr class="separator:ga8e3c68fad68a6d23ab1c03ff8e0dba65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8e6e121a6da9c2f82c4ec6cef0fec67"><td class="memItemLeft" align="right" valign="top">SPOT_API const formula *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#gac8e6e121a6da9c2f82c4ec6cef0fec67">spot::ltl::parse_lbt</a> (const std::string &amp;ltl_string, parse_error_list &amp;error_list, environment &amp;env=default_environment::instance(), bool debug=false)</td></tr>
<tr class="memdesc:gac8e6e121a6da9c2f82c4ec6cef0fec67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a formula from an LTL string in LBT's format.  <a href="#gac8e6e121a6da9c2f82c4ec6cef0fec67">More...</a><br/></td></tr>
<tr class="separator:gac8e6e121a6da9c2f82c4ec6cef0fec67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3d88b783babf37a53f62df9d29a92a2"><td class="memItemLeft" align="right" valign="top">SPOT_API const formula *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#gad3d88b783babf37a53f62df9d29a92a2">spot::ltl::parse_sere</a> (const std::string &amp;sere_string, parse_error_list &amp;error_list, environment &amp;env=default_environment::instance(), bool debug=false, bool lenient=false)</td></tr>
<tr class="memdesc:gad3d88b783babf37a53f62df9d29a92a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a formula from a string representing a SERE.  <a href="#gad3d88b783babf37a53f62df9d29a92a2">More...</a><br/></td></tr>
<tr class="separator:gad3d88b783babf37a53f62df9d29a92a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd1bb9e7c7a13b11cb337cc9410b32e9"><td class="memItemLeft" align="right" valign="top">SPOT_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#gadd1bb9e7c7a13b11cb337cc9410b32e9">spot::ltl::format_parse_errors</a> (std::ostream &amp;os, const std::string &amp;input_string, const parse_error_list &amp;error_list)</td></tr>
<tr class="memdesc:gadd1bb9e7c7a13b11cb337cc9410b32e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format diagnostics produced by spot::ltl::parse or spot::ltl::ratexp.  <a href="#gadd1bb9e7c7a13b11cb337cc9410b32e9">More...</a><br/></td></tr>
<tr class="separator:gadd1bb9e7c7a13b11cb337cc9410b32e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga798851c1bb918f63265bce356479bca4"><td class="memItemLeft" align="right" valign="top">SPOT_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga798851c1bb918f63265bce356479bca4">spot::ltl::fix_utf8_locations</a> (const std::string &amp;input_string, parse_error_list &amp;error_list)</td></tr>
<tr class="memdesc:ga798851c1bb918f63265bce356479bca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fix location of diagnostics assuming the input is utf8.  <a href="#ga798851c1bb918f63265bce356479bca4">More...</a><br/></td></tr>
<tr class="separator:ga798851c1bb918f63265bce356479bca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7687f551ce0e287e81e4152002ae008c"><td class="memItemLeft" align="right" valign="top">SPOT_API std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga7687f551ce0e287e81e4152002ae008c">spot::ltl::dotty</a> (std::ostream &amp;os, const formula *f)</td></tr>
<tr class="memdesc:ga7687f551ce0e287e81e4152002ae008c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a formula tree using dot's syntax.  <a href="#ga7687f551ce0e287e81e4152002ae008c">More...</a><br/></td></tr>
<tr class="separator:ga7687f551ce0e287e81e4152002ae008c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga410bc3eaed909f4c0687dc5c449907db"><td class="memItemLeft" align="right" valign="top">SPOT_API std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga410bc3eaed909f4c0687dc5c449907db">spot::ltl::dump</a> (std::ostream &amp;os, const formula *f)</td></tr>
<tr class="memdesc:ga410bc3eaed909f4c0687dc5c449907db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a formula tree.  <a href="#ga410bc3eaed909f4c0687dc5c449907db">More...</a><br/></td></tr>
<tr class="separator:ga410bc3eaed909f4c0687dc5c449907db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00941055abdb0a5f4461c9650b99d21d"><td class="memItemLeft" align="right" valign="top">SPOT_API std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga00941055abdb0a5f4461c9650b99d21d">spot::ltl::to_lbt_string</a> (const formula *f, std::ostream &amp;os)</td></tr>
<tr class="memdesc:ga00941055abdb0a5f4461c9650b99d21d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output an LTL formula as a string in LBT's format.  <a href="#ga00941055abdb0a5f4461c9650b99d21d">More...</a><br/></td></tr>
<tr class="separator:ga00941055abdb0a5f4461c9650b99d21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga801538d6b1933c49f203c67a2f1050c7"><td class="memItemLeft" align="right" valign="top">SPOT_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga801538d6b1933c49f203c67a2f1050c7">spot::ltl::to_lbt_string</a> (const formula *f)</td></tr>
<tr class="memdesc:ga801538d6b1933c49f203c67a2f1050c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output an LTL formula as a string in LBT's format.  <a href="#ga801538d6b1933c49f203c67a2f1050c7">More...</a><br/></td></tr>
<tr class="separator:ga801538d6b1933c49f203c67a2f1050c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54f0da54c8798afb01b9f2aa605f6b21"><td class="memItemLeft" align="right" valign="top">SPOT_API std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga54f0da54c8798afb01b9f2aa605f6b21">spot::ltl::to_string</a> (const formula *f, std::ostream &amp;os, bool full_parent=false, bool ratexp=false)</td></tr>
<tr class="memdesc:ga54f0da54c8798afb01b9f2aa605f6b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a formula as a string which is parsable unless the formula contains automaton operators (used in ELTL formulae).  <a href="#ga54f0da54c8798afb01b9f2aa605f6b21">More...</a><br/></td></tr>
<tr class="separator:ga54f0da54c8798afb01b9f2aa605f6b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga710ceff49a60300bd9ed99e40ac342cd"><td class="memItemLeft" align="right" valign="top">SPOT_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga710ceff49a60300bd9ed99e40ac342cd">spot::ltl::to_string</a> (const formula *f, bool full_parent=false, bool ratexp=false)</td></tr>
<tr class="memdesc:ga710ceff49a60300bd9ed99e40ac342cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a formula as a string which is parsable unless the formula contains automaton operators (used in ELTL formulae).  <a href="#ga710ceff49a60300bd9ed99e40ac342cd">More...</a><br/></td></tr>
<tr class="separator:ga710ceff49a60300bd9ed99e40ac342cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf13cc1ab08f063e304f74fe99a2d5326"><td class="memItemLeft" align="right" valign="top">SPOT_API std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#gaf13cc1ab08f063e304f74fe99a2d5326">spot::ltl::to_utf8_string</a> (const formula *f, std::ostream &amp;os, bool full_parent=false, bool ratexp=false)</td></tr>
<tr class="memdesc:gaf13cc1ab08f063e304f74fe99a2d5326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a formula as an utf8 string which is parsable unless the formula contains automaton operators (used in ELTL formulae).  <a href="#gaf13cc1ab08f063e304f74fe99a2d5326">More...</a><br/></td></tr>
<tr class="separator:gaf13cc1ab08f063e304f74fe99a2d5326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa74a6ae7206b51fcc1fa109131dec858"><td class="memItemLeft" align="right" valign="top">SPOT_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#gaa74a6ae7206b51fcc1fa109131dec858">spot::ltl::to_utf8_string</a> (const formula *f, bool full_parent=false, bool ratexp=false)</td></tr>
<tr class="memdesc:gaa74a6ae7206b51fcc1fa109131dec858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a formula as an utf8 string which is parsable unless the formula contains automaton operators (used in ELTL formulae).  <a href="#gaa74a6ae7206b51fcc1fa109131dec858">More...</a><br/></td></tr>
<tr class="separator:gaa74a6ae7206b51fcc1fa109131dec858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf1e905621e01320f1e55146cb3cf83d"><td class="memItemLeft" align="right" valign="top">SPOT_API std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#gadf1e905621e01320f1e55146cb3cf83d">spot::ltl::to_spin_string</a> (const formula *f, std::ostream &amp;os, bool full_parent=false)</td></tr>
<tr class="memdesc:gadf1e905621e01320f1e55146cb3cf83d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a formula as a string parsable by Spin.  <a href="#gadf1e905621e01320f1e55146cb3cf83d">More...</a><br/></td></tr>
<tr class="separator:gadf1e905621e01320f1e55146cb3cf83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafadea056965374010e41609c32f2be8b"><td class="memItemLeft" align="right" valign="top">SPOT_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#gafadea056965374010e41609c32f2be8b">spot::ltl::to_spin_string</a> (const formula *f, bool full_parent=false)</td></tr>
<tr class="memdesc:gafadea056965374010e41609c32f2be8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a formula into a string parsable by Spin.  <a href="#gafadea056965374010e41609c32f2be8b">More...</a><br/></td></tr>
<tr class="separator:gafadea056965374010e41609c32f2be8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga194bbfda410b89ca616f91b265c37441"><td class="memItemLeft" align="right" valign="top">SPOT_API std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga194bbfda410b89ca616f91b265c37441">spot::ltl::to_wring_string</a> (const formula *f, std::ostream &amp;os)</td></tr>
<tr class="memdesc:ga194bbfda410b89ca616f91b265c37441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a formula as a string parsable by Wring.  <a href="#ga194bbfda410b89ca616f91b265c37441">More...</a><br/></td></tr>
<tr class="separator:ga194bbfda410b89ca616f91b265c37441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab44eff34258eaf361ee69e0fe12dd162"><td class="memItemLeft" align="right" valign="top">SPOT_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#gab44eff34258eaf361ee69e0fe12dd162">spot::ltl::to_wring_string</a> (const formula *f)</td></tr>
<tr class="memdesc:gab44eff34258eaf361ee69e0fe12dd162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a formula into a string parsable by Wring.  <a href="#gab44eff34258eaf361ee69e0fe12dd162">More...</a><br/></td></tr>
<tr class="separator:gab44eff34258eaf361ee69e0fe12dd162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ff219c5277168251c15af97f40cc75b"><td class="memItemLeft" align="right" valign="top">SPOT_API std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga9ff219c5277168251c15af97f40cc75b">spot::ltl::to_latex_string</a> (const formula *f, std::ostream &amp;os, bool full_parent=false, bool ratexp=false)</td></tr>
<tr class="memdesc:ga9ff219c5277168251c15af97f40cc75b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a formula as an LaTeX string which is parsable unless the formula contains automaton operators (used in ELTL formulae).  <a href="#ga9ff219c5277168251c15af97f40cc75b">More...</a><br/></td></tr>
<tr class="separator:ga9ff219c5277168251c15af97f40cc75b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabeb2be24ed5fb5c1607eb0d8c86b299d"><td class="memItemLeft" align="right" valign="top">SPOT_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#gabeb2be24ed5fb5c1607eb0d8c86b299d">spot::ltl::to_latex_string</a> (const formula *f, bool full_parent=false, bool ratexp=false)</td></tr>
<tr class="memdesc:gabeb2be24ed5fb5c1607eb0d8c86b299d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a formula as a LaTeX string which is parsable unless the formula contains automaton operators (used in ELTL formulae).  <a href="#gabeb2be24ed5fb5c1607eb0d8c86b299d">More...</a><br/></td></tr>
<tr class="separator:gabeb2be24ed5fb5c1607eb0d8c86b299d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gad9d5ceb0eb2188cf2db664032f86d392"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;location, std::string&gt; <a class="el" href="group__ltl__io.html#gad9d5ceb0eb2188cf2db664032f86d392">spot::ltl::parse_error</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A parse diagnostic with its location. </p>

</div>
</div>
<a class="anchor" id="ga22bfe02649dde06a6eba252ed16a6ff1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;spot::location, spair&gt; <a class="el" href="group__ltl__io.html#ga22bfe02649dde06a6eba252ed16a6ff1">spot::eltl::parse_error</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A parse diagnostic &lt;location, &lt;file, message&gt;&gt;. </p>

</div>
</div>
<a class="anchor" id="ga9eb0f7867a212f92b0fd64a6ac5a12cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;parse_error&gt; <a class="el" href="group__ltl__io.html#ga9eb0f7867a212f92b0fd64a6ac5a12cd">spot::ltl::parse_error_list</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A list of parser diagnostics, as filled by parse. </p>

</div>
</div>
<a class="anchor" id="ga017167786b87df9a15ec651897ed5cb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;parse_error&gt; <a class="el" href="group__ltl__io.html#ga017167786b87df9a15ec651897ed5cb0">spot::eltl::parse_error_list</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A list of parser diagnostics, as filled by parse. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga7687f551ce0e287e81e4152002ae008c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API std::ostream&amp; spot::ltl::dotty </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a formula tree using dot's syntax. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The stream where it should be output. </td></tr>
    <tr><td class="paramname">f</td><td>The formula to translate.</td></tr>
  </table>
  </dd>
</dl>
<p><code>dot</code> is part of the GraphViz package <a href="http://www.research.att.com/sw/tools/graphviz/">http://www.research.att.com/sw/tools/graphviz/</a> </p>

</div>
</div>
<a class="anchor" id="ga410bc3eaed909f4c0687dc5c449907db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API std::ostream&amp; spot::ltl::dump </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a formula tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The stream where it should be output. </td></tr>
    <tr><td class="paramname">f</td><td>The formula to dump.</td></tr>
  </table>
  </dd>
</dl>
<p>This is useful to display a formula when debugging. </p>

</div>
</div>
<a class="anchor" id="ga798851c1bb918f63265bce356479bca4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API void spot::ltl::fix_utf8_locations </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parse_error_list &amp;&#160;</td>
          <td class="paramname"><em>error_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fix location of diagnostics assuming the input is utf8. </p>
<p>The <a class="el" href="group__ltl__io.html#gacd1c74572de8d1addfe5f45a239a01cb" title="Build a formula from an LTL string. ">spot::ltl::parse()</a> and <a class="el" href="group__ltl__io.html#gad3d88b783babf37a53f62df9d29a92a2" title="Build a formula from a string representing a SERE. ">spot::ltl::parse_sere()</a> function return a parse_error_list that contain locations specified at the byte level. Although these parser recognize some utf8 characters they only work byte by byte and will report positions by counting byte.</p>
<p>This function fixes the positions returned by the parser to look correct when the string is interpreted as a utf8-encoded string.</p>
<p>It is invalid to call this function on a string that is not valid utf8.</p>
<p>You should NOT call this function before calling <a class="el" href="group__ltl__io.html#ga9d6d5997acc20b7f078b92a7f7209675" title="Format diagnostics produced by spot::eltl::parse. ">spot::ltl::format_parse_errors()</a> because it is already called inside if needed. You may need this function only if you want to write your own error reporting code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_string</td><td>The string that were parsed. </td></tr>
    <tr><td class="paramname">error_list</td><td>The error list filled by spot::ltl::parse or spot::ltl::parse_sere while parsing <em>input_string</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9d6d5997acc20b7f078b92a7f7209675"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API bool spot::eltl::format_parse_errors </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parse_error_list &amp;&#160;</td>
          <td class="paramname"><em>error_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format diagnostics produced by spot::eltl::parse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Where diagnostics should be output. </td></tr>
    <tr><td class="paramname">error_list</td><td>The error list filled by spot::eltl::parse while parsing <em>eltl_string</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff any diagnostic was output. </dd></dl>

</div>
</div>
<a class="anchor" id="gadd1bb9e7c7a13b11cb337cc9410b32e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API bool spot::ltl::format_parse_errors </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const parse_error_list &amp;&#160;</td>
          <td class="paramname"><em>error_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format diagnostics produced by spot::ltl::parse or spot::ltl::ratexp. </p>
<p>If the string is utf8 encoded, <a class="el" href="group__ltl__io.html#ga798851c1bb918f63265bce356479bca4" title="Fix location of diagnostics assuming the input is utf8. ">spot::ltl::fix_utf8_locations()</a> will be used to report correct utf8 locations (assuming the output is utf8 aware). Nonetheless, the supplied <em>error_list</em> will not be modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Where diagnostics should be output. </td></tr>
    <tr><td class="paramname">input_string</td><td>The string that were parsed. </td></tr>
    <tr><td class="paramname">error_list</td><td>The error list filled by spot::ltl::parse or spot::ltl::parse_sere while parsing <em>input_string</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff any diagnostic was output. </dd></dl>

</div>
</div>
<a class="anchor" id="gacd1c74572de8d1addfe5f45a239a01cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API const formula* spot::ltl::parse </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ltl_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parse_error_list &amp;&#160;</td>
          <td class="paramname"><em>error_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">environment &amp;&#160;</td>
          <td class="paramname"><em>env</em> = <code>default_environment::instance()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lenient</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a formula from an LTL string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ltl_string</td><td>The string to parse. </td></tr>
    <tr><td class="paramname">error_list</td><td>A list that will be filled with parse errors that occured during parsing. </td></tr>
    <tr><td class="paramname">env</td><td>The environment into which parsing should take place. </td></tr>
    <tr><td class="paramname">debug</td><td>When true, causes the parser to trace its execution. </td></tr>
    <tr><td class="paramname">lenient</td><td>When true, parenthesized blocks that cannot be parsed as subformulas will be considered as atomic propositions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the formula built from <em>ltl_string</em>, or 0 if the input was unparsable.</dd></dl>
<p>Note that the parser usually tries to recover from errors. It can return a non zero value even if it encountered error during the parsing of <em>ltl_string</em>. If you want to make sure <em>ltl_string</em> was parsed succesfully, check <em>error_list</em> for emptiness.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function is not reentrant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e3c68fad68a6d23ab1c03ff8e0dba65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API const formula* spot::ltl::parse_boolean </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ltl_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parse_error_list &amp;&#160;</td>
          <td class="paramname"><em>error_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">environment &amp;&#160;</td>
          <td class="paramname"><em>env</em> = <code>default_environment::instance()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lenient</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a Boolean formula from a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ltl_string</td><td>The string to parse. </td></tr>
    <tr><td class="paramname">error_list</td><td>A list that will be filled with parse errors that occured during parsing. </td></tr>
    <tr><td class="paramname">env</td><td>The environment into which parsing should take place. </td></tr>
    <tr><td class="paramname">debug</td><td>When true, causes the parser to trace its execution. </td></tr>
    <tr><td class="paramname">lenient</td><td>When true, parenthesized blocks that cannot be parsed as subformulas will be considered as atomic propositions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the formula built from <em>ltl_string</em>, or 0 if the input was unparsable.</dd></dl>
<p>Note that the parser usually tries to recover from errors. It can return a non zero value even if it encountered error during the parsing of <em>ltl_string</em>. If you want to make sure <em>ltl_string</em> was parsed succesfully, check <em>error_list</em> for emptiness.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function is not reentrant. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa1b344ecd592830c46ddc0b5414f2967"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API const formula* spot::eltl::parse_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parse_error_list &amp;&#160;</td>
          <td class="paramname"><em>error_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">environment &amp;&#160;</td>
          <td class="paramname"><em>env</em> = <code>default_environment::instance()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a formula from a text file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the file to parse. </td></tr>
    <tr><td class="paramname">error_list</td><td>A list that will be filled with parse errors that occured during parsing. </td></tr>
    <tr><td class="paramname">env</td><td>The environment into which parsing should take place. </td></tr>
    <tr><td class="paramname">debug</td><td>When true, causes the parser to trace its execution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the tgba built from <em>filename</em>, or 0 if the file could not be opened.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is not reentrant. </dd></dl>

</div>
</div>
<a class="anchor" id="gac8e6e121a6da9c2f82c4ec6cef0fec67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API const formula* spot::ltl::parse_lbt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ltl_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parse_error_list &amp;&#160;</td>
          <td class="paramname"><em>error_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">environment &amp;&#160;</td>
          <td class="paramname"><em>env</em> = <code>default_environment::instance()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a formula from an LTL string in LBT's format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ltl_string</td><td>The string to parse. </td></tr>
    <tr><td class="paramname">error_list</td><td>A list that will be filled with parse errors that occured during parsing. </td></tr>
    <tr><td class="paramname">env</td><td>The environment into which parsing should take place. </td></tr>
    <tr><td class="paramname">debug</td><td>When true, causes the parser to trace its execution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the formula built from <em>ltl_string</em>, or 0 if the input was unparsable.</dd></dl>
<p>Note that the parser usually tries to recover from errors. It can return an non zero value even if it encountered error during the parsing of <em>ltl_string</em>. If you want to make sure <em>ltl_string</em> was parsed succesfully, check <em>error_list</em> for emptiness.</p>
<p>The LBT syntax, also used by the lbtt and scheck tools, is extended to support W, and M operators (as done in lbtt), and double-quoted atomic propositions that do not start with 'p'.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function is not reentrant. </dd></dl>

</div>
</div>
<a class="anchor" id="gad3d88b783babf37a53f62df9d29a92a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API const formula* spot::ltl::parse_sere </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sere_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parse_error_list &amp;&#160;</td>
          <td class="paramname"><em>error_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">environment &amp;&#160;</td>
          <td class="paramname"><em>env</em> = <code>default_environment::instance()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lenient</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a formula from a string representing a SERE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sere_string</td><td>The string to parse. </td></tr>
    <tr><td class="paramname">error_list</td><td>A list that will be filled with parse errors that occured during parsing. </td></tr>
    <tr><td class="paramname">env</td><td>The environment into which parsing should take place. </td></tr>
    <tr><td class="paramname">debug</td><td>When true, causes the parser to trace its execution. </td></tr>
    <tr><td class="paramname">lenient</td><td>When true, parenthesized blocks that cannot be parsed as subformulas will be considered as atomic propositions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the formula built from <em>sere_string</em>, or 0 if the input was unparsable.</dd></dl>
<p>Note that the parser usually tries to recover from errors. It can return an non zero value even if it encountered error during the parsing of <em>ltl_string</em>. If you want to make sure <em>ltl_string</em> was parsed succesfully, check <em>error_list</em> for emptiness.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function is not reentrant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0b21d7e34c784bc290f23fe80fcd38c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API const formula* spot::eltl::parse_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>eltl_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parse_error_list &amp;&#160;</td>
          <td class="paramname"><em>error_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">environment &amp;&#160;</td>
          <td class="paramname"><em>env</em> = <code>default_environment::instance()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a formula from an ELTL string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eltl_string</td><td>The string to parse. </td></tr>
    <tr><td class="paramname">error_list</td><td>A list that will be filled with parse errors that occured during parsing. </td></tr>
    <tr><td class="paramname">env</td><td>The environment into which parsing should take place. </td></tr>
    <tr><td class="paramname">debug</td><td>When true, causes the parser to trace its execution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the formula built from <em>eltl_string</em>, or 0 if the input was unparsable.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is not reentrant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9ff219c5277168251c15af97f40cc75b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API std::ostream&amp; spot::ltl::to_latex_string </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full_parent</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ratexp</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output a formula as an LaTeX string which is parsable unless the formula contains automaton operators (used in ELTL formulae). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to translate. </td></tr>
    <tr><td class="paramname">os</td><td>The stream where it should be output. </td></tr>
    <tr><td class="paramname">full_parent</td><td>Whether or not the string should by fully parenthesized. </td></tr>
    <tr><td class="paramname">ratexp</td><td>Whether we are printing a SERE. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabeb2be24ed5fb5c1607eb0d8c86b299d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API std::string spot::ltl::to_latex_string </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full_parent</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ratexp</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output a formula as a LaTeX string which is parsable unless the formula contains automaton operators (used in ELTL formulae). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to translate. </td></tr>
    <tr><td class="paramname">full_parent</td><td>Whether or not the string should by fully parenthesized. </td></tr>
    <tr><td class="paramname">ratexp</td><td>Whether we are printing a SERE. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga00941055abdb0a5f4461c9650b99d21d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API std::ostream&amp; spot::ltl::to_lbt_string </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output an LTL formula as a string in LBT's format. </p>
<p>The formula must be an LTL formula (ELTL and PSL operators are not supported). The M and W operator will be output as-is, because this is accepted by LBTT, however if you plan to use the output with other tools, you should probably rewrite these two operators using <a class="el" href="group__ltl__rewriting.html#ga30990992634fa97920f8b7fa65060838" title="Rewrite a formula to remove the W and M operators. ">unabbreviate_wm()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to translate. </td></tr>
    <tr><td class="paramname">os</td><td>The stream where it should be output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga801538d6b1933c49f203c67a2f1050c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API std::string spot::ltl::to_lbt_string </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output an LTL formula as a string in LBT's format. </p>
<p>The formula must be an LTL formula (ELTL and PSL operators are not supported). The M and W operator will be output as-is, because this is accepted by LBTT, however if you plan to use the output with other tools, you should probably rewrite these two operators using <a class="el" href="group__ltl__rewriting.html#ga30990992634fa97920f8b7fa65060838" title="Rewrite a formula to remove the W and M operators. ">unabbreviate_wm()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to translate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadf1e905621e01320f1e55146cb3cf83d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API std::ostream&amp; spot::ltl::to_spin_string </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full_parent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output a formula as a string parsable by Spin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to translate. </td></tr>
    <tr><td class="paramname">os</td><td>The stream where it should be output. </td></tr>
    <tr><td class="paramname">full_parent</td><td>Whether or not the string should by fully parenthesized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafadea056965374010e41609c32f2be8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API std::string spot::ltl::to_spin_string </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full_parent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a formula into a string parsable by Spin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to translate. </td></tr>
    <tr><td class="paramname">full_parent</td><td>Whether or not the string should by fully parenthesized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga54f0da54c8798afb01b9f2aa605f6b21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API std::ostream&amp; spot::ltl::to_string </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full_parent</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ratexp</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output a formula as a string which is parsable unless the formula contains automaton operators (used in ELTL formulae). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to translate. </td></tr>
    <tr><td class="paramname">os</td><td>The stream where it should be output. </td></tr>
    <tr><td class="paramname">full_parent</td><td>Whether or not the string should by fully parenthesized. </td></tr>
    <tr><td class="paramname">ratexp</td><td>Whether we are printing a SERE. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga710ceff49a60300bd9ed99e40ac342cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API std::string spot::ltl::to_string </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full_parent</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ratexp</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output a formula as a string which is parsable unless the formula contains automaton operators (used in ELTL formulae). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to translate. </td></tr>
    <tr><td class="paramname">full_parent</td><td>Whether or not the string should by fully parenthesized. </td></tr>
    <tr><td class="paramname">ratexp</td><td>Whether we are printing a SERE. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf13cc1ab08f063e304f74fe99a2d5326"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API std::ostream&amp; spot::ltl::to_utf8_string </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full_parent</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ratexp</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output a formula as an utf8 string which is parsable unless the formula contains automaton operators (used in ELTL formulae). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to translate. </td></tr>
    <tr><td class="paramname">os</td><td>The stream where it should be output. </td></tr>
    <tr><td class="paramname">full_parent</td><td>Whether or not the string should by fully parenthesized. </td></tr>
    <tr><td class="paramname">ratexp</td><td>Whether we are printing a SERE. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa74a6ae7206b51fcc1fa109131dec858"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API std::string spot::ltl::to_utf8_string </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full_parent</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ratexp</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output a formula as an utf8 string which is parsable unless the formula contains automaton operators (used in ELTL formulae). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to translate. </td></tr>
    <tr><td class="paramname">full_parent</td><td>Whether or not the string should by fully parenthesized. </td></tr>
    <tr><td class="paramname">ratexp</td><td>Whether we are printing a SERE. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga194bbfda410b89ca616f91b265c37441"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API std::ostream&amp; spot::ltl::to_wring_string </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output a formula as a string parsable by Wring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to translate. </td></tr>
    <tr><td class="paramname">os</td><td>The stream where it should be output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab44eff34258eaf361ee69e0fe12dd162"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPOT_API std::string spot::ltl::to_wring_string </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a formula into a string parsable by Wring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to translate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<hr size="1">
Please direct any <b>question</b>, <b>comment</b>, or <b>bug report</b> to the Spot mailing list at <a href="mailto:spot@lrde.epita.fr">spot@lrde.epita.fr</a>.
<br><address style="align: right;"><small>
Generated on Thu Aug 21 2014 17:41:53 for spot by <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border=0></a> 1.8.4</small></address>
</body>
</html>
