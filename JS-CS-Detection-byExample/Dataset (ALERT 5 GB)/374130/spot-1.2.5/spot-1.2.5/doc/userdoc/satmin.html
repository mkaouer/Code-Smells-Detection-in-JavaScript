<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>SAT-based Minimization of Deterministic (Generalized) Büchi Automata</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="SAT-based Minimization of Deterministic (Generalized) Büchi Automata"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2014-08-21T17:42+0200"/>
<meta name="author" content="Alexandre Duret-Lutz"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="syntax.css" />
<link rel="stylesheet" type="text/css" href="http://spot.lip6.fr/css/spot-zenburn.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js">
/**
 *
 * @source: http://orgmode.org/mathjax/MathJax.js
 *
 * @licstart  The following is the entire license notice for the
 *  JavaScript code in http://orgmode.org/mathjax/MathJax.js.
 *
 * Copyright (C) 2012-2013  MathJax
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend  The above is the entire license notice
 * for the JavaScript code in http://orgmode.org/mathjax/MathJax.js.
 *
 */

/*
@licstart  The following is the entire license notice for the
JavaScript code below.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code below is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code below.
*/
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up" style="text-align:center;white-space:nowrap;">
 <a accesskey="h" href="tools.html">UP</a> | <a accesskey="H" href="tools.html">HOME</a>
</div>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">SAT-based Minimization of Deterministic (Generalized) Büchi Automata</h1>

<p>This page explains how to use <a href="ltl2tgba.html"><code>ltl2tgba</code></a> or <a href="dstar2tgba.html"><code>dstar2tgba</code></a> to minimize
deterministic automata using a SAT solver.
</p>
<p>
Let us first state a few facts about this minimization procedure.
</p>
<ol>
<li>The procedure works only on <b>deterministic</b> Büchi automata: any
   recurrence property can be converted into a deterministic Büchi
   automaton, and sometimes there are several ways of doing so.
</li>
<li>Spot actually implement two SAT-based minimization procedures: one
   that builds a deterministic transition-based Büchi automaton
   (DTBA), and one the builds a deterministic transition-based
   generalized Büchi automaton (DTGBA).  For the latter, we can supply
   the number \(m\) of acceptance sets to use.
</li>
<li>These two procedures can optionally constrain their output to
   use state-based acceptance. (They simply restrict all the outgoing
   transitions of a state to belong to the same acceptance sets.)
</li>
<li>A SAT solver should be installed for this to work. (Spot does not
   distribute any SAT solver.)
</li>
<li><a href="ltl2tgba.html"><code>ltl2tgba</code></a> and <a href="dstar2tgba.html"><code>dstar2tgba</code></a> will always try to output an automaton
   If they fail to determinize the property, they will simply output a
   nondeterministic automaton, if they managed to obtain a
   deterministic automaton but failed to minimize it (e.g., the
   requested number of states in the final automaton is too low), they
   will return that "unminimized" deterministic automaton.  There are
   only two cases where these tool will abort without returning an
   automaton: when the number of clauses output by Spot (and to be fed
   to the SAT solver) exceeds \(2^{31}\), or when the SAT-solver was
   killed by a signal.
</li>
<li>Details about the SAT encoding used in the two procedures can be
   found in our <a href="http://www.lrde.epita.fr/~adl/dl/adl/baarir.14.forte.pdf">FORTE'14 paper</a>.
</li>
</ol>



<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">How to change the SAT solver used</a></li>
<li><a href="#sec-2">Enabling SAT-based minimization for deterministic automata</a></li>
<li><a href="#sec-3">More acceptance sets</a></li>
<li><a href="#sec-4">Low-level details</a></li>
<li><a href="#sec-5">Logging statistics</a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">How to change the SAT solver used</h2>
<div class="outline-text-2" id="text-1">


<p>
The environment variable <code>SPOT_SATSOLVER</code> can be used to change the
SAT solver used by Spot.  The default is "<code>glucose -verb=0 -model %I &gt;%O</code>", therefore if you have installed <a href="http://www.labri.fr/perso/lsimon/glucose/"><code>glucose</code> 3.0</a> in your <code>$PATH</code>,
it should work right away.  Otherwise you may redefine this variable
to point the correct location or to another SAT solver (for older
versions of glucose, remove the <code>-model</code> option).  The <code>%I</code> and <code>%O</code>
sequences will be replaced by the names of temporary files containing
the input for the SAT solver and receiving its output.  We assume that
the SAT solver should follow the conventions of the <a href="http://www.satcompetition.org/">SAT competition</a>
for input and output.
</p>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">Enabling SAT-based minimization for deterministic automata</h2>
<div class="outline-text-2" id="text-2">


<p>
Both tools follow the same interface, because they use the same
post-processing steps internally (i.e., the <code>spot::postprocessor</code>
class).
</p>
<p>
First, option <code>-D</code> should be used to declare that you are looking for
more determinism.  This will tweak the translation algorithm used by
<code>ltl2tgba</code> to improve determinism, and will also instruct the
post-processing routine used by both tools to prefer a
deterministic automaton over a smaller equivalent nondeterministic
automaton.
</p>
<p>
However <code>-D</code> is not a guarantee to obtain a deterministic automaton,
even if one exists.  For instance, <code>-D</code> fails to produce a
deterministic automaton for <code>GF(a &lt;-&gt; XXb)</code>.  Instead we get a 9-state
non-deterministic automaton.
</p>



<pre class="src src-sh">ltl2tgba -D <span class="org-string">"GF(a &lt;-&gt; XXb)"</span> --stats=<span class="org-string">'states=%s, det=%d'</span>
</pre>

<pre class="example">
states=9, det=0
</pre>


<p>
Option <code>-x tba-det</code> enables an additional
determinization procedure, that would otherwise not be used by <code>-D</code>
alone.  This procedure will work on any automaton that can be
represented by a DTBA; if the automaton to process use multiple
acceptance conditions, it will be degeneralized first.
</p>
<p>
On our example, <code>-x tba-det</code> successfully produces a deterministic
TBA, but a non-minimal one:
</p>



<pre class="src src-sh">ltl2tgba -D -x tba-det <span class="org-string">"GF(a &lt;-&gt; XXb)"</span> --stats=<span class="org-string">'states=%s, det=%d'</span>
</pre>

<pre class="example">
states=7, det=1
</pre>


<p>
Option <code>-x sat-minimize</code> will turn-on SAT-based minimization.  It also
implies <code>-x tba-det</code>, so there is no need to supply both options.
</p>



<pre class="src src-sh">ltl2tgba -D -x sat-minimize <span class="org-string">"GF(a &lt;-&gt; XXb)"</span> --stats=<span class="org-string">'states=%s, det=%d'</span>
</pre>

<pre class="example">
states=4, det=1
</pre>


<p>
We can draw it:
</p>



<pre class="src src-sh">ltl2tgba -D -x sat-minimize <span class="org-string">"GF(a &lt;-&gt; XXb)"</span>
</pre>



<p>
<img src="gfaexxb3.png"  alt="gfaexxb3.png" />
</p>
<p>
Clearly this is automaton benefits from the transition-based
acceptance.  If we want a traditional Büchi automaton, with
state-based acceptance, we only need to add the <code>-B</code> option.  The
result will of course be slightly bigger.
</p>



<pre class="src src-sh">ltl2tgba -BD -x sat-minimize <span class="org-string">"GF(a &lt;-&gt; XXb)"</span>
</pre>



<p>
<img src="gfaexxb4.png"  alt="gfaexxb4.png" />
</p>

<p>
There are cases where <code>ltl2tgba</code>'s <code>tba-det</code> algorithm fails to produce a deterministic automaton.
In that case, SAT-based minimization is simply skipped.  For instance:
</p>



<pre class="src src-sh">ltl2tgba -D -x sat-minimize <span class="org-string">"Ga R (F!b &amp; (c U b))"</span> --stats=<span class="org-string">'states=%s, det=%d'</span>
</pre>

<pre class="example">
states=4, det=0
</pre>


<p>
The question, of course, is whether there exist a deterministic
automaton for this formula, in other words: is this a recurrence
property?  There are two ways to answer this question using Spot (and
some help from <a href="http://www.ltl2dstar.de/"><code>ltl2dstar</code></a>).
</p>
<p>
The first is purely syntactic.  If a formula belongs to the class of
"syntactic recurrence formulas", it expresses a syntactic property.
(Of course there are formulas that expresses a syntactic properties
without being syntactic recurrences.)  <a href="ltlfilt.html"><code>ltlfilt</code></a> can be instructed to
print only formulas that are syntactic recurrences:
</p>



<pre class="src src-sh">ltlfilt --syntactic-recurrence -f <span class="org-string">"Ga R (F!b &amp; (c U b))"</span>
</pre>

<pre class="example">
Ga R (F!b &amp; (c U b))
</pre>


<p>
Since our input formula was output, it expresses a recurrence property.
</p>
<p>
The second way to check whether a formula is a recurrence is by
converting a deterministic Rabin automaton using <a href="dstar2tgba.html"><code>dstar2tgba</code></a>.  The
output is guaranteed to be deterministic if and only if the input DRA
expresses a recurrence property.
</p>



<pre class="src src-sh">ltlfilt -f <span class="org-string">"Ga R (F!b &amp; (c U b))"</span> -l |
ltl2dstar --ltl2nba=spin:../../src/bin/ltl2tgba@-Ds - - |
dstar2tgba -D --stats=<span class="org-string">'input(states=%S) output(states=%s, acc-sets=%a, det=%d)'</span>
</pre>

<pre class="example">
input(states=11) output(states=9, acc-sets=1, det=1)
</pre>


<p>
In the above command, <code>ltlfilt</code> is used to convert the LTL formula
into <code>ltl2dstar</code>'s syntax.  Then <code>ltl2dstar</code> creates a deterministic
Rabin automaton (using <code>ltl2tgba</code> as an LTL to BA translator), and the
resulting 11-state DRA is converted into a 9-state DTBA by
<code>dstar2tgba</code>.  Since that result is deterministic, we can conclude
that the formula was a recurrence.
</p>
<p>
As far as SAT-based minimization goes, <code>dstar2tgba</code> will take the same
options as <code>ltl2tgba</code>.  For instance we can see that the smallest DTBA
has 6 states:
</p>



<pre class="src src-sh">ltlfilt -f <span class="org-string">"Ga R (F!b &amp; (c U b))"</span> -l |
ltl2dstar --ltl2nba=spin:../../src/bin/ltl2tgba@-Ds - - |
dstar2tgba -D -x sat-minimize --stats=<span class="org-string">'input(states=%S) output(states=%s, acc-sets=%a, det=%d)'</span>
</pre>

<pre class="example">
input(states=11) output(states=6, acc-sets=1, det=1)
</pre>


</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">More acceptance sets</h2>
<div class="outline-text-2" id="text-3">


<p>
The formula "<code>Ga R (F!b &amp; (c U b))</code>" can in fact be minimized into an
even smaller automaton if we use multiple acceptance sets.
</p>
<p>
Unfortunately because <code>dstar2tgba</code> does not know the formula being
translated, and it always convert a DRA into a DBA (with a single
acceptance set) before further processing, it does not know if using
more acceptance sets could be useful to further minimize it.   This
number of acceptance sets can however be specified on the command-line
with option <code>-x sat-acc=M</code>.  For instance:
</p>



<pre class="src src-sh">ltlfilt -f <span class="org-string">"Ga R (F!b &amp; (c U b))"</span> -l |
ltl2dstar --ltl2nba=spin:../../src/bin/ltl2tgba@-Ds - - |
dstar2tgba -D -x sat-minimize,sat-acc=2 --stats=<span class="org-string">'input(states=%S) output(states=%s, acc-sets=%a, det=%d)'</span>
</pre>

<pre class="example">
input(states=11) output(states=5, acc-sets=2, det=1)
</pre>


<p>
Beware that the size of the SAT problem is exponential in the number of acceptance sets.
</p>
<p>
The case of <code>ltl2tgba</code> is slightly different because it can remember
the number of acceptance sets used by the translation algorithm, and
reuse that for SAT-minimization even if the automaton had to be
degeneralized in the meantime for the purpose of determinization.
</p>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4">Low-level details</h2>
<div class="outline-text-2" id="text-4">


<p>
The following figure gives an overview of the processing chains that
can be used to turn an LTL formula into a minimal DBA/DTBA/DTGBA.  The
blue area at the top describes <code>ltl2tgba -D -x sat-minimize</code>, while
the purple area at the bottom corresponds to <code>dstar2tgba -D -x stat-minimize</code>.
</p>
<p>
<img src="satmin.png"  alt="satmin.png" />
</p>
<p>
The picture is slightly inaccurate in the sense that both <code>ltl2tgba</code>
and <code>dstar2tgba</code> are actually using the same post-processing chain:
only the initial translation to TGBA or conversion to DBA differs, the
rest is the same.  However in the case of <code>dstar2tgba</code>, no
degeneration or determinization are needed.
</p>
<p>
Also the picture does not show what happens when <code>-B</code> is used: any
DTBA is degeneralized into a DBA, before being sent to "DTBA SAT
minimization", with a special option to request state-based output.
</p>
<p>
The WDBA-minimization boxes are able to produce minimal Weak DBA from
any TGBA representing an obligation property.  In that case using
transition-based or generalized acceptance will not allow further
reduction.  This minimal WDBA is always used when <code>-D</code> is given
(otherwise, for the default <code>--small</code> option, the minimal WDBA is only
used if it is smaller than the nondeterministic automaton it has been
built from).
</p>
<p>
The "simplify" boxes are actually simulation-based reductions, and
SCC-based simplifications.
</p>
<p>
The red boxes "not in TCONG" or "not a recurrence" correspond to
situations where the tools will produce non-deterministic automata.
</p>
<p>
The following options can be used to fine-tune this procedure:
</p>
<dl>
<dt><code>-x tba-det</code></dt><dd>attempt a powerset construction and check if
                  there exists a acceptance set such that the
                  resulting DTBA is equivalent to the input
</dd>
<dt><code>-x sat-minimize</code></dt><dd>enable SAT-based minimization.  By default it
     tries to reduce the size of the automaton one state at a time.
     This option implies <code>-x tba-det</code>.
</dd>
<dt><code>-x sat-minimize=2</code></dt><dd>enabled SAT-based minimization, but perform a
     dichotomy to locate the correct automaton size.  Use this only if
     you suspect that the optimal size is far away from the input
     size.  This option implies <code>-x tba-det</code>.
</dd>
<dt><code>-x sat-acc=$m$</code></dt><dd>attempt to build a minimal DTGBA with \(m\) acceptance sets.
     This options implies <code>-x sat-minimize</code>.
</dd>
<dt><code>-x sat-states=$n$</code></dt><dd>attempt to build an equivalent DTGBA with \(n\)
     states.  This also implies <code>-x sat-minimize</code> but won't perform
     any loop to lower the number of states.  Note that \(n\) should be
     the number of states in a complete automaton, while <code>ltl2tgba</code>
     and <code>dstar2tgba</code> both remove sink states in their output by
     default (use option <code>--complete</code> to output a complete automaton).
     Also note that even with the <code>--complete</code> option, the output
     automaton may have appear to have less states because the other
     are unreachable.
</dd>
<dt><code>-x state-based</code></dt><dd>for all outgoing transition of each state
     to belong to the same acceptance sets.
</dd>
<dt><code>-x !wdba-minimize</code></dt><dd>disable WDBA minimization.
</dd>
</dl>


<p>
When options <code>-B</code> and <code>-x sat-minimize</code> are both used, <code>-x state-based</code> and <code>-x sat-acc=1</code> are implied.
</p>

</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5">Logging statistics</h2>
<div class="outline-text-2" id="text-5">


<p>
If the environment variable <code>SPOT_SATLOG</code> is set to the name of a
file, the minimization function will append statistics about each of
its iterations in this file.
</p>



<pre class="src src-sh">rm -f stats.csv
<span class="org-builtin">export</span> <span class="org-variable-name">SPOT_SATLOG</span>=stats.csv
ltlfilt -f <span class="org-string">"Ga R (F!b &amp; (c U b))"</span> -l |
ltl2dstar --ltl2nba=spin:../../src/bin/ltl2tgba@-Ds - - |
dstar2tgba -D -x sat-minimize,sat-acc=2 --stats=<span class="org-string">'input(states=%S) output(states=%s, acc-sets=%a, det=%d)'</span>
cat stats.csv
</pre>

<pre class="example">
input(states=11) output(states=5, acc-sets=2, det=1)
9,8,35,64,44064,9043076,982,30,281,21
7,7,33,56,14504,2191905,237,5,114,5
6,6,28,48,10512,1358243,147,3,42,3
5,,,,7200,782342,85,1,30,1
</pre>


<p>
The generated CSV file use the following columns:
</p><ul>
<li>the n passed to the SAT-based minimization algorithm
  (it means the input automaton had n+1 states)
</li>
<li>number of reachable states in the output of
  the minimization.
</li>
<li>number of edges in the output
</li>
<li>number of transitions
</li>
<li>number of variables in the SAT problem
</li>
<li>number of clauses in the SAT problem
</li>
<li>user time for encoding the SAT problem
</li>
<li>system time for encoding the SAT problem
</li>
<li>user time for solving the SAT problem
</li>
<li>system time for solving the SAT problem
</li>
</ul>


<p>
Times are measured with the times() function, and expressed
in ticks (usually: 1/100 of seconds).
</p>
<p>
In the above example, the input DRA had 11
states.  In the first line of the <code>stats.csv</code> file, you can see the
minimization function searching for a 9 state DTBA and obtaining a
8-state solution.  (Since the minimization function searched for a
9-state DTBA, it means it received a 10-state complete DTBA, so the
processings performed before the minimization procedure managed to
convert the 11-state DRA into a 10-state DTBA.)  Starting from the
8-state solution, it looked for (and found) a 7-state solution, and
then a 6-state solution.  The search for a 5-state complete DTBA
failed.  The final output is reported with 5 states, because by
default we output trim automata. If the <code>--complete</code> option had been
given, the useless sink state would have been kept and the output
automaton would have 6 states.
</p></div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2014-08-21T17:42+0200</p>
<p class="author">Author: Alexandre Duret-Lutz</p>
<p class="creator"><a href="http://orgmode.org">Org</a> version 7.9.3f with <a href="http://www.gnu.org/software/emacs/">Emacs</a> version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
