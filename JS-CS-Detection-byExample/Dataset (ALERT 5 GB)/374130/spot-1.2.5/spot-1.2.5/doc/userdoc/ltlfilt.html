<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title><code>ltlfilt</code></title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="title" content="<code>ltlfilt</code>"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2014-08-21T17:43+0200"/>
<meta name="author" content="Alexandre Duret-Lutz"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="syntax.css" />
<link rel="stylesheet" type="text/css" href="http://spot.lip6.fr/css/spot-zenburn.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>
<div id="org-div-home-and-up" style="text-align:center;white-space:nowrap;">
 <a accesskey="h" href="tools.html">UP</a> | <a accesskey="H" href="tools.html">HOME</a>
</div>

<div id="preamble">

</div>

<div id="content">
<h1 class="title"><code>ltlfilt</code></h1>

<p>This tool is a filter for LTL formulas.  (It will also work with PSL
formulas.)  It can be used to perform a number of tasks.  Essentially:
</p><ul>
<li>converting formulas from one syntax to another,
</li>
<li>transforming formulas,
</li>
<li>selecting formulas matching some criterion.
</li>
</ul>



<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Changing syntaxes</a></li>
<li><a href="#sec-2">Altering the formula</a></li>
<li><a href="#sec-3">Filtering</a></li>
<li><a href="#sec-4">Using <code>--format</code></a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Changing syntaxes</h2>
<div class="outline-text-2" id="text-1">


<p>
Because it read and write formulas, <code>ltlfilt</code> accepts
all the <a href="ioltl.html">common input and output options</a>.
</p>
<p>
Additionally, if no <code>-f</code> or <code>-F</code> option is specified, <code>ltlfilt</code>
will read formulas from the standard input.
</p>
<p>
For instance the following will convert two LTL formulas expressed
using infix notation (with different names supported for the same
operators) and convert it into LBT's syntax.
</p>



<pre class="src src-sh">ltlfilt -l -f <span class="org-string">'p1 U (p2 &amp; GFp3)'</span> -f <span class="org-string">'X&lt;&gt;[]p4'</span>
</pre>

<pre class="example">
U p1 &amp; p2 G F p3
X F G p4
</pre>


<p>
Conversely, here is how to rewrite formulas expressed using the
LBT's Polish notation.  Let's take the following four formulas
taken from examples distributed with <code>scheck</code>:
</p>


<pre class="src src-sh">cat &gt;scheck.ltl&lt;&lt;EOF
<span class="org-sh-heredoc">! | G p0 &amp; G p1 F p3</span>
<span class="org-sh-heredoc">| | X p7 F p6 &amp; | | t p3 p7 U | f p3 p3</span>
<span class="org-sh-heredoc">&amp; U &amp; X p0 X p4 F p1 X X U X F p5 U p0 X X p3</span>
<span class="org-sh-heredoc">U p0 &amp; | p0 p5 p1</span>
<span class="org-sh-heredoc">EOF</span>
</pre>


<p>
These can be turned into something easier to read (to the human) with:
</p>


<pre class="src src-sh">ltlfilt --lbt-input -F scheck.ltl
</pre>

<pre class="example">
!(Gp0 | (Gp1 &amp; Fp3))
p3 | Xp7 | Fp6
((Xp0 &amp; Xp4) U Fp1) &amp; XX(XFp5 U (p0 U XXp3))
p0 U (p1 &amp; (p0 | p5))
</pre>


</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">Altering the formula</h2>
<div class="outline-text-2" id="text-2">


<p>
As with <a href="randltl.html"><code>randltl</code></a>, the <code>-r</code> option can be used to simplify formulas.
</p>



<pre class="src src-sh">ltlfilt --lbt-input -F scheck.ltl -r
</pre>

<pre class="example">
F!p0 &amp; (F!p1 | G!p3)
p3 | Xp7 | Fp6
Fp1 &amp; XX(XFp5 U (p0 U XXp3))
p0 U (p1 &amp; (p0 | p5))
</pre>


<p>
You may notice that operands of n-ary operators such as <code>&amp;</code> or <code>|</code> can
be reordered by <code>ltlfilt</code> even when the formula is not changed
otherwise.  This is because Spot internally order all operands of
commutative and associative operators, and that this order depends on
the order in which the subformulas are first encountered.  Adding
transformation options such as <code>-r</code> may alter this order.  However
this difference is semantically insignificant.
</p>
<p>
Formulas can be easily negated using the <code>-n</code> option, rewritten into
negative normal form using the <code>--nnf</code> option, and the <code>W</code> and <code>M</code>
operators can be rewritten using <code>U</code> and <code>R</code> using the <code>--remove-wm</code>
option (note that this is already done when a formula is output in
Spin's syntax).
</p>
<p>
Another way to alter formula is to rename the atomic propositions it
uses.  The <code>--relabel=abc</code> will relabel all atomic propositions using
letters of the alphabet, while <code>--relabel=pnn</code> will use <code>p0</code>, <code>p1</code>,
etc. as in LBT's syntax.
</p>



<pre class="src src-sh">ltlfilt --lbt-input -F scheck.ltl -r --relabel=abc
</pre>

<pre class="example">
F!a &amp; (F!b | G!c)
a | Xb | Fc
Fa &amp; XX(XFb U (c U XXd))
a U (b &amp; (a | c))
</pre>


<p>
Note that the relabeling is reset between each formula: <code>p3</code> became
<code>c</code> in the first formula, but it became <code>d</code> in the third.
</p>
<p>
Another use of relabeling is to get rid of complex atomic propositions
such as the one shown when <a href="ioltl.html">presenting lenient mode</a>:
</p>



<pre class="src src-sh">ltlfilt --lenient --relabel=pnn -f <span class="org-string">'(a &lt; b) U (process[2]@ok)'</span>
</pre>

<pre class="example">
p0 U p1
</pre>



<p>
Finally, there is a second variant of the relabeling procedure that is
enabled by <code>--relabel-bool=abc</code> or <code>--relabel-book=pnn</code>.  With this
option, Boolean subformulas that do not interfere with other
subformulas will be changed into atomic propositions.  For instance:
</p>



<pre class="src src-sh">ltlfilt -f <span class="org-string">'(a &amp; !b) &amp; GF(a &amp; !b) &amp; FG(!c)'</span> --relabel-bool=pnn
ltlfilt -f <span class="org-string">'(a &amp; !b) &amp; GF(a &amp; !b) &amp; FG(!c &amp; a)'</span> --relabel-bool=pnn
</pre>

<pre class="example">
p0 &amp; GFp0 &amp; FGp1
p0 &amp; p1 &amp; GF(p0 &amp; p1) &amp; FG(p0 &amp; p2)
</pre>


<p>
In the first formula, the independent <code>a &amp; !b</code> and <code>!c</code> subformulae
were respectively renamed <code>p0</code> and <code>p1</code>.  In the second formula, <code>a &amp; !b</code> and <code>!c &amp; a</code> are dependent so they could not be renamed; instead
<code>a</code>, <code>!b</code> and <code>c</code> were renamed as <code>p0</code>, <code>p1</code> and <code>p2</code>.
</p>
<p>
This option was originally developed to remove superfluous formulas
from benchmarks of LTL translators.  For instance the automata
generated for <code>GF(a|b)</code> and <code>GF(p0)</code> should be structurally
equivalent: replacing <code>p0</code> by <code>a|b</code> in the second automaton should
turn in into the first automaton, and vice-versa.  (However algorithms
dealing with <code>GF(a|b)</code> might be slower because they have to deal with
more atomic propositions.)  So given a long list of LTL formulas, we
can combine <code>--relabel-bool</code> and <code>-u</code> to keep only one instance of
formulas that are equivalent after such relabeling.  We also suggest
to use <code>--nnf</code> so that <code>!FG(a -&gt; b)</code> would become <code>GF(p0)</code>
as well.  For instance here are some LTL formulas extracted from an
<a href="http://www.fi.muni.cz/~xrehak/publications/verificationresults.ps.gz">industrial project</a>:
</p>



<pre class="src src-sh">ltlfilt --nnf -u --relabel-bool &lt;&lt;EOF
<span class="org-sh-heredoc">G (hfe_rdy -&gt; F !hfe_req)</span>
<span class="org-sh-heredoc">G (lup_sr_valid -&gt; F lup_sr_clean )</span>
<span class="org-sh-heredoc">G F (hfe_req)</span>
<span class="org-sh-heredoc">reset &amp;&amp; X G (!reset)</span>
<span class="org-sh-heredoc">G ( (F hfe_clk) &amp;&amp; (F ! hfe_clk) )</span>
<span class="org-sh-heredoc">G ( (F lup_clk) &amp;&amp; (F ! lup_clk) )</span>
<span class="org-sh-heredoc">G F (lup_sr_clean)</span>
<span class="org-sh-heredoc">G ( ( !(lup_addr_5_ &lt;-&gt; (X lup_addr_5_)) || !(lup_addr_6_ &lt;-&gt; (X lup_addr_6_)) || !(lup_addr_7_ &lt;-&gt; (X lup_addr_7_)) || !(lup_addr_8_ &lt;-&gt; (X lup_addr_8_)) ) -&gt; ( (X !lup_sr_clean) &amp;&amp; X ( (!( !(lup_addr_5_ &lt;-&gt; (X lup_addr_5_)) || !(lup_addr_6_ &lt;-&gt; (X lup_addr_6_)) || !(lup_addr_7_ &lt;-&gt; (X lup_addr_7_)) || !(lup_addr_8_ &lt;-&gt; (X lup_addr_8_)) )) U lup_sr_clean ) ) )</span>
<span class="org-sh-heredoc">G F ( !(lup_addr_5_ &lt;-&gt; (X lup_addr_5_)) || !(lup_addr_6_ &lt;-&gt; (X lup_addr_6_)) || !(lup_addr_7_ &lt;-&gt; (X lup_addr_7_)) || !(lup_addr_8_ &lt;-&gt; (X lup_addr_8_)) )</span>
<span class="org-sh-heredoc">(lup_addr_8__5__eq_0)</span>
<span class="org-sh-heredoc">((hfe_block_0__eq_0)&amp;&amp;(hfe_block_1__eq_0)&amp;&amp;(hfe_block_2__eq_0)&amp;&amp;(hfe_block_3__eq_0))</span>
<span class="org-sh-heredoc">G ((lup_addr_8__5__eq_0) -&gt; X( (lup_addr_8__5__eq_0) || (lup_addr_8__5__eq_1) ) )</span>
<span class="org-sh-heredoc">G ((lup_addr_8__5__eq_1) -&gt; X( (lup_addr_8__5__eq_1) || (lup_addr_8__5__eq_2) ) )</span>
<span class="org-sh-heredoc">G ((lup_addr_8__5__eq_2) -&gt; X( (lup_addr_8__5__eq_2) || (lup_addr_8__5__eq_3) ) )</span>
<span class="org-sh-heredoc">G ((lup_addr_8__5__eq_3) -&gt; X( (lup_addr_8__5__eq_3) || (lup_addr_8__5__eq_4) ) )</span>
<span class="org-sh-heredoc">G ((lup_addr_8__5__eq_4) -&gt; X( (lup_addr_8__5__eq_4) || (lup_addr_8__5__eq_5) ) )</span>
<span class="org-sh-heredoc">G ((lup_addr_8__5__eq_5) -&gt; X( (lup_addr_8__5__eq_5) || (lup_addr_8__5__eq_6) ) )</span>
<span class="org-sh-heredoc">G ((lup_addr_8__5__eq_6) -&gt; X( (lup_addr_8__5__eq_6) || (lup_addr_8__5__eq_7) ) )</span>
<span class="org-sh-heredoc">G ((lup_addr_8__5__eq_7) -&gt; X( (lup_addr_8__5__eq_7) || (lup_addr_8__5__eq_8) ) )</span>
<span class="org-sh-heredoc">G ((lup_addr_8__5__eq_8) -&gt; X( (lup_addr_8__5__eq_8) || (lup_addr_8__5__eq_9) ) )</span>
<span class="org-sh-heredoc">G ((lup_addr_8__5__eq_9) -&gt; X( (lup_addr_8__5__eq_9) || (lup_addr_8__5__eq_10) ) )</span>
<span class="org-sh-heredoc">G ((lup_addr_8__5__eq_10) -&gt; X( (lup_addr_8__5__eq_10) || (lup_addr_8__5__eq_11) ) )</span>
<span class="org-sh-heredoc">G ((lup_addr_8__5__eq_11) -&gt; X( (lup_addr_8__5__eq_11) || (lup_addr_8__5__eq_12) ) )</span>
<span class="org-sh-heredoc">G ((lup_addr_8__5__eq_12) -&gt; X( (lup_addr_8__5__eq_12) || (lup_addr_8__5__eq_13) ) )</span>
<span class="org-sh-heredoc">G ((lup_addr_8__5__eq_13) -&gt; X( (lup_addr_8__5__eq_13) || (lup_addr_8__5__eq_14) ) )</span>
<span class="org-sh-heredoc">G ((lup_addr_8__5__eq_14) -&gt; X( (lup_addr_8__5__eq_14) || (lup_addr_8__5__eq_15) ) )</span>
<span class="org-sh-heredoc">G ((lup_addr_8__5__eq_15) -&gt; X( (lup_addr_8__5__eq_15) || (lup_addr_8__5__eq_0) ) )</span>
<span class="org-sh-heredoc">G (((X hfe_clk) -&gt; hfe_clk)-&gt;((hfe_req-&gt;X hfe_req)&amp;&amp;((!hfe_req) -&gt; (X !hfe_req))))</span>
<span class="org-sh-heredoc">G (((X lup_clk) -&gt; lup_clk)-&gt;((lup_sr_clean-&gt;X lup_sr_clean)&amp;&amp;((!lup_sr_clean) -&gt; (X !lup_sr_clean))))</span>
<span class="org-sh-heredoc">EOF</span>
</pre>

<pre class="example">
G(a | Fb)
GFa
a &amp; XG!a
G(Fa &amp; F!a)
G((((!a &amp; X!a) | (a &amp; Xa)) &amp; ((!b &amp; X!b) | (b &amp; Xb)) &amp; ((!c &amp; X!c) | (c &amp; Xc)) &amp; ((!d &amp; X!d) | (d &amp; Xd))) | (X!e &amp; X((((!a &amp; X!a) | (a &amp; Xa)) &amp; ((!b &amp; X!b) | (b &amp; Xb)) &amp; ((!c &amp; X!c) | (c &amp; Xc)) &amp; ((!d &amp; X!d) | (d &amp; Xd))) U e)))
GF((!a &amp; Xa) | (a &amp; X!a) | (!b &amp; Xb) | (b &amp; X!b) | (!c &amp; Xc) | (c &amp; X!c) | (!d &amp; Xd) | (d &amp; X!d))
a
G(!a | X(a | b))
G((!b &amp; Xb) | ((!a | Xa) &amp; (a | X!a)))
</pre>


<p>
Here 29 formulas were reduced into 9 formulas after relabeling of
Boolean subexpression and removing of duplicate formulas.  In other
words the original set of formulas contains 9 different patterns.
</p>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">Filtering</h2>
<div class="outline-text-2" id="text-3">


<p>
<code>ltlfilt</code> supports many ways to filter formulas:
</p>




<pre class="example">    --boolean              match Boolean formulas
    --bsize-max=INT        match formulas with Boolean size &lt;= INT
    --bsize-min=INT        match formulas with Boolean size &gt;= INT
    --equivalent-to=FORMULA   match formulas equivalent to FORMULA
    --eventual             match pure eventualities
    --guarantee            match guarantee formulas (even pathological)
    --implied-by=FORMULA   match formulas implied by FORMULA
    --imply=FORMULA        match formulas implying FORMULA
    --ltl                  match only LTL formulas (no PSL operator)
    --nox                  match X-free formulas
    --obligation           match obligation formulas (even pathological)
    --safety               match safety formulas (even pathological)
    --size-max=INT         match formulas with size &lt;= INT
    --size-min=INT         match formulas with size &gt;= INT
    --stutter-insensitive, --stutter-invariant
                           match stutter-insensitive LTL formulas
    --syntactic-guarantee  match syntactic-guarantee formulas
    --syntactic-obligation match syntactic-obligation formulas
    --syntactic-persistence   match syntactic-persistence formulas
    --syntactic-recurrence match syntactic-recurrence formulas
    --syntactic-safety     match syntactic-safety formulas
    --universal            match purely universal formulas
-u, --unique               drop formulas that have already been output (not
                           affected by -v)
-v, --invert-match         select non-matching formulas
</pre>


<p>
Most of the above options should be self-explanatory.  For instance
the following command will extract all formulas from <code>scheck.ltl</code>
which do not represent guarantee properties.
</p>



<pre class="src src-sh">ltlfilt --lbt-input -F scheck.ltl -v --guarantee
</pre>

<pre class="example">
!(Gp0 | (Gp1 &amp; Fp3))
</pre>


<p>
Combining <code>ltlfilt</code> with <a href="randltl.html"><code>randltl</code></a> makes it easier to generate random
formulas that respect certain constraints.  For instance let us
generate 10 formulas that are equivalent to <code>a U b</code>:
</p>



<pre class="src src-sh">randltl -n -1 a b | ltlfilt --equivalent-to <span class="org-string">'a U b'</span> | head -n 10
</pre>


<pre class="example">a U b
b | (b W (Xb M a))
(a | Gb) U b
(a U b) &amp; Fb
((b &amp; F!a) U (a W (a W b))) U b
(a &amp; b) | (a U b)
b M (a U b)
(a U b) | Gb
Fb &amp; (a W b)
b | (XFb &amp; (Xb M a))
</pre>


<p>
The <code>-n -1</code> option to <code>randltl</code> will cause it to output an infinite
stream of random formulas.  <code>ltlfilt</code>, which reads its standard input
by default, will select only those equivalent to <code>a U b</code>.  The output
of <code>ltlfilt</code> would still be an infinite stream of random formulas, so
we display only the first 10 using the standard <code>head</code> utility.  Less
trivial formulas could be obtained by adding the <code>-r</code> option to
<code>randltl</code> (or equivalently adding the <code>-r</code> and <code>-u</code> option to
<code>ltlfilt</code>).
</p>

<p>
Another similar example, that requires two calls to <code>ltlfilt</code>, is the
generation of random pathological safety formulas.  Pathological
safety formulas are safety formulas that do not <i>look</i> so
syntactically.  We can generate some starting again with <code>randltl</code>,
then ignoring all syntactic safety formulas, and keeping only the
safety formulas in the remaining list.
</p>



<pre class="src src-sh">randltl -r -n -1 a b | ltlfilt -v --syntactic-safety | ltlfilt --safety | head -n 10
</pre>


<pre class="example">F(XF!b W Gb)
(((!a &amp; b) | (a &amp; !b)) U a) R ((!a &amp; X!a) | (a &amp; Xa))
F(b | G(!b &amp; X(!b W !a)))
G(!b &amp; Fb)
X(!a | ((a &amp; Fb) M b))
!a | XX!b | (a M Xa)
a | (a U Xb)
((!b &amp; Fa) | (b &amp; G!a)) R b
(b M a) U XXa
G((!a &amp; (a M b)) | (a &amp; (!a W !b)))
</pre>



<p>
<code>ltlfilt</code>'s filtering ability can also be used to answer questions
about a single formula.  For instance is <code>a U (b U a)</code> equivalent to
<code>b U a</code>?
</p>



<pre class="src src-sh">ltlfilt -f <span class="org-string">'a U (b U a)'</span> --equivalent-to <span class="org-string">'b U a'</span>
</pre>

<pre class="example">
a U (b U a)
</pre>


<p>
The command prints the formula and returns an exit status of 0 if the
two formulas are equivalent.  It would print nothing and set the exit
status to 1, were the two formulas not equivalent.
</p>

<p>
Is the formula <code>F(a &amp; X(!a &amp; Gb))</code> stutter-invariant?
</p>



<pre class="src src-sh">ltlfilt -f <span class="org-string">'F(a &amp; X(!a &amp; Gb))'</span> --stutter-invariant
</pre>

<pre class="example">
F(a &amp; X(!a &amp; Gb))
</pre>


<p>
Yes it is.  And since it is stutter-invariant, there exist some
equivalent formulas that do not use <code>X</code> operator.  The <code>--remove-x</code>
option gives one:
</p>



<pre class="src src-sh">ltlfilt -f <span class="org-string">'F(a &amp; X(!a &amp; Gb))'</span> --remove-x
</pre>

<pre class="example">
F(a &amp; ((a &amp; (a U (!a &amp; Gb)) &amp; ((!b U !a) | (b U !a))) | (!a &amp; (!a U (a &amp; !a &amp; Gb)) &amp; ((!b U a) | (b U a))) | (b &amp; (b U (!a &amp; !b &amp; Gb)) &amp; ((!a U !b) | (a U !b))) | (!b &amp; (!b U (!a &amp; b &amp; Gb)) &amp; ((!a U b) | (a U b))) | (!a &amp; Gb &amp; (G!a | Ga) &amp; (Gb | G!b))))
</pre>


<p>
We could even verify that the resulting horrible formula is equivalent
to the original one:
</p>



<pre class="src src-sh">ltlfilt -f <span class="org-string">'F(a &amp; X(!a &amp; Gb))'</span> --remove-x | ltlfilt --equivalent-to <span class="org-string">'F(a &amp; X(!a &amp; Gb))'</span>
</pre>

<pre class="example">
F(a &amp; ((a &amp; (a U (!a &amp; Gb)) &amp; ((!b U !a) | (b U !a))) | (!a &amp; (!a U (a &amp; !a &amp; Gb)) &amp; ((!b U a) | (b U a))) | (b &amp; (b U (!a &amp; !b &amp; Gb)) &amp; ((!a U !b) | (a U !b))) | (!b &amp; (!b U (!a &amp; b &amp; Gb)) &amp; ((!a U b) | (a U b))) | (!a &amp; Gb &amp; (G!a | Ga) &amp; (Gb | G!b))))
</pre>


<p>
It is therefore equivalent, but that is not a surprise since the
<code>--stutter-invariant</code> filter is actually implemented using exactly
<a href="http://homepages.inf.ed.ac.uk/kousha/note_on_stut_tl_lpi.ps">this procedure</a> (calling the <code>remove_x()</code> function, and building automata
to check the equivalence of the resulting formula with the original one).
</p>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4">Using <code>--format</code></h2>
<div class="outline-text-2" id="text-4">


<p>
The <code>--format</code> option can be used the alter the way formulas are output (for instance use
<code>--latex --format='$%f$'</code>
to enclose formula in LaTeX format with <code>$...$</code>).  You may also find
<code>--format</code> useful in more complex scenarios.  For instance you could
print only the line numbers containing formulas matching some
criterion.  In the following, we print only the numbers of the lines
of <code>scheck.ltl</code> that contain guarantee formulas:
</p>



<pre class="src src-sh">ltlfilt --lbt-input -F scheck.ltl --guarantee --format=%L
</pre>

<pre class="example">
2
3
4
</pre>


<p>
<a href="csv.html">More examples of how to use <code>&ndash;format</code> to create CSV files are on a separate page</a>
</p>
</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2014-08-21T17:43+0200</p>
<p class="author">Author: Alexandre Duret-Lutz</p>
<p class="creator"><a href="http://orgmode.org">Org</a> version 7.9.3f with <a href="http://www.gnu.org/software/emacs/">Emacs</a> version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
