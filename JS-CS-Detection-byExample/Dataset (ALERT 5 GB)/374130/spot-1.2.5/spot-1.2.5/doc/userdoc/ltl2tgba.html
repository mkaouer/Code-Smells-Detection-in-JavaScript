<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title><code>ltl2tgba</code></title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="<code>ltl2tgba</code>"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2014-08-21T17:43+0200"/>
<meta name="author" content="Alexandre Duret-Lutz"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="syntax.css" />
<link rel="stylesheet" type="text/css" href="http://spot.lip6.fr/css/spot-zenburn.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>
<div id="org-div-home-and-up" style="text-align:center;white-space:nowrap;">
 <a accesskey="h" href="tools.html">UP</a> | <a accesskey="H" href="tools.html">HOME</a>
</div>

<div id="preamble">

</div>

<div id="content">
<h1 class="title"><code>ltl2tgba</code></h1>

<p>This tool translates LTL or PSL formulas into two kinds of Büchi
automata, or to monitors.  The default is to output Transition-based
Generalized Büchi Automata (hereinafter abbreviated TGBA), but more
traditional Büchi automata (BA) may be requested using the <code>-B</code>
option.
</p>

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">TGBA and BA</a></li>
<li><a href="#sec-2">Spin output</a></li>
<li><a href="#sec-3">Do you favor deterministic or small automata?</a></li>
<li><a href="#sec-4">Translating multiple formulas for statistics</a></li>
<li><a href="#sec-5">Building Monitors</a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">TGBA and BA</h2>
<div class="outline-text-2" id="text-1">


<p>
Formulas to translate may be specified using <a href="ioltl.html">common input options for LTL/PSL formulas</a>.
</p>



<pre class="src src-sh">ltl2tgba -f <span class="org-string">'Fa &amp; GFb'</span>
</pre>


<pre class="example">digraph G {
  0 [label="", style=invis, height=0]
  0 -&gt; 1
  1 [label="1"]
  1 -&gt; 2 [label="a\n"]
  1 -&gt; 1 [label="!a\n"]
  2 [label="2"]
  2 -&gt; 2 [label="b\n{Acc[a]}"]
  2 -&gt; 2 [label="!b\n"]
}
</pre>


<p>
Actually, because <code>ltl2tgba</code> is often used with a single formula
passed on the command line, the <code>-f</code> option can be omitted and any
command-line parameter that is not the argument of some option will be
assumed to be a formula to translate (this differs from <a href="ltlfilt.html"><code>ltlfilt</code></a>,
where such parameters are assumed to be filenames).
</p>
<p>
The default output format, as shown above, is <a href="http://http://www.graphviz.org/">GraphViz</a>'s format.  This
can converted into a picture, or into vectorial format using <code>dot</code> or
<code>dotty</code>.  Typically, you could get a <code>pdf</code> of this TGBA using
</p>


<pre class="src src-sh">ltl2tgba <span class="org-string">"Fa &amp; GFb"</span> | dot -Tpdf &gt; tgba.pdf
</pre>

<p>
The result would look like this:
</p>


<p>
<img src="dotex.png"  alt="dotex.png" />
</p>
<p>
The string between braces, <code>Acc[b]</code>, represents an acceptance set (its
actual name is not really important): any transition labeled by
<code>Acc[b]</code> belongs to the <code>Acc[b]</code> acceptance set.  You may have many
transitions in the same acceptance set, and a transition may also
belong to multiple acceptance sets.  An infinite path through this
automaton is accepting iff it visit each acceptance set infinitely
often.  Therefore, in the above example, any accepted path will
<i>necessarily</i> leave the initial state after a finite amount of steps,
and then it will verify the property <code>b</code> infinitely often.  It is also
possible that an automaton do not use any acceptance set at all, in
which any run is accepting.
</p>
<p>
Here is a TGBA with multiple acceptance sets (we omit the call to
<code>dot</code> to render the output of <code>ltl2tgba</code> from now on):
</p>



<pre class="src src-sh">ltl2tgba <span class="org-string">'GFa &amp; GFb'</span>
</pre>



<p>
<img src="dotex2.png"  alt="dotex2.png" />
</p>
<p>
The above TGBA has two acceptance sets: <code>Acc[a]</code> and <code>Acc[b]</code>.
The position of these acceptance sets ensures that <code>a</code> and <code>b</code> atomic
proposition must be true infinitely often.
</p>
<p>
A Büchi automaton for the previous formula can be obtained with the
<code>-B</code> option:
</p>



<pre class="src src-sh">ltl2tgba -B <span class="org-string">'GFa &amp; GFb'</span>
</pre>



<p>
<img src="dotex2ba.png"  alt="dotex2ba.png" />
</p>
<p>
Although accepting states in the Büchi automaton are pictured with
double-lines, internally this automaton is still handled as a TGBA
with a single acceptance set <code>Acc[1]</code> such that the transitions
leaving the state are either all accepting, or all non-accepting.
This is the reason why the <code>Acc[1]</code> sets are still shown in the
output: it shows that a Büchi automaton is (a special case of) a TGBA.
</p>
<p>
Various options controls the output format of <code>ltl2tgba</code>:
</p>




<pre class="example">-8, --utf8                 enable UTF-8 characters in output (ignored with
                           --lbtt or --spin)
    --csv-escape           quote formula output by %f in --format for use in
                           CSV file
    --dot                  GraphViz's format (default)
-H, --hoaf[=s|t|m|l]       Output the automaton in HOA format.  Add letters
                           to select (s) state-based acceptance, (t)
                           transition-based acceptance, (m) mixed acceptance,
                           (l) single-line output
    --lbtt[=t]             LBTT's format (add =t to force transition-based
                           acceptance even on Büchi automata)
-s, --spin                 Spin neverclaim (implies --ba)
    --spot                 SPOT's format
    --stats=FORMAT         output statistics about the automaton
</pre>



<p>
Option <code>-8</code> can be used to improve the readability of the output
if your system can display UTF-8 correctly.
</p>



<pre class="src src-sh">ltl2tgba -B8 <span class="org-string">'GFa &amp; GFb'</span>
</pre>



<p>
<img src="dotex2ba8.png"  alt="dotex2ba8.png" />
</p>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">Spin output</h2>
<div class="outline-text-2" id="text-2">


<p>
Using the <code>--spin</code> or <code>-s</code> option, <code>ltl2tgba</code> will produce a Büchi automaton
(the <code>-B</code> option is implied) as a never claim that can be fed to Spin.
<code>ltl2tgba -s</code> is therefore a drop-in replacement for <code>spin -f</code>.
</p>




<pre class="src src-sh">ltl2tgba -s <span class="org-string">'GFa &amp; GFb'</span>
</pre>


<pre class="example">never { /* G(Fa &amp; Fb) */
accept_init:
  if
  :: ((a) &amp;&amp; (b)) -&gt; goto accept_init
  :: ((!(a)) &amp;&amp; (b)) -&gt; goto T0_S2
  :: ((!(b))) -&gt; goto T0_S3
  fi;
T0_S2:
  if
  :: ((a)) -&gt; goto accept_init
  :: ((!(a))) -&gt; goto T0_S2
  fi;
T0_S3:
  if
  :: ((a) &amp;&amp; (b)) -&gt; goto accept_init
  :: ((!(a)) &amp;&amp; (b)) -&gt; goto T0_S2
  :: ((!(b))) -&gt; goto T0_S3
  fi;
}
</pre>


<p>
Since Spin 6 extended its syntax to support arbitrary atomic
propositions, you may also need put the parser in <code>--lenient</code> mode to
support these:
</p>



<pre class="src src-sh">ltl2tgba -s --lenient <span class="org-string">'(a &lt; b) U (process[2]@ok)'</span>
</pre>

<pre class="example">
never { /* "a &lt; b" U "process[2]@ok" */
T0_init:
  if
  :: ((process[2]@ok)) -&gt; goto accept_all
  :: ((a &lt; b) &amp;&amp; (!(process[2]@ok))) -&gt; goto T0_init
  fi;
accept_all:
  skip
}
</pre>



</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">Do you favor deterministic or small automata?</h2>
<div class="outline-text-2" id="text-3">


<p>
The translation procedure can be controled by a few switches.  A first
set of options specifies the intent of the translation: whenever
possible, would you prefer a small automaton or a deterministic
automaton?
</p>

<pre class="example">
  -a, --any                  no preference
  -C, --complete             output a complete automaton (combine with other
                             intents)
  -D, --deterministic        prefer deterministic automata
      --small                prefer small automata (default)
</pre>


<p>
The <code>--any</code> option tells the translator that it should not target any
particular form of result: any automaton denoting the given formula is
OK.  This effectively disables post-processings and speeds up the
translation.
</p>
<p>
With the <code>-D</code> option, the translator will <i>attempt</i> to produce a
deterministic automaton, even if this requires a lot of states.  <code>ltl2tgba</code>
knows how to produce the minimal deterministic Büchi automaton for
any obligation property (this includes safety properties).
</p>
<p>
With the <code>--small</code> option (the default), the translator will not
produce a deterministic automaton when it knows how to build smaller
automaton.
</p>
<p>
An example formula where the difference between <code>-D</code> and <code>--small</code> is
flagrant is <code>Ga|Gb|Gc</code>:
</p>



<pre class="src src-sh">ltl2tgba <span class="org-string">'Ga|Gb|Gc'</span>
</pre>



<p>
<img src="gagbgc1.png"  alt="gagbgc1.png" />
</p>



<pre class="src src-sh">ltl2tgba -D <span class="org-string">'Ga|Gb|Gc'</span>
</pre>



<p>
<img src="gagbgc2.png"  alt="gagbgc2.png" />
</p>
<p>
You can augment the number of terms in the disjunction to magnify the
difference.  For N terms, the <code>--small</code> automaton has N+1 states,
while the <code>--deterministic</code> automaton needs 2<sup>N</sup>-1 states.
</p>
<p>
Add the <code>--complete</code> option if you want to obtain a complete
automaton, with a sink state capturing that rejected words that would
not otherwise have a run in the output automaton.
</p>

<p>
A last parameter that can be used to tune the translation is the amount
of pre- and post-processing performed.  These two steps can be adjusted
via a common set of switches:
</p>
<pre class="example">
      --high                 all available optimizations (slow, default)
      --low                  minimal optimizations (fast)
      --medium               moderate optimizations
</pre>


<p>
Pre-processings are rewritings done on the LTL formulas, usually to
reduce its size, but mainly to put it in a form that will help the
translator (for instance <code>F(a|b)</code> is easier to translate than
<code>F(a)|F(b)</code>).  At <code>--low</code> level, only simple syntactic rewritings are
performed.  At <code>--medium</code> level, additional simplifications based on
syntactic implications are performed.  At <code>--high</code> level, language
containment is used instead of syntactic implications.
</p>
<p>
Post-processings are cleanups and simplifications of the automaton
produced by the core translator.  The algorithms used during post-processing
are
</p><ul>
<li>SCC filtering: removing useless strongly connected components,
  and useless acceptance sets.
</li>
<li>direct simulation: merge states based on suffix inclusion.
</li>
<li>iterated simulations: merge states based on suffix inclusion,
  or prefix inclusion, in a loop.
</li>
<li>WDBA minimization: determinize and minimize automata representing
  obligation properties.
</li>
<li>degeneralization: convert a TGBA into a BA
</li>
</ul>


<p>
The chaining of these various algorithms depends on the selected
combination of optimization level (<code>--low</code>, <code>--medium</code>, <code>--high</code>),
translation intent (<code>--small</code>, <code>--deterministic</code>) and type of
automaton desired (<code>--tgba</code>, <code>--ba</code>).
</p>
<p>
A notable configuration is <code>--any --low</code>, which will produce a TGBA as
fast as possible.  In this case, post-processing is disabled, and only
syntactic rewritings are performed.  This can be used for
satisfiability checking, although in this context even building an
automaton is overkill (you only need an accepted run).
</p>
<p>
Finally, it should be noted that the default optimization options
(<code>--small --high</code>) are usually overkill.  <code>--low</code> will produce good
automata most of the time.  Most of pattern formulas of <a href="genltl.html"><code>genltl</code></a> will
be efficiently translated in this configuration (meaning that <code>--small --high</code> will not produce a better automaton).  If you are planning to
generate automata for large family of pattern formulas, it makes sense
to experiment with the different settings on a small version of the
pattern, and select the lowest setting that satisfies your
expectations.
</p>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4">Translating multiple formulas for statistics</h2>
<div class="outline-text-2" id="text-4">


<p>
If multiple formulas are given to <code>ltl2tgba</code>, the corresponding
automata will be output one after the other.  This is not very
convenient, since most of these output formats are not designed to
represent multiple automata, and tools like <code>dot</code> will only display
the first one.
</p>
<p>
One situation where passing many formulas to <code>ltl2tgba</code> is useful is
in combination with the <code>--stats=FORMAT</code> option.  This option will
output statistics about the translated automata instead of the
automata themselves.  The <code>FORMAT</code> string should indicate which
statistics should be output, and how they should be output using the
following sequence of characters (other characters are output as-is):
</p>




<pre class="example">%%                         a single %
%a                         number of acceptance sets
%c                         number of SCCs
%d                         1 if the automaton is deterministic, 0 otherwise
%e                         number of edges
%f                         the formula, in Spot's syntax
%n                         number of nondeterministic states
%p                         1 if the automaton is complete, 0 otherwise
%r                         translation time (including pre- and
%s                         number of states
%t                         number of transitions
</pre>


<p>
For instance we can study the size of the automata generated for the
right-nested <code>U</code> formulas as follows:
</p>



<pre class="src src-sh">genltl --u-right=1..8 | ltl2tgba -F - --stats <span class="org-string">'%s states and %e edges for "%f"'</span>
</pre>

<pre class="example">
2 states and 2 edges for "p1"
2 states and 3 edges for "p1 U p2"
3 states and 6 edges for "p1 U (p2 U p3)"
4 states and 10 edges for "p1 U (p2 U (p3 U p4))"
5 states and 15 edges for "p1 U (p2 U (p3 U (p4 U p5)))"
6 states and 21 edges for "p1 U (p2 U (p3 U (p4 U (p5 U p6))))"
7 states and 28 edges for "p1 U (p2 U (p3 U (p4 U (p5 U (p6 U p7)))))"
8 states and 36 edges for "p1 U (p2 U (p3 U (p4 U (p5 U (p6 U (p7 U p8))))))"
</pre>


<p>
Here <code>-F -</code> means that formulas should be read from the standard input.
</p>
<p>
When computing the size of an automaton, we distinguish <i>transitions</i>
and <i>edges</i>.  An edge between two states is labeled by a Boolean
formula and may in fact represent several transitions labeled by
compatible Boolean assignment.
</p>
<p>
For instance if the atomic propositions are <code>x</code> and <code>y</code>, an edge labeled
by the formula <code>!x</code> actually represents two transitions labeled respectively
with <code>!x&amp;y</code> and <code>!x&amp;!y</code>.
</p>
<p>
Two automata with the same structures (states and edges) but differing
labels, may have a different count of transitions, e.g., if one has
more restricted labels.
</p>
<p>
<a href="csv.html">More examples of how to use <code>&ndash;stats</code> to create CSV files are on a separate page</a>.
</p>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5">Building Monitors</h2>
<div class="outline-text-2" id="text-5">


<p>
In addition to TGBA and BA, <code>ltl2tgba</code> can output <i>monitor</i> using the
<code>-M</code> option.  These are finite automata that accept all prefixes of a
formula.  The idea is that you can use these automata to monitor a
system as it is running, and report a violation as soon as no
compatible outgoing transition exist.
</p>
<p>
<code>ltl2tgba -M</code> may output non-deterministic monitors while <code>ltl2tgba -MD</code> (short for <code>--monitor --deterministic</code>) will output the minimal
deterministic monitor for the given formula.
</p>



<pre class="src src-sh">ltl2tgba -M <span class="org-string">'(Xa &amp; Fb) | Gc'</span>
</pre>




<pre class="example">digraph G {
  0 [label="", style=invis, height=0]
  0 -&gt; 1
  1 [label="1", peripheries=2]
  1 -&gt; 2 [label="1\\n"]
  1 -&gt; 3 [label="c\\n"]
  2 [label="2", peripheries=2]
  2 -&gt; 4 [label="a\\n"]
  3 [label="3", peripheries=2]
  3 -&gt; 3 [label="c\\n"]
  4 [label="4", peripheries=2]
  4 -&gt; 4 [label="1\\n"]
}
</pre>




<p>
<img src="monitor1.png"  alt="monitor1.png" />
</p>



<pre class="src src-sh">ltl2tgba -MD <span class="org-string">'(Xa &amp; Fb) | Gc'</span>
</pre>





<p>
<img src="monitor2.png"  alt="monitor2.png" />
</p>
<p>
Because they accept all finite executions that could be extended to
match the formula, monitor cannot be used to check for eventualities
such as <code>F(a)</code>.  Any finite execution can be extended to match <code>F(a)</code>.
</p>
</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2014-08-21T17:43+0200</p>
<p class="author">Author: Alexandre Duret-Lutz</p>
<p class="creator"><a href="http://orgmode.org">Org</a> version 7.9.3f with <a href="http://www.gnu.org/software/emacs/">Emacs</a> version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
