<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>spot: spot::loopless_modular_mixed_radix_gray_code Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="namespacespot.html">spot</a>::<a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html">loopless_modular_mixed_radix_gray_code</a></div>
<h1>spot::loopless_modular_mixed_radix_gray_code Class Reference<br>
<small>
[<a class="el" href="group__misc__tools.html">Miscellaneous helper algorithms</a>]</small>
</h1><!-- doxytag: class="spot::loopless_modular_mixed_radix_gray_code" -->Loopless modular mixed radix Gray code iteration.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="modgray_8hh-source.html">misc/modgray.hh</a>&gt;</code>
<p>
<a href="classspot_1_1loopless__modular__mixed__radix__gray__code-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#565b6c52e7b37b83bb829095e11c69c9">loopless_modular_mixed_radix_gray_code</a> (int n)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#53934ac1621f8bd1c55ef9ccbf9e4a11">~loopless_modular_mixed_radix_gray_code</a> ()</td></tr>

<tr><td colspan="2"><div class="groupHeader">iteration over an element in a tuple</div></td></tr>
<tr><td colspan="2"><div class="groupText">The class does not know how to modify the elements of the tuple (Knuth's a<sub>j</sub>s). These changes are therefore abstracted using the a_first(), a_next(), and a_last() abstract functions. These need to be implemented in subclasses as appropriate. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#f1aab585098500e6acb78675967ef530">a_first</a> (int j)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset a<sub>j</sub> to its initial value.  <a href="#f1aab585098500e6acb78675967ef530"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#d2299afa2a00ff9cc5f202b9854bdf4d">a_next</a> (int j)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Advance a<sub>j</sub> to its next value.  <a href="#d2299afa2a00ff9cc5f202b9854bdf4d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#8b6a865cb55084f8a71acb8082213477">a_last</a> (int j) const=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether a<sub>j</sub> is on its last value.  <a href="#8b6a865cb55084f8a71acb8082213477"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">iteration over all the tuples</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#9c918e8524bdeb3e3a80054becbd30df">first</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the iteration to the first tuple.  <a href="#9c918e8524bdeb3e3a80054becbd30df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#21b854c63955b060f35b6f25863fe98a">last</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether this the last tuple.  <a href="#21b854c63955b060f35b6f25863fe98a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#e1ac398218fc6a462c8ecccb31d6ec96">done</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether all tuple have been explored.  <a href="#e1ac398218fc6a462c8ecccb31d6ec96"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#5ef37d3a269687be631a65769ad209b9">next</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update one item of the tuple and return its position.  <a href="#5ef37d3a269687be631a65769ad209b9"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#2551f357ca1be741bc5300d06a4c3b63">n_</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#01d93ad137b3a2368270ec3779e32eee">done_</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#68e9eea9d2632d66f2ef1042f2d27b68">a_</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#6f86e8454e331df5b4aacf5eef3f41ef">f_</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a8342a062c7d6845b4473c0617bb4552">m_</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#3dfc0ecaeaf71747a972ce8339d63e50">s_</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#7c8c0adbecfdb2060d4696cf2bbf799e">non_one_radixes_</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Loopless modular mixed radix Gray code iteration. 
<p>
This class is based on the loopless modular mixed radix gray code algorithm described in exercise 77 of "The Art of Computer Programming", Pre-Fascicle 2A (Draft of section 7.2.1.1: generating all n-tuples) by Donald E. Knuth.<p>
The idea is to enumerate the set of all n-tuples (a<sub>0</sub>,a<sub>1</sub>,...,a<sub>n-1</sub>) where each a<sub>j</sub> range over a distinct set (this is the <em>mixed radix</em> part), so that only one a<sub>j</sub> changes between two successive tuples of the iteration (that is the <em>Gray code</em> part), and that this changes occurs always in the same direction, cycling over the set a<sub>j</sub> must cover (i.e., <em>modular</em>). The algorithm is <em>loopless</em> in that computing the next tuple done without any loop, i.e., in constant time.<p>
This class does not need to know the type of the a<sub>j</sub>, it will handle them indirectly through three methods: <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#f1aab585098500e6acb78675967ef530" title="Reset aj to its initial value.">a_first()</a>, <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#d2299afa2a00ff9cc5f202b9854bdf4d" title="Advance aj to its next value.">a_next()</a>, and <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#8b6a865cb55084f8a71acb8082213477" title="Whether aj is on its last value.">a_last()</a>. These methods need to be implemented in a subclass for the particular type of a<sub>j</sub> at hand.<p>
The class itself offers four functions to control the iteration over the set of all the (a<sub>0</sub>,a<sub>1</sub>,..., a<sub>n-1</sub>) tuples: <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#9c918e8524bdeb3e3a80054becbd30df" title="Reset the iteration to the first tuple.">first()</a>, <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#5ef37d3a269687be631a65769ad209b9" title="Update one item of the tuple and return its position.">next()</a>, <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#21b854c63955b060f35b6f25863fe98a" title="Whether this the last tuple.">last()</a>, and <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#e1ac398218fc6a462c8ecccb31d6ec96" title="Whether all tuple have been explored.">done()</a>. These functions are usually used as follows: <div class="fragment"><pre class="fragment">    <span class="keywordflow">for</span> (g.first(); !g.done(); g.next())
       use the tuple
</pre></div> How to use the tuple of course depends on the way it as been stored in the subclass.<p>
Finally, let's mention two differences between this algorithm and the one in Knuth's book. This version of the algorithm does not need to know the radixes (i.e., the size of set of each a<sub>j</sub>) beforehand: it will discover them on-the-fly when a_last(j) first return true. It will also work with a<sub>j</sub> that cannot be changed. (This is achieved by reindexing the elements through <code>non_one_radixes_</code>, to consider only the elements with a non-singleton range.) 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="565b6c52e7b37b83bb829095e11c69c9"></a><!-- doxytag: member="spot::loopless_modular_mixed_radix_gray_code::loopless_modular_mixed_radix_gray_code" ref="565b6c52e7b37b83bb829095e11c69c9" args="(int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spot::loopless_modular_mixed_radix_gray_code::loopless_modular_mixed_radix_gray_code           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>The size of the tuples to enumerate. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="53934ac1621f8bd1c55ef9ccbf9e4a11"></a><!-- doxytag: member="spot::loopless_modular_mixed_radix_gray_code::~loopless_modular_mixed_radix_gray_code" ref="53934ac1621f8bd1c55ef9ccbf9e4a11" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual spot::loopless_modular_mixed_radix_gray_code::~loopless_modular_mixed_radix_gray_code           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="f1aab585098500e6acb78675967ef530"></a><!-- doxytag: member="spot::loopless_modular_mixed_radix_gray_code::a_first" ref="f1aab585098500e6acb78675967ef530" args="(int j)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void spot::loopless_modular_mixed_radix_gray_code::a_first           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>j</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reset a<sub>j</sub> to its initial value. 
<p>

</div>
</div><p>
<a class="anchor" name="d2299afa2a00ff9cc5f202b9854bdf4d"></a><!-- doxytag: member="spot::loopless_modular_mixed_radix_gray_code::a_next" ref="d2299afa2a00ff9cc5f202b9854bdf4d" args="(int j)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void spot::loopless_modular_mixed_radix_gray_code::a_next           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>j</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Advance a<sub>j</sub> to its next value. 
<p>
This will never be called if a_last(j) is true. 
</div>
</div><p>
<a class="anchor" name="8b6a865cb55084f8a71acb8082213477"></a><!-- doxytag: member="spot::loopless_modular_mixed_radix_gray_code::a_last" ref="8b6a865cb55084f8a71acb8082213477" args="(int j) const=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool spot::loopless_modular_mixed_radix_gray_code::a_last           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>j</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Whether a<sub>j</sub> is on its last value. 
<p>

</div>
</div><p>
<a class="anchor" name="9c918e8524bdeb3e3a80054becbd30df"></a><!-- doxytag: member="spot::loopless_modular_mixed_radix_gray_code::first" ref="9c918e8524bdeb3e3a80054becbd30df" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spot::loopless_modular_mixed_radix_gray_code::first           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reset the iteration to the first tuple. 
<p>
This must be called before calling any of <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#5ef37d3a269687be631a65769ad209b9" title="Update one item of the tuple and return its position.">next()</a>, <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#21b854c63955b060f35b6f25863fe98a" title="Whether this the last tuple.">last()</a>, or <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#e1ac398218fc6a462c8ecccb31d6ec96" title="Whether all tuple have been explored.">done()</a>. 
</div>
</div><p>
<a class="anchor" name="21b854c63955b060f35b6f25863fe98a"></a><!-- doxytag: member="spot::loopless_modular_mixed_radix_gray_code::last" ref="21b854c63955b060f35b6f25863fe98a" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spot::loopless_modular_mixed_radix_gray_code::last           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Whether this the last tuple. 
<p>
At this point it is still OK to call <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#5ef37d3a269687be631a65769ad209b9" title="Update one item of the tuple and return its position.">next()</a>, and then <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#e1ac398218fc6a462c8ecccb31d6ec96" title="Whether all tuple have been explored.">done()</a> will become true. 
</div>
</div><p>
<a class="anchor" name="e1ac398218fc6a462c8ecccb31d6ec96"></a><!-- doxytag: member="spot::loopless_modular_mixed_radix_gray_code::done" ref="e1ac398218fc6a462c8ecccb31d6ec96" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spot::loopless_modular_mixed_radix_gray_code::done           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Whether all tuple have been explored. 
<p>

</div>
</div><p>
<a class="anchor" name="5ef37d3a269687be631a65769ad209b9"></a><!-- doxytag: member="spot::loopless_modular_mixed_radix_gray_code::next" ref="5ef37d3a269687be631a65769ad209b9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spot::loopless_modular_mixed_radix_gray_code::next           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Update one item of the tuple and return its position. 
<p>
<a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#5ef37d3a269687be631a65769ad209b9" title="Update one item of the tuple and return its position.">next()</a> should never be called if <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#e1ac398218fc6a462c8ecccb31d6ec96" title="Whether all tuple have been explored.">done()</a> is true. If it is called on the last tuple (i.e., <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#21b854c63955b060f35b6f25863fe98a" title="Whether this the last tuple.">last()</a> is true), it will return -1. Otherwise it will update one a<sub>j</sub> of the tuple through one the a<sub>j</sub> handling functions, and return j. 
</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="2551f357ca1be741bc5300d06a4c3b63"></a><!-- doxytag: member="spot::loopless_modular_mixed_radix_gray_code::n_" ref="2551f357ca1be741bc5300d06a4c3b63" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#2551f357ca1be741bc5300d06a4c3b63">spot::loopless_modular_mixed_radix_gray_code::n_</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="01d93ad137b3a2368270ec3779e32eee"></a><!-- doxytag: member="spot::loopless_modular_mixed_radix_gray_code::done_" ref="01d93ad137b3a2368270ec3779e32eee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#01d93ad137b3a2368270ec3779e32eee">spot::loopless_modular_mixed_radix_gray_code::done_</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="68e9eea9d2632d66f2ef1042f2d27b68"></a><!-- doxytag: member="spot::loopless_modular_mixed_radix_gray_code::a_" ref="68e9eea9d2632d66f2ef1042f2d27b68" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#68e9eea9d2632d66f2ef1042f2d27b68">spot::loopless_modular_mixed_radix_gray_code::a_</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="6f86e8454e331df5b4aacf5eef3f41ef"></a><!-- doxytag: member="spot::loopless_modular_mixed_radix_gray_code::f_" ref="6f86e8454e331df5b4aacf5eef3f41ef" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#6f86e8454e331df5b4aacf5eef3f41ef">spot::loopless_modular_mixed_radix_gray_code::f_</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a8342a062c7d6845b4473c0617bb4552"></a><!-- doxytag: member="spot::loopless_modular_mixed_radix_gray_code::m_" ref="a8342a062c7d6845b4473c0617bb4552" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a8342a062c7d6845b4473c0617bb4552">spot::loopless_modular_mixed_radix_gray_code::m_</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="3dfc0ecaeaf71747a972ce8339d63e50"></a><!-- doxytag: member="spot::loopless_modular_mixed_radix_gray_code::s_" ref="3dfc0ecaeaf71747a972ce8339d63e50" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#3dfc0ecaeaf71747a972ce8339d63e50">spot::loopless_modular_mixed_radix_gray_code::s_</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="7c8c0adbecfdb2060d4696cf2bbf799e"></a><!-- doxytag: member="spot::loopless_modular_mixed_radix_gray_code::non_one_radixes_" ref="7c8c0adbecfdb2060d4696cf2bbf799e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#7c8c0adbecfdb2060d4696cf2bbf799e">spot::loopless_modular_mixed_radix_gray_code::non_one_radixes_</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>misc/<a class="el" href="modgray_8hh-source.html">modgray.hh</a></ul>
<hr size="1">
Please <b>comment</b> this page and <b>report errors</b> about it on
<a href="http://spot.lip6.fr/wiki/RefDocComments">the RefDocComments page</a>.
<br><address style="align: right;"><small>
Generated on Tue Jul 17 15:14:16 2007 for spot by <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border=0></a> 1.5.2</small></address>
</body>
</html>
