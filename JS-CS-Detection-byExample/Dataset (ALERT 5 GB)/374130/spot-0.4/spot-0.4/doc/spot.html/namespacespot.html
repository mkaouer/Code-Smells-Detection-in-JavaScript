<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>spot: spot Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="namespaces.html"><span>Namespace List</span></a></li>
    <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
  </ul>
</div>
<h1>spot Namespace Reference</h1>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1evtgba.html">evtgba</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1evtgba__iterator.html">evtgba_iterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1evtgba__explicit.html">evtgba_explicit</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1state__evtgba__explicit.html">state_evtgba_explicit</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">States used by spot::tgba_evtgba_explicit.  <a href="classspot_1_1state__evtgba__explicit.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1evtgba__product.html">evtgba_product</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1symbol.html">symbol</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1rsymbol.html">rsymbol</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1evtgba__reachable__iterator.html">evtgba_reachable_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate over all reachable states of a <a class="el" href="classspot_1_1evtgba.html">spot::evtgba</a>.  <a href="classspot_1_1evtgba__reachable__iterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1evtgba__reachable__iterator__depth__first.html">evtgba_reachable_iterator_depth_first</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An implementation of <a class="el" href="classspot_1_1evtgba__reachable__iterator.html" title="Iterate over all reachable states of a spot::evtgba.">spot::evtgba_reachable_iterator</a> that browses states depth first.  <a href="classspot_1_1evtgba__reachable__iterator__depth__first.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1evtgba__reachable__iterator__breadth__first.html">evtgba_reachable_iterator_breadth_first</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An implementation of <a class="el" href="classspot_1_1evtgba__reachable__iterator.html" title="Iterate over all reachable states of a spot::evtgba.">spot::evtgba_reachable_iterator</a> that browses states breadth first.  <a href="classspot_1_1evtgba__reachable__iterator__breadth__first.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__allocator.html">bdd_allocator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Manage ranges of variables.  <a href="classspot_1_1bdd__allocator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1bdd__less__than.html">bdd_less_than</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison functor for BDDs.  <a href="structspot_1_1bdd__less__than.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1free__list.html">free_list</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Manage list of free integers.  <a href="classspot_1_1free__list.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1ptr__hash.html">ptr_hash</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A hash function for pointers.  <a href="structspot_1_1ptr__hash.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1string__hash.html">string_hash</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A hash function for strings.  <a href="structspot_1_1string__hash.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1char__ptr__less__than.html">char_ptr_less_than</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Strict Weak Ordering for <code>char*</code>.  <a href="structspot_1_1char__ptr__less__than.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1minato__isop.html">minato_isop</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate an irredundant sum-of-products (ISOP) form of a BDD function.  <a href="classspot_1_1minato__isop.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html">loopless_modular_mixed_radix_gray_code</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loopless modular mixed radix Gray code iteration.  <a href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1option__map.html">option_map</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Manage a map of options.  <a href="classspot_1_1option__map.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1barand.html">barand</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute pseudo-random integer value between 0 and <em>n</em> included, following a binomial distribution for probability <em>p</em>.  <a href="classspot_1_1barand.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1time__info.html">time_info</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A structure to record elapsed time in clock ticks.  <a href="structspot_1_1time__info.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1timer.html">timer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A timekeeper that accumulate interval of time.  <a href="classspot_1_1timer.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1timer__map.html">timer_map</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A map of <a class="el" href="classspot_1_1timer.html" title="A timekeeper that accumulate interval of time.">timer</a>, where each <a class="el" href="classspot_1_1timer.html" title="A timekeeper that accumulate interval of time.">timer</a> has a name.  <a href="classspot_1_1timer__map.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1state.html">state</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract class for states.  <a href="classspot_1_1state.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1state__ptr__less__than.html">state_ptr_less_than</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Strict Weak Ordering for <code>state*</code>.  <a href="structspot_1_1state__ptr__less__than.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1state__ptr__equal.html">state_ptr_equal</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An Equivalence Relation for <code>state*</code>.  <a href="structspot_1_1state__ptr__equal.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1state__ptr__hash.html">state_ptr_hash</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hash Function for <code>state*</code>.  <a href="structspot_1_1state__ptr__hash.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1state__bdd.html">state_bdd</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__succ__iterator.html">tgba_succ_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate over the successors of a <a class="el" href="classspot_1_1state.html" title="Abstract class for states.">state</a>.  <a href="classspot_1_1tgba__succ__iterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__succ__iterator__concrete.html">tgba_succ_iterator_concrete</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba.html">tgba</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A Transition-based Generalized Büchi Automaton.  <a href="classspot_1_1tgba.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__bdd__concrete.html">tgba_bdd_concrete</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A concrete <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.">spot::tgba</a> implemented using BDDs.  <a href="classspot_1_1tgba__bdd__concrete.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__bdd__concrete__factory.html">tgba_bdd_concrete_factory</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper class to build a <a class="el" href="classspot_1_1tgba__bdd__concrete.html" title="A concrete spot::tgba implemented using BDDs.">spot::tgba_bdd_concrete</a> object.  <a href="classspot_1_1tgba__bdd__concrete__factory.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1tgba__bdd__core__data.html">tgba_bdd_core_data</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Core data for a TGBA encoded using BDDs.  <a href="structspot_1_1tgba__bdd__core__data.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__bdd__factory.html">tgba_bdd_factory</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract class for <a class="el" href="classspot_1_1tgba__bdd__concrete.html" title="A concrete spot::tgba implemented using BDDs.">spot::tgba_bdd_concrete</a> factories.  <a href="classspot_1_1tgba__bdd__factory.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__explicit.html">tgba_explicit</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1state__explicit.html">state_explicit</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__explicit__succ__iterator.html">tgba_explicit_succ_iterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1state__product.html">state_product</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <a class="el" href="classspot_1_1state.html" title="Abstract class for states.">state</a> for <a class="el" href="classspot_1_1tgba__product.html" title="A lazy product. (States are computed on the fly.).">spot::tgba_product</a>.  <a href="classspot_1_1state__product.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__succ__iterator__product.html">tgba_succ_iterator_product</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate over the successors of a product computed on the fly.  <a href="classspot_1_1tgba__succ__iterator__product.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__product.html">tgba_product</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A lazy product. (States are computed on the fly.).  <a href="classspot_1_1tgba__product.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1direct__simulation__relation.html">direct_simulation_relation</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1delayed__simulation__relation.html">delayed_simulation_relation</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__reduc.html">tgba_reduc</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__tba__proxy.html">tgba_tba_proxy</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Degeneralize a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.">spot::tgba</a> on the fly, producing a TBA.  <a href="classspot_1_1tgba__tba__proxy.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__sba__proxy.html">tgba_sba_proxy</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Degeneralize a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.">spot::tgba</a> on the fly, producing an SBA.  <a href="classspot_1_1tgba__sba__proxy.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bfs__steps.html">bfs_steps</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a BFS in a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.">spot::tgba</a> to compute a <a class="el" href="structspot_1_1tgba__run.html#992869805fc5a8c3146e77309be61312">tgba_run::steps</a>.  <a href="classspot_1_1bfs__steps.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1dotty__decorator.html">dotty_decorator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Choose <a class="el" href="classspot_1_1state.html" title="Abstract class for states.">state</a> and link styles for <a class="el" href="namespacespot.html#b3ff98345b771b22e0a9b67063676e84" title="Print reachable states in dot format.">spot::dotty_reachable</a>.  <a href="classspot_1_1dotty__decorator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1emptiness__check__result.html">emptiness_check_result</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The result of an emptiness check.  <a href="classspot_1_1emptiness__check__result.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Common interface to emptiness check algorithms.  <a href="classspot_1_1emptiness__check.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1emptiness__check__instantiator.html">emptiness_check_instantiator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1tgba__run.html">tgba_run</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An accepted run, for a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.">tgba</a>.  <a href="structspot_1_1tgba__run.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1unsigned__statistics.html">unsigned_statistics</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1unsigned__statistics__copy.html">unsigned_statistics_copy</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">comparable statistics  <a href="classspot_1_1unsigned__statistics__copy.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ec__statistics.html">ec_statistics</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Emptiness-check statistics.  <a href="classspot_1_1ec__statistics.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ars__statistics.html">ars_statistics</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accepting Run Search statistics.  <a href="classspot_1_1ars__statistics.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1acss__statistics.html">acss_statistics</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accepting Cycle Search Space statistics.  <a href="classspot_1_1acss__statistics.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1couvreur99__check__result.html">couvreur99_check_result</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute a counter example from a <a class="el" href="classspot_1_1couvreur99__check__status.html" title="The status of the emptiness-check on success.">spot::couvreur99_check_status</a>.  <a href="classspot_1_1couvreur99__check__result.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1explicit__connected__component.html">explicit_connected_component</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An SCC storing all its states explicitly.  <a href="classspot_1_1explicit__connected__component.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1connected__component__hash__set.html">connected_component_hash_set</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1explicit__connected__component__factory.html">explicit_connected_component_factory</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract factory for <a class="el" href="classspot_1_1explicit__connected__component.html" title="An SCC storing all its states explicitly.">explicit_connected_component</a>.  <a href="classspot_1_1explicit__connected__component__factory.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1connected__component__hash__set__factory.html">connected_component_hash_set_factory</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory for <a class="el" href="classspot_1_1connected__component__hash__set.html">connected_component_hash_set</a>.  <a href="classspot_1_1connected__component__hash__set__factory.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1couvreur99__check.html">couvreur99_check</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An implementation of the Couvreur99 emptiness-check algorithm.  <a href="classspot_1_1couvreur99__check.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1couvreur99__check__shy.html">couvreur99_check_shy</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A version of <a class="el" href="classspot_1_1couvreur99__check.html" title="An implementation of the Couvreur99 emptiness-check algorithm.">spot::couvreur99_check</a> that tries to visit known states first.  <a href="classspot_1_1couvreur99__check__shy.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1numbered__state__heap__const__iterator.html">numbered_state_heap_const_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator on <a class="el" href="classspot_1_1numbered__state__heap.html" title="Keep track of a large quantity of indexed states.">numbered_state_heap</a> objects.  <a href="classspot_1_1numbered__state__heap__const__iterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1numbered__state__heap.html">numbered_state_heap</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Keep track of a large quantity of indexed states.  <a href="classspot_1_1numbered__state__heap.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1numbered__state__heap__factory.html">numbered_state_heap_factory</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract factory for <a class="el" href="classspot_1_1numbered__state__heap.html" title="Keep track of a large quantity of indexed states.">numbered_state_heap</a>.  <a href="classspot_1_1numbered__state__heap__factory.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1numbered__state__heap__hash__map.html">numbered_state_heap_hash_map</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A straightforward implementation of <a class="el" href="classspot_1_1numbered__state__heap.html" title="Keep track of a large quantity of indexed states.">numbered_state_heap</a> with a hash map.  <a href="classspot_1_1numbered__state__heap__hash__map.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1numbered__state__heap__hash__map__factory.html">numbered_state_heap_hash_map_factory</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory for <a class="el" href="classspot_1_1numbered__state__heap__hash__map.html" title="A straightforward implementation of numbered_state_heap with a hash map.">numbered_state_heap_hash_map</a>.  <a href="classspot_1_1numbered__state__heap__hash__map__factory.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1scc__stack.html">scc_stack</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1couvreur99__check__status.html">couvreur99_check_status</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The status of the emptiness-check on success.  <a href="classspot_1_1couvreur99__check__status.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__reachable__iterator.html">tgba_reachable_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate over all reachable states of a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.">spot::tgba</a>.  <a href="classspot_1_1tgba__reachable__iterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__reachable__iterator__depth__first.html">tgba_reachable_iterator_depth_first</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An implementation of <a class="el" href="classspot_1_1tgba__reachable__iterator.html" title="Iterate over all reachable states of a spot::tgba.">spot::tgba_reachable_iterator</a> that browses states depth first.  <a href="classspot_1_1tgba__reachable__iterator__depth__first.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__reachable__iterator__breadth__first.html">tgba_reachable_iterator_breadth_first</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An implementation of <a class="el" href="classspot_1_1tgba__reachable__iterator.html" title="Iterate over all reachable states of a spot::tgba.">spot::tgba_reachable_iterator</a> that browses states breadth first.  <a href="classspot_1_1tgba__reachable__iterator__breadth__first.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1parity__game__graph.html">parity_game_graph</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parity game graph which compute a simulation relation.  <a href="classspot_1_1parity__game__graph.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1spoiler__node.html">spoiler_node</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Spoiler node of parity game graph.  <a href="classspot_1_1spoiler__node.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1duplicator__node.html">duplicator_node</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Duplicator node of parity game graph.  <a href="classspot_1_1duplicator__node.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1parity__game__graph__direct.html">parity_game_graph_direct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parity game graph which compute the direct simulation relation.  <a href="classspot_1_1parity__game__graph__direct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1spoiler__node__delayed.html">spoiler_node_delayed</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Spoiler node of parity game graph for delayed simulation.  <a href="classspot_1_1spoiler__node__delayed.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1duplicator__node__delayed.html">duplicator_node_delayed</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Duplicator node of parity game graph for delayed simulation.  <a href="classspot_1_1duplicator__node__delayed.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1parity__game__graph__delayed.html">parity_game_graph_delayed</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__run__dotty__decorator.html">tgba_run_dotty_decorator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Highlight a <a class="el" href="structspot_1_1tgba__run.html" title="An accepted run, for a tgba.">spot::tgba_run</a> on a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.">spot::tgba</a>.  <a href="classspot_1_1tgba__run__dotty__decorator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1tgba__statistics.html">tgba_statistics</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1weight.html">weight</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Manage for a given automaton a vector of counter indexed by its acceptance condition.  <a href="classspot_1_1weight.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1gspn__exception.html">gspn_exception</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An exception used to forward GSPN errors.  <a href="classspot_1_1gspn__exception.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1gspn__interface.html">gspn_interface</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1gspn__ssp__interface.html">gspn_ssp_interface</a></td></tr>

<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html">ltl</a></td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::set&lt; const <a class="el" href="classspot_1_1symbol.html">symbol</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#b1fe964166144356a185c98ce0bcbde6">symbol_set</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::set&lt; <a class="el" href="classspot_1_1rsymbol.html">rsymbol</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#5f139f442de158fbe3bf9fab3ddee7f3">rsymbol_set</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::pair&lt; evtgbayy::location,<br>
 std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#d049f28e03c2ebe740e5597034fd5c93">evtgba_parse_error</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A parse diagnostic with its location.  <a href="#d049f28e03c2ebe740e5597034fd5c93"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::list&lt; <a class="el" href="namespacespot.html#d049f28e03c2ebe740e5597034fd5c93">evtgba_parse_error</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#90dc0e2318bb80c45893922f42ec44fe">evtgba_parse_error_list</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A list of parser diagnostics, as filled by parse.  <a href="#90dc0e2318bb80c45893922f42ec44fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::pair&lt; const <a class="el" href="classspot_1_1state.html">spot::state</a> *,<br>
 const <a class="el" href="classspot_1_1state.html">spot::state</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#335079e354907be71c014b01c2fb1573">state_couple</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::vector&lt; <a class="el" href="namespacespot.html#335079e354907be71c014b01c2fb1573">state_couple</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#9ec17bbfe207de0e9c4e699ee3f02572">simulation_relation</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::vector&lt; <a class="el" href="classspot_1_1spoiler__node.html">spoiler_node</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__reduction.html#ga807b9e3dabba60063c3dff70244c79a">sn_v</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::vector&lt; <a class="el" href="classspot_1_1duplicator__node.html">duplicator_node</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__reduction.html#g57d3005aa0c7d42803556c39d62d2995">dn_v</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::vector&lt; const <br>
<a class="el" href="classspot_1_1state.html">state</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__reduction.html#g1aecc57153bbe4d48c62d7dcedde5afb">s_v</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::pair&lt; tgbayy::location,<br>
 std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#gdcc2cd9b328a5c3f63918c577f86f18c">tgba_parse_error</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A parse diagnostic with its location.  <a href="group__tgba__io.html#gdcc2cd9b328a5c3f63918c577f86f18c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::list&lt; <a class="el" href="group__tgba__io.html#gdcc2cd9b328a5c3f63918c577f86f18c">tgba_parse_error</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#g76b22bb081d5c36378098caa5bf58081">tgba_parse_error_list</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A list of parser diagnostics, as filled by parse.  <a href="group__tgba__io.html#g76b22bb081d5c36378098caa5bf58081"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__reduction.html#g5bd08ab74b3ab10a27beceaa04d9217a">reduce_tgba_options</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__tgba__reduction.html#gg5bd08ab74b3ab10a27beceaa04d9217a28ab8e63b3f476424eec1d49fb19b1e6">Reduce_None</a> =  0, 
<a class="el" href="group__tgba__reduction.html#gg5bd08ab74b3ab10a27beceaa04d9217a6ef94353974a1119b8c3265eb0bcbe42">Reduce_quotient_Dir_Sim</a> =  1, 
<a class="el" href="group__tgba__reduction.html#gg5bd08ab74b3ab10a27beceaa04d9217a7b2d15a717f241527e25e1266370033e">Reduce_transition_Dir_Sim</a> =  2, 
<a class="el" href="group__tgba__reduction.html#gg5bd08ab74b3ab10a27beceaa04d9217a040be3fac90f0ddb426644a52418d7a3">Reduce_quotient_Del_Sim</a> =  4, 
<br>
&nbsp;&nbsp;<a class="el" href="group__tgba__reduction.html#gg5bd08ab74b3ab10a27beceaa04d9217a21c74a793193bfe95e63b43ef1b59350">Reduce_transition_Del_Sim</a> =  8, 
<a class="el" href="group__tgba__reduction.html#gg5bd08ab74b3ab10a27beceaa04d9217a685daa8530de270e1588cdc2c178a2ab">Reduce_Scc</a> =  16, 
<a class="el" href="group__tgba__reduction.html#gg5bd08ab74b3ab10a27beceaa04d9217a81a405e18e9bbd601c4183e1c7ff49e1">Reduce_All</a> =  -1U
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Options for reduce.  <a href="group__tgba__reduction.html#g5bd08ab74b3ab10a27beceaa04d9217a">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#b3ff98345b771b22e0a9b67063676e84">dotty_reachable</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1evtgba.html">evtgba</a> *g)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print reachable states in dot format.  <a href="#b3ff98345b771b22e0a9b67063676e84"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#ade1f7e5b6c685b5393d8a6d3ab7e09d">evtgba_save_reachable</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1evtgba.html">evtgba</a> *g)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save reachable states in text format.  <a href="#ade1f7e5b6c685b5393d8a6d3ab7e09d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classspot_1_1evtgba__explicit.html">evtgba_explicit</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#3b22a05fb3e16d693b2d80425dfa4500">tgba_to_evtgba</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.">tgba</a> into an <a class="el" href="classspot_1_1evtgba.html">evtgba</a>.  <a href="#3b22a05fb3e16d693b2d80425dfa4500"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classspot_1_1evtgba__explicit.html">evtgba_explicit</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#6805befaee0df3f7cb4427d30782f230">evtgba_parse</a> (const std::string &amp;filename, <a class="el" href="namespacespot.html#90dc0e2318bb80c45893922f42ec44fe">evtgba_parse_error_list</a> &amp;error_list, bool debug=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build a <a class="el" href="classspot_1_1evtgba__explicit.html">spot::evtgba_explicit</a> from a text file.  <a href="#6805befaee0df3f7cb4427d30782f230"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#805ae4b750b93c1d2e19d81faa609065">format_evtgba_parse_errors</a> (std::ostream &amp;os, const std::string &amp;filename, <a class="el" href="namespacespot.html#90dc0e2318bb80c45893922f42ec44fe">evtgba_parse_error_list</a> &amp;error_list)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Format diagnostics produced by <a class="el" href="namespacespot.html#6805befaee0df3f7cb4427d30782f230" title="Build a spot::evtgba_explicit from a text file.">spot::evtgba_parse</a>.  <a href="#805ae4b750b93c1d2e19d81faa609065"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#gae6fadac6a2f91d7b8e27b3eb6ad647e">is_bare_word</a> (const char *str)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#g4731f21b7b43332b5c7b5bc63c6d67e6">quote_unless_bare_word</a> (const std::string &amp;str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Double-quote words that are not bare.  <a href="group__misc__tools.html#g4731f21b7b43332b5c7b5bc63c6d67e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#g84a8b196e2ec651f0fd039c70c7ff6cb">escape_str</a> (std::ostream &amp;os, const std::string &amp;str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Escape " and \ characters in <em>str</em>.  <a href="group__misc__tools.html#g84a8b196e2ec651f0fd039c70c7ff6cb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#gd4b0b4fae7b93db7d704a5fef6e021c6">escape_str</a> (const std::string &amp;str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Escape " and \ characters in <em>str</em>.  <a href="group__misc__tools.html#gd4b0b4fae7b93db7d704a5fef6e021c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hash__funcs.html#g9422ff0c16df957910dd4a0275d9f726">wang32_hash</a> (size_t key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thomas Wang's 32 bit hash function.  <a href="group__hash__funcs.html#g9422ff0c16df957910dd4a0275d9f726"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hash__funcs.html#gea94dbea4a286b0bde253baf07e7a56e">knuth32_hash</a> (size_t key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Knuth's Multiplicative hash function.  <a href="group__hash__funcs.html#gea94dbea4a286b0bde253baf07e7a56e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#1a8d0610b61c0a30aad16791b0b73d15">memusage</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Total number of pages in use by the program.  <a href="#1a8d0610b61c0a30aad16791b0b73d15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__random.html#g539812ab355a561fee1ecbfe60b276e4">srand</a> (unsigned int seed)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the seed of the pseudo-random number generator.  <a href="group__random.html#g539812ab355a561fee1ecbfe60b276e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__random.html#g86ce713fe60de9af440a7331de74aa1a">rrand</a> (int min, int max)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute a pseudo-random integer value between <em>min</em> and <em>max</em> included.  <a href="group__random.html#g86ce713fe60de9af440a7331de74aa1a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__random.html#gfe8da996f40caa7d188f6b408ae62904">mrand</a> (int max)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute a pseudo-random integer value between 0 and <em>max-1</em> included.  <a href="group__random.html#gfe8da996f40caa7d188f6b408ae62904"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__random.html#g42801cd81368df5c1c61aa1626e299ff">drand</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute a pseudo-random double value between 0.0 and 1.0 (1.0 excluded).  <a href="group__random.html#g42801cd81368df5c1c61aa1626e299ff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__random.html#g978e1c6fb8f447274a05ddd3f87ce58b">nrand</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute a pseudo-random double value following a standard normal distribution. (Odeh &amp; Evans).  <a href="group__random.html#g978e1c6fb8f447274a05ddd3f87ce58b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__random.html#g0130217a19e5156f796ab774dca4b08c">bmrand</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute a pseudo-random double value following a standard normal distribution. (Box-Muller).  <a href="group__random.html#g0130217a19e5156f796ab774dca4b08c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__random.html#g816b558a7c64daca3a2a018704377dac">prand</a> (double p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a pseudo-random positive integer value following a Poisson distribution with parameter <em>p</em>.  <a href="group__random.html#g816b558a7c64daca3a2a018704377dac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#g85c83eb1d18703782d129dbe4a518fca">version</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return Spot's version.  <a href="group__misc__tools.html#g85c83eb1d18703782d129dbe4a518fca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#59e91579989d390a3979a5badf302255">bdd_print_sat</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print a BDD as a list of literals.  <a href="#59e91579989d390a3979a5badf302255"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#ba342c9d66d191b7ed930e2b02043e7f">bdd_format_sat</a> (const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Format a BDD as a list of literals.  <a href="#ba342c9d66d191b7ed930e2b02043e7f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#3b659fe265e2014282d3b25db928794b">bdd_print_acc</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print a BDD as a list of acceptance conditions.  <a href="#3b659fe265e2014282d3b25db928794b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a75a117405f2292f6d80abc2ae930946">bdd_print_accset</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print a BDD as a set of acceptance conditions.  <a href="#a75a117405f2292f6d80abc2ae930946"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a04818924fa41d2230160b499d95173d">bdd_format_accset</a> (const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Format a BDD as a set of acceptance conditions.  <a href="#a04818924fa41d2230160b499d95173d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#ca49e9ec778c8a6b38455a68db8d6ece">bdd_print_set</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print a BDD as a set.  <a href="#ca49e9ec778c8a6b38455a68db8d6ece"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#73d8fa997efd95d08e0d1b9dfa7b7073">bdd_format_set</a> (const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Format a BDD as a set.  <a href="#73d8fa997efd95d08e0d1b9dfa7b7073"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#174c8f965f37e9a26b33c9f76183720f">bdd_print_formula</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print a BDD as a formula.  <a href="#174c8f965f37e9a26b33c9f76183720f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#b9eea881fdb5d8e629db7102fde452ea">bdd_format_formula</a> (const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Format a BDD as a formula.  <a href="#b9eea881fdb5d8e629db7102fde452ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#3ec151057e33aadb60d2b47ffaa64c24">bdd_print_dot</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print a BDD as a diagram in dotty format.  <a href="#3ec151057e33aadb60d2b47ffaa64c24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#c8434843d2dcb0d99a027e398b01bafe">bdd_print_table</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print a BDD as a table.  <a href="#c8434843d2dcb0d99a027e398b01bafe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bdd&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#b6641d7d9896e016376b1c618da92469">formula_to_bdd</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f, <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *d, void *for_me)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#ebfbc06108c79ba74f84a838af4f1772">bdd_to_formula</a> (bdd f, const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *d)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classspot_1_1tgba__bdd__concrete.html">tgba_bdd_concrete</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__algorithms.html#g9a8f2973e4358cf18aa162634b61ab51">product</a> (const <a class="el" href="classspot_1_1tgba__bdd__concrete.html">tgba_bdd_concrete</a> *left, const <a class="el" href="classspot_1_1tgba__bdd__concrete.html">tgba_bdd_concrete</a> *right)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplies two <a class="el" href="classspot_1_1tgba__bdd__concrete.html" title="A concrete spot::tgba implemented using BDDs.">spot::tgba_bdd_concrete</a> automata.  <a href="group__tgba__algorithms.html#g9a8f2973e4358cf18aa162634b61ab51"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#g07d47453e3bab574bf4b09589a18dcf9">dotty_reachable</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1tgba.html">tgba</a> *g, <a class="el" href="classspot_1_1dotty__decorator.html">dotty_decorator</a> *dd=dotty_decorator::instance())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print reachable states in dot format.  <a href="group__tgba__io.html#g07d47453e3bab574bf4b09589a18dcf9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classspot_1_1tgba__explicit.html">tgba_explicit</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#gee64e1fa586af205fa41aaf2c0dbb4bc">tgba_dupexp_bfs</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *aut)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build an explicit automata from all states of <em>aut</em>, numbering states in bread first order as they are processed.  <a href="group__tgba__misc.html#gee64e1fa586af205fa41aaf2c0dbb4bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classspot_1_1tgba__explicit.html">tgba_explicit</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#g2d17e428249fb0e43ce9ae1ee0e4ddf8">tgba_dupexp_dfs</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *aut)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build an explicit automata from all states of <em>aut</em>, numbering states in depth first order as they are processed.  <a href="group__tgba__misc.html#g2d17e428249fb0e43ce9ae1ee0e4ddf8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__run.html#g3aa3b6dd9854c94b6aaabafd4a612de2">print_tgba_run</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, const <a class="el" href="structspot_1_1tgba__run.html">tgba_run</a> *run)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Display a <a class="el" href="structspot_1_1tgba__run.html" title="An accepted run, for a tgba.">tgba_run</a>.  <a href="group__tgba__run.html#g3aa3b6dd9854c94b6aaabafd4a612de2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classspot_1_1tgba.html">tgba</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__run.html#g60bd6401d35428aa22bda3388765099b">tgba_run_to_tgba</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, const <a class="el" href="structspot_1_1tgba__run.html">tgba_run</a> *run)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an explicit_tgba corresponding to <em>run</em> (i.e. comparable states are merged).  <a href="group__tgba__run.html#g60bd6401d35428aa22bda3388765099b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#g9bb3670ecff03df6d792c8a315c3e75c">couvreur99</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, <a class="el" href="classspot_1_1option__map.html">option_map</a> options=<a class="el" href="classspot_1_1option__map.html">option_map</a>(), const <a class="el" href="classspot_1_1numbered__state__heap__factory.html">numbered_state_heap_factory</a> *nshf=numbered_state_heap_hash_map_factory::instance())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether the language of an automate is empty.  <a href="group__emptiness__check__algorithms.html#g9bb3670ecff03df6d792c8a315c3e75c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ge45e3a4c2ba4b8c0609a2afca67eabe8">explicit_gv04_check</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, <a class="el" href="classspot_1_1option__map.html">option_map</a> o=<a class="el" href="classspot_1_1option__map.html">option_map</a>())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Emptiness check based on Geldenhuys and Valmari's TACAS'04 paper.  <a href="group__emptiness__check__algorithms.html#ge45e3a4c2ba4b8c0609a2afca67eabe8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#g955eb1141519477fda8d09fae2a9cb4a">lbtt_reachable</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1tgba.html">tgba</a> *g)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print reachable states in LBTT format.  <a href="group__tgba__io.html#g955eb1141519477fda8d09fae2a9cb4a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classspot_1_1tgba__explicit.html">tgba_explicit</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__ltl.html#g749653f0f15ebc9d56e6978314f50421">ltl_to_tgba_fm</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f, <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bool exprop=false, bool symb_merge=true, bool branching_postponement=false, bool fair_loop_approx=false, const <a class="el" href="group__ltl__misc.html#g305ebfb1906e717fc70cfba0fa14b4b9">ltl::atomic_prop_set</a> *unobs=0, int reduce_ltl=ltl::Reduce_None, bool containment_checks=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build a <a class="el" href="classspot_1_1tgba__explicit.html">spot::tgba_explicit</a>* from an LTL formula.  <a href="group__tgba__ltl.html#g749653f0f15ebc9d56e6978314f50421"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classspot_1_1tgba__bdd__concrete.html">tgba_bdd_concrete</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__ltl.html#g911db84b8e05185bb50b5eda55efe6b6">ltl_to_tgba_lacim</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f, <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build a <a class="el" href="classspot_1_1tgba__bdd__concrete.html" title="A concrete spot::tgba implemented using BDDs.">spot::tgba_bdd_concrete</a> from an LTL formula.  <a href="group__tgba__ltl.html#g911db84b8e05185bb50b5eda55efe6b6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#g392d772bf851002cdda0ca34615aa54b">explicit_magic_search</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, <a class="el" href="classspot_1_1option__map.html">option_map</a> o=<a class="el" href="classspot_1_1option__map.html">option_map</a>())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.">spot::tgba</a> automaton <em>a</em>.  <a href="group__emptiness__check__algorithms.html#g392d772bf851002cdda0ca34615aa54b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#gdae7938a96420813bcdabb1b31295294">bit_state_hashing_magic_search</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, size_t size, <a class="el" href="classspot_1_1option__map.html">option_map</a> o=<a class="el" href="classspot_1_1option__map.html">option_map</a>())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.">spot::tgba</a> automaton <em>a</em>.  <a href="group__emptiness__check__algorithms.html#gdae7938a96420813bcdabb1b31295294"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#g054c1948b6c5076350e44a85ad580403">magic_search</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, <a class="el" href="classspot_1_1option__map.html">option_map</a> o=<a class="el" href="classspot_1_1option__map.html">option_map</a>())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper for the two magic_search implementations.  <a href="group__emptiness__check__algorithms.html#g054c1948b6c5076350e44a85ad580403"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#gc20ccafb63e86ac18a638cbfda5c0eab">never_claim_reachable</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1tgba__sba__proxy.html">tgba_sba_proxy</a> *g, const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print reachable states in Spin never claim format.  <a href="group__tgba__io.html#gc20ccafb63e86ac18a638cbfda5c0eab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classspot_1_1tgba__explicit.html">tgba_explicit</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#g261dcd2ce23378bebecc939b72889e08">tgba_powerset</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *aut)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build a deterministic automaton, ignoring acceptance conditions.  <a href="group__tgba__misc.html#g261dcd2ce23378bebecc939b72889e08"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structspot_1_1tgba__run.html">tgba_run</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__run.html#g1e0b8aeb36e622ac26a6c540ac17fddc">project_tgba_run</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a_run, const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a_proj, const <a class="el" href="structspot_1_1tgba__run.html">tgba_run</a> *run)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Project a <a class="el" href="structspot_1_1tgba__run.html" title="An accepted run, for a tgba.">tgba_run</a> on a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.">tgba</a>.  <a href="group__tgba__run.html#g1e0b8aeb36e622ac26a6c540ac17fddc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classspot_1_1tgba.html">tgba</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#gdcf8ba83bd92b5cbf8f5b8f1083a793b">random_graph</a> (int n, float d, const <a class="el" href="group__ltl__misc.html#g305ebfb1906e717fc70cfba0fa14b4b9">ltl::atomic_prop_set</a> *ap, <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, int n_acc=0, float a=0.1, float t=0.5, <a class="el" href="classspot_1_1ltl_1_1environment.html">ltl::environment</a> *env=&amp;ltl::default_environment::instance())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.">tgba</a> randomly.  <a href="group__tgba__misc.html#gdcf8ba83bd92b5cbf8f5b8f1083a793b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structspot_1_1tgba__run.html">tgba_run</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__run.html#gbc4ad10830cd80a3237415d28adeee1b">reduce_run</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, const <a class="el" href="structspot_1_1tgba__run.html">tgba_run</a> *org)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reduce an accepting run.  <a href="group__tgba__run.html#gbc4ad10830cd80a3237415d28adeee1b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classspot_1_1tgba.html">tgba</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__reduction.html#g3e05060db57bf0e735f08d057db3fae2">reduc_tgba_sim</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, int opt=Reduce_All)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove some node of the automata using a simulation relation.  <a href="group__tgba__reduction.html#g3e05060db57bf0e735f08d057db3fae2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classspot_1_1direct__simulation__relation.html">direct_simulation_relation</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__reduction.html#g031fe9f92e0d1dbe9af8ca695b2f1161">get_direct_relation_simulation</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, std::ostream &amp;os, int opt=-1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute a direct simulation relation on <a class="el" href="classspot_1_1state.html" title="Abstract class for states.">state</a> of <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.">tgba</a> <em>f</em>.  <a href="group__tgba__reduction.html#g031fe9f92e0d1dbe9af8ca695b2f1161"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classspot_1_1delayed__simulation__relation.html">delayed_simulation_relation</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__reduction.html#gb80a323c2a5aa8bbf1541afa8a3036a9">get_delayed_relation_simulation</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, std::ostream &amp;os, int opt=-1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__reduction.html#gb2aceabca87cc15e9aa79abbcc23358e">free_relation_simulation</a> (<a class="el" href="classspot_1_1direct__simulation__relation.html">direct_simulation_relation</a> *rel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">To free a simulation relation.  <a href="group__tgba__reduction.html#gb2aceabca87cc15e9aa79abbcc23358e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__reduction.html#g9ef87dd9bf31b79cfaa19431a019b98a">free_relation_simulation</a> (<a class="el" href="classspot_1_1delayed__simulation__relation.html">delayed_simulation_relation</a> *rel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">To free a simulation relation.  <a href="group__tgba__reduction.html#g9ef87dd9bf31b79cfaa19431a019b98a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__run.html#ge2bf747c24d2fb1a06f1a033f67fe6dc">replay_tgba_run</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, const <a class="el" href="structspot_1_1tgba__run.html">tgba_run</a> *run, bool debug=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replay a <a class="el" href="structspot_1_1tgba__run.html" title="An accepted run, for a tgba.">tgba_run</a> on a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.">tgba</a>.  <a href="group__tgba__run.html#ge2bf747c24d2fb1a06f1a033f67fe6dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#g5c7f56a5941eb2380676c4ff6706e1c2">tgba_save_reachable</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1tgba.html">tgba</a> *g)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save reachable states in text format.  <a href="group__tgba__io.html#g5c7f56a5941eb2380676c4ff6706e1c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#g8c176368673a0c009dd3e934d57fb492">explicit_se05_search</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, <a class="el" href="classspot_1_1option__map.html">option_map</a> o=<a class="el" href="classspot_1_1option__map.html">option_map</a>())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an emptiness check on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.">spot::tgba</a> automaton <em>a</em>.  <a href="group__emptiness__check__algorithms.html#g8c176368673a0c009dd3e934d57fb492"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ge822266082cdb9772ce31388a6538cb9">bit_state_hashing_se05_search</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, size_t size, <a class="el" href="classspot_1_1option__map.html">option_map</a> o=<a class="el" href="classspot_1_1option__map.html">option_map</a>())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.">spot::tgba</a> automaton <em>a</em>.  <a href="group__emptiness__check__algorithms.html#ge822266082cdb9772ce31388a6538cb9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#g23a00d19bf7613222e6e41833e515c00">se05</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, <a class="el" href="classspot_1_1option__map.html">option_map</a> o)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper for the two se05 implementations.  <a href="group__emptiness__check__algorithms.html#g23a00d19bf7613222e6e41833e515c00"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structspot_1_1tgba__statistics.html">tgba_statistics</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#geeb949ca5fa52c1e292e0a7732ef46c4">stats_reachable</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *g)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute statistics for an automaton.  <a href="group__tgba__misc.html#geeb949ca5fa52c1e292e0a7732ef46c4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#g159e81f9b91f99b2a749185f47924d99">explicit_tau03_search</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, <a class="el" href="classspot_1_1option__map.html">option_map</a> o=<a class="el" href="classspot_1_1option__map.html">option_map</a>())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.">spot::tgba</a> automaton <em>a</em>.  <a href="group__emptiness__check__algorithms.html#g159e81f9b91f99b2a749185f47924d99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#g68f7245733f5fe5a86e6dd416d7746f1">explicit_tau03_opt_search</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, <a class="el" href="classspot_1_1option__map.html">option_map</a> o=<a class="el" href="classspot_1_1option__map.html">option_map</a>())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.">spot::tgba</a> automaton <em>a</em>.  <a href="group__emptiness__check__algorithms.html#g68f7245733f5fe5a86e6dd416d7746f1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classspot_1_1tgba__explicit.html">tgba_explicit</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#g4548696ddb1001650da2d5fd9b0f77bd">tgba_parse</a> (const std::string &amp;filename, <a class="el" href="group__tgba__io.html#g76b22bb081d5c36378098caa5bf58081">tgba_parse_error_list</a> &amp;error_list, <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, <a class="el" href="classspot_1_1ltl_1_1environment.html">ltl::environment</a> &amp;env=ltl::default_environment::instance(), <a class="el" href="classspot_1_1ltl_1_1environment.html">ltl::environment</a> &amp;envacc=ltl::default_environment::instance(), bool debug=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build a <a class="el" href="classspot_1_1tgba__explicit.html">spot::tgba_explicit</a> from a text file.  <a href="group__tgba__io.html#g4548696ddb1001650da2d5fd9b0f77bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#g95b48c3bd896478c7e22b0d49c39d89c">format_tgba_parse_errors</a> (std::ostream &amp;os, const std::string &amp;filename, <a class="el" href="group__tgba__io.html#g76b22bb081d5c36378098caa5bf58081">tgba_parse_error_list</a> &amp;error_list)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Format diagnostics produced by <a class="el" href="group__tgba__io.html#g4548696ddb1001650da2d5fd9b0f77bd" title="Build a spot::tgba_explicit from a text file.">spot::tgba_parse</a>.  <a href="group__tgba__io.html#g95b48c3bd896478c7e22b0d49c39d89c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#83bcadbb0c347d956021471f8c7d2135">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1gspn__exception.html">gspn_exception</a> &amp;e)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classspot_1_1couvreur99__check.html">couvreur99_check</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__ssp.html#g41573dafc02e8da2283670fa7aefebcf">couvreur99_check_ssp_semi</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *ssp_automata)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classspot_1_1couvreur99__check.html">couvreur99_check</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__ssp.html#g9e84d9fcba32903d98fc0a0ebdc73ac1">couvreur99_check_ssp_shy_semi</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *ssp_automata)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classspot_1_1couvreur99__check.html">couvreur99_check</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__ssp.html#g9dba9cdb805e4187dc072c0ff7ea3d67">couvreur99_check_ssp_shy</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *ssp_automata, bool stack_inclusion=true)</td></tr>

</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="d049f28e03c2ebe740e5597034fd5c93"></a><!-- doxytag: member="spot::evtgba_parse_error" ref="d049f28e03c2ebe740e5597034fd5c93" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;evtgbayy::location, std::string&gt; <a class="el" href="namespacespot.html#d049f28e03c2ebe740e5597034fd5c93">spot::evtgba_parse_error</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A parse diagnostic with its location. 
<p>

</div>
</div><p>
<a class="anchor" name="90dc0e2318bb80c45893922f42ec44fe"></a><!-- doxytag: member="spot::evtgba_parse_error_list" ref="90dc0e2318bb80c45893922f42ec44fe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;<a class="el" href="namespacespot.html#d049f28e03c2ebe740e5597034fd5c93">evtgba_parse_error</a>&gt; <a class="el" href="namespacespot.html#90dc0e2318bb80c45893922f42ec44fe">spot::evtgba_parse_error_list</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A list of parser diagnostics, as filled by parse. 
<p>

</div>
</div><p>
<a class="anchor" name="5f139f442de158fbe3bf9fab3ddee7f3"></a><!-- doxytag: member="spot::rsymbol_set" ref="5f139f442de158fbe3bf9fab3ddee7f3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt;<a class="el" href="classspot_1_1rsymbol.html">rsymbol</a>&gt; <a class="el" href="namespacespot.html#5f139f442de158fbe3bf9fab3ddee7f3">spot::rsymbol_set</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="9ec17bbfe207de0e9c4e699ee3f02572"></a><!-- doxytag: member="spot::simulation_relation" ref="9ec17bbfe207de0e9c4e699ee3f02572" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="namespacespot.html#335079e354907be71c014b01c2fb1573">state_couple</a>*&gt; <a class="el" href="namespacespot.html#9ec17bbfe207de0e9c4e699ee3f02572">spot::simulation_relation</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="335079e354907be71c014b01c2fb1573"></a><!-- doxytag: member="spot::state_couple" ref="335079e354907be71c014b01c2fb1573" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;const <a class="el" href="classspot_1_1state.html">spot::state</a>*, const <a class="el" href="classspot_1_1state.html">spot::state</a>*&gt; <a class="el" href="namespacespot.html#335079e354907be71c014b01c2fb1573">spot::state_couple</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b1fe964166144356a185c98ce0bcbde6"></a><!-- doxytag: member="spot::symbol_set" ref="b1fe964166144356a185c98ce0bcbde6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt;const <a class="el" href="classspot_1_1symbol.html">symbol</a>*&gt; <a class="el" href="namespacespot.html#b1fe964166144356a185c98ce0bcbde6">spot::symbol_set</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a04818924fa41d2230160b499d95173d"></a><!-- doxytag: member="spot::bdd_format_accset" ref="a04818924fa41d2230160b499d95173d" args="(const bdd_dict *dict, bdd b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string spot::bdd_format_accset           </td>
          <td>(</td>
          <td class="paramtype">const bdd_dict *&nbsp;</td>
          <td class="paramname"> <em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Format a BDD as a set of acceptance conditions. 
<p>
This is used when saving a TGBA. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dict</em>&nbsp;</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The BDD to print. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The BDD formated as a string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b9eea881fdb5d8e629db7102fde452ea"></a><!-- doxytag: member="spot::bdd_format_formula" ref="b9eea881fdb5d8e629db7102fde452ea" args="(const bdd_dict *dict, bdd b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string spot::bdd_format_formula           </td>
          <td>(</td>
          <td class="paramtype">const bdd_dict *&nbsp;</td>
          <td class="paramname"> <em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Format a BDD as a formula. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dict</em>&nbsp;</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The BDD to print. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The BDD formated as a string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ba342c9d66d191b7ed930e2b02043e7f"></a><!-- doxytag: member="spot::bdd_format_sat" ref="ba342c9d66d191b7ed930e2b02043e7f" args="(const bdd_dict *dict, bdd b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string spot::bdd_format_sat           </td>
          <td>(</td>
          <td class="paramtype">const bdd_dict *&nbsp;</td>
          <td class="paramname"> <em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Format a BDD as a list of literals. 
<p>
This assumes that <em>b</em> is a conjunction of literals. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dict</em>&nbsp;</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The BDD to print. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The BDD formated as a string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="73d8fa997efd95d08e0d1b9dfa7b7073"></a><!-- doxytag: member="spot::bdd_format_set" ref="73d8fa997efd95d08e0d1b9dfa7b7073" args="(const bdd_dict *dict, bdd b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string spot::bdd_format_set           </td>
          <td>(</td>
          <td class="paramtype">const bdd_dict *&nbsp;</td>
          <td class="paramname"> <em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Format a BDD as a set. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dict</em>&nbsp;</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The BDD to print. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The BDD formated as a string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3b659fe265e2014282d3b25db928794b"></a><!-- doxytag: member="spot::bdd_print_acc" ref="3b659fe265e2014282d3b25db928794b" args="(std::ostream &amp;os, const bdd_dict *dict, bdd b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::bdd_print_acc           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bdd_dict *&nbsp;</td>
          <td class="paramname"> <em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print a BDD as a list of acceptance conditions. 
<p>
This is used when saving a TGBA. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>The output stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dict</em>&nbsp;</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The BDD to print. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The BDD formated as a string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a75a117405f2292f6d80abc2ae930946"></a><!-- doxytag: member="spot::bdd_print_accset" ref="a75a117405f2292f6d80abc2ae930946" args="(std::ostream &amp;os, const bdd_dict *dict, bdd b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::bdd_print_accset           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bdd_dict *&nbsp;</td>
          <td class="paramname"> <em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print a BDD as a set of acceptance conditions. 
<p>
This is used when saving a TGBA. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>The output stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dict</em>&nbsp;</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The BDD to print. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The BDD formated as a string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3ec151057e33aadb60d2b47ffaa64c24"></a><!-- doxytag: member="spot::bdd_print_dot" ref="3ec151057e33aadb60d2b47ffaa64c24" args="(std::ostream &amp;os, const bdd_dict *dict, bdd b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::bdd_print_dot           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bdd_dict *&nbsp;</td>
          <td class="paramname"> <em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print a BDD as a diagram in dotty format. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>The output stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dict</em>&nbsp;</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The BDD to print. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="174c8f965f37e9a26b33c9f76183720f"></a><!-- doxytag: member="spot::bdd_print_formula" ref="174c8f965f37e9a26b33c9f76183720f" args="(std::ostream &amp;os, const bdd_dict *dict, bdd b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::bdd_print_formula           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bdd_dict *&nbsp;</td>
          <td class="paramname"> <em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print a BDD as a formula. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>The output stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dict</em>&nbsp;</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The BDD to print. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="59e91579989d390a3979a5badf302255"></a><!-- doxytag: member="spot::bdd_print_sat" ref="59e91579989d390a3979a5badf302255" args="(std::ostream &amp;os, const bdd_dict *dict, bdd b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::bdd_print_sat           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bdd_dict *&nbsp;</td>
          <td class="paramname"> <em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print a BDD as a list of literals. 
<p>
This assumes that <em>b</em> is a conjunction of literals. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>The output stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dict</em>&nbsp;</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The BDD to print. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ca49e9ec778c8a6b38455a68db8d6ece"></a><!-- doxytag: member="spot::bdd_print_set" ref="ca49e9ec778c8a6b38455a68db8d6ece" args="(std::ostream &amp;os, const bdd_dict *dict, bdd b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::bdd_print_set           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bdd_dict *&nbsp;</td>
          <td class="paramname"> <em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print a BDD as a set. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>The output stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dict</em>&nbsp;</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The BDD to print. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c8434843d2dcb0d99a027e398b01bafe"></a><!-- doxytag: member="spot::bdd_print_table" ref="c8434843d2dcb0d99a027e398b01bafe" args="(std::ostream &amp;os, const bdd_dict *dict, bdd b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::bdd_print_table           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bdd_dict *&nbsp;</td>
          <td class="paramname"> <em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print a BDD as a table. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>The output stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dict</em>&nbsp;</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The BDD to print. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ebfbc06108c79ba74f84a838af4f1772"></a><!-- doxytag: member="spot::bdd_to_formula" ref="ebfbc06108c79ba74f84a838af4f1772" args="(bdd f, const bdd_dict *d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a>* spot::bdd_to_formula           </td>
          <td>(</td>
          <td class="paramtype">bdd&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bdd_dict *&nbsp;</td>
          <td class="paramname"> <em>d</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b3ff98345b771b22e0a9b67063676e84"></a><!-- doxytag: member="spot::dotty_reachable" ref="b3ff98345b771b22e0a9b67063676e84" args="(std::ostream &amp;os, const evtgba *g)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::dotty_reachable           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const evtgba *&nbsp;</td>
          <td class="paramname"> <em>g</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print reachable states in dot format. 
<p>

</div>
</div><p>
<a class="anchor" name="6805befaee0df3f7cb4427d30782f230"></a><!-- doxytag: member="spot::evtgba_parse" ref="6805befaee0df3f7cb4427d30782f230" args="(const std::string &amp;filename, evtgba_parse_error_list &amp;error_list, bool debug=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspot_1_1evtgba__explicit.html">evtgba_explicit</a>* spot::evtgba_parse           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">evtgba_parse_error_list &amp;&nbsp;</td>
          <td class="paramname"> <em>error_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>debug</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Build a <a class="el" href="classspot_1_1evtgba__explicit.html">spot::evtgba_explicit</a> from a text file. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>The name of the file to parse. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_list</em>&nbsp;</td><td>A list that will be filled with parse errors that occured during parsing. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>debug</em>&nbsp;</td><td>When true, causes the parser to trace its execution. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the <a class="el" href="classspot_1_1evtgba.html">evtgba</a> built from <em>filename</em>, or 0 if the file could not be opened.</dd></dl>
Note that the parser usually tries to recover from errors. It can return an non zero value even if it encountered error during the parsing of <em>filename</em>. If you want to make sure <em>filename</em> was parsed succesfully, check <em>error_list</em> for emptiness.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>This function is not reentrant. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ade1f7e5b6c685b5393d8a6d3ab7e09d"></a><!-- doxytag: member="spot::evtgba_save_reachable" ref="ade1f7e5b6c685b5393d8a6d3ab7e09d" args="(std::ostream &amp;os, const evtgba *g)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::evtgba_save_reachable           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const evtgba *&nbsp;</td>
          <td class="paramname"> <em>g</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Save reachable states in text format. 
<p>

</div>
</div><p>
<a class="anchor" name="805ae4b750b93c1d2e19d81faa609065"></a><!-- doxytag: member="spot::format_evtgba_parse_errors" ref="805ae4b750b93c1d2e19d81faa609065" args="(std::ostream &amp;os, const std::string &amp;filename, evtgba_parse_error_list &amp;error_list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spot::format_evtgba_parse_errors           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">evtgba_parse_error_list &amp;&nbsp;</td>
          <td class="paramname"> <em>error_list</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Format diagnostics produced by <a class="el" href="namespacespot.html#6805befaee0df3f7cb4427d30782f230" title="Build a spot::evtgba_explicit from a text file.">spot::evtgba_parse</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>Where diagnostics should be output. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>The filename that should appear in the diagnostics. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_list</em>&nbsp;</td><td>The error list filled by <a class="el" href="group__ltl__io.html#g64770999ec846fe07292163e33509da5" title="Build a formula from an LTL string.">spot::ltl::parse</a> while parsing <em>ltl_string</em>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> iff any diagnostic was output. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b6641d7d9896e016376b1c618da92469"></a><!-- doxytag: member="spot::formula_to_bdd" ref="b6641d7d9896e016376b1c618da92469" args="(const ltl::formula *f, bdd_dict *d, void *for_me)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdd spot::formula_to_bdd           </td>
          <td>(</td>
          <td class="paramtype">const ltl::formula *&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_dict *&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>for_me</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="1a8d0610b61c0a30aad16791b0b73d15"></a><!-- doxytag: member="spot::memusage" ref="1a8d0610b61c0a30aad16791b0b73d15" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spot::memusage           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Total number of pages in use by the program. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The total number of pages in use by the program if known. -1 otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="83bcadbb0c347d956021471f8c7d2135"></a><!-- doxytag: member="spot::operator&lt;&lt;" ref="83bcadbb0c347d956021471f8c7d2135" args="(std::ostream &amp;os, const gspn_exception &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gspn_exception &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="3b22a05fb3e16d693b2d80425dfa4500"></a><!-- doxytag: member="spot::tgba_to_evtgba" ref="3b22a05fb3e16d693b2d80425dfa4500" args="(const tgba *a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspot_1_1evtgba__explicit.html">evtgba_explicit</a>* spot::tgba_to_evtgba           </td>
          <td>(</td>
          <td class="paramtype">const tgba *&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.">tgba</a> into an <a class="el" href="classspot_1_1evtgba.html">evtgba</a>. 
<p>
(This cannot be done on-the-fly because the alphabet of a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.">tgba</a> as unknown beforehand.) 
</div>
</div><p>
<hr size="1">
Please <b>comment</b> this page and <b>report errors</b> about it on
<a href="http://spot.lip6.fr/wiki/RefDocComments">the RefDocComments page</a>.
<br><address style="align: right;"><small>
Generated on Tue Jul 17 15:14:10 2007 for spot by <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border=0></a> 1.5.2</small></address>
</body>
</html>
