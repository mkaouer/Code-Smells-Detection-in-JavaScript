<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>spot: Class List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">spot&#160;<span id="projectnumber">0.8</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li class="current"><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Class List</div>  </div>
</div>
<div class="contents">
<div class="textblock">Here are the classes, structs, unions and interfaces with brief descriptions:</div><table>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1acceptance__convertor.html">spot::acceptance_convertor</a></td><td class="indexvalue">Help class to convert between acceptance conditions to other BDD formats </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1acss__statistics.html">spot::acss_statistics</a></td><td class="indexvalue">Accepting Cycle Search Space statistics </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1bdd__dict_1_1anon__free__list.html">spot::bdd_dict::anon_free_list</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ars__statistics.html">spot::ars_statistics</a></td><td class="indexvalue">Accepting Run Search statistics </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1atomic__prop.html">spot::ltl::atomic_prop</a></td><td class="indexvalue">Atomic propositions </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1automatop.html">spot::ltl::automatop</a></td><td class="indexvalue">Automaton operators </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1barand.html">spot::barand&lt; gen &gt;</a></td><td class="indexvalue">Compute pseudo-random integer value between 0 and <em>n</em> included, following a binomial distribution for probability <em>p</em> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1bdd__allocator.html">spot::bdd_allocator</a></td><td class="indexvalue">Manage ranges of variables </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1bdd__dict.html">spot::bdd_dict</a></td><td class="indexvalue">Map BDD variables to formulae </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1bdd__hash.html">spot::bdd_hash</a></td><td class="indexvalue">Hash functor for BDDs </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1bdd__less__than.html">spot::bdd_less_than</a></td><td class="indexvalue">Comparison functor for BDDs </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1bdd__ordered.html">spot::bdd_ordered</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1bfs__steps.html">spot::bfs_steps</a></td><td class="indexvalue">Make a BFS in a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> to compute a <a class="el" href="structspot_1_1tgba__run.html#a992869805fc5a8c3146e77309be61312">tgba_run::steps</a>.This class should be used to compute the shortest path between a state of a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> and the first transition or state that matches some conditions </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1binop.html">spot::ltl::binop</a></td><td class="indexvalue">Binary operator </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1fixed__size__pool_1_1block__.html">spot::fixed_size_pool::block_</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1multiple__size__pool_1_1block__.html">spot::multiple_size_pool::block_</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1char__ptr__less__than.html">spot::char_ptr_less_than</a></td><td class="indexvalue">Strict Weak Ordering for <code>char*</code>.This is meant to be used as a comparison functor for STL <code>map</code> whose key are of type <code>const char*</code> </td></tr>
  <tr><td class="indexkey"><a class="el" href="unionspot_1_1fixed__size__pool_1_1chunk__.html">spot::fixed_size_pool::chunk_</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="unionspot_1_1multiple__size__pool_1_1chunk__.html">spot::multiple_size_pool::chunk_</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1clone__visitor.html">spot::ltl::clone_visitor</a></td><td class="indexvalue">Clone a formula.This visitor is public, because it's convenient to derive from it and override part of its methods. But if you just want the functionality, consider using <a class="el" href="classspot_1_1ltl_1_1formula.html#a57d5414b1fd1eafb9ef6191309c66a4f" title="clone this node">spot::ltl::formula::clone</a> instead, it is way faster </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1scc__stack_1_1connected__component.html">spot::scc_stack::connected_component</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1connected__component__hash__set.html">spot::connected_component_hash_set</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1connected__component__hash__set__factory.html">spot::connected_component_hash_set_factory</a></td><td class="indexvalue">Factory for <a class="el" href="classspot_1_1connected__component__hash__set.html">connected_component_hash_set</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1ltl_1_1const__visitor.html">spot::ltl::const_visitor</a></td><td class="indexvalue">Formula visitor that cannot modify the formula </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1constant.html">spot::ltl::constant</a></td><td class="indexvalue">A constant (True or False) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1couvreur99__check.html">spot::couvreur99_check</a></td><td class="indexvalue">An implementation of the Couvreur99 emptiness-check algorithm </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1couvreur99__check__result.html">spot::couvreur99_check_result</a></td><td class="indexvalue">Compute a counter example from a <a class="el" href="classspot_1_1couvreur99__check__status.html" title="The status of the emptiness-check on success.">spot::couvreur99_check_status</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1couvreur99__check__shy.html">spot::couvreur99_check_shy</a></td><td class="indexvalue">A version of <a class="el" href="classspot_1_1couvreur99__check.html" title="An implementation of the Couvreur99 emptiness-check algorithm.">spot::couvreur99_check</a> that tries to visit known states first </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1couvreur99__check__status.html">spot::couvreur99_check_status</a></td><td class="indexvalue">The status of the emptiness-check on success </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1declarative__environment.html">spot::ltl::declarative_environment</a></td><td class="indexvalue">A declarative environment.This environment recognizes all atomic propositions that have been previously declared. It will reject other </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1default__environment.html">spot::ltl::default_environment</a></td><td class="indexvalue">A laxist environment.This environment recognizes all atomic propositions </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1delayed__simulation__relation.html">spot::delayed_simulation_relation</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1direct__simulation__relation.html">spot::direct_simulation_relation</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1taa__succ__iterator_1_1distance__sort.html">spot::taa_succ_iterator::distance_sort</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1dotty__decorator.html">spot::dotty_decorator</a></td><td class="indexvalue">Choose state and link styles for <a class="el" href="namespacespot.html#ab3ff98345b771b22e0a9b67063676e84" title="Print reachable states in dot format.">spot::dotty_reachable</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1duplicator__node.html">spot::duplicator_node</a></td><td class="indexvalue">Duplicator node of parity game graph </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1duplicator__node__delayed.html">spot::duplicator_node_delayed</a></td><td class="indexvalue">Duplicator node of parity game graph for delayed simulation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ec__statistics.html">spot::ec_statistics</a></td><td class="indexvalue">Emptiness-check statistics </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1emptiness__check.html">spot::emptiness_check</a></td><td class="indexvalue">Common interface to emptiness check algorithms </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1emptiness__check__instantiator.html">spot::emptiness_check_instantiator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1emptiness__check__result.html">spot::emptiness_check_result</a></td><td class="indexvalue">The result of an emptiness check </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1environment.html">spot::ltl::environment</a></td><td class="indexvalue">An environment that describes atomic propositions </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1evtgba.html">spot::evtgba</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1evtgba__explicit.html">spot::evtgba_explicit</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1evtgba__iterator.html">spot::evtgba_iterator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1evtgba__product.html">spot::evtgba_product</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1evtgba__reachable__iterator.html">spot::evtgba_reachable_iterator</a></td><td class="indexvalue">Iterate over all reachable states of a <a class="el" href="classspot_1_1evtgba.html">spot::evtgba</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1evtgba__reachable__iterator__breadth__first.html">spot::evtgba_reachable_iterator_breadth_first</a></td><td class="indexvalue">An implementation of <a class="el" href="classspot_1_1evtgba__reachable__iterator.html" title="Iterate over all reachable states of a spot::evtgba.">spot::evtgba_reachable_iterator</a> that browses states breadth first </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1evtgba__reachable__iterator__depth__first.html">spot::evtgba_reachable_iterator_depth_first</a></td><td class="indexvalue">An implementation of <a class="el" href="classspot_1_1evtgba__reachable__iterator.html" title="Iterate over all reachable states of a spot::evtgba.">spot::evtgba_reachable_iterator</a> that browses states depth first </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1explicit__connected__component.html">spot::explicit_connected_component</a></td><td class="indexvalue">An SCC storing all its states explicitly </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1explicit__connected__component__factory.html">spot::explicit_connected_component_factory</a></td><td class="indexvalue">Abstract factory for <a class="el" href="classspot_1_1explicit__connected__component.html" title="An SCC storing all its states explicitly.">explicit_connected_component</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1explicit__state__conjunction.html">spot::explicit_state_conjunction</a></td><td class="indexvalue">Basic implementation of <a class="el" href="classspot_1_1saba__state__conjunction.html" title="Iterate over a conjunction of saba_state.This class provides the basic functionalities required to it...">saba_state_conjunction</a>.This class provides a basic implementation to iterate over a conjunction of states of a saba </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1fair__kripke.html">spot::fair_kripke</a></td><td class="indexvalue">Interface for a Fair Kripke structure.A Kripke structure is a graph in which each node (=state) is labeled by a conjunction of atomic proposition, and a set of acceptance conditions </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1fair__kripke__succ__iterator.html">spot::fair_kripke_succ_iterator</a></td><td class="indexvalue">Iterator code for a Fair Kripke structure.This iterator can be used to simplify the writing of an iterator on a Fair Kripke structure (or lookalike) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1fixed__size__pool.html">spot::fixed_size_pool</a></td><td class="indexvalue">A fixed-size memory pool implementation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1formula.html">spot::ltl::formula</a></td><td class="indexvalue">An LTL formula.The only way you can work with a formula is to build a <a class="el" href="structspot_1_1ltl_1_1visitor.html" title="Formula visitor that can modify the formula.Writing visitors is the prefered way to traverse a formul...">spot::ltl::visitor</a> or <a class="el" href="structspot_1_1ltl_1_1const__visitor.html" title="Formula visitor that cannot modify the formula.">spot::ltl::const_visitor</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1ltl_1_1formula__ptr__hash.html">spot::ltl::formula_ptr_hash</a></td><td class="indexvalue">Hash Function for <code>const formula*</code>.This is meant to be used as a hash functor for Sgi's <code>hash_map</code> whose key are of type <code>const formula*</code> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1ltl_1_1formula__ptr__less__than.html">spot::ltl::formula_ptr_less_than</a></td><td class="indexvalue">Strict Weak Ordering for <code>const formula*</code>.This is meant to be used as a comparison functor for STL <code>map</code> whose key are of type <code>const formula*</code> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1free__list.html">spot::free_list</a></td><td class="indexvalue">Manage list of free integers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1future__conditions__collector.html">spot::future_conditions_collector</a></td><td class="indexvalue">Wrap a tgba to offer information about upcoming conditions.This class is a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> wrapper that simply add a new method, <a class="el" href="classspot_1_1future__conditions__collector.html#a9417271a5ecac3517205108fbcf1e638" title="Returns the set of future conditions visible after s.">future_conditions()</a>, to any <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1gspn__exception.html">spot::gspn_exception</a></td><td class="indexvalue">An exception used to forward GSPN errors </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1gspn__interface.html">spot::gspn_interface</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1gspn__ssp__interface.html">spot::gspn_ssp_interface</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1identity__hash.html">spot::identity_hash&lt; T &gt;</a></td><td class="indexvalue">A hash function that returns identity </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1kripke.html">spot::kripke</a></td><td class="indexvalue">Interface for a Kripke structureA Kripke structure is a graph in which each node (=state) is labeled by a conjunction of atomic proposition </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1kripke__explicit.html">spot::kripke_explicit</a></td><td class="indexvalue">Kripke Structure </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1kripke__explicit__succ__iterator.html">spot::kripke_explicit_succ_iterator</a></td><td class="indexvalue">Implement iterator pattern on successor of a <a class="el" href="classspot_1_1state__kripke.html" title="Concrete class for kripke states.">state_kripke</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1kripke__succ__iterator.html">spot::kripke_succ_iterator</a></td><td class="indexvalue">Iterator code for Kripke structureThis iterator can be used to simplify the writing of an iterator on a Kripke structure (or lookalike) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1language__containment__checker.html">spot::ltl::language_containment_checker</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1minato__isop_1_1local__vars.html">spot::minato_isop::local_vars</a></td><td class="indexvalue">Internal variables for <a class="el" href="classspot_1_1minato__isop.html" title="Generate an irredundant sum-of-products (ISOP) form of a BDD function.This algorithm implements a der...">minato_isop</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeltlyy_1_1location.html">eltlyy::location</a></td><td class="indexvalue">Abstract a location </td></tr>
  <tr><td class="indexkey"><a class="el" href="classneverclaimyy_1_1location.html">neverclaimyy::location</a></td><td class="indexvalue">Abstract a location </td></tr>
  <tr><td class="indexkey"><a class="el" href="classkripkeyy_1_1location.html">kripkeyy::location</a></td><td class="indexvalue">Abstract a location </td></tr>
  <tr><td class="indexkey"><a class="el" href="classltlyy_1_1location.html">ltlyy::location</a></td><td class="indexvalue">Abstract a location </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html">spot::loopless_modular_mixed_radix_gray_code</a></td><td class="indexvalue">Loopless modular mixed radix Gray code iteration.This class is based on the loopless modular mixed radix gray code algorithm described in exercise 77 of "The Art of Computer
      Programming", Pre-Fascicle 2A (Draft of section 7.2.1.1: generating all n-tuples) by Donald E. Knuth </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1ltl__file.html">spot::ltl::ltl_file</a></td><td class="indexvalue">Read LTL formulae from a file, one by one </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1minato__isop.html">spot::minato_isop</a></td><td class="indexvalue">Generate an irredundant sum-of-products (ISOP) form of a BDD function.This algorithm implements a derecursived version the Minato-Morreale algorithm presented in the following paper </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1multiple__size__pool.html">spot::multiple_size_pool</a></td><td class="indexvalue">A multiple-size memory pool implementation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1multop.html">spot::ltl::multop</a></td><td class="indexvalue">Multi-operand operators.These operators are considered commutative and associative </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1nfa.html">spot::ltl::nfa</a></td><td class="indexvalue">Nondeterministic Finite Automata used by automata operators </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1ltl_1_1formula__tree_1_1node.html">spot::ltl::formula_tree::node</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1ltl_1_1formula__tree_1_1node__atomic.html">spot::ltl::formula_tree::node_atomic</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1ltl_1_1formula__tree_1_1node__binop.html">spot::ltl::formula_tree::node_binop</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1ltl_1_1formula__tree_1_1node__multop.html">spot::ltl::formula_tree::node_multop</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1ltl_1_1formula__tree_1_1node__nfa.html">spot::ltl::formula_tree::node_nfa</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1ltl_1_1formula__tree_1_1node__unop.html">spot::ltl::formula_tree::node_unop</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1numbered__state__heap.html">spot::numbered_state_heap</a></td><td class="indexvalue">Keep track of a large quantity of indexed states </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1numbered__state__heap__const__iterator.html">spot::numbered_state_heap_const_iterator</a></td><td class="indexvalue">Iterator on <a class="el" href="classspot_1_1numbered__state__heap.html" title="Keep track of a large quantity of indexed states.">numbered_state_heap</a> objects </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1numbered__state__heap__factory.html">spot::numbered_state_heap_factory</a></td><td class="indexvalue">Abstract factory for <a class="el" href="classspot_1_1numbered__state__heap.html" title="Keep track of a large quantity of indexed states.">numbered_state_heap</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1numbered__state__heap__hash__map.html">spot::numbered_state_heap_hash_map</a></td><td class="indexvalue">A straightforward implementation of <a class="el" href="classspot_1_1numbered__state__heap.html" title="Keep track of a large quantity of indexed states.">numbered_state_heap</a> with a hash map </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1numbered__state__heap__hash__map__factory.html">spot::numbered_state_heap_hash_map_factory</a></td><td class="indexvalue">Factory for <a class="el" href="classspot_1_1numbered__state__heap__hash__map.html" title="A straightforward implementation of numbered_state_heap with a hash map.">numbered_state_heap_hash_map</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1ltl_1_1random__ltl_1_1op__proba.html">spot::ltl::random_ltl::op_proba</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1option__map.html">spot::option_map</a></td><td class="indexvalue">Manage a map of options.Each option is defined by a string and is associated to an integer value </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1ltl_1_1multop_1_1paircmp.html">spot::ltl::multop::paircmp</a></td><td class="indexvalue">Comparison functor used internally by <a class="el" href="classspot_1_1ltl_1_1multop.html" title="Multi-operand operators.These operators are considered commutative and associative.">ltl::multop</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1parity__game__graph.html">spot::parity_game_graph</a></td><td class="indexvalue">Parity game graph which compute a simulation relation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1parity__game__graph__delayed.html">spot::parity_game_graph_delayed</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1parity__game__graph__direct.html">spot::parity_game_graph_direct</a></td><td class="indexvalue">Parity game graph which compute the direct simulation relation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classneverclaimyy_1_1position.html">neverclaimyy::position</a></td><td class="indexvalue">Abstract a position </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeltlyy_1_1position.html">eltlyy::position</a></td><td class="indexvalue">Abstract a position </td></tr>
  <tr><td class="indexkey"><a class="el" href="classkripkeyy_1_1position.html">kripkeyy::position</a></td><td class="indexvalue">Abstract a position </td></tr>
  <tr><td class="indexkey"><a class="el" href="classltlyy_1_1position.html">ltlyy::position</a></td><td class="indexvalue">Abstract a position </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1postfix__visitor.html">spot::ltl::postfix_visitor</a></td><td class="indexvalue">Apply an algorithm on each node of an AST, during a postfix traversal.Override one or more of the postifix_visitor::doit methods with the algorithm to apply </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1power__map.html">spot::power_map</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1ptr__hash.html">spot::ptr_hash&lt; T &gt;</a></td><td class="indexvalue">A hash function for pointers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1random__ltl.html">spot::ltl::random_ltl</a></td><td class="indexvalue">Generate random LTL formulae.This class recursively construct LTL formulae of a given size. The formulae will use the use atomic propositions from the set of proposition passed to the constructor, in addition to the constant and all LTL operators supported by Spot </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1ltl_1_1language__containment__checker_1_1record__.html">spot::ltl::language_containment_checker::record_</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1ref__formula.html">spot::ltl::ref_formula</a></td><td class="indexvalue">A reference-counted LTL formula </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1rsymbol.html">spot::rsymbol</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1saba.html">spot::saba</a></td><td class="indexvalue">A State-based Alternating (Generalized) Büchi Automaton.Browsing such automaton can be achieved using two functions: <code>get_init_state</code>, and <code>succ_iter</code>. The former returns the initial state while the latter lists the successor states of any state </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1saba__complement__tgba.html">spot::saba_complement_tgba</a></td><td class="indexvalue">Complement a TGBA and produce a SABA.The original TGBA is transformed into a States-based Büchi Automaton </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1saba__reachable__iterator.html">spot::saba_reachable_iterator</a></td><td class="indexvalue">Iterate over all reachable states of a <a class="el" href="classspot_1_1saba.html" title="A State-based Alternating (Generalized) Büchi Automaton.Browsing such automaton can be achieved using...">spot::saba</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1saba__reachable__iterator__breadth__first.html">spot::saba_reachable_iterator_breadth_first</a></td><td class="indexvalue">An implementation of <a class="el" href="classspot_1_1saba__reachable__iterator.html" title="Iterate over all reachable states of a spot::saba.">spot::saba_reachable_iterator</a> that browses states breadth first </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1saba__reachable__iterator__depth__first.html">spot::saba_reachable_iterator_depth_first</a></td><td class="indexvalue">An implementation of <a class="el" href="classspot_1_1saba__reachable__iterator.html" title="Iterate over all reachable states of a spot::saba.">spot::saba_reachable_iterator</a> that browses states depth first </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1saba__state.html">spot::saba_state</a></td><td class="indexvalue">Abstract class for saba states </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1saba__state__conjunction.html">spot::saba_state_conjunction</a></td><td class="indexvalue">Iterate over a conjunction of <a class="el" href="classspot_1_1saba__state.html" title="Abstract class for saba states.">saba_state</a>.This class provides the basic functionalities required to iterate over a conjunction of states of a saba </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1saba__state__ptr__equal.html">spot::saba_state_ptr_equal</a></td><td class="indexvalue">An Equivalence Relation for <code>saba_state*</code>.This is meant to be used as a comparison functor for Sgi <code>hash_map</code> whose key are of type <code>saba_state*</code> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1saba__state__ptr__hash.html">spot::saba_state_ptr_hash</a></td><td class="indexvalue">Hash Function for <code>saba_state*</code>.This is meant to be used as a hash functor for Sgi's <code>hash_map</code> whose key are of type <code>saba_state*</code> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1saba__state__ptr__less__than.html">spot::saba_state_ptr_less_than</a></td><td class="indexvalue">Strict Weak Ordering for <code>saba_state*</code>.This is meant to be used as a comparison functor for STL <code>map</code> whose key are of type <code>saba_state*</code> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1saba__state__shared__ptr__equal.html">spot::saba_state_shared_ptr_equal</a></td><td class="indexvalue">An Equivalence Relation for <code>shared_saba_state</code> (shared_ptr&lt;const saba_state*&gt;).This is meant to be used as a comparison functor for Sgi <code>hash_map</code> whose key are of type <code>shared_saba_state</code> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1saba__state__shared__ptr__hash.html">spot::saba_state_shared_ptr_hash</a></td><td class="indexvalue">Hash Function for <code>shared_saba_state</code> (shared_ptr&lt;const saba_state*&gt;).This is meant to be used as a hash functor for Sgi's <code>hash_map</code> whose key are of type <code>shared_saba_state</code> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1saba__state__shared__ptr__less__than.html">spot::saba_state_shared_ptr_less_than</a></td><td class="indexvalue">Strict Weak Ordering for <code>shared_saba_state</code> (shared_ptr&lt;const saba_state*&gt;).This is meant to be used as a comparison functor for STL <code>map</code> whose key are of type <code>shared_saba_state</code> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1saba__succ__iterator.html">spot::saba_succ_iterator</a></td><td class="indexvalue">Iterate over the successors of a <a class="el" href="classspot_1_1saba__state.html" title="Abstract class for saba states.">saba_state</a>.This class provides the basic functionalities required to iterate over the successors of a state of a saba. Since transitions of an alternating automaton are defined as a boolean function with conjunctions (universal) and disjunctions (non-deterministic), </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1scc__map_1_1scc.html">spot::scc_map::scc</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1scc__map.html">spot::scc_map</a></td><td class="indexvalue">Build a map of Strongly Connected components in in a TGBA </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1scc__stack.html">spot::scc_stack</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1scc__stats.html">spot::scc_stats</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1sccs__set.html">spot::sccs_set</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1simplify__f__g__visitor.html">spot::ltl::simplify_f_g_visitor</a></td><td class="indexvalue">Replace <code>true U f</code> and <code>false R g</code> by <code>F f</code> and <code>G g</code> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeltlyy_1_1slice.html">eltlyy::slice&lt; T, S &gt;</a></td><td class="indexvalue">Present a slice of the top of a stack </td></tr>
  <tr><td class="indexkey"><a class="el" href="classneverclaimyy_1_1slice.html">neverclaimyy::slice&lt; T, S &gt;</a></td><td class="indexvalue">Present a slice of the top of a stack </td></tr>
  <tr><td class="indexkey"><a class="el" href="classkripkeyy_1_1slice.html">kripkeyy::slice&lt; T, S &gt;</a></td><td class="indexvalue">Present a slice of the top of a stack </td></tr>
  <tr><td class="indexkey"><a class="el" href="classltlyy_1_1slice.html">ltlyy::slice&lt; T, S &gt;</a></td><td class="indexvalue">Present a slice of the top of a stack </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1spoiler__node.html">spot::spoiler_node</a></td><td class="indexvalue">Spoiler node of parity game graph </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1spoiler__node__delayed.html">spot::spoiler_node_delayed</a></td><td class="indexvalue">Spoiler node of parity game graph for delayed simulation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeltlyy_1_1stack.html">eltlyy::stack&lt; T, S &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classltlyy_1_1stack.html">ltlyy::stack&lt; T, S &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classkripkeyy_1_1stack.html">kripkeyy::stack&lt; T, S &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classneverclaimyy_1_1stack.html">neverclaimyy::stack&lt; T, S &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1evtgba__explicit_1_1state.html">spot::evtgba_explicit::state</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1state.html">spot::state</a></td><td class="indexvalue">Abstract class for states </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1state__bdd.html">spot::state_bdd</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1state__evtgba__explicit.html">spot::state_evtgba_explicit</a></td><td class="indexvalue">States used by spot::tgba_evtgba_explicit </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1state__explicit.html">spot::state_explicit</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1state__kripke.html">spot::state_kripke</a></td><td class="indexvalue">Concrete class for kripke states </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1state__product.html">spot::state_product</a></td><td class="indexvalue">A state for <a class="el" href="classspot_1_1tgba__product.html" title="A lazy product. (States are computed on the fly.)">spot::tgba_product</a>.This state is in fact a pair of state: the state from the left automaton and that of the right </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1state__ptr__equal.html">spot::state_ptr_equal</a></td><td class="indexvalue">An Equivalence Relation for <code>state*</code>.This is meant to be used as a comparison functor for Sgi <code>hash_map</code> whose key are of type <code>state*</code> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1state__ptr__hash.html">spot::state_ptr_hash</a></td><td class="indexvalue">Hash Function for <code>state*</code>.This is meant to be used as a hash functor for Sgi's <code>hash_map</code> whose key are of type <code>state*</code> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1state__ptr__less__than.html">spot::state_ptr_less_than</a></td><td class="indexvalue">Strict Weak Ordering for <code>state*</code>.This is meant to be used as a comparison functor for STL <code>map</code> whose key are of type <code>state*</code> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1state__set.html">spot::state_set</a></td><td class="indexvalue">Set of states deriving from <a class="el" href="classspot_1_1state.html" title="Abstract class for states.">spot::state</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1state__shared__ptr__equal.html">spot::state_shared_ptr_equal</a></td><td class="indexvalue">An Equivalence Relation for <code>shared_state</code> (shared_ptr&lt;const state*&gt;).This is meant to be used as a comparison functor for Sgi <code>hash_map</code> whose key are of type <code>shared_state</code> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1state__shared__ptr__hash.html">spot::state_shared_ptr_hash</a></td><td class="indexvalue">Hash Function for <code>shared_state</code> (shared_ptr&lt;const state*&gt;).This is meant to be used as a hash functor for Sgi's <code>hash_map</code> whose key are of type <code>shared_state</code> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1state__shared__ptr__less__than.html">spot::state_shared_ptr_less_than</a></td><td class="indexvalue">Strict Weak Ordering for <code>shared_state</code> (shared_ptr&lt;const state*&gt;).This is meant to be used as a comparison functor for STL <code>map</code> whose key are of type <code>shared_state</code> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1state__union.html">spot::state_union</a></td><td class="indexvalue">A state for <a class="el" href="classspot_1_1tgba__union.html" title="A lazy union. (States are computed on the fly.)">spot::tgba_union</a>.This state is in fact a pair. If the first member equals 0 and the second is different from 0, the state belongs to the left automaton. If the first member is different from 0 and the second is 0, the state belongs to the right automaton. If both members are 0, the state is the initial state </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1tgba__run_1_1step.html">spot::tgba_run::step</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1string__hash.html">spot::string_hash</a></td><td class="indexvalue">A hash function for strings </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1succ__iterator.html">spot::ltl::succ_iterator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1couvreur99__check__shy_1_1successor.html">spot::couvreur99_check_shy::successor</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1symbol.html">spot::symbol</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1taa__succ__iterator.html">spot::taa_succ_iterator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1taa__tgba.html">spot::taa_tgba</a></td><td class="indexvalue">A self-loop Transition-based Alternating Automaton (TAA) which is seen as a TGBA (abstract class, see below) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1taa__tgba__formula.html">spot::taa_tgba_formula</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1taa__tgba__labelled.html">spot::taa_tgba_labelled&lt; label, label_hash &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1taa__tgba__string.html">spot::taa_tgba_string</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba.html">spot::tgba</a></td><td class="indexvalue">A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi Automaton) was coined by Dimitra Giannakopoulou and Flavio Lerda in "From States to Transitions: Improving Translation of LTL
      Formulae to Büchi Automata". (FORTE'02) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__bdd__concrete.html">spot::tgba_bdd_concrete</a></td><td class="indexvalue">A concrete <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> implemented using BDDs </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__bdd__concrete__factory.html">spot::tgba_bdd_concrete_factory</a></td><td class="indexvalue">Helper class to build a <a class="el" href="classspot_1_1tgba__bdd__concrete.html" title="A concrete spot::tgba implemented using BDDs.">spot::tgba_bdd_concrete</a> object </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1tgba__bdd__core__data.html">spot::tgba_bdd_core_data</a></td><td class="indexvalue">Core data for a TGBA encoded using BDDs </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__bdd__factory.html">spot::tgba_bdd_factory</a></td><td class="indexvalue">Abstract class for <a class="el" href="classspot_1_1tgba__bdd__concrete.html" title="A concrete spot::tgba implemented using BDDs.">spot::tgba_bdd_concrete</a> factories </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__explicit.html">spot::tgba_explicit</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__explicit__formula.html">spot::tgba_explicit_formula</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__explicit__labelled.html">spot::tgba_explicit_labelled&lt; label, label_hash &gt;</a></td><td class="indexvalue">A <a class="el" href="classspot_1_1tgba__explicit.html">tgba_explicit</a> instance with states labeled by a given type </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__explicit__number.html">spot::tgba_explicit_number</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__explicit__string.html">spot::tgba_explicit_string</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__explicit__succ__iterator.html">spot::tgba_explicit_succ_iterator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__kv__complement.html">spot::tgba_kv_complement</a></td><td class="indexvalue">Build a complemented automaton.The construction comes from: </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__product.html">spot::tgba_product</a></td><td class="indexvalue">A lazy product. (States are computed on the fly.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__product__init.html">spot::tgba_product_init</a></td><td class="indexvalue">A lazy product with different initial states </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__reachable__iterator.html">spot::tgba_reachable_iterator</a></td><td class="indexvalue">Iterate over all reachable states of a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__reachable__iterator__breadth__first.html">spot::tgba_reachable_iterator_breadth_first</a></td><td class="indexvalue">An implementation of <a class="el" href="classspot_1_1tgba__reachable__iterator.html" title="Iterate over all reachable states of a spot::tgba.">spot::tgba_reachable_iterator</a> that browses states breadth first </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__reachable__iterator__depth__first.html">spot::tgba_reachable_iterator_depth_first</a></td><td class="indexvalue">An implementation of <a class="el" href="classspot_1_1tgba__reachable__iterator.html" title="Iterate over all reachable states of a spot::tgba.">spot::tgba_reachable_iterator</a> that browses states depth first </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__reduc.html">spot::tgba_reduc</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1tgba__run.html">spot::tgba_run</a></td><td class="indexvalue">An accepted run, for a tgba </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__run__dotty__decorator.html">spot::tgba_run_dotty_decorator</a></td><td class="indexvalue">Highlight a <a class="el" href="structspot_1_1tgba__run.html" title="An accepted run, for a tgba.">spot::tgba_run</a> on a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a>.An instance of this class can be passed to <a class="el" href="namespacespot.html#ab3ff98345b771b22e0a9b67063676e84" title="Print reachable states in dot format.">spot::dotty_reachable</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__safra__complement.html">spot::tgba_safra_complement</a></td><td class="indexvalue">Build a complemented automaton.It creates an automaton that recognizes the negated language of <em>aut</em> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__sba__proxy.html">spot::tgba_sba_proxy</a></td><td class="indexvalue">Degeneralize a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> on the fly, producing an SBA.This class acts as a proxy in front of a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a>, that should be degeneralized on the fly </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__scc.html">spot::tgba_scc</a></td><td class="indexvalue">Wrap a tgba to offer information about strongly connected components.This class is a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> wrapper that simply add a new method <a class="el" href="classspot_1_1tgba__scc.html#a0710f2fdfd1d418eef39b96f03b21d68" title="Returns the number of the SCC s belongs to.">scc_of_state()</a> to retrieve the number of a SCC a state belongs to </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__sgba__proxy.html">spot::tgba_sgba_proxy</a></td><td class="indexvalue">Change the labeling-mode of <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> on the fly, producing a state-based generalized Büchi automaton.This class acts as a proxy in front of a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a>, that should label on states on-the-fly. The result is still a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a>, but acceptances conditions are also on states </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1tgba__statistics.html">spot::tgba_statistics</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1tgba__sub__statistics.html">spot::tgba_sub_statistics</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__succ__iterator.html">spot::tgba_succ_iterator</a></td><td class="indexvalue">Iterate over the successors of a state.This class provides the basic functionalities required to iterate over the successors of a state, as well as querying transition labels. Because transitions are never explicitely encoded, labels (conditions and acceptance conditions) can only be queried while iterating over the successors </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__succ__iterator__concrete.html">spot::tgba_succ_iterator_concrete</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__succ__iterator__union.html">spot::tgba_succ_iterator_union</a></td><td class="indexvalue">Iterate over the successors of an union computed on the fly </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__tba__proxy.html">spot::tgba_tba_proxy</a></td><td class="indexvalue">Degeneralize a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> on the fly, producing a TBA.This class acts as a proxy in front of a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a>, that should be degeneralized on the fly. The result is still a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a>, but it will always have exactly one acceptance condition so it could be called TBA (without the G) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__union.html">spot::tgba_union</a></td><td class="indexvalue">A lazy union. (States are computed on the fly.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1time__info.html">spot::time_info</a></td><td class="indexvalue">A structure to record elapsed time in clock ticks </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1timer.html">spot::timer</a></td><td class="indexvalue">A timekeeper that accumulate interval of time </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1timer__map.html">spot::timer_map</a></td><td class="indexvalue">A map of timer, where each timer has a name </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1couvreur99__check__shy_1_1todo__item.html">spot::couvreur99_check_shy::todo_item</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1evtgba__explicit_1_1transition.html">spot::evtgba_explicit::transition</a></td><td class="indexvalue">Explicit transitions (used by <a class="el" href="classspot_1_1evtgba__explicit.html">spot::evtgba_explicit</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1state__explicit_1_1transition.html">spot::state_explicit::transition</a></td><td class="indexvalue">Explicit transitions </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1taa__tgba_1_1transition.html">spot::taa_tgba::transition</a></td><td class="indexvalue">Explicit transitions </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1ltl_1_1nfa_1_1transition.html">spot::ltl::nfa::transition</a></td><td class="indexvalue">Explicit transitions </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1ltl_1_1automatop_1_1tripletcmp.html">spot::ltl::automatop::tripletcmp</a></td><td class="indexvalue">Comparison functor used internally by <a class="el" href="classspot_1_1ltl_1_1automatop.html" title="Automaton operators.">ltl::automatop</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1unabbreviate__logic__visitor.html">spot::ltl::unabbreviate_logic_visitor</a></td><td class="indexvalue">Clone and rewrite a formula to remove most of the abbreviated logical operators.This will rewrite binary operators such as <a class="el" href="classspot_1_1ltl_1_1binop.html#a7c5967c6908151a90ff72f210bfb59a2ac5d2a034f0dd62b98fe785d0372c0c9a">binop::Implies</a>, binop::Equals, and <a class="el" href="classspot_1_1ltl_1_1binop.html#a7c5967c6908151a90ff72f210bfb59a2a71177fc6c4bfbc11a0fd7acceeed1ed5">binop::Xor</a>, using only <a class="el" href="classspot_1_1ltl_1_1unop.html#ab6cd495a942b8c203f547cccb50916bca5c70279f9221ae04c99dfcfb1d8cce21">unop::Not</a>, <a class="el" href="classspot_1_1ltl_1_1multop.html#a7ff9fb342ce923eed135a23285d686feaec9dacb72caa01e417f04a398770b16f">multop::Or</a>, and <a class="el" href="classspot_1_1ltl_1_1multop.html#a7ff9fb342ce923eed135a23285d686fea134bbaa37c9a0db99c61af1f61b7f037">multop::And</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1unabbreviate__ltl__visitor.html">spot::ltl::unabbreviate_ltl_visitor</a></td><td class="indexvalue">Clone and rewrite a formula to remove most of the abbreviated LTL and logical operators.The rewriting performed on logical operator is the same as the one done by <a class="el" href="classspot_1_1ltl_1_1unabbreviate__logic__visitor.html" title="Clone and rewrite a formula to remove most of the abbreviated logical operators.This will rewrite bin...">spot::ltl::unabbreviate_logic_visitor</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1unop.html">spot::ltl::unop</a></td><td class="indexvalue">Unary operators </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1unsigned__statistics.html">spot::unsigned_statistics</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1unsigned__statistics__copy.html">spot::unsigned_statistics_copy</a></td><td class="indexvalue">Comparable statistics </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1ltl_1_1visitor.html">spot::ltl::visitor</a></td><td class="indexvalue">Formula visitor that can modify the formula.Writing visitors is the prefered way to traverse a formula, since it doesn't involve any cast </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1weight.html">spot::weight</a></td><td class="indexvalue">Manage for a given automaton a vector of counter indexed by its acceptance condition </td></tr>
</table>
</div>
<hr size="1">
Please <b>comment</b> this page and <b>report errors</b> about it on
<a href="http://spot.lip6.fr/wiki/RefDocComments">the RefDocComments page</a>.
<br><address style="align: right;"><small>
Generated on Mon Nov 28 2011 15:23:18 for spot by <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border=0></a> 1.7.4</small></address>
</body>
</html>
