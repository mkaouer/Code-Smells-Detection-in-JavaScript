<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>spot: spot::loopless_modular_mixed_radix_gray_code Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">spot&#160;<span id="projectnumber">0.8</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacespot.html">spot</a>      </li>
      <li class="navelem"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html">loopless_modular_mixed_radix_gray_code</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">spot::loopless_modular_mixed_radix_gray_code Class Reference<div class="ingroups"><a class="el" href="group__misc__tools.html">Miscellaneous helper algorithms</a></div></div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="spot::loopless_modular_mixed_radix_gray_code" -->
<p>Loopless modular mixed radix Gray code iteration.This class is based on the loopless modular mixed radix gray code algorithm described in exercise 77 of "The Art of Computer
      Programming", Pre-Fascicle 2A (Draft of section 7.2.1.1: generating all n-tuples) by Donald E. Knuth.  
 <a href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="modgray_8hh_source.html">misc/modgray.hh</a>&gt;</code></p>

<p><a href="classspot_1_1loopless__modular__mixed__radix__gray__code-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a565b6c52e7b37b83bb829095e11c69c9">loopless_modular_mixed_radix_gray_code</a> (int n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a53934ac1621f8bd1c55ef9ccbf9e4a11">~loopless_modular_mixed_radix_gray_code</a> ()</td></tr>
<tr><td colspan="2"><div class="groupHeader">iteration over an element in a tuple</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The class does not know how to modify the elements of the tuple (Knuth's a<sub>j</sub>s). These changes are therefore abstracted using the <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#af1aab585098500e6acb78675967ef530" title="Reset aj to its initial value.">a_first()</a>, <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#ad2299afa2a00ff9cc5f202b9854bdf4d" title="Advance aj to its next value.">a_next()</a>, and <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#aed1aa03144c6dcb46e13c38b5c51a260" title="Whether aj is on its last value.">a_last()</a> abstract functions. These need to be implemented in subclasses as appropriate. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#af1aab585098500e6acb78675967ef530">a_first</a> (int j)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset a<sub>j</sub> to its initial value.  <a href="#af1aab585098500e6acb78675967ef530"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#ad2299afa2a00ff9cc5f202b9854bdf4d">a_next</a> (int j)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance a<sub>j</sub> to its next value.  <a href="#ad2299afa2a00ff9cc5f202b9854bdf4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#aed1aa03144c6dcb46e13c38b5c51a260">a_last</a> (int j) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a<sub>j</sub> is on its last value.  <a href="#aed1aa03144c6dcb46e13c38b5c51a260"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">iteration over all the tuples</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a9c918e8524bdeb3e3a80054becbd30df">first</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the iteration to the first tuple.  <a href="#a9c918e8524bdeb3e3a80054becbd30df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a98269cadd64926b5cf408cc4ab0ed2a5">last</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this the last tuple.  <a href="#a98269cadd64926b5cf408cc4ab0ed2a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a60dcf75008df5bbab91533ee6ac03297">done</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether all tuple have been explored.  <a href="#a60dcf75008df5bbab91533ee6ac03297"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a5ef37d3a269687be631a65769ad209b9">next</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update one item of the tuple and return its position.  <a href="#a5ef37d3a269687be631a65769ad209b9"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a2551f357ca1be741bc5300d06a4c3b63">n_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a01d93ad137b3a2368270ec3779e32eee">done_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a68e9eea9d2632d66f2ef1042f2d27b68">a_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a6f86e8454e331df5b4aacf5eef3f41ef">f_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#aa8342a062c7d6845b4473c0617bb4552">m_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a3dfc0ecaeaf71747a972ce8339d63e50">s_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a7c8c0adbecfdb2060d4696cf2bbf799e">non_one_radixes_</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Loopless modular mixed radix Gray code iteration.</p>
<p>This class is based on the loopless modular mixed radix gray code algorithm described in exercise 77 of "The Art of Computer
      Programming", Pre-Fascicle 2A (Draft of section 7.2.1.1: generating all n-tuples) by Donald E. Knuth. </p>
<p>The idea is to enumerate the set of all n-tuples (a<sub>0</sub>,a<sub>1</sub>,...,a<sub>n-1</sub>) where each a<sub>j</sub> range over a distinct set (this is the <em>mixed radix</em> part), so that only one a<sub>j</sub> changes between two successive tuples of the iteration (that is the <em>Gray code</em> part), and that this changes occurs always in the same direction, cycling over the set a<sub>j</sub> must cover (i.e., <em>modular</em>). The algorithm is <em>loopless</em> in that computing the next tuple done without any loop, i.e., in constant time.</p>
<p>This class does not need to know the type of the a<sub>j</sub>, it will handle them indirectly through three methods: <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#af1aab585098500e6acb78675967ef530" title="Reset aj to its initial value.">a_first()</a>, <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#ad2299afa2a00ff9cc5f202b9854bdf4d" title="Advance aj to its next value.">a_next()</a>, and <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#aed1aa03144c6dcb46e13c38b5c51a260" title="Whether aj is on its last value.">a_last()</a>. These methods need to be implemented in a subclass for the particular type of a<sub>j</sub> at hand.</p>
<p>The class itself offers four functions to control the iteration over the set of all the (a<sub>0</sub>,a<sub>1</sub>,..., a<sub>n-1</sub>) tuples: <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a9c918e8524bdeb3e3a80054becbd30df" title="Reset the iteration to the first tuple.">first()</a>, <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a5ef37d3a269687be631a65769ad209b9" title="Update one item of the tuple and return its position.">next()</a>, <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a98269cadd64926b5cf408cc4ab0ed2a5" title="Whether this the last tuple.">last()</a>, and <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a60dcf75008df5bbab91533ee6ac03297" title="Whether all tuple have been explored.">done()</a>. These functions are usually used as follows: </p>
<div class="fragment"><pre class="fragment">    <span class="keywordflow">for</span> (g.first(); !g.done(); g.next())
       use the tuple
</pre></div><p> How to use the tuple of course depends on the way it as been stored in the subclass.</p>
<p>Finally, let's mention two differences between this algorithm and the one in Knuth's book. This version of the algorithm does not need to know the radixes (i.e., the size of set of each a<sub>j</sub>) beforehand: it will discover them on-the-fly when a_last(j) first return true. It will also work with a<sub>j</sub> that cannot be changed. (This is achieved by reindexing the elements through <code>non_one_radixes_</code>, to consider only the elements with a non-singleton range.) </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a565b6c52e7b37b83bb829095e11c69c9"></a><!-- doxytag: member="spot::loopless_modular_mixed_radix_gray_code::loopless_modular_mixed_radix_gray_code" ref="a565b6c52e7b37b83bb829095e11c69c9" args="(int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spot::loopless_modular_mixed_radix_gray_code::loopless_modular_mixed_radix_gray_code </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The size of the tuples to enumerate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a53934ac1621f8bd1c55ef9ccbf9e4a11"></a><!-- doxytag: member="spot::loopless_modular_mixed_radix_gray_code::~loopless_modular_mixed_radix_gray_code" ref="a53934ac1621f8bd1c55ef9ccbf9e4a11" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual spot::loopless_modular_mixed_radix_gray_code::~loopless_modular_mixed_radix_gray_code </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af1aab585098500e6acb78675967ef530"></a><!-- doxytag: member="spot::loopless_modular_mixed_radix_gray_code::a_first" ref="af1aab585098500e6acb78675967ef530" args="(int j)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void spot::loopless_modular_mixed_radix_gray_code::a_first </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset a<sub>j</sub> to its initial value. </p>

</div>
</div>
<a class="anchor" id="aed1aa03144c6dcb46e13c38b5c51a260"></a><!-- doxytag: member="spot::loopless_modular_mixed_radix_gray_code::a_last" ref="aed1aa03144c6dcb46e13c38b5c51a260" args="(int j) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool spot::loopless_modular_mixed_radix_gray_code::a_last </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Whether a<sub>j</sub> is on its last value. </p>

</div>
</div>
<a class="anchor" id="ad2299afa2a00ff9cc5f202b9854bdf4d"></a><!-- doxytag: member="spot::loopless_modular_mixed_radix_gray_code::a_next" ref="ad2299afa2a00ff9cc5f202b9854bdf4d" args="(int j)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void spot::loopless_modular_mixed_radix_gray_code::a_next </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Advance a<sub>j</sub> to its next value. </p>
<p>This will never be called if a_last(j) is true. </p>

</div>
</div>
<a class="anchor" id="a60dcf75008df5bbab91533ee6ac03297"></a><!-- doxytag: member="spot::loopless_modular_mixed_radix_gray_code::done" ref="a60dcf75008df5bbab91533ee6ac03297" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spot::loopless_modular_mixed_radix_gray_code::done </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Whether all tuple have been explored. </p>

<p>References <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a01d93ad137b3a2368270ec3779e32eee">done_</a>.</p>

</div>
</div>
<a class="anchor" id="a9c918e8524bdeb3e3a80054becbd30df"></a><!-- doxytag: member="spot::loopless_modular_mixed_radix_gray_code::first" ref="a9c918e8524bdeb3e3a80054becbd30df" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spot::loopless_modular_mixed_radix_gray_code::first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset the iteration to the first tuple. </p>
<p>This must be called before calling any of <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a5ef37d3a269687be631a65769ad209b9" title="Update one item of the tuple and return its position.">next()</a>, <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a98269cadd64926b5cf408cc4ab0ed2a5" title="Whether this the last tuple.">last()</a>, or <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a60dcf75008df5bbab91533ee6ac03297" title="Whether all tuple have been explored.">done()</a>. </p>

</div>
</div>
<a class="anchor" id="a98269cadd64926b5cf408cc4ab0ed2a5"></a><!-- doxytag: member="spot::loopless_modular_mixed_radix_gray_code::last" ref="a98269cadd64926b5cf408cc4ab0ed2a5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spot::loopless_modular_mixed_radix_gray_code::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Whether this the last tuple. </p>
<p>At this point it is still OK to call <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a5ef37d3a269687be631a65769ad209b9" title="Update one item of the tuple and return its position.">next()</a>, and then <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a60dcf75008df5bbab91533ee6ac03297" title="Whether all tuple have been explored.">done()</a> will become true. </p>

<p>References <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a6f86e8454e331df5b4aacf5eef3f41ef">f_</a>, and <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a2551f357ca1be741bc5300d06a4c3b63">n_</a>.</p>

</div>
</div>
<a class="anchor" id="a5ef37d3a269687be631a65769ad209b9"></a><!-- doxytag: member="spot::loopless_modular_mixed_radix_gray_code::next" ref="a5ef37d3a269687be631a65769ad209b9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spot::loopless_modular_mixed_radix_gray_code::next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update one item of the tuple and return its position. </p>
<p><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a5ef37d3a269687be631a65769ad209b9" title="Update one item of the tuple and return its position.">next()</a> should never be called if <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a60dcf75008df5bbab91533ee6ac03297" title="Whether all tuple have been explored.">done()</a> is true. If it is called on the last tuple (i.e., <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a98269cadd64926b5cf408cc4ab0ed2a5" title="Whether this the last tuple.">last()</a> is true), it will return -1. Otherwise it will update one a<sub>j</sub> of the tuple through one the a<sub>j</sub> handling functions, and return j. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a68e9eea9d2632d66f2ef1042f2d27b68"></a><!-- doxytag: member="spot::loopless_modular_mixed_radix_gray_code::a_" ref="a68e9eea9d2632d66f2ef1042f2d27b68" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a68e9eea9d2632d66f2ef1042f2d27b68">spot::loopless_modular_mixed_radix_gray_code::a_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a01d93ad137b3a2368270ec3779e32eee"></a><!-- doxytag: member="spot::loopless_modular_mixed_radix_gray_code::done_" ref="a01d93ad137b3a2368270ec3779e32eee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a01d93ad137b3a2368270ec3779e32eee">spot::loopless_modular_mixed_radix_gray_code::done_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a60dcf75008df5bbab91533ee6ac03297">done()</a>.</p>

</div>
</div>
<a class="anchor" id="a6f86e8454e331df5b4aacf5eef3f41ef"></a><!-- doxytag: member="spot::loopless_modular_mixed_radix_gray_code::f_" ref="a6f86e8454e331df5b4aacf5eef3f41ef" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a6f86e8454e331df5b4aacf5eef3f41ef">spot::loopless_modular_mixed_radix_gray_code::f_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a98269cadd64926b5cf408cc4ab0ed2a5">last()</a>.</p>

</div>
</div>
<a class="anchor" id="aa8342a062c7d6845b4473c0617bb4552"></a><!-- doxytag: member="spot::loopless_modular_mixed_radix_gray_code::m_" ref="aa8342a062c7d6845b4473c0617bb4552" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#aa8342a062c7d6845b4473c0617bb4552">spot::loopless_modular_mixed_radix_gray_code::m_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2551f357ca1be741bc5300d06a4c3b63"></a><!-- doxytag: member="spot::loopless_modular_mixed_radix_gray_code::n_" ref="a2551f357ca1be741bc5300d06a4c3b63" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a2551f357ca1be741bc5300d06a4c3b63">spot::loopless_modular_mixed_radix_gray_code::n_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a98269cadd64926b5cf408cc4ab0ed2a5">last()</a>.</p>

</div>
</div>
<a class="anchor" id="a7c8c0adbecfdb2060d4696cf2bbf799e"></a><!-- doxytag: member="spot::loopless_modular_mixed_radix_gray_code::non_one_radixes_" ref="a7c8c0adbecfdb2060d4696cf2bbf799e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a7c8c0adbecfdb2060d4696cf2bbf799e">spot::loopless_modular_mixed_radix_gray_code::non_one_radixes_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3dfc0ecaeaf71747a972ce8339d63e50"></a><!-- doxytag: member="spot::loopless_modular_mixed_radix_gray_code::s_" ref="a3dfc0ecaeaf71747a972ce8339d63e50" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#a3dfc0ecaeaf71747a972ce8339d63e50">spot::loopless_modular_mixed_radix_gray_code::s_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>misc/<a class="el" href="modgray_8hh_source.html">modgray.hh</a></li>
</ul>
</div>
<hr size="1">
Please <b>comment</b> this page and <b>report errors</b> about it on
<a href="http://spot.lip6.fr/wiki/RefDocComments">the RefDocComments page</a>.
<br><address style="align: right;"><small>
Generated on Mon Nov 28 2011 15:23:18 for spot by <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border=0></a> 1.7.4</small></address>
</body>
</html>
