<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>spot: spot Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">spot&#160;<span id="projectnumber">0.8</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">spot Namespace Reference</div>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1eltl.html">eltl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html">ltl</a></td></tr>
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1evtgba.html">evtgba</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1evtgba__iterator.html">evtgba_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1evtgba__explicit.html">evtgba_explicit</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1state__evtgba__explicit.html">state_evtgba_explicit</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">States used by spot::tgba_evtgba_explicit.  <a href="classspot_1_1state__evtgba__explicit.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1evtgba__product.html">evtgba_product</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1symbol.html">symbol</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1rsymbol.html">rsymbol</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1evtgba__reachable__iterator.html">evtgba_reachable_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all reachable states of a <a class="el" href="classspot_1_1evtgba.html">spot::evtgba</a>.  <a href="classspot_1_1evtgba__reachable__iterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1evtgba__reachable__iterator__depth__first.html">evtgba_reachable_iterator_depth_first</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="classspot_1_1evtgba__reachable__iterator.html" title="Iterate over all reachable states of a spot::evtgba.">spot::evtgba_reachable_iterator</a> that browses states depth first.  <a href="classspot_1_1evtgba__reachable__iterator__depth__first.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1evtgba__reachable__iterator__breadth__first.html">evtgba_reachable_iterator_breadth_first</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="classspot_1_1evtgba__reachable__iterator.html" title="Iterate over all reachable states of a spot::evtgba.">spot::evtgba_reachable_iterator</a> that browses states breadth first.  <a href="classspot_1_1evtgba__reachable__iterator__breadth__first.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1fair__kripke__succ__iterator.html">fair_kripke_succ_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator code for a Fair Kripke structure.This iterator can be used to simplify the writing of an iterator on a Fair Kripke structure (or lookalike).  <a href="classspot_1_1fair__kripke__succ__iterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1fair__kripke.html">fair_kripke</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for a Fair Kripke structure.A Kripke structure is a graph in which each node (=state) is labeled by a conjunction of atomic proposition, and a set of acceptance conditions.  <a href="classspot_1_1fair__kripke.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1kripke__succ__iterator.html">kripke_succ_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator code for Kripke structureThis iterator can be used to simplify the writing of an iterator on a Kripke structure (or lookalike).  <a href="classspot_1_1kripke__succ__iterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1kripke.html">kripke</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for a Kripke structureA Kripke structure is a graph in which each node (=state) is labeled by a conjunction of atomic proposition.  <a href="classspot_1_1kripke.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1state__kripke.html">state_kripke</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete class for kripke states.  <a href="classspot_1_1state__kripke.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1kripke__explicit__succ__iterator.html">kripke_explicit_succ_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement iterator pattern on successor of a <a class="el" href="classspot_1_1state__kripke.html" title="Concrete class for kripke states.">state_kripke</a>.  <a href="classspot_1_1kripke__explicit__succ__iterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1kripke__explicit.html">kripke_explicit</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Kripke Structure.  <a href="classspot_1_1kripke__explicit.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1acceptance__convertor.html">acceptance_convertor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Help class to convert between acceptance conditions to other BDD formats.  <a href="classspot_1_1acceptance__convertor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__allocator.html">bdd_allocator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Manage ranges of variables.  <a href="classspot_1_1bdd__allocator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1bdd__less__than.html">bdd_less_than</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison functor for BDDs.  <a href="structspot_1_1bdd__less__than.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1bdd__hash.html">bdd_hash</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor for BDDs.  <a href="structspot_1_1bdd__hash.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1fixed__size__pool.html">fixed_size_pool</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A fixed-size memory pool implementation.  <a href="classspot_1_1fixed__size__pool.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1free__list.html">free_list</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Manage list of free integers.  <a href="classspot_1_1free__list.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1ptr__hash.html">ptr_hash</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A hash function for pointers.  <a href="structspot_1_1ptr__hash.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1string__hash.html">string_hash</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A hash function for strings.  <a href="structspot_1_1string__hash.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1identity__hash.html">identity_hash</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A hash function that returns identity.  <a href="structspot_1_1identity__hash.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1char__ptr__less__than.html">char_ptr_less_than</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Strict Weak Ordering for <code>char*</code>.This is meant to be used as a comparison functor for STL <code>map</code> whose key are of type <code>const char*</code>.  <a href="structspot_1_1char__ptr__less__than.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1minato__isop.html">minato_isop</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an irredundant sum-of-products (ISOP) form of a BDD function.This algorithm implements a derecursived version the Minato-Morreale algorithm presented in the following paper.  <a href="classspot_1_1minato__isop.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1loopless__modular__mixed__radix__gray__code.html">loopless_modular_mixed_radix_gray_code</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Loopless modular mixed radix Gray code iteration.This class is based on the loopless modular mixed radix gray code algorithm described in exercise 77 of "The Art of Computer
      Programming", Pre-Fascicle 2A (Draft of section 7.2.1.1: generating all n-tuples) by Donald E. Knuth.  <a href="classspot_1_1loopless__modular__mixed__radix__gray__code.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1multiple__size__pool.html">multiple_size_pool</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A multiple-size memory pool implementation.  <a href="classspot_1_1multiple__size__pool.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1option__map.html">option_map</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Manage a map of options.Each option is defined by a string and is associated to an integer value.  <a href="classspot_1_1option__map.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1barand.html">barand</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute pseudo-random integer value between 0 and <em>n</em> included, following a binomial distribution for probability <em>p</em>.  <a href="classspot_1_1barand.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1time__info.html">time_info</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure to record elapsed time in clock ticks.  <a href="structspot_1_1time__info.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1timer.html">timer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A timekeeper that accumulate interval of time.  <a href="classspot_1_1timer.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1timer__map.html">timer_map</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A map of timer, where each timer has a name.  <a href="classspot_1_1timer__map.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1explicit__state__conjunction.html">explicit_state_conjunction</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic implementation of <a class="el" href="classspot_1_1saba__state__conjunction.html" title="Iterate over a conjunction of saba_state.This class provides the basic functionalities required to it...">saba_state_conjunction</a>.This class provides a basic implementation to iterate over a conjunction of states of a saba.  <a href="classspot_1_1explicit__state__conjunction.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1saba.html">saba</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A State-based Alternating (Generalized) Büchi Automaton.Browsing such automaton can be achieved using two functions: <code>get_init_state</code>, and <code>succ_iter</code>. The former returns the initial state while the latter lists the successor states of any state.  <a href="classspot_1_1saba.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1saba__complement__tgba.html">saba_complement_tgba</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Complement a TGBA and produce a SABA.The original TGBA is transformed into a States-based Büchi Automaton.  <a href="classspot_1_1saba__complement__tgba.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1saba__state.html">saba_state</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for saba states.  <a href="classspot_1_1saba__state.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1saba__state__ptr__less__than.html">saba_state_ptr_less_than</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Strict Weak Ordering for <code>saba_state*</code>.This is meant to be used as a comparison functor for STL <code>map</code> whose key are of type <code>saba_state*</code>.  <a href="structspot_1_1saba__state__ptr__less__than.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1saba__state__ptr__equal.html">saba_state_ptr_equal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An Equivalence Relation for <code>saba_state*</code>.This is meant to be used as a comparison functor for Sgi <code>hash_map</code> whose key are of type <code>saba_state*</code>.  <a href="structspot_1_1saba__state__ptr__equal.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1saba__state__ptr__hash.html">saba_state_ptr_hash</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash Function for <code>saba_state*</code>.This is meant to be used as a hash functor for Sgi's <code>hash_map</code> whose key are of type <code>saba_state*</code>.  <a href="structspot_1_1saba__state__ptr__hash.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1saba__state__shared__ptr__less__than.html">saba_state_shared_ptr_less_than</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Strict Weak Ordering for <code>shared_saba_state</code> (shared_ptr&lt;const saba_state*&gt;).This is meant to be used as a comparison functor for STL <code>map</code> whose key are of type <code>shared_saba_state</code>.  <a href="structspot_1_1saba__state__shared__ptr__less__than.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1saba__state__shared__ptr__equal.html">saba_state_shared_ptr_equal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An Equivalence Relation for <code>shared_saba_state</code> (shared_ptr&lt;const saba_state*&gt;).This is meant to be used as a comparison functor for Sgi <code>hash_map</code> whose key are of type <code>shared_saba_state</code>.  <a href="structspot_1_1saba__state__shared__ptr__equal.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1saba__state__shared__ptr__hash.html">saba_state_shared_ptr_hash</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash Function for <code>shared_saba_state</code> (shared_ptr&lt;const saba_state*&gt;).This is meant to be used as a hash functor for Sgi's <code>hash_map</code> whose key are of type <code>shared_saba_state</code>.  <a href="structspot_1_1saba__state__shared__ptr__hash.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1saba__state__conjunction.html">saba_state_conjunction</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over a conjunction of <a class="el" href="classspot_1_1saba__state.html" title="Abstract class for saba states.">saba_state</a>.This class provides the basic functionalities required to iterate over a conjunction of states of a saba.  <a href="classspot_1_1saba__state__conjunction.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1saba__succ__iterator.html">saba_succ_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over the successors of a <a class="el" href="classspot_1_1saba__state.html" title="Abstract class for saba states.">saba_state</a>.This class provides the basic functionalities required to iterate over the successors of a state of a saba. Since transitions of an alternating automaton are defined as a boolean function with conjunctions (universal) and disjunctions (non-deterministic),.  <a href="classspot_1_1saba__succ__iterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1saba__reachable__iterator.html">saba_reachable_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all reachable states of a <a class="el" href="classspot_1_1saba.html" title="A State-based Alternating (Generalized) Büchi Automaton.Browsing such automaton can be achieved using...">spot::saba</a>.  <a href="classspot_1_1saba__reachable__iterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1saba__reachable__iterator__depth__first.html">saba_reachable_iterator_depth_first</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="classspot_1_1saba__reachable__iterator.html" title="Iterate over all reachable states of a spot::saba.">spot::saba_reachable_iterator</a> that browses states depth first.  <a href="classspot_1_1saba__reachable__iterator__depth__first.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1saba__reachable__iterator__breadth__first.html">saba_reachable_iterator_breadth_first</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="classspot_1_1saba__reachable__iterator.html" title="Iterate over all reachable states of a spot::saba.">spot::saba_reachable_iterator</a> that browses states breadth first.  <a href="classspot_1_1saba__reachable__iterator__breadth__first.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Map BDD variables to formulae.  <a href="classspot_1_1bdd__dict.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1future__conditions__collector.html">future_conditions_collector</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a tgba to offer information about upcoming conditions.This class is a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> wrapper that simply add a new method, <a class="el" href="classspot_1_1future__conditions__collector.html#a9417271a5ecac3517205108fbcf1e638" title="Returns the set of future conditions visible after s.">future_conditions()</a>, to any <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a>.  <a href="classspot_1_1future__conditions__collector.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1state.html">state</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for states.  <a href="classspot_1_1state.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1state__ptr__less__than.html">state_ptr_less_than</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Strict Weak Ordering for <code>state*</code>.This is meant to be used as a comparison functor for STL <code>map</code> whose key are of type <code>state*</code>.  <a href="structspot_1_1state__ptr__less__than.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1state__ptr__equal.html">state_ptr_equal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An Equivalence Relation for <code>state*</code>.This is meant to be used as a comparison functor for Sgi <code>hash_map</code> whose key are of type <code>state*</code>.  <a href="structspot_1_1state__ptr__equal.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1state__ptr__hash.html">state_ptr_hash</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash Function for <code>state*</code>.This is meant to be used as a hash functor for Sgi's <code>hash_map</code> whose key are of type <code>state*</code>.  <a href="structspot_1_1state__ptr__hash.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1state__shared__ptr__less__than.html">state_shared_ptr_less_than</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Strict Weak Ordering for <code>shared_state</code> (shared_ptr&lt;const state*&gt;).This is meant to be used as a comparison functor for STL <code>map</code> whose key are of type <code>shared_state</code>.  <a href="structspot_1_1state__shared__ptr__less__than.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1state__shared__ptr__equal.html">state_shared_ptr_equal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An Equivalence Relation for <code>shared_state</code> (shared_ptr&lt;const state*&gt;).This is meant to be used as a comparison functor for Sgi <code>hash_map</code> whose key are of type <code>shared_state</code>.  <a href="structspot_1_1state__shared__ptr__equal.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1state__shared__ptr__hash.html">state_shared_ptr_hash</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash Function for <code>shared_state</code> (shared_ptr&lt;const state*&gt;).This is meant to be used as a hash functor for Sgi's <code>hash_map</code> whose key are of type <code>shared_state</code>.  <a href="structspot_1_1state__shared__ptr__hash.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1state__bdd.html">state_bdd</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__succ__iterator.html">tgba_succ_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over the successors of a state.This class provides the basic functionalities required to iterate over the successors of a state, as well as querying transition labels. Because transitions are never explicitely encoded, labels (conditions and acceptance conditions) can only be queried while iterating over the successors.  <a href="classspot_1_1tgba__succ__iterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__succ__iterator__concrete.html">tgba_succ_iterator_concrete</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1taa__tgba.html">taa_tgba</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A self-loop Transition-based Alternating Automaton (TAA) which is seen as a TGBA (abstract class, see below).  <a href="classspot_1_1taa__tgba.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1state__set.html">state_set</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of states deriving from <a class="el" href="classspot_1_1state.html" title="Abstract class for states.">spot::state</a>.  <a href="classspot_1_1state__set.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1taa__succ__iterator.html">taa_succ_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1taa__tgba__labelled.html">taa_tgba_labelled</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1taa__tgba__string.html">taa_tgba_string</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1taa__tgba__formula.html">taa_tgba_formula</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba.html">tgba</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi Automaton) was coined by Dimitra Giannakopoulou and Flavio Lerda in "From States to Transitions: Improving Translation of LTL
      Formulae to Büchi Automata". (FORTE'02)  <a href="classspot_1_1tgba.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__bdd__concrete.html">tgba_bdd_concrete</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A concrete <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> implemented using BDDs.  <a href="classspot_1_1tgba__bdd__concrete.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__bdd__concrete__factory.html">tgba_bdd_concrete_factory</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to build a <a class="el" href="classspot_1_1tgba__bdd__concrete.html" title="A concrete spot::tgba implemented using BDDs.">spot::tgba_bdd_concrete</a> object.  <a href="classspot_1_1tgba__bdd__concrete__factory.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1tgba__bdd__core__data.html">tgba_bdd_core_data</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Core data for a TGBA encoded using BDDs.  <a href="structspot_1_1tgba__bdd__core__data.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__bdd__factory.html">tgba_bdd_factory</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for <a class="el" href="classspot_1_1tgba__bdd__concrete.html" title="A concrete spot::tgba implemented using BDDs.">spot::tgba_bdd_concrete</a> factories.  <a href="classspot_1_1tgba__bdd__factory.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1state__explicit.html">state_explicit</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__explicit.html">tgba_explicit</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__explicit__succ__iterator.html">tgba_explicit_succ_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__explicit__labelled.html">tgba_explicit_labelled</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classspot_1_1tgba__explicit.html">tgba_explicit</a> instance with states labeled by a given type.  <a href="classspot_1_1tgba__explicit__labelled.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__explicit__string.html">tgba_explicit_string</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__explicit__formula.html">tgba_explicit_formula</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__explicit__number.html">tgba_explicit_number</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bdd__ordered.html">bdd_ordered</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__kv__complement.html">tgba_kv_complement</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a complemented automaton.The construction comes from:  <a href="classspot_1_1tgba__kv__complement.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1state__product.html">state_product</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A state for <a class="el" href="classspot_1_1tgba__product.html" title="A lazy product. (States are computed on the fly.)">spot::tgba_product</a>.This state is in fact a pair of state: the state from the left automaton and that of the right.  <a href="classspot_1_1state__product.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__product.html">tgba_product</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A lazy product. (States are computed on the fly.)  <a href="classspot_1_1tgba__product.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__product__init.html">tgba_product_init</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A lazy product with different initial states.  <a href="classspot_1_1tgba__product__init.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1direct__simulation__relation.html">direct_simulation_relation</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1delayed__simulation__relation.html">delayed_simulation_relation</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__reduc.html">tgba_reduc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__safra__complement.html">tgba_safra_complement</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a complemented automaton.It creates an automaton that recognizes the negated language of <em>aut</em>.  <a href="classspot_1_1tgba__safra__complement.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__scc.html">tgba_scc</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a tgba to offer information about strongly connected components.This class is a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> wrapper that simply add a new method <a class="el" href="classspot_1_1tgba__scc.html#a0710f2fdfd1d418eef39b96f03b21d68" title="Returns the number of the SCC s belongs to.">scc_of_state()</a> to retrieve the number of a SCC a state belongs to.  <a href="classspot_1_1tgba__scc.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__sgba__proxy.html">tgba_sgba_proxy</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the labeling-mode of <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> on the fly, producing a state-based generalized Büchi automaton.This class acts as a proxy in front of a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a>, that should label on states on-the-fly. The result is still a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a>, but acceptances conditions are also on states.  <a href="classspot_1_1tgba__sgba__proxy.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__tba__proxy.html">tgba_tba_proxy</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Degeneralize a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> on the fly, producing a TBA.This class acts as a proxy in front of a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a>, that should be degeneralized on the fly. The result is still a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a>, but it will always have exactly one acceptance condition so it could be called TBA (without the G).  <a href="classspot_1_1tgba__tba__proxy.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__sba__proxy.html">tgba_sba_proxy</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Degeneralize a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> on the fly, producing an SBA.This class acts as a proxy in front of a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a>, that should be degeneralized on the fly.  <a href="classspot_1_1tgba__sba__proxy.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1state__union.html">state_union</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A state for <a class="el" href="classspot_1_1tgba__union.html" title="A lazy union. (States are computed on the fly.)">spot::tgba_union</a>.This state is in fact a pair. If the first member equals 0 and the second is different from 0, the state belongs to the left automaton. If the first member is different from 0 and the second is 0, the state belongs to the right automaton. If both members are 0, the state is the initial state.  <a href="classspot_1_1state__union.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__succ__iterator__union.html">tgba_succ_iterator_union</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over the successors of an union computed on the fly.  <a href="classspot_1_1tgba__succ__iterator__union.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__union.html">tgba_union</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A lazy union. (States are computed on the fly.)  <a href="classspot_1_1tgba__union.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1bfs__steps.html">bfs_steps</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a BFS in a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> to compute a <a class="el" href="structspot_1_1tgba__run.html#a992869805fc5a8c3146e77309be61312">tgba_run::steps</a>.This class should be used to compute the shortest path between a state of a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> and the first transition or state that matches some conditions.  <a href="classspot_1_1bfs__steps.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1sccs__set.html">sccs_set</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1dotty__decorator.html">dotty_decorator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose state and link styles for <a class="el" href="namespacespot.html#ab3ff98345b771b22e0a9b67063676e84" title="Print reachable states in dot format.">spot::dotty_reachable</a>.  <a href="classspot_1_1dotty__decorator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1emptiness__check__result.html">emptiness_check_result</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The result of an emptiness check.  <a href="classspot_1_1emptiness__check__result.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Common interface to emptiness check algorithms.  <a href="classspot_1_1emptiness__check.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1emptiness__check__instantiator.html">emptiness_check_instantiator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1tgba__run.html">tgba_run</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An accepted run, for a tgba.  <a href="structspot_1_1tgba__run.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1unsigned__statistics.html">unsigned_statistics</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1unsigned__statistics__copy.html">unsigned_statistics_copy</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">comparable statistics  <a href="classspot_1_1unsigned__statistics__copy.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ec__statistics.html">ec_statistics</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Emptiness-check statistics.  <a href="classspot_1_1ec__statistics.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ars__statistics.html">ars_statistics</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accepting Run Search statistics.  <a href="classspot_1_1ars__statistics.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1acss__statistics.html">acss_statistics</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accepting Cycle Search Space statistics.  <a href="classspot_1_1acss__statistics.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1couvreur99__check__result.html">couvreur99_check_result</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a counter example from a <a class="el" href="classspot_1_1couvreur99__check__status.html" title="The status of the emptiness-check on success.">spot::couvreur99_check_status</a>.  <a href="classspot_1_1couvreur99__check__result.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1explicit__connected__component.html">explicit_connected_component</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An SCC storing all its states explicitly.  <a href="classspot_1_1explicit__connected__component.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1connected__component__hash__set.html">connected_component_hash_set</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1explicit__connected__component__factory.html">explicit_connected_component_factory</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract factory for <a class="el" href="classspot_1_1explicit__connected__component.html" title="An SCC storing all its states explicitly.">explicit_connected_component</a>.  <a href="classspot_1_1explicit__connected__component__factory.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1connected__component__hash__set__factory.html">connected_component_hash_set_factory</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for <a class="el" href="classspot_1_1connected__component__hash__set.html">connected_component_hash_set</a>.  <a href="classspot_1_1connected__component__hash__set__factory.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1couvreur99__check.html">couvreur99_check</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of the Couvreur99 emptiness-check algorithm.  <a href="classspot_1_1couvreur99__check.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1couvreur99__check__shy.html">couvreur99_check_shy</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A version of <a class="el" href="classspot_1_1couvreur99__check.html" title="An implementation of the Couvreur99 emptiness-check algorithm.">spot::couvreur99_check</a> that tries to visit known states first.  <a href="classspot_1_1couvreur99__check__shy.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1numbered__state__heap__const__iterator.html">numbered_state_heap_const_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator on <a class="el" href="classspot_1_1numbered__state__heap.html" title="Keep track of a large quantity of indexed states.">numbered_state_heap</a> objects.  <a href="classspot_1_1numbered__state__heap__const__iterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1numbered__state__heap.html">numbered_state_heap</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep track of a large quantity of indexed states.  <a href="classspot_1_1numbered__state__heap.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1numbered__state__heap__factory.html">numbered_state_heap_factory</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract factory for <a class="el" href="classspot_1_1numbered__state__heap.html" title="Keep track of a large quantity of indexed states.">numbered_state_heap</a>.  <a href="classspot_1_1numbered__state__heap__factory.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1numbered__state__heap__hash__map.html">numbered_state_heap_hash_map</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A straightforward implementation of <a class="el" href="classspot_1_1numbered__state__heap.html" title="Keep track of a large quantity of indexed states.">numbered_state_heap</a> with a hash map.  <a href="classspot_1_1numbered__state__heap__hash__map.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1numbered__state__heap__hash__map__factory.html">numbered_state_heap_hash_map_factory</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for <a class="el" href="classspot_1_1numbered__state__heap__hash__map.html" title="A straightforward implementation of numbered_state_heap with a hash map.">numbered_state_heap_hash_map</a>.  <a href="classspot_1_1numbered__state__heap__hash__map__factory.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1scc__stack.html">scc_stack</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1couvreur99__check__status.html">couvreur99_check_status</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The status of the emptiness-check on success.  <a href="classspot_1_1couvreur99__check__status.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1power__map.html">power_map</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__reachable__iterator.html">tgba_reachable_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all reachable states of a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a>.  <a href="classspot_1_1tgba__reachable__iterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__reachable__iterator__depth__first.html">tgba_reachable_iterator_depth_first</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="classspot_1_1tgba__reachable__iterator.html" title="Iterate over all reachable states of a spot::tgba.">spot::tgba_reachable_iterator</a> that browses states depth first.  <a href="classspot_1_1tgba__reachable__iterator__depth__first.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__reachable__iterator__breadth__first.html">tgba_reachable_iterator_breadth_first</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="classspot_1_1tgba__reachable__iterator.html" title="Iterate over all reachable states of a spot::tgba.">spot::tgba_reachable_iterator</a> that browses states breadth first.  <a href="classspot_1_1tgba__reachable__iterator__breadth__first.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1parity__game__graph.html">parity_game_graph</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parity game graph which compute a simulation relation.  <a href="classspot_1_1parity__game__graph.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1spoiler__node.html">spoiler_node</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Spoiler node of parity game graph.  <a href="classspot_1_1spoiler__node.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1duplicator__node.html">duplicator_node</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicator node of parity game graph.  <a href="classspot_1_1duplicator__node.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1parity__game__graph__direct.html">parity_game_graph_direct</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parity game graph which compute the direct simulation relation.  <a href="classspot_1_1parity__game__graph__direct.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1spoiler__node__delayed.html">spoiler_node_delayed</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Spoiler node of parity game graph for delayed simulation.  <a href="classspot_1_1spoiler__node__delayed.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1duplicator__node__delayed.html">duplicator_node_delayed</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicator node of parity game graph for delayed simulation.  <a href="classspot_1_1duplicator__node__delayed.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1parity__game__graph__delayed.html">parity_game_graph_delayed</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1tgba__run__dotty__decorator.html">tgba_run_dotty_decorator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Highlight a <a class="el" href="structspot_1_1tgba__run.html" title="An accepted run, for a tgba.">spot::tgba_run</a> on a <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a>.An instance of this class can be passed to <a class="el" href="namespacespot.html#ab3ff98345b771b22e0a9b67063676e84" title="Print reachable states in dot format.">spot::dotty_reachable</a>.  <a href="classspot_1_1tgba__run__dotty__decorator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1scc__stats.html">scc_stats</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1scc__map.html">scc_map</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a map of Strongly Connected components in in a TGBA.  <a href="classspot_1_1scc__map.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1tgba__statistics.html">tgba_statistics</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1tgba__sub__statistics.html">tgba_sub_statistics</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1weight.html">weight</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Manage for a given automaton a vector of counter indexed by its acceptance condition.  <a href="classspot_1_1weight.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1gspn__exception.html">gspn_exception</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception used to forward GSPN errors.  <a href="classspot_1_1gspn__exception.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1gspn__interface.html">gspn_interface</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1gspn__ssp__interface.html">gspn_ssp_interface</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; const <a class="el" href="classspot_1_1symbol.html">symbol</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#ab1fe964166144356a185c98ce0bcbde6">symbol_set</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; <a class="el" href="classspot_1_1rsymbol.html">rsymbol</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a5f139f442de158fbe3bf9fab3ddee7f3">rsymbol_set</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::pair<br class="typebreak"/>
&lt; evtgbayy::location, <br class="typebreak"/>
std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#ad049f28e03c2ebe740e5597034fd5c93">evtgba_parse_error</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A parse diagnostic with its location.  <a href="#ad049f28e03c2ebe740e5597034fd5c93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::list<br class="typebreak"/>
&lt; <a class="el" href="namespacespot.html#ad049f28e03c2ebe740e5597034fd5c93">evtgba_parse_error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a90dc0e2318bb80c45893922f42ec44fe">evtgba_parse_error_list</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of parser diagnostics, as filled by parse.  <a href="#a90dc0e2318bb80c45893922f42ec44fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::pair<br class="typebreak"/>
&lt; <a class="el" href="classkripkeyy_1_1location.html">kripkeyy::location</a>, <br class="typebreak"/>
std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a68ac7577bed0b7af5dd8e45135797759">kripke_parse_error</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A parse diagnostic with its location.  <a href="#a68ac7577bed0b7af5dd8e45135797759"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::list<br class="typebreak"/>
&lt; <a class="el" href="namespacespot.html#a68ac7577bed0b7af5dd8e45135797759">kripke_parse_error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a429e9facc10a0958d14ff3f94d71b006">kripke_parse_error_list</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of parser diagnostics, as filled by parse.  <a href="#a429e9facc10a0958d14ff3f94d71b006"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::pair<br class="typebreak"/>
&lt; <a class="el" href="classneverclaimyy_1_1location.html">neverclaimyy::location</a>, <br class="typebreak"/>
std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#ga3a14d5793c8decc8de5c19f640c721bf">neverclaim_parse_error</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A parse diagnostic with its location.  <a href="group__tgba__io.html#ga3a14d5793c8decc8de5c19f640c721bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::list<br class="typebreak"/>
&lt; <a class="el" href="group__tgba__io.html#ga3a14d5793c8decc8de5c19f640c721bf">neverclaim_parse_error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#ga15242b071d7c485804548ff2ee41b3d1">neverclaim_parse_error_list</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of parser diagnostics, as filled by parse.  <a href="group__tgba__io.html#ga15242b071d7c485804548ff2ee41b3d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; const <a class="el" href="classspot_1_1saba__state.html">saba_state</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a5494e2802ca03bd036c523a1c65f3a3e">shared_saba_state</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; const <a class="el" href="classspot_1_1state.html">state</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a13a1db95095eccfe0a4ce4a818442fbf">shared_state</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="classspot_1_1bdd__ordered.html">bdd_ordered</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a4260b69cfc6b42df1b242d141d250acc">acc_list_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; const <br class="typebreak"/>
<a class="el" href="classspot_1_1state.html">spot::state</a> *, const <br class="typebreak"/>
<a class="el" href="classspot_1_1state.html">spot::state</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a335079e354907be71c014b01c2fb1573">state_couple</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="namespacespot.html#a335079e354907be71c014b01c2fb1573">state_couple</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a9ec17bbfe207de0e9c4e699ee3f02572">simulation_relation</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="classspot_1_1spoiler__node.html">spoiler_node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__reduction.html#gaa807b9e3dabba60063c3dff70244c79a">sn_v</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="classspot_1_1duplicator__node.html">duplicator_node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__reduction.html#ga57d3005aa0c7d42803556c39d62d2995">dn_v</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; const <br class="typebreak"/>
<a class="el" href="classspot_1_1state.html">state</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__reduction.html#ga1aecc57153bbe4d48c62d7dcedde5afb">s_v</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::pair<br class="typebreak"/>
&lt; tgbayy::location, <br class="typebreak"/>
std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#gadcc2cd9b328a5c3f63918c577f86f18c">tgba_parse_error</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A parse diagnostic with its location.  <a href="group__tgba__io.html#gadcc2cd9b328a5c3f63918c577f86f18c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::list<br class="typebreak"/>
&lt; <a class="el" href="group__tgba__io.html#gadcc2cd9b328a5c3f63918c577f86f18c">tgba_parse_error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#ga76b22bb081d5c36378098caa5bf58081">tgba_parse_error_list</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of parser diagnostics, as filled by parse.  <a href="group__tgba__io.html#ga76b22bb081d5c36378098caa5bf58081"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__reduction.html#ga5bd08ab74b3ab10a27beceaa04d9217a">reduce_tgba_options</a> { <br/>
&#160;&#160;<a class="el" href="group__tgba__reduction.html#gga5bd08ab74b3ab10a27beceaa04d9217aa28ab8e63b3f476424eec1d49fb19b1e6">Reduce_None</a> =  0, 
<a class="el" href="group__tgba__reduction.html#gga5bd08ab74b3ab10a27beceaa04d9217aa6ef94353974a1119b8c3265eb0bcbe42">Reduce_quotient_Dir_Sim</a> =  1, 
<a class="el" href="group__tgba__reduction.html#gga5bd08ab74b3ab10a27beceaa04d9217aa7b2d15a717f241527e25e1266370033e">Reduce_transition_Dir_Sim</a> =  2, 
<a class="el" href="group__tgba__reduction.html#gga5bd08ab74b3ab10a27beceaa04d9217aa040be3fac90f0ddb426644a52418d7a3">Reduce_quotient_Del_Sim</a> =  4, 
<br/>
&#160;&#160;<a class="el" href="group__tgba__reduction.html#gga5bd08ab74b3ab10a27beceaa04d9217aa21c74a793193bfe95e63b43ef1b59350">Reduce_transition_Del_Sim</a> =  8, 
<a class="el" href="group__tgba__reduction.html#gga5bd08ab74b3ab10a27beceaa04d9217aa685daa8530de270e1588cdc2c178a2ab">Reduce_Scc</a> =  16, 
<a class="el" href="group__tgba__reduction.html#gga5bd08ab74b3ab10a27beceaa04d9217aa81a405e18e9bbd601c4183e1c7ff49e1">Reduce_All</a> =  -1U
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for reduce.  <a href="group__tgba__reduction.html#ga5bd08ab74b3ab10a27beceaa04d9217a">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#ab3ff98345b771b22e0a9b67063676e84">dotty_reachable</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1evtgba.html">evtgba</a> *g)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print reachable states in dot format.  <a href="#ab3ff98345b771b22e0a9b67063676e84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#aade1f7e5b6c685b5393d8a6d3ab7e09d">evtgba_save_reachable</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1evtgba.html">evtgba</a> *g)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Save reachable states in text format.  <a href="#aade1f7e5b6c685b5393d8a6d3ab7e09d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1evtgba__explicit.html">evtgba_explicit</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a3b22a05fb3e16d693b2d80425dfa4500">tgba_to_evtgba</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a tgba into an evtgba.  <a href="#a3b22a05fb3e16d693b2d80425dfa4500"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1evtgba__explicit.html">evtgba_explicit</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a6805befaee0df3f7cb4427d30782f230">evtgba_parse</a> (const std::string &amp;filename, <a class="el" href="namespacespot.html#a90dc0e2318bb80c45893922f42ec44fe">evtgba_parse_error_list</a> &amp;error_list, bool debug=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="classspot_1_1evtgba__explicit.html">spot::evtgba_explicit</a> from a text file.  <a href="#a6805befaee0df3f7cb4427d30782f230"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a805ae4b750b93c1d2e19d81faa609065">format_evtgba_parse_errors</a> (std::ostream &amp;os, const std::string &amp;filename, <a class="el" href="namespacespot.html#a90dc0e2318bb80c45893922f42ec44fe">evtgba_parse_error_list</a> &amp;error_list)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Format diagnostics produced by <a class="el" href="namespacespot.html#a6805befaee0df3f7cb4427d30782f230" title="Build a spot::evtgba_explicit from a text file.">spot::evtgba_parse</a>.  <a href="#a805ae4b750b93c1d2e19d81faa609065"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#ga297ff6967b82ecb1de793bce48701379">kripke_save_reachable</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1kripke.html">kripke</a> *k)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the reachable part of Kripke structure in text format.  <a href="group__tgba__io.html#ga297ff6967b82ecb1de793bce48701379"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#ga65e6d2507fc1692b1405a26b7306379f">kripke_save_reachable_renumbered</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1kripke.html">kripke</a> *k)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the reachable part of Kripke structure in text format.  <a href="group__tgba__io.html#ga65e6d2507fc1692b1405a26b7306379f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1kripke__explicit.html">kripke_explicit</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#ad7749e1e9d7c9449aa0c0639f6e7add0">kripke_parse</a> (const std::string &amp;name, <a class="el" href="namespacespot.html#a429e9facc10a0958d14ff3f94d71b006">kripke_parse_error_list</a> &amp;error_list, <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, <a class="el" href="classspot_1_1ltl_1_1environment.html">ltl::environment</a> &amp;env=ltl::default_environment::instance(), bool debug=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a119f3d265650a37c30f816ad189725ae">format_kripke_parse_errors</a> (std::ostream &amp;os, const std::string &amp;filename, <a class="el" href="namespacespot.html#a429e9facc10a0958d14ff3f94d71b006">kripke_parse_error_list</a> &amp;error_list)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Format diagnostics produced by <a class="el" href="namespacespot.html#ad7749e1e9d7c9449aa0c0639f6e7add0">spot::kripke_parse</a>.  <a href="#a119f3d265650a37c30f816ad189725ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#gaae6fadac6a2f91d7b8e27b3eb6ad647e">is_bare_word</a> (const char *str)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#ga4731f21b7b43332b5c7b5bc63c6d67e6">quote_unless_bare_word</a> (const std::string &amp;str)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Double-quote words that are not bare.  <a href="group__misc__tools.html#ga4731f21b7b43332b5c7b5bc63c6d67e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bdd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a1c1c9963ce3385c106461526f80e4d7a">compute_all_acceptance_conditions</a> (bdd neg_acceptance_conditions)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute all acceptance conditions from all neg acceptance conditions.  <a href="#a1c1c9963ce3385c106461526f80e4d7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bdd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#acbfcdc0a54e339085eb6c5458c994832">compute_neg_acceptance_conditions</a> (bdd all_acceptance_conditions)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute neg acceptance conditions from all acceptance conditions.  <a href="#acbfcdc0a54e339085eb6c5458c994832"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#ga84a8b196e2ec651f0fd039c70c7ff6cb">escape_str</a> (std::ostream &amp;os, const std::string &amp;str)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape characters <code>"</code>, <code>\</code>, and <code>\n</code> in <em>str</em>.  <a href="group__misc__tools.html#ga84a8b196e2ec651f0fd039c70c7ff6cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#gad4b0b4fae7b93db7d704a5fef6e021c6">escape_str</a> (const std::string &amp;str)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape characters <code>"</code>, <code>\</code>, and <code>\n</code> in <em>str</em>.  <a href="group__misc__tools.html#gad4b0b4fae7b93db7d704a5fef6e021c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hash__funcs.html#ga9422ff0c16df957910dd4a0275d9f726">wang32_hash</a> (size_t key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Thomas Wang's 32 bit hash function.  <a href="group__hash__funcs.html#ga9422ff0c16df957910dd4a0275d9f726"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hash__funcs.html#gaea94dbea4a286b0bde253baf07e7a56e">knuth32_hash</a> (size_t key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Knuth's Multiplicative hash function.  <a href="group__hash__funcs.html#gaea94dbea4a286b0bde253baf07e7a56e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#ga5253b7b9fd60f3285091b39a1f1b815d">int_array_array_compress2</a> (const int *array, size_t n, int *dest, size_t &amp;dest_size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress an int array of size <em>n</em> into a int array.  <a href="group__misc__tools.html#ga5253b7b9fd60f3285091b39a1f1b815d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#gaed78e6934b190995ba5a162ad0e76560">int_array_array_decompress2</a> (const int *array, size_t array_size, int *res, size_t size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Uncompress an int array of size <em>array_size</em> into a int array of size <em>size</em>.  <a href="group__misc__tools.html#gaed78e6934b190995ba5a162ad0e76560"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#ga86ac44d535ef8f28e5d81a2edf907065">int_vector_vector_compress</a> (const std::vector&lt; int &gt; &amp;input, std::vector&lt; unsigned int &gt; &amp;output)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress an int vector into a vector of unsigned int.  <a href="group__misc__tools.html#ga86ac44d535ef8f28e5d81a2edf907065"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#gade72f3d754ef89b594db989893ee3e7b">int_vector_vector_decompress</a> (const std::vector&lt; unsigned int &gt; &amp;array, std::vector&lt; int &gt; &amp;output, size_t size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Uncompress a vector of unsigned int into a vector of size <em>size</em>.  <a href="group__misc__tools.html#gade72f3d754ef89b594db989893ee3e7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned int &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#gae8556060f7963410dd8c52d2426d7269">int_array_vector_compress</a> (const int *array, size_t n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress an int array if size <em>n</em> into a vector of unsigned int.  <a href="group__misc__tools.html#gae8556060f7963410dd8c52d2426d7269"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#ga6c161d70b36c5637b6511f2192f2d9bf">int_vector_array_decompress</a> (const std::vector&lt; unsigned int &gt; *array, int *res, size_t size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Uncompress a vector of unsigned int into an int array of size <em>size</em>.  <a href="group__misc__tools.html#ga6c161d70b36c5637b6511f2192f2d9bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#ga72a6bb80b592f562634a6bd8aedd9ff6">int_array_array_compress</a> (const int *array, size_t n, int *dest, size_t &amp;dest_size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress an int array of size <em>n</em> into a int array.  <a href="group__misc__tools.html#ga72a6bb80b592f562634a6bd8aedd9ff6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#gad595c02553de6187297d09d2b47c995c">int_array_array_decompress</a> (const int *array, size_t array_size, int *res, size_t size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Uncompress an int array of size <em>array_size</em> into a int array of size <em>size</em>.  <a href="group__misc__tools.html#gad595c02553de6187297d09d2b47c995c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a1a8d0610b61c0a30aad16791b0b73d15">memusage</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of pages in use by the program.  <a href="#a1a8d0610b61c0a30aad16791b0b73d15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__random.html#ga539812ab355a561fee1ecbfe60b276e4">srand</a> (unsigned int seed)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the seed of the pseudo-random number generator.  <a href="group__random.html#ga539812ab355a561fee1ecbfe60b276e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__random.html#ga86ce713fe60de9af440a7331de74aa1a">rrand</a> (int min, int max)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a pseudo-random integer value between <em>min</em> and <em>max</em> included.  <a href="group__random.html#ga86ce713fe60de9af440a7331de74aa1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__random.html#gafe8da996f40caa7d188f6b408ae62904">mrand</a> (int max)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a pseudo-random integer value between 0 and <em>max-1</em> included.  <a href="group__random.html#gafe8da996f40caa7d188f6b408ae62904"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__random.html#ga42801cd81368df5c1c61aa1626e299ff">drand</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a pseudo-random double value between 0.0 and 1.0 (1.0 excluded).  <a href="group__random.html#ga42801cd81368df5c1c61aa1626e299ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__random.html#ga978e1c6fb8f447274a05ddd3f87ce58b">nrand</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a pseudo-random double value following a standard normal distribution. (Odeh &amp; Evans)  <a href="group__random.html#ga978e1c6fb8f447274a05ddd3f87ce58b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__random.html#ga0130217a19e5156f796ab774dca4b08c">bmrand</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a pseudo-random double value following a standard normal distribution. (Box-Muller)  <a href="group__random.html#ga0130217a19e5156f796ab774dca4b08c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__random.html#ga816b558a7c64daca3a2a018704377dac">prand</a> (double p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pseudo-random positive integer value following a Poisson distribution with parameter <em>p</em>.  <a href="group__random.html#ga816b558a7c64daca3a2a018704377dac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__tools.html#ga85c83eb1d18703782d129dbe4a518fca">version</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Spot's version.  <a href="group__misc__tools.html#ga85c83eb1d18703782d129dbe4a518fca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1tgba__explicit__string.html">tgba_explicit_string</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#gadc0e10bdf5a88fc8ee6fb83952f537e0">neverclaim_parse</a> (const std::string &amp;filename, <a class="el" href="group__tgba__io.html#ga15242b071d7c485804548ff2ee41b3d1">neverclaim_parse_error_list</a> &amp;error_list, <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, <a class="el" href="classspot_1_1ltl_1_1environment.html">ltl::environment</a> &amp;env=ltl::default_environment::instance(), bool debug=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="classspot_1_1tgba__explicit.html">spot::tgba_explicit</a> from a Spin never claim file.  <a href="group__tgba__io.html#gadc0e10bdf5a88fc8ee6fb83952f537e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#ga596bbd8f0703340f2b556e43dfa7995e">format_neverclaim_parse_errors</a> (std::ostream &amp;os, const std::string &amp;filename, <a class="el" href="group__tgba__io.html#ga15242b071d7c485804548ff2ee41b3d1">neverclaim_parse_error_list</a> &amp;error_list)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Format diagnostics produced by <a class="el" href="group__tgba__io.html#gadc0e10bdf5a88fc8ee6fb83952f537e0" title="Build a spot::tgba_explicit from a Spin never claim file.">spot::neverclaim_parse</a>.  <a href="group__tgba__io.html#ga596bbd8f0703340f2b556e43dfa7995e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a9f2c6c63ca4916813045c4326c635b93">saba_dotty_reachable</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1saba.html">saba</a> *g)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print reachable states in dot format.  <a href="#a9f2c6c63ca4916813045c4326c635b93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a59e91579989d390a3979a5badf302255">bdd_print_sat</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a BDD as a list of literals.  <a href="#a59e91579989d390a3979a5badf302255"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#aba342c9d66d191b7ed930e2b02043e7f">bdd_format_sat</a> (const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a BDD as a list of literals.  <a href="#aba342c9d66d191b7ed930e2b02043e7f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a3b659fe265e2014282d3b25db928794b">bdd_print_acc</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a BDD as a list of acceptance conditions.  <a href="#a3b659fe265e2014282d3b25db928794b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#aa75a117405f2292f6d80abc2ae930946">bdd_print_accset</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a BDD as a set of acceptance conditions.  <a href="#aa75a117405f2292f6d80abc2ae930946"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#aa04818924fa41d2230160b499d95173d">bdd_format_accset</a> (const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a BDD as a set of acceptance conditions.  <a href="#aa04818924fa41d2230160b499d95173d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#aca49e9ec778c8a6b38455a68db8d6ece">bdd_print_set</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a BDD as a set.  <a href="#aca49e9ec778c8a6b38455a68db8d6ece"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a73d8fa997efd95d08e0d1b9dfa7b7073">bdd_format_set</a> (const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a BDD as a set.  <a href="#a73d8fa997efd95d08e0d1b9dfa7b7073"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a174c8f965f37e9a26b33c9f76183720f">bdd_print_formula</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a BDD as a formula.  <a href="#a174c8f965f37e9a26b33c9f76183720f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#ab9eea881fdb5d8e629db7102fde452ea">bdd_format_formula</a> (const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a BDD as a formula.  <a href="#ab9eea881fdb5d8e629db7102fde452ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a3ec151057e33aadb60d2b47ffaa64c24">bdd_print_dot</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a BDD as a diagram in dotty format.  <a href="#a3ec151057e33aadb60d2b47ffaa64c24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#ac8434843d2dcb0d99a027e398b01bafe">bdd_print_table</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a BDD as a table.  <a href="#ac8434843d2dcb0d99a027e398b01bafe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bdd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#ab6641d7d9896e016376b1c618da92469">formula_to_bdd</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f, <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *d, void *for_me)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#aebfbc06108c79ba74f84a838af4f1772">bdd_to_formula</a> (bdd f, const <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *d)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a361af6c0080f2280ac0a884960374bd3">shared_state_deleter</a> (<a class="el" href="classspot_1_1state.html">state</a> *s)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1tgba__bdd__concrete.html">tgba_bdd_concrete</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__algorithms.html#ga9a8f2973e4358cf18aa162634b61ab51">product</a> (const <a class="el" href="classspot_1_1tgba__bdd__concrete.html">tgba_bdd_concrete</a> *left, const <a class="el" href="classspot_1_1tgba__bdd__concrete.html">tgba_bdd_concrete</a> *right)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies two <a class="el" href="classspot_1_1tgba__bdd__concrete.html" title="A concrete spot::tgba implemented using BDDs.">spot::tgba_bdd_concrete</a> automata.This function builds the resulting product as another <a class="el" href="classspot_1_1tgba__bdd__concrete.html" title="A concrete spot::tgba implemented using BDDs.">spot::tgba_bdd_concrete</a> automaton.  <a href="group__tgba__algorithms.html#ga9a8f2973e4358cf18aa162634b61ab51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#ae6985cd6c82ba766e2e853f5a1e82e24">display_safra</a> (const <a class="el" href="classspot_1_1tgba__safra__complement.html">tgba_safra_complement</a> *a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a dot output of the Safra automaton associated to <em>a</em>.  <a href="#ae6985cd6c82ba766e2e853f5a1e82e24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1tgba.html">tgba</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__on__the__fly__algorithms.html#ga3d28f3aabd3fc1014482983f48a691e9">wdba_complement</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *aut)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Complement a weak deterministic Büchi automaton.  <a href="group__tgba__on__the__fly__algorithms.html#ga3d28f3aabd3fc1014482983f48a691e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector<br class="typebreak"/>
&lt; <a class="el" href="structspot_1_1sccs__set.html">sccs_set</a> * &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a7a3b33efec82bd649f01077850ddfc2a">find_paths</a> (<a class="el" href="classspot_1_1tgba.html">tgba</a> *a, const <a class="el" href="classspot_1_1scc__map.html">scc_map</a> &amp;m)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#af2a55d9921bf9eab8f9b410ff0ad0e0d">max_spanning_paths</a> (std::vector&lt; <a class="el" href="structspot_1_1sccs__set.html">sccs_set</a> * &gt; *paths, <a class="el" href="classspot_1_1scc__map.html">scc_map</a> &amp;m)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="classspot_1_1tgba.html">tgba</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a9f710ac23d3a22a3a66244d15de62a3c">split_tgba</a> (<a class="el" href="classspot_1_1tgba.html">tgba</a> *a, const <a class="el" href="classspot_1_1scc__map.html">scc_map</a> &amp;m, unsigned split_number)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#ga5655f6a593bb8c0e425a3b5ca7837d7c">dotty_reachable</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1tgba.html">tgba</a> *g, bool assume_sba=false, <a class="el" href="classspot_1_1dotty__decorator.html">dotty_decorator</a> *dd=dotty_decorator::instance())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print reachable states in dot format.If assume_sba is set, this assumes that the automaton is an SBA and use double elipse to mark accepting states.  <a href="group__tgba__io.html#ga5655f6a593bb8c0e425a3b5ca7837d7c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1tgba__explicit.html">tgba_explicit</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#gaee64e1fa586af205fa41aaf2c0dbb4bc">tgba_dupexp_bfs</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *aut)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an explicit automata from all states of <em>aut</em>, numbering states in bread first order as they are processed.  <a href="group__tgba__misc.html#gaee64e1fa586af205fa41aaf2c0dbb4bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1tgba__explicit.html">tgba_explicit</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#ga2d17e428249fb0e43ce9ae1ee0e4ddf8">tgba_dupexp_dfs</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *aut)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an explicit automata from all states of <em>aut</em>, numbering states in depth first order as they are processed.  <a href="group__tgba__misc.html#ga2d17e428249fb0e43ce9ae1ee0e4ddf8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1tgba__bdd__concrete.html">tgba_bdd_concrete</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__ltl.html#gafbf62421b9c1da3df47ea92ade8ecdd4">eltl_to_tgba_lacim</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f, <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="classspot_1_1tgba__bdd__concrete.html" title="A concrete spot::tgba implemented using BDDs.">spot::tgba_bdd_concrete</a> from an ELTL formula.This is based on the following paper.  <a href="group__tgba__ltl.html#gafbf62421b9c1da3df47ea92ade8ecdd4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__run.html#ga3aa3b6dd9854c94b6aaabafd4a612de2">print_tgba_run</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, const <a class="el" href="structspot_1_1tgba__run.html">tgba_run</a> *run)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Display a <a class="el" href="structspot_1_1tgba__run.html" title="An accepted run, for a tgba.">tgba_run</a>.  <a href="group__tgba__run.html#ga3aa3b6dd9854c94b6aaabafd4a612de2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1tgba.html">tgba</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__run.html#ga60bd6401d35428aa22bda3388765099b">tgba_run_to_tgba</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, const <a class="el" href="structspot_1_1tgba__run.html">tgba_run</a> *run)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an explicit_tgba corresponding to <em>run</em> (i.e. comparable states are merged).  <a href="group__tgba__run.html#ga60bd6401d35428aa22bda3388765099b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga9bb3670ecff03df6d792c8a315c3e75c">couvreur99</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, <a class="el" href="classspot_1_1option__map.html">option_map</a> options=<a class="el" href="classspot_1_1option__map.html">option_map</a>(), const <a class="el" href="classspot_1_1numbered__state__heap__factory.html">numbered_state_heap_factory</a> *nshf=numbered_state_heap_hash_map_factory::instance())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the language of an automate is empty.  <a href="group__emptiness__check__algorithms.html#ga9bb3670ecff03df6d792c8a315c3e75c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#gae45e3a4c2ba4b8c0609a2afca67eabe8">explicit_gv04_check</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, <a class="el" href="classspot_1_1option__map.html">option_map</a> o=<a class="el" href="classspot_1_1option__map.html">option_map</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Emptiness check based on Geldenhuys and Valmari's TACAS'04 paper.  <a href="group__emptiness__check__algorithms.html#gae45e3a4c2ba4b8c0609a2afca67eabe8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#ga955eb1141519477fda8d09fae2a9cb4a">lbtt_reachable</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1tgba.html">tgba</a> *g)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print reachable states in LBTT format.  <a href="group__tgba__io.html#ga955eb1141519477fda8d09fae2a9cb4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1taa__tgba.html">taa_tgba</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__ltl.html#gab63f738c24846842339e8c12fd5eb777">ltl_to_taa</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f, <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bool refined_rules=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a spot::taa* from an LTL formula.This is based on the following.  <a href="group__tgba__ltl.html#gab63f738c24846842339e8c12fd5eb777"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1tgba__explicit.html">tgba_explicit</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__ltl.html#ga6f1d4c56d80739bc22e9c11680c9a724">ltl_to_tgba_fm</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f, <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bool exprop=false, bool symb_merge=true, bool branching_postponement=false, bool fair_loop_approx=false, const <a class="el" href="group__ltl__misc.html#ga305ebfb1906e717fc70cfba0fa14b4b9">ltl::atomic_prop_set</a> *unobs=0, int reduce_ltl=ltl::Reduce_None)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="classspot_1_1tgba__explicit.html">spot::tgba_explicit</a>* from an LTL formula.This is based on the following paper.  <a href="group__tgba__ltl.html#ga6f1d4c56d80739bc22e9c11680c9a724"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1tgba__bdd__concrete.html">tgba_bdd_concrete</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__ltl.html#ga911db84b8e05185bb50b5eda55efe6b6">ltl_to_tgba_lacim</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f, <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="classspot_1_1tgba__bdd__concrete.html" title="A concrete spot::tgba implemented using BDDs.">spot::tgba_bdd_concrete</a> from an LTL formula.This is based on the following paper.  <a href="group__tgba__ltl.html#ga911db84b8e05185bb50b5eda55efe6b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga392d772bf851002cdda0ca34615aa54b">explicit_magic_search</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, <a class="el" href="classspot_1_1option__map.html">option_map</a> o=<a class="el" href="classspot_1_1option__map.html">option_map</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>.  <a href="group__emptiness__check__algorithms.html#ga392d772bf851002cdda0ca34615aa54b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#gadae7938a96420813bcdabb1b31295294">bit_state_hashing_magic_search</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, size_t size, <a class="el" href="classspot_1_1option__map.html">option_map</a> o=<a class="el" href="classspot_1_1option__map.html">option_map</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>.  <a href="group__emptiness__check__algorithms.html#gadae7938a96420813bcdabb1b31295294"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga054c1948b6c5076350e44a85ad580403">magic_search</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, <a class="el" href="classspot_1_1option__map.html">option_map</a> o=<a class="el" href="classspot_1_1option__map.html">option_map</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for the two magic_search implementations.  <a href="group__emptiness__check__algorithms.html#ga054c1948b6c5076350e44a85ad580403"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1tgba__explicit__number.html">tgba_explicit_number</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__reduction.html#gad89c9f2cfc1415238f9afd8264587a77">minimize_monitor</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a minimal deterministic monitor.  <a href="group__tgba__reduction.html#gad89c9f2cfc1415238f9afd8264587a77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1tgba__explicit__number.html">tgba_explicit_number</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__reduction.html#ga6141d10905f032cbcd4deea13d2c1bb2">minimize_wdba</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimize a Büchi automaton in the WDBA class.  <a href="group__tgba__reduction.html#ga6141d10905f032cbcd4deea13d2c1bb2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1tgba.html">tgba</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__reduction.html#ga6c21b3a493e8d0c10292f3e10776a99c">minimize_obligation</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *aut_f, const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f=0, const <a class="el" href="classspot_1_1tgba.html">tgba</a> *aut_neg_f=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimize an automaton if it represents an obligation property.  <a href="group__tgba__reduction.html#ga6c21b3a493e8d0c10292f3e10776a99c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#ga989d3c71e821143e5b33d9f310784d64">never_claim_reachable</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1tgba.html">tgba</a> *g, const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f=0, bool comments=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print reachable states in Spin never claim format.  <a href="group__tgba__io.html#ga989d3c71e821143e5b33d9f310784d64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structspot_1_1tgba__run.html">tgba_run</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__run.html#ga1e0b8aeb36e622ac26a6c540ac17fddc">project_tgba_run</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a_run, const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a_proj, const <a class="el" href="structspot_1_1tgba__run.html">tgba_run</a> *run)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Project a <a class="el" href="structspot_1_1tgba__run.html" title="An accepted run, for a tgba.">tgba_run</a> on a tgba.If a <a class="el" href="structspot_1_1tgba__run.html" title="An accepted run, for a tgba.">tgba_run</a> has been generated on a product, or any other on-the-fly algorithm with tgba operands,.  <a href="group__tgba__run.html#ga1e0b8aeb36e622ac26a6c540ac17fddc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1tgba.html">tgba</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#gadcf8ba83bd92b5cbf8f5b8f1083a793b">random_graph</a> (int n, float d, const <a class="el" href="group__ltl__misc.html#ga305ebfb1906e717fc70cfba0fa14b4b9">ltl::atomic_prop_set</a> *ap, <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, int n_acc=0, float a=0.1, float t=0.5, <a class="el" href="classspot_1_1ltl_1_1environment.html">ltl::environment</a> *env=&amp;ltl::default_environment::instance())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a tgba randomly.  <a href="group__tgba__misc.html#gadcf8ba83bd92b5cbf8f5b8f1083a793b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structspot_1_1tgba__run.html">tgba_run</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__run.html#gabc4ad10830cd80a3237415d28adeee1b">reduce_run</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, const <a class="el" href="structspot_1_1tgba__run.html">tgba_run</a> *org)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce an accepting run.Return a run which is accepting for <em>and</em> that is no longer that <em>org</em>.  <a href="group__tgba__run.html#gabc4ad10830cd80a3237415d28adeee1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classspot_1_1tgba.html">tgba</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__reduction.html#gaa6ffda0ae1ab4b30ea4f4f8303f36929">reduc_tgba_sim</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, int opt=Reduce_All)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove some node of the automata using a simulation relation.  <a href="group__tgba__reduction.html#gaa6ffda0ae1ab4b30ea4f4f8303f36929"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1direct__simulation__relation.html">direct_simulation_relation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__reduction.html#ga031fe9f92e0d1dbe9af8ca695b2f1161">get_direct_relation_simulation</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, std::ostream &amp;os, int opt=-1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a direct simulation relation on state of tgba <em>f</em>.  <a href="group__tgba__reduction.html#ga031fe9f92e0d1dbe9af8ca695b2f1161"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1delayed__simulation__relation.html">delayed_simulation_relation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__reduction.html#gab80a323c2a5aa8bbf1541afa8a3036a9">get_delayed_relation_simulation</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, std::ostream &amp;os, int opt=-1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__reduction.html#gab2aceabca87cc15e9aa79abbcc23358e">free_relation_simulation</a> (<a class="el" href="classspot_1_1direct__simulation__relation.html">direct_simulation_relation</a> *rel)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">To free a simulation relation.  <a href="group__tgba__reduction.html#gab2aceabca87cc15e9aa79abbcc23358e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__reduction.html#ga9ef87dd9bf31b79cfaa19431a019b98a">free_relation_simulation</a> (<a class="el" href="classspot_1_1delayed__simulation__relation.html">delayed_simulation_relation</a> *rel)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">To free a simulation relation.  <a href="group__tgba__reduction.html#ga9ef87dd9bf31b79cfaa19431a019b98a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__run.html#gae2bf747c24d2fb1a06f1a033f67fe6dc">replay_tgba_run</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, const <a class="el" href="structspot_1_1tgba__run.html">tgba_run</a> *run, bool debug=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replay a <a class="el" href="structspot_1_1tgba__run.html" title="An accepted run, for a tgba.">tgba_run</a> on a tgba.This is similar to <a class="el" href="group__tgba__run.html#ga3aa3b6dd9854c94b6aaabafd4a612de2" title="Display a tgba_run.">print_tgba_run()</a>, except that the run is actually replayed on the automaton while it is printed. Doing so makes it possible to display transition annotations (returned by <a class="el" href="classspot_1_1tgba.html#a00272efd8025be669d827658dc121c82" title="Return a possible annotation for the transition pointed to by the iterator.">spot::tgba::transition_annotation()</a>). The output will stop if the run cannot be completed.  <a href="group__tgba__run.html#gae2bf747c24d2fb1a06f1a033f67fe6dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a8a3357941b87b564d5db84960ac97f24">is_guarantee_automaton</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *aut, const <a class="el" href="classspot_1_1scc__map.html">scc_map</a> *sm=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an automaton represents a guarantee property.  <a href="#a8a3357941b87b564d5db84960ac97f24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a674e27c0b7e007eede14c4337b67581c">is_safety_mwdba</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *aut)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a minimized WDBA represents a safety property.  <a href="#a674e27c0b7e007eede14c4337b67581c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#ga5c7f56a5941eb2380676c4ff6706e1c2">tgba_save_reachable</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1tgba.html">tgba</a> *g)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Save reachable states in text format.  <a href="group__tgba__io.html#ga5c7f56a5941eb2380676c4ff6706e1c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structspot_1_1scc__stats.html">scc_stats</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#ac57eb2b36c82228391e91bfdfd5e896e">build_scc_stats</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structspot_1_1scc__stats.html">scc_stats</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a3a3040faf1273245a9e256b406d2fcca">build_scc_stats</a> (const <a class="el" href="classspot_1_1scc__map.html">scc_map</a> &amp;m)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a773a06917359e059e86d341d62ecbb64">dump_scc_dot</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, std::ostream &amp;out, bool verbose=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#ac55b8611e3b6da1437248c2c6d0d064a">dump_scc_dot</a> (const <a class="el" href="classspot_1_1scc__map.html">scc_map</a> &amp;m, std::ostream &amp;out, bool verbose=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1tgba.html">tgba</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a0eb62dcb2baeb2717a69966b5f7607d9">scc_filter</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *aut, bool remove_all_useless=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prune unaccepting SCCs and remove superfluous acceptance conditions.  <a href="#a0eb62dcb2baeb2717a69966b5f7607d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga8c176368673a0c009dd3e934d57fb492">explicit_se05_search</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, <a class="el" href="classspot_1_1option__map.html">option_map</a> o=<a class="el" href="classspot_1_1option__map.html">option_map</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an emptiness check on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>.  <a href="group__emptiness__check__algorithms.html#ga8c176368673a0c009dd3e934d57fb492"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#gae822266082cdb9772ce31388a6538cb9">bit_state_hashing_se05_search</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, size_t size, <a class="el" href="classspot_1_1option__map.html">option_map</a> o=<a class="el" href="classspot_1_1option__map.html">option_map</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>.  <a href="group__emptiness__check__algorithms.html#gae822266082cdb9772ce31388a6538cb9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga23a00d19bf7613222e6e41833e515c00">se05</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, <a class="el" href="classspot_1_1option__map.html">option_map</a> o)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for the two se05 implementations.  <a href="group__emptiness__check__algorithms.html#ga23a00d19bf7613222e6e41833e515c00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structspot_1_1tgba__statistics.html">tgba_statistics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#gaeeb949ca5fa52c1e292e0a7732ef46c4">stats_reachable</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *g)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute statistics for an automaton.  <a href="group__tgba__misc.html#gaeeb949ca5fa52c1e292e0a7732ef46c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structspot_1_1tgba__sub__statistics.html">tgba_sub_statistics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#gaec71c3349daead65b683e5ba99b893cf">sub_stats_reachable</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *g)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute subended statistics for an automaton.  <a href="group__tgba__misc.html#gaec71c3349daead65b683e5ba99b893cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga159e81f9b91f99b2a749185f47924d99">explicit_tau03_search</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, <a class="el" href="classspot_1_1option__map.html">option_map</a> o=<a class="el" href="classspot_1_1option__map.html">option_map</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>.  <a href="group__emptiness__check__algorithms.html#ga159e81f9b91f99b2a749185f47924d99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga68f7245733f5fe5a86e6dd416d7746f1">explicit_tau03_opt_search</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *a, <a class="el" href="classspot_1_1option__map.html">option_map</a> o=<a class="el" href="classspot_1_1option__map.html">option_map</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>.  <a href="group__emptiness__check__algorithms.html#ga68f7245733f5fe5a86e6dd416d7746f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1tgba__explicit__string.html">tgba_explicit_string</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#gab07f6359e41046dd8f1452ce3665e152">tgba_parse</a> (const std::string &amp;filename, <a class="el" href="group__tgba__io.html#ga76b22bb081d5c36378098caa5bf58081">tgba_parse_error_list</a> &amp;error_list, <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, <a class="el" href="classspot_1_1ltl_1_1environment.html">ltl::environment</a> &amp;env=ltl::default_environment::instance(), <a class="el" href="classspot_1_1ltl_1_1environment.html">ltl::environment</a> &amp;envacc=ltl::default_environment::instance(), bool debug=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="classspot_1_1tgba__explicit.html">spot::tgba_explicit</a> from a text file.  <a href="group__tgba__io.html#gab07f6359e41046dd8f1452ce3665e152"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__io.html#ga95b48c3bd896478c7e22b0d49c39d89c">format_tgba_parse_errors</a> (std::ostream &amp;os, const std::string &amp;filename, <a class="el" href="group__tgba__io.html#ga76b22bb081d5c36378098caa5bf58081">tgba_parse_error_list</a> &amp;error_list)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Format diagnostics produced by <a class="el" href="group__tgba__io.html#gab07f6359e41046dd8f1452ce3665e152" title="Build a spot::tgba_explicit from a text file.">spot::tgba_parse</a>.  <a href="group__tgba__io.html#ga95b48c3bd896478c7e22b0d49c39d89c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1kripke.html">kripke</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#afbc3f43caf8b96d8e715661d45e0a2b0">load_dve2</a> (const std::string &amp;file, <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, const <a class="el" href="group__ltl__misc.html#ga305ebfb1906e717fc70cfba0fa14b4b9">ltl::atomic_prop_set</a> *to_observe, const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *dead=ltl::constant::true_instance(), int compress=0, bool verbose=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot.html#a83bcadbb0c347d956021471f8c7d2135">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1gspn__exception.html">gspn_exception</a> &amp;e)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1couvreur99__check.html">couvreur99_check</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__ssp.html#ga41573dafc02e8da2283670fa7aefebcf">couvreur99_check_ssp_semi</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *ssp_automata)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1couvreur99__check.html">couvreur99_check</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__ssp.html#ga9e84d9fcba32903d98fc0a0ebdc73ac1">couvreur99_check_ssp_shy_semi</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *ssp_automata)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1couvreur99__check.html">couvreur99_check</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__ssp.html#ga4f5db797b2fc8a4b7617a76519114800">couvreur99_check_ssp_shy</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *ssp_automata, bool stack_inclusion=true, bool double_inclusion=false, bool reversed_double_inclusion=false, bool no_decomp=false)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1tgba__explicit__number.html">tgba_explicit_number</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#gafa490c8262811858828ad363760d911d">tgba_powerset</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *aut, <a class="el" href="structspot_1_1power__map.html">power_map</a> &amp;pm)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a deterministic automaton, ignoring acceptance conditions.This create a deterministic automaton that recognizes the same language as <em>aut</em> would if its acceptance conditions were ignored. This is the classical powerset algorithm.  <a href="group__tgba__misc.html#gafa490c8262811858828ad363760d911d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1tgba__explicit__number.html">tgba_explicit_number</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tgba__misc.html#ga42b9bff1af663f032af02cc8007db6d6">tgba_powerset</a> (const <a class="el" href="classspot_1_1tgba.html">tgba</a> *aut)</td></tr>
</table>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a4260b69cfc6b42df1b242d141d250acc"></a><!-- doxytag: member="spot::acc_list_t" ref="a4260b69cfc6b42df1b242d141d250acc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="classspot_1_1bdd__ordered.html">bdd_ordered</a>&gt; <a class="el" href="namespacespot.html#a4260b69cfc6b42df1b242d141d250acc">spot::acc_list_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad049f28e03c2ebe740e5597034fd5c93"></a><!-- doxytag: member="spot::evtgba_parse_error" ref="ad049f28e03c2ebe740e5597034fd5c93" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;evtgbayy::location, std::string&gt; <a class="el" href="namespacespot.html#ad049f28e03c2ebe740e5597034fd5c93">spot::evtgba_parse_error</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A parse diagnostic with its location. </p>

</div>
</div>
<a class="anchor" id="a90dc0e2318bb80c45893922f42ec44fe"></a><!-- doxytag: member="spot::evtgba_parse_error_list" ref="a90dc0e2318bb80c45893922f42ec44fe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;<a class="el" href="namespacespot.html#ad049f28e03c2ebe740e5597034fd5c93">evtgba_parse_error</a>&gt; <a class="el" href="namespacespot.html#a90dc0e2318bb80c45893922f42ec44fe">spot::evtgba_parse_error_list</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A list of parser diagnostics, as filled by parse. </p>

</div>
</div>
<a class="anchor" id="a68ac7577bed0b7af5dd8e45135797759"></a><!-- doxytag: member="spot::kripke_parse_error" ref="a68ac7577bed0b7af5dd8e45135797759" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;<a class="el" href="classkripkeyy_1_1location.html">kripkeyy::location</a>, std::string&gt; <a class="el" href="namespacespot.html#a68ac7577bed0b7af5dd8e45135797759">spot::kripke_parse_error</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A parse diagnostic with its location. </p>

</div>
</div>
<a class="anchor" id="a429e9facc10a0958d14ff3f94d71b006"></a><!-- doxytag: member="spot::kripke_parse_error_list" ref="a429e9facc10a0958d14ff3f94d71b006" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;<a class="el" href="namespacespot.html#a68ac7577bed0b7af5dd8e45135797759">kripke_parse_error</a>&gt; <a class="el" href="namespacespot.html#a429e9facc10a0958d14ff3f94d71b006">spot::kripke_parse_error_list</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A list of parser diagnostics, as filled by parse. </p>

</div>
</div>
<a class="anchor" id="a5f139f442de158fbe3bf9fab3ddee7f3"></a><!-- doxytag: member="spot::rsymbol_set" ref="a5f139f442de158fbe3bf9fab3ddee7f3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt;<a class="el" href="classspot_1_1rsymbol.html">rsymbol</a>&gt; <a class="el" href="namespacespot.html#a5f139f442de158fbe3bf9fab3ddee7f3">spot::rsymbol_set</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5494e2802ca03bd036c523a1c65f3a3e"></a><!-- doxytag: member="spot::shared_saba_state" ref="a5494e2802ca03bd036c523a1c65f3a3e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;const <a class="el" href="classspot_1_1saba__state.html">saba_state</a>&gt; <a class="el" href="namespacespot.html#a5494e2802ca03bd036c523a1c65f3a3e">spot::shared_saba_state</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a13a1db95095eccfe0a4ce4a818442fbf"></a><!-- doxytag: member="spot::shared_state" ref="a13a1db95095eccfe0a4ce4a818442fbf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;const <a class="el" href="classspot_1_1state.html">state</a>&gt; <a class="el" href="namespacespot.html#a13a1db95095eccfe0a4ce4a818442fbf">spot::shared_state</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9ec17bbfe207de0e9c4e699ee3f02572"></a><!-- doxytag: member="spot::simulation_relation" ref="a9ec17bbfe207de0e9c4e699ee3f02572" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="namespacespot.html#a335079e354907be71c014b01c2fb1573">state_couple</a>*&gt; <a class="el" href="namespacespot.html#a9ec17bbfe207de0e9c4e699ee3f02572">spot::simulation_relation</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a335079e354907be71c014b01c2fb1573"></a><!-- doxytag: member="spot::state_couple" ref="a335079e354907be71c014b01c2fb1573" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;const <a class="el" href="classspot_1_1state.html">spot::state</a>*, const <a class="el" href="classspot_1_1state.html">spot::state</a>*&gt; <a class="el" href="namespacespot.html#a335079e354907be71c014b01c2fb1573">spot::state_couple</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab1fe964166144356a185c98ce0bcbde6"></a><!-- doxytag: member="spot::symbol_set" ref="ab1fe964166144356a185c98ce0bcbde6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt;const <a class="el" href="classspot_1_1symbol.html">symbol</a>*&gt; <a class="el" href="namespacespot.html#ab1fe964166144356a185c98ce0bcbde6">spot::symbol_set</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aa04818924fa41d2230160b499d95173d"></a><!-- doxytag: member="spot::bdd_format_accset" ref="aa04818924fa41d2230160b499d95173d" args="(const bdd_dict *dict, bdd b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string spot::bdd_format_accset </td>
          <td>(</td>
          <td class="paramtype">const bdd_dict *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Format a BDD as a set of acceptance conditions. </p>
<p>This is used when saving a TGBA. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dict</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td class="paramname">b</td><td>The BDD to print. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The BDD formated as a string. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9eea881fdb5d8e629db7102fde452ea"></a><!-- doxytag: member="spot::bdd_format_formula" ref="ab9eea881fdb5d8e629db7102fde452ea" args="(const bdd_dict *dict, bdd b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string spot::bdd_format_formula </td>
          <td>(</td>
          <td class="paramtype">const bdd_dict *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Format a BDD as a formula. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dict</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td class="paramname">b</td><td>The BDD to print. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The BDD formated as a string. </dd></dl>

</div>
</div>
<a class="anchor" id="aba342c9d66d191b7ed930e2b02043e7f"></a><!-- doxytag: member="spot::bdd_format_sat" ref="aba342c9d66d191b7ed930e2b02043e7f" args="(const bdd_dict *dict, bdd b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string spot::bdd_format_sat </td>
          <td>(</td>
          <td class="paramtype">const bdd_dict *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Format a BDD as a list of literals. </p>
<p>This assumes that <em>b</em> is a conjunction of literals. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dict</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td class="paramname">b</td><td>The BDD to print. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The BDD formated as a string. </dd></dl>

</div>
</div>
<a class="anchor" id="a73d8fa997efd95d08e0d1b9dfa7b7073"></a><!-- doxytag: member="spot::bdd_format_set" ref="a73d8fa997efd95d08e0d1b9dfa7b7073" args="(const bdd_dict *dict, bdd b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string spot::bdd_format_set </td>
          <td>(</td>
          <td class="paramtype">const bdd_dict *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Format a BDD as a set. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dict</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td class="paramname">b</td><td>The BDD to print. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The BDD formated as a string. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b659fe265e2014282d3b25db928794b"></a><!-- doxytag: member="spot::bdd_print_acc" ref="a3b659fe265e2014282d3b25db928794b" args="(std::ostream &amp;os, const bdd_dict *dict, bdd b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::bdd_print_acc </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bdd_dict *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print a BDD as a list of acceptance conditions. </p>
<p>This is used when saving a TGBA. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream. </td></tr>
    <tr><td class="paramname">dict</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td class="paramname">b</td><td>The BDD to print. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The BDD formated as a string. </dd></dl>

</div>
</div>
<a class="anchor" id="aa75a117405f2292f6d80abc2ae930946"></a><!-- doxytag: member="spot::bdd_print_accset" ref="aa75a117405f2292f6d80abc2ae930946" args="(std::ostream &amp;os, const bdd_dict *dict, bdd b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::bdd_print_accset </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bdd_dict *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print a BDD as a set of acceptance conditions. </p>
<p>This is used when saving a TGBA. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream. </td></tr>
    <tr><td class="paramname">dict</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td class="paramname">b</td><td>The BDD to print. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The BDD formated as a string. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ec151057e33aadb60d2b47ffaa64c24"></a><!-- doxytag: member="spot::bdd_print_dot" ref="a3ec151057e33aadb60d2b47ffaa64c24" args="(std::ostream &amp;os, const bdd_dict *dict, bdd b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::bdd_print_dot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bdd_dict *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print a BDD as a diagram in dotty format. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream. </td></tr>
    <tr><td class="paramname">dict</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td class="paramname">b</td><td>The BDD to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a174c8f965f37e9a26b33c9f76183720f"></a><!-- doxytag: member="spot::bdd_print_formula" ref="a174c8f965f37e9a26b33c9f76183720f" args="(std::ostream &amp;os, const bdd_dict *dict, bdd b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::bdd_print_formula </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bdd_dict *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print a BDD as a formula. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream. </td></tr>
    <tr><td class="paramname">dict</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td class="paramname">b</td><td>The BDD to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a59e91579989d390a3979a5badf302255"></a><!-- doxytag: member="spot::bdd_print_sat" ref="a59e91579989d390a3979a5badf302255" args="(std::ostream &amp;os, const bdd_dict *dict, bdd b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::bdd_print_sat </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bdd_dict *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print a BDD as a list of literals. </p>
<p>This assumes that <em>b</em> is a conjunction of literals. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream. </td></tr>
    <tr><td class="paramname">dict</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td class="paramname">b</td><td>The BDD to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aca49e9ec778c8a6b38455a68db8d6ece"></a><!-- doxytag: member="spot::bdd_print_set" ref="aca49e9ec778c8a6b38455a68db8d6ece" args="(std::ostream &amp;os, const bdd_dict *dict, bdd b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::bdd_print_set </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bdd_dict *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print a BDD as a set. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream. </td></tr>
    <tr><td class="paramname">dict</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td class="paramname">b</td><td>The BDD to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac8434843d2dcb0d99a027e398b01bafe"></a><!-- doxytag: member="spot::bdd_print_table" ref="ac8434843d2dcb0d99a027e398b01bafe" args="(std::ostream &amp;os, const bdd_dict *dict, bdd b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::bdd_print_table </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bdd_dict *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print a BDD as a table. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream. </td></tr>
    <tr><td class="paramname">dict</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td class="paramname">b</td><td>The BDD to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aebfbc06108c79ba74f84a838af4f1772"></a><!-- doxytag: member="spot::bdd_to_formula" ref="aebfbc06108c79ba74f84a838af4f1772" args="(bdd f, const bdd_dict *d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a>* spot::bdd_to_formula </td>
          <td>(</td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bdd_dict *&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac57eb2b36c82228391e91bfdfd5e896e"></a><!-- doxytag: member="spot::build_scc_stats" ref="ac57eb2b36c82228391e91bfdfd5e896e" args="(const tgba *a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspot_1_1scc__stats.html">scc_stats</a> spot::build_scc_stats </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3a3040faf1273245a9e256b406d2fcca"></a><!-- doxytag: member="spot::build_scc_stats" ref="a3a3040faf1273245a9e256b406d2fcca" args="(const scc_map &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspot_1_1scc__stats.html">scc_stats</a> spot::build_scc_stats </td>
          <td>(</td>
          <td class="paramtype">const scc_map &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1c1c9963ce3385c106461526f80e4d7a"></a><!-- doxytag: member="spot::compute_all_acceptance_conditions" ref="a1c1c9963ce3385c106461526f80e4d7a" args="(bdd neg_acceptance_conditions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdd spot::compute_all_acceptance_conditions </td>
          <td>(</td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>neg_acceptance_conditions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute all acceptance conditions from all neg acceptance conditions. </p>

</div>
</div>
<a class="anchor" id="acbfcdc0a54e339085eb6c5458c994832"></a><!-- doxytag: member="spot::compute_neg_acceptance_conditions" ref="acbfcdc0a54e339085eb6c5458c994832" args="(bdd all_acceptance_conditions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdd spot::compute_neg_acceptance_conditions </td>
          <td>(</td>
          <td class="paramtype">bdd&#160;</td>
          <td class="paramname"><em>all_acceptance_conditions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute neg acceptance conditions from all acceptance conditions. </p>

</div>
</div>
<a class="anchor" id="ae6985cd6c82ba766e2e853f5a1e82e24"></a><!-- doxytag: member="spot::display_safra" ref="ae6985cd6c82ba766e2e853f5a1e82e24" args="(const tgba_safra_complement *a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spot::display_safra </td>
          <td>(</td>
          <td class="paramtype">const tgba_safra_complement *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Produce a dot output of the Safra automaton associated to <em>a</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The <code><a class="el" href="classspot_1_1tgba__safra__complement.html" title="Build a complemented automaton.It creates an automaton that recognizes the negated language of aut...">tgba_safra_complement</a></code> with an intermediate Safra automaton to display </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3ff98345b771b22e0a9b67063676e84"></a><!-- doxytag: member="spot::dotty_reachable" ref="ab3ff98345b771b22e0a9b67063676e84" args="(std::ostream &amp;os, const evtgba *g)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::dotty_reachable </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const evtgba *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print reachable states in dot format. </p>

</div>
</div>
<a class="anchor" id="a773a06917359e059e86d341d62ecbb64"></a><!-- doxytag: member="spot::dump_scc_dot" ref="a773a06917359e059e86d341d62ecbb64" args="(const tgba *a, std::ostream &amp;out, bool verbose=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::dump_scc_dot </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac55b8611e3b6da1437248c2c6d0d064a"></a><!-- doxytag: member="spot::dump_scc_dot" ref="ac55b8611e3b6da1437248c2c6d0d064a" args="(const scc_map &amp;m, std::ostream &amp;out, bool verbose=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::dump_scc_dot </td>
          <td>(</td>
          <td class="paramtype">const scc_map &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6805befaee0df3f7cb4427d30782f230"></a><!-- doxytag: member="spot::evtgba_parse" ref="a6805befaee0df3f7cb4427d30782f230" args="(const std::string &amp;filename, evtgba_parse_error_list &amp;error_list, bool debug=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspot_1_1evtgba__explicit.html">evtgba_explicit</a>* spot::evtgba_parse </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">evtgba_parse_error_list &amp;&#160;</td>
          <td class="paramname"><em>error_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build a <a class="el" href="classspot_1_1evtgba__explicit.html">spot::evtgba_explicit</a> from a text file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the file to parse. </td></tr>
    <tr><td class="paramname">error_list</td><td>A list that will be filled with parse errors that occured during parsing. </td></tr>
    <tr><td class="paramname">debug</td><td>When true, causes the parser to trace its execution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the evtgba built from <em>filename</em>, or 0 if the file could not be opened.</dd></dl>
<p>Note that the parser usually tries to recover from errors. It can return an non zero value even if it encountered error during the parsing of <em>filename</em>. If you want to make sure <em>filename</em> was parsed succesfully, check <em>error_list</em> for emptiness.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This function is not reentrant. </dd></dl>

</div>
</div>
<a class="anchor" id="aade1f7e5b6c685b5393d8a6d3ab7e09d"></a><!-- doxytag: member="spot::evtgba_save_reachable" ref="aade1f7e5b6c685b5393d8a6d3ab7e09d" args="(std::ostream &amp;os, const evtgba *g)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::evtgba_save_reachable </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const evtgba *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save reachable states in text format. </p>

</div>
</div>
<a class="anchor" id="a7a3b33efec82bd649f01077850ddfc2a"></a><!-- doxytag: member="spot::find_paths" ref="a7a3b33efec82bd649f01077850ddfc2a" args="(tgba *a, const scc_map &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="structspot_1_1sccs__set.html">sccs_set</a>* &gt; &gt;* spot::find_paths </td>
          <td>(</td>
          <td class="paramtype">tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scc_map &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a805ae4b750b93c1d2e19d81faa609065"></a><!-- doxytag: member="spot::format_evtgba_parse_errors" ref="a805ae4b750b93c1d2e19d81faa609065" args="(std::ostream &amp;os, const std::string &amp;filename, evtgba_parse_error_list &amp;error_list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spot::format_evtgba_parse_errors </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">evtgba_parse_error_list &amp;&#160;</td>
          <td class="paramname"><em>error_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Format diagnostics produced by <a class="el" href="namespacespot.html#a6805befaee0df3f7cb4427d30782f230" title="Build a spot::evtgba_explicit from a text file.">spot::evtgba_parse</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Where diagnostics should be output. </td></tr>
    <tr><td class="paramname">filename</td><td>The filename that should appear in the diagnostics. </td></tr>
    <tr><td class="paramname">error_list</td><td>The error list filled by <a class="el" href="group__ltl__io.html#ga64770999ec846fe07292163e33509da5" title="Build a formula from an LTL string.">spot::ltl::parse</a> while parsing <em>ltl_string</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> iff any diagnostic was output. </dd></dl>

</div>
</div>
<a class="anchor" id="a119f3d265650a37c30f816ad189725ae"></a><!-- doxytag: member="spot::format_kripke_parse_errors" ref="a119f3d265650a37c30f816ad189725ae" args="(std::ostream &amp;os, const std::string &amp;filename, kripke_parse_error_list &amp;error_list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spot::format_kripke_parse_errors </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kripke_parse_error_list &amp;&#160;</td>
          <td class="paramname"><em>error_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Format diagnostics produced by <a class="el" href="namespacespot.html#ad7749e1e9d7c9449aa0c0639f6e7add0">spot::kripke_parse</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Where diagnostics should be output. </td></tr>
    <tr><td class="paramname">filename</td><td>The filename that should appear in the diagnostics. </td></tr>
    <tr><td class="paramname">error_list</td><td>The error list filled by <a class="el" href="group__ltl__io.html#ga64770999ec846fe07292163e33509da5" title="Build a formula from an LTL string.">spot::ltl::parse</a> while parsing <em>ltl_string</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if any diagnostic was output. </dd></dl>

</div>
</div>
<a class="anchor" id="ab6641d7d9896e016376b1c618da92469"></a><!-- doxytag: member="spot::formula_to_bdd" ref="ab6641d7d9896e016376b1c618da92469" args="(const ltl::formula *f, bdd_dict *d, void *for_me)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdd spot::formula_to_bdd </td>
          <td>(</td>
          <td class="paramtype">const ltl::formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_dict *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>for_me</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8a3357941b87b564d5db84960ac97f24"></a><!-- doxytag: member="spot::is_guarantee_automaton" ref="a8a3357941b87b564d5db84960ac97f24" args="(const tgba *aut, const scc_map *sm=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spot::is_guarantee_automaton </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>aut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scc_map *&#160;</td>
          <td class="paramname"><em>sm</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Whether an automaton represents a guarantee property. </p>
<p>A weak deterministic TGBA represents a guarantee property if any accepting path ends on an accepting state with only one transition that is a self-loop labelled by true.</p>
<p>Note that in the general case, this is only a sufficient condition : some guarantee automata might not be recognized with this check e.g. because of some non-determinism in the automaton. In that case, you should interpret a <code>false</code> return value as "I don't know".</p>
<p>If you apply this function on a weak deterministic TGBA (e.g. after a successful minimization with <a class="el" href="group__tgba__reduction.html#ga6c21b3a493e8d0c10292f3e10776a99c" title="Minimize an automaton if it represents an obligation property.">minimize_obligation()</a>), then the result leaves no doubt: false really means that the automaton is not a guarantee property.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">aut</td><td>the automaton to check</td></tr>
    <tr><td class="paramname">sm</td><td>an <a class="el" href="classspot_1_1scc__map.html" title="Build a map of Strongly Connected components in in a TGBA.">scc_map</a> of the automaton if available (it will be built otherwise. If you supply an <a class="el" href="classspot_1_1scc__map.html" title="Build a map of Strongly Connected components in in a TGBA.">scc_map</a> you should call build_map() before passing it to this function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a674e27c0b7e007eede14c4337b67581c"></a><!-- doxytag: member="spot::is_safety_mwdba" ref="a674e27c0b7e007eede14c4337b67581c" args="(const tgba *aut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spot::is_safety_mwdba </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>aut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Whether a minimized WDBA represents a safety property. </p>
<p>A minimized WDBA (as returned by a successful run of <a class="el" href="group__tgba__reduction.html#ga6c21b3a493e8d0c10292f3e10776a99c" title="Minimize an automaton if it represents an obligation property.">minimize_obligation()</a>) represent safety property if it contains only accepting transitions.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">aut</td><td>the automaton to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad7749e1e9d7c9449aa0c0639f6e7add0"></a><!-- doxytag: member="spot::kripke_parse" ref="ad7749e1e9d7c9449aa0c0639f6e7add0" args="(const std::string &amp;name, kripke_parse_error_list &amp;error_list, bdd_dict *dict, ltl::environment &amp;env=ltl::default_environment::instance(), bool debug=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspot_1_1kripke__explicit.html">kripke_explicit</a>* spot::kripke_parse </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kripke_parse_error_list &amp;&#160;</td>
          <td class="paramname"><em>error_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_dict *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ltl::environment &amp;&#160;</td>
          <td class="paramname"><em>env</em> = <code>ltl::default_environment::instance()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afbc3f43caf8b96d8e715661d45e0a2b0"></a><!-- doxytag: member="spot::load_dve2" ref="afbc3f43caf8b96d8e715661d45e0a2b0" args="(const std::string &amp;file, bdd_dict *dict, const ltl::atomic_prop_set *to_observe, const ltl::formula *dead=ltl::constant::true_instance(), int compress=0, bool verbose=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspot_1_1kripke.html">kripke</a>* spot::load_dve2 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bdd_dict *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ltl::atomic_prop_set *&#160;</td>
          <td class="paramname"><em>to_observe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ltl::formula *&#160;</td>
          <td class="paramname"><em>dead</em> = <code>ltl::constant::true_instance()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compress</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af2a55d9921bf9eab8f9b410ff0ad0e0d"></a><!-- doxytag: member="spot::max_spanning_paths" ref="af2a55d9921bf9eab8f9b410ff0ad0e0d" args="(std::vector&lt; sccs_set * &gt; *paths, scc_map &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned spot::max_spanning_paths </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; sccs_set * &gt; *&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scc_map &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1a8d0610b61c0a30aad16791b0b73d15"></a><!-- doxytag: member="spot::memusage" ref="a1a8d0610b61c0a30aad16791b0b73d15" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spot::memusage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Total number of pages in use by the program. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The total number of pages in use by the program if known. -1 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a83bcadbb0c347d956021471f8c7d2135"></a><!-- doxytag: member="spot::operator&lt;&lt;" ref="a83bcadbb0c347d956021471f8c7d2135" args="(std::ostream &amp;os, const gspn_exception &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gspn_exception &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9f2c6c63ca4916813045c4326c635b93"></a><!-- doxytag: member="spot::saba_dotty_reachable" ref="a9f2c6c63ca4916813045c4326c635b93" args="(std::ostream &amp;os, const saba *g)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::saba_dotty_reachable </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const saba *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print reachable states in dot format. </p>

</div>
</div>
<a class="anchor" id="a0eb62dcb2baeb2717a69966b5f7607d9"></a><!-- doxytag: member="spot::scc_filter" ref="a0eb62dcb2baeb2717a69966b5f7607d9" args="(const tgba *aut, bool remove_all_useless=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspot_1_1tgba.html">tgba</a>* spot::scc_filter </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>aut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove_all_useless</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prune unaccepting SCCs and remove superfluous acceptance conditions. </p>
<p>This function will explore the SCCs of the automaton and remove dead SCCs (i.e. SCC that are not accepting, and those with no exit path leading to an accepting SCC).</p>
<p>Additionally, this will try to remove useless acceptance conditions. This operation may diminish the number of acceptance condition of the automaton (for instance when two acceptance conditions are always used together we only keep one) but it will never remove all acceptance conditions, even if it would be OK to have zero.</p>
<p>Acceptance conditions on transitions going to non-accepting SCC are all removed. Acceptance conditions going to an accepting SCC and coming from another SCC are only removed if <em>remove_all_useless</em> is set. The default value of <em>remove_all_useless</em> is <code>false</code> because some algorithms (like the degeneralization) will work better if transitions going to an accepting SCC are accepting. </p>

</div>
</div>
<a class="anchor" id="a361af6c0080f2280ac0a884960374bd3"></a><!-- doxytag: member="spot::shared_state_deleter" ref="a361af6c0080f2280ac0a884960374bd3" args="(state *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spot::shared_state_deleter </td>
          <td>(</td>
          <td class="paramtype">state *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="classspot_1_1state.html#afa00fb3e8019389e2b6fbec0b5e40ded">spot::state::destroy()</a>.</p>

</div>
</div>
<a class="anchor" id="a9f710ac23d3a22a3a66244d15de62a3c"></a><!-- doxytag: member="spot::split_tgba" ref="a9f710ac23d3a22a3a66244d15de62a3c" args="(tgba *a, const scc_map &amp;m, unsigned split_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="classspot_1_1tgba.html">tgba</a>*&gt; spot::split_tgba </td>
          <td>(</td>
          <td class="paramtype">tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scc_map &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>split_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3b22a05fb3e16d693b2d80425dfa4500"></a><!-- doxytag: member="spot::tgba_to_evtgba" ref="a3b22a05fb3e16d693b2d80425dfa4500" args="(const tgba *a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspot_1_1evtgba__explicit.html">evtgba_explicit</a>* spot::tgba_to_evtgba </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a tgba into an evtgba. </p>
<p>(This cannot be done on-the-fly because the alphabet of a tgba as unknown beforehand.) </p>

</div>
</div>
</div>
<hr size="1">
Please <b>comment</b> this page and <b>report errors</b> about it on
<a href="http://spot.lip6.fr/wiki/RefDocComments">the RefDocComments page</a>.
<br><address style="align: right;"><small>
Generated on Mon Nov 28 2011 15:23:18 for spot by <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border=0></a> 1.7.4</small></address>
</body>
</html>
