<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>spot: Input/Output of LTL formulae</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">spot&#160;<span id="projectnumber">0.8</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Input/Output of LTL formulae</div>  </div>
<div class="ingroups"><a class="el" href="group__ltl__algorithm.html">Algorithms for LTL formulae</a></div></div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1ltl__file.html">spot::ltl::ltl_file</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read LTL formulae from a file, one by one.  <a href="classspot_1_1ltl_1_1ltl__file.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1random__ltl.html">spot::ltl::random_ltl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate random LTL formulae.This class recursively construct LTL formulae of a given size. The formulae will use the use atomic propositions from the set of proposition passed to the constructor, in addition to the constant and all LTL operators supported by Spot.  <a href="classspot_1_1ltl_1_1random__ltl.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; std::string, <br class="typebreak"/>
std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#gaf0c33c18fcffd60a2c676bdc6b5214de">spot::eltl::spair</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::pair<br class="typebreak"/>
&lt; <a class="el" href="classeltlyy_1_1location.html">eltlyy::location</a>, spair &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga502251e9b247bf1f614b151254048b2e">spot::eltl::parse_error</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A parse diagnostic &lt;location, &lt;file, message&gt;&gt;.  <a href="#ga502251e9b247bf1f614b151254048b2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; parse_error &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga017167786b87df9a15ec651897ed5cb0">spot::eltl::parse_error_list</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of parser diagnostics, as filled by parse.  <a href="#ga017167786b87df9a15ec651897ed5cb0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::pair<br class="typebreak"/>
&lt; <a class="el" href="classltlyy_1_1location.html">ltlyy::location</a>, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga9bf19c38b4ae7d74e6a9633ed360c147">spot::ltl::parse_error</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A parse diagnostic with its location.  <a href="#ga9bf19c38b4ae7d74e6a9633ed360c147"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; parse_error &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga9eb0f7867a212f92b0fd64a6ac5a12cd">spot::ltl::parse_error_list</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of parser diagnostics, as filled by parse.  <a href="#ga9eb0f7867a212f92b0fd64a6ac5a12cd"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">formula *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#gadb7ab46068f2749014b79c3da00e32f5">spot::eltl::parse_file</a> (const std::string &amp;filename, parse_error_list &amp;error_list, environment &amp;env=default_environment::instance(), bool debug=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a formula from a text file.  <a href="#gadb7ab46068f2749014b79c3da00e32f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">formula *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#gacc30fbc8b33d58b5f83bbf382d63e78f">spot::eltl::parse_string</a> (const std::string &amp;eltl_string, parse_error_list &amp;error_list, environment &amp;env=default_environment::instance(), bool debug=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a formula from an ELTL string.  <a href="#gacc30fbc8b33d58b5f83bbf382d63e78f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga12db416891d2b540640c434afd0e5859">spot::eltl::format_parse_errors</a> (std::ostream &amp;os, parse_error_list &amp;error_list)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Format diagnostics produced by spot::eltl::parse.  <a href="#ga12db416891d2b540640c434afd0e5859"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">formula *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga64770999ec846fe07292163e33509da5">spot::ltl::parse</a> (const std::string &amp;ltl_string, parse_error_list &amp;error_list, environment &amp;env=default_environment::instance(), bool debug=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a formula from an LTL string.  <a href="#ga64770999ec846fe07292163e33509da5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#gac69f09c520acfe742653158946413faf">spot::ltl::format_parse_errors</a> (std::ostream &amp;os, const std::string &amp;ltl_string, parse_error_list &amp;error_list)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Format diagnostics produced by <a class="el" href="group__ltl__io.html#ga64770999ec846fe07292163e33509da5" title="Build a formula from an LTL string.">spot::ltl::parse</a>.  <a href="#gac69f09c520acfe742653158946413faf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga7e27d31b2209954c1d57d3b8b5224473">spot::ltl::dotty</a> (std::ostream &amp;os, const formula *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a formula tree using dot's syntax.  <a href="#ga7e27d31b2209954c1d57d3b8b5224473"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#gaaf316635f1320fa38885fa89e23e2098">spot::ltl::dump</a> (std::ostream &amp;os, const formula *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a formula tree.  <a href="#gaaf316635f1320fa38885fa89e23e2098"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#gabaa78c2c94915029a809fa2928f3da59">spot::ltl::to_string</a> (const formula *f, std::ostream &amp;os, bool full_parent=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a formula as a string which is parsable unless the formula contains automaton operators (used in ELTL formulae).  <a href="#gabaa78c2c94915029a809fa2928f3da59"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga1b4f9b4e51b1f57413e18dc5212b4236">spot::ltl::to_string</a> (const formula *f, bool full_parent=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a formula as a string which is parsable unless the formula contains automaton operators (used in ELTL formulae).  <a href="#ga1b4f9b4e51b1f57413e18dc5212b4236"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga0a8dd6d9bb385a69fabea697df9be925">spot::ltl::to_spin_string</a> (const formula *f, std::ostream &amp;os, bool full_parent=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a formula as a (parsable by Spin) string.  <a href="#ga0a8dd6d9bb385a69fabea697df9be925"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga62c230f1cb3170370c25d8bffb4ea141">spot::ltl::to_spin_string</a> (const formula *f, bool full_parent=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a formula into a (parsable by Spin) string.  <a href="#ga62c230f1cb3170370c25d8bffb4ea141"></a><br/></td></tr>
</table>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga502251e9b247bf1f614b151254048b2e"></a><!-- doxytag: member="spot::eltl::parse_error" ref="ga502251e9b247bf1f614b151254048b2e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;<a class="el" href="classeltlyy_1_1location.html">eltlyy::location</a>, spair&gt; <a class="el" href="group__ltl__io.html#ga502251e9b247bf1f614b151254048b2e">spot::eltl::parse_error</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A parse diagnostic &lt;location, &lt;file, message&gt;&gt;. </p>

</div>
</div>
<a class="anchor" id="ga9bf19c38b4ae7d74e6a9633ed360c147"></a><!-- doxytag: member="spot::ltl::parse_error" ref="ga9bf19c38b4ae7d74e6a9633ed360c147" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;<a class="el" href="classltlyy_1_1location.html">ltlyy::location</a>, std::string&gt; <a class="el" href="group__ltl__io.html#ga9bf19c38b4ae7d74e6a9633ed360c147">spot::ltl::parse_error</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A parse diagnostic with its location. </p>

</div>
</div>
<a class="anchor" id="ga9eb0f7867a212f92b0fd64a6ac5a12cd"></a><!-- doxytag: member="spot::ltl::parse_error_list" ref="ga9eb0f7867a212f92b0fd64a6ac5a12cd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;parse_error&gt; <a class="el" href="group__ltl__io.html#ga9eb0f7867a212f92b0fd64a6ac5a12cd">spot::ltl::parse_error_list</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A list of parser diagnostics, as filled by parse. </p>

</div>
</div>
<a class="anchor" id="ga017167786b87df9a15ec651897ed5cb0"></a><!-- doxytag: member="spot::eltl::parse_error_list" ref="ga017167786b87df9a15ec651897ed5cb0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;parse_error&gt; <a class="el" href="group__ltl__io.html#ga017167786b87df9a15ec651897ed5cb0">spot::eltl::parse_error_list</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A list of parser diagnostics, as filled by parse. </p>

</div>
</div>
<a class="anchor" id="gaf0c33c18fcffd60a2c676bdc6b5214de"></a><!-- doxytag: member="spot::eltl::spair" ref="gaf0c33c18fcffd60a2c676bdc6b5214de" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;std::string, std::string&gt; <a class="el" href="group__ltl__io.html#gaf0c33c18fcffd60a2c676bdc6b5214de">spot::eltl::spair</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga7e27d31b2209954c1d57d3b8b5224473"></a><!-- doxytag: member="spot::ltl::dotty" ref="ga7e27d31b2209954c1d57d3b8b5224473" args="(std::ostream &amp;os, const formula *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::ltl::dotty </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a formula tree using dot's syntax. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The stream where it should be output. </td></tr>
    <tr><td class="paramname">f</td><td>The formula to translate.</td></tr>
  </table>
  </dd>
</dl>
<p><code>dot</code> is part of the GraphViz package <a href="http://www.research.att.com/sw/tools/graphviz/">http://www.research.att.com/sw/tools/graphviz/</a> </p>

</div>
</div>
<a class="anchor" id="gaaf316635f1320fa38885fa89e23e2098"></a><!-- doxytag: member="spot::ltl::dump" ref="gaaf316635f1320fa38885fa89e23e2098" args="(std::ostream &amp;os, const formula *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::ltl::dump </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dump a formula tree. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The stream where it should be output. </td></tr>
    <tr><td class="paramname">f</td><td>The formula to dump.</td></tr>
  </table>
  </dd>
</dl>
<p>This is useful to display a formula when debugging. </p>

</div>
</div>
<a class="anchor" id="gac69f09c520acfe742653158946413faf"></a><!-- doxytag: member="spot::ltl::format_parse_errors" ref="gac69f09c520acfe742653158946413faf" args="(std::ostream &amp;os, const std::string &amp;ltl_string, parse_error_list &amp;error_list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spot::ltl::format_parse_errors </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ltl_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parse_error_list &amp;&#160;</td>
          <td class="paramname"><em>error_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Format diagnostics produced by <a class="el" href="group__ltl__io.html#ga64770999ec846fe07292163e33509da5" title="Build a formula from an LTL string.">spot::ltl::parse</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Where diagnostics should be output. </td></tr>
    <tr><td class="paramname">ltl_string</td><td>The string that were parsed. </td></tr>
    <tr><td class="paramname">error_list</td><td>The error list filled by <a class="el" href="group__ltl__io.html#ga64770999ec846fe07292163e33509da5" title="Build a formula from an LTL string.">spot::ltl::parse</a> while parsing <em>ltl_string</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> iff any diagnostic was output. </dd></dl>

</div>
</div>
<a class="anchor" id="ga12db416891d2b540640c434afd0e5859"></a><!-- doxytag: member="spot::eltl::format_parse_errors" ref="ga12db416891d2b540640c434afd0e5859" args="(std::ostream &amp;os, parse_error_list &amp;error_list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spot::eltl::format_parse_errors </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parse_error_list &amp;&#160;</td>
          <td class="paramname"><em>error_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Format diagnostics produced by spot::eltl::parse. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Where diagnostics should be output. </td></tr>
    <tr><td class="paramname">error_list</td><td>The error list filled by spot::eltl::parse while parsing <em>eltl_string</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> iff any diagnostic was output. </dd></dl>

</div>
</div>
<a class="anchor" id="ga64770999ec846fe07292163e33509da5"></a><!-- doxytag: member="spot::ltl::parse" ref="ga64770999ec846fe07292163e33509da5" args="(const std::string &amp;ltl_string, parse_error_list &amp;error_list, environment &amp;env=default_environment::instance(), bool debug=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">formula* spot::ltl::parse </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ltl_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parse_error_list &amp;&#160;</td>
          <td class="paramname"><em>error_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">environment &amp;&#160;</td>
          <td class="paramname"><em>env</em> = <code>default_environment::instance()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build a formula from an LTL string. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ltl_string</td><td>The string to parse. </td></tr>
    <tr><td class="paramname">error_list</td><td>A list that will be filled with parse errors that occured during parsing. </td></tr>
    <tr><td class="paramname">env</td><td>The environment into which parsing should take place. </td></tr>
    <tr><td class="paramname">debug</td><td>When true, causes the parser to trace its execution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the formula built from <em>ltl_string</em>, or 0 if the input was unparsable.</dd></dl>
<p>Note that the parser usually tries to recover from errors. It can return an non zero value even if it encountered error during the parsing of <em>ltl_string</em>. If you want to make sure <em>ltl_string</em> was parsed succesfully, check <em>error_list</em> for emptiness.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This function is not reentrant. </dd></dl>

</div>
</div>
<a class="anchor" id="gadb7ab46068f2749014b79c3da00e32f5"></a><!-- doxytag: member="spot::eltl::parse_file" ref="gadb7ab46068f2749014b79c3da00e32f5" args="(const std::string &amp;filename, parse_error_list &amp;error_list, environment &amp;env=default_environment::instance(), bool debug=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">formula* spot::eltl::parse_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parse_error_list &amp;&#160;</td>
          <td class="paramname"><em>error_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">environment &amp;&#160;</td>
          <td class="paramname"><em>env</em> = <code>default_environment::instance()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build a formula from a text file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the file to parse. </td></tr>
    <tr><td class="paramname">error_list</td><td>A list that will be filled with parse errors that occured during parsing. </td></tr>
    <tr><td class="paramname">env</td><td>The environment into which parsing should take place. </td></tr>
    <tr><td class="paramname">debug</td><td>When true, causes the parser to trace its execution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the tgba built from <em>filename</em>, or 0 if the file could not be opened.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This function is not reentrant. </dd></dl>

</div>
</div>
<a class="anchor" id="gacc30fbc8b33d58b5f83bbf382d63e78f"></a><!-- doxytag: member="spot::eltl::parse_string" ref="gacc30fbc8b33d58b5f83bbf382d63e78f" args="(const std::string &amp;eltl_string, parse_error_list &amp;error_list, environment &amp;env=default_environment::instance(), bool debug=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">formula* spot::eltl::parse_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>eltl_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parse_error_list &amp;&#160;</td>
          <td class="paramname"><em>error_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">environment &amp;&#160;</td>
          <td class="paramname"><em>env</em> = <code>default_environment::instance()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build a formula from an ELTL string. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">eltl_string</td><td>The string to parse. </td></tr>
    <tr><td class="paramname">error_list</td><td>A list that will be filled with parse errors that occured during parsing. </td></tr>
    <tr><td class="paramname">env</td><td>The environment into which parsing should take place. </td></tr>
    <tr><td class="paramname">debug</td><td>When true, causes the parser to trace its execution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the formula built from <em>eltl_string</em>, or 0 if the input was unparsable.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This function is not reentrant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0a8dd6d9bb385a69fabea697df9be925"></a><!-- doxytag: member="spot::ltl::to_spin_string" ref="ga0a8dd6d9bb385a69fabea697df9be925" args="(const formula *f, std::ostream &amp;os, bool full_parent=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::ltl::to_spin_string </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full_parent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output a formula as a (parsable by Spin) string. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to translate. </td></tr>
    <tr><td class="paramname">os</td><td>The stream where it should be output. </td></tr>
    <tr><td class="paramname">full_parent</td><td>Whether or not the string should by fully parenthesized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga62c230f1cb3170370c25d8bffb4ea141"></a><!-- doxytag: member="spot::ltl::to_spin_string" ref="ga62c230f1cb3170370c25d8bffb4ea141" args="(const formula *f, bool full_parent=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string spot::ltl::to_spin_string </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full_parent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a formula into a (parsable by Spin) string. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to translate. </td></tr>
    <tr><td class="paramname">full_parent</td><td>Whether or not the string should by fully parenthesized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabaa78c2c94915029a809fa2928f3da59"></a><!-- doxytag: member="spot::ltl::to_string" ref="gabaa78c2c94915029a809fa2928f3da59" args="(const formula *f, std::ostream &amp;os, bool full_parent=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; spot::ltl::to_string </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full_parent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output a formula as a string which is parsable unless the formula contains automaton operators (used in ELTL formulae). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to translate. </td></tr>
    <tr><td class="paramname">os</td><td>The stream where it should be output. </td></tr>
    <tr><td class="paramname">full_parent</td><td>Whether or not the string should by fully parenthesized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1b4f9b4e51b1f57413e18dc5212b4236"></a><!-- doxytag: member="spot::ltl::to_string" ref="ga1b4f9b4e51b1f57413e18dc5212b4236" args="(const formula *f, bool full_parent=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string spot::ltl::to_string </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full_parent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output a formula as a string which is parsable unless the formula contains automaton operators (used in ELTL formulae). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to translate. </td></tr>
    <tr><td class="paramname">full_parent</td><td>Whether or not the string should by fully parenthesized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<hr size="1">
Please <b>comment</b> this page and <b>report errors</b> about it on
<a href="http://spot.lip6.fr/wiki/RefDocComments">the RefDocComments page</a>.
<br><address style="align: right;"><small>
Generated on Mon Nov 28 2011 15:23:18 for spot by <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border=0></a> 1.7.4</small></address>
</body>
</html>
