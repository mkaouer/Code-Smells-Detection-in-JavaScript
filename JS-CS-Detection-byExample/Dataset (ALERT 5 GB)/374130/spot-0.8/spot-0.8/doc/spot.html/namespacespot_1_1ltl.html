<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>spot: spot::ltl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">spot&#160;<span id="projectnumber">0.8</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacespot.html">spot</a>      </li>
      <li class="navelem"><a class="el" href="namespacespot_1_1ltl.html">ltl</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">spot::ltl Namespace Reference</div>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl_1_1formula__tree.html">formula_tree</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Trees representing formulae where atomic propositions are unknown. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1atomic__prop.html">atomic_prop</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic propositions.  <a href="classspot_1_1ltl_1_1atomic__prop.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1automatop.html">automatop</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Automaton operators.  <a href="classspot_1_1ltl_1_1automatop.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1binop.html">binop</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary operator.  <a href="classspot_1_1ltl_1_1binop.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1constant.html">constant</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant (True or False)  <a href="classspot_1_1ltl_1_1constant.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An LTL formula.The only way you can work with a formula is to build a <a class="el" href="structspot_1_1ltl_1_1visitor.html" title="Formula visitor that can modify the formula.Writing visitors is the prefered way to traverse a formul...">spot::ltl::visitor</a> or <a class="el" href="structspot_1_1ltl_1_1const__visitor.html" title="Formula visitor that cannot modify the formula.">spot::ltl::const_visitor</a>.  <a href="classspot_1_1ltl_1_1formula.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1ltl_1_1formula__ptr__less__than.html">formula_ptr_less_than</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Strict Weak Ordering for <code>const formula*</code>.This is meant to be used as a comparison functor for STL <code>map</code> whose key are of type <code>const formula*</code>.  <a href="structspot_1_1ltl_1_1formula__ptr__less__than.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1ltl_1_1formula__ptr__hash.html">formula_ptr_hash</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash Function for <code>const formula*</code>.This is meant to be used as a hash functor for Sgi's <code>hash_map</code> whose key are of type <code>const formula*</code>.  <a href="structspot_1_1ltl_1_1formula__ptr__hash.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1multop.html">multop</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-operand operators.These operators are considered commutative and associative.  <a href="classspot_1_1ltl_1_1multop.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1nfa.html">nfa</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Nondeterministic Finite Automata used by automata operators.  <a href="classspot_1_1ltl_1_1nfa.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1succ__iterator.html">succ_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1ref__formula.html">ref_formula</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted LTL formula.  <a href="classspot_1_1ltl_1_1ref__formula.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1unop.html">unop</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary operators.  <a href="classspot_1_1ltl_1_1unop.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1ltl_1_1visitor.html">visitor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Formula visitor that can modify the formula.Writing visitors is the prefered way to traverse a formula, since it doesn't involve any cast.  <a href="structspot_1_1ltl_1_1visitor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspot_1_1ltl_1_1const__visitor.html">const_visitor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Formula visitor that cannot modify the formula.  <a href="structspot_1_1ltl_1_1const__visitor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1declarative__environment.html">declarative_environment</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A declarative environment.This environment recognizes all atomic propositions that have been previously declared. It will reject other.  <a href="classspot_1_1ltl_1_1declarative__environment.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1default__environment.html">default_environment</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A laxist environment.This environment recognizes all atomic propositions.  <a href="classspot_1_1ltl_1_1default__environment.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1environment.html">environment</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An environment that describes atomic propositions.  <a href="classspot_1_1ltl_1_1environment.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1ltl__file.html">ltl_file</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read LTL formulae from a file, one by one.  <a href="classspot_1_1ltl_1_1ltl__file.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1clone__visitor.html">clone_visitor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone a formula.This visitor is public, because it's convenient to derive from it and override part of its methods. But if you just want the functionality, consider using <a class="el" href="classspot_1_1ltl_1_1formula.html#a57d5414b1fd1eafb9ef6191309c66a4f" title="clone this node">spot::ltl::formula::clone</a> instead, it is way faster.  <a href="classspot_1_1ltl_1_1clone__visitor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1language__containment__checker.html">language_containment_checker</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1unabbreviate__logic__visitor.html">unabbreviate_logic_visitor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone and rewrite a formula to remove most of the abbreviated logical operators.This will rewrite binary operators such as <a class="el" href="classspot_1_1ltl_1_1binop.html#a7c5967c6908151a90ff72f210bfb59a2ac5d2a034f0dd62b98fe785d0372c0c9a">binop::Implies</a>, binop::Equals, and <a class="el" href="classspot_1_1ltl_1_1binop.html#a7c5967c6908151a90ff72f210bfb59a2a71177fc6c4bfbc11a0fd7acceeed1ed5">binop::Xor</a>, using only <a class="el" href="classspot_1_1ltl_1_1unop.html#ab6cd495a942b8c203f547cccb50916bca5c70279f9221ae04c99dfcfb1d8cce21">unop::Not</a>, <a class="el" href="classspot_1_1ltl_1_1multop.html#a7ff9fb342ce923eed135a23285d686feaec9dacb72caa01e417f04a398770b16f">multop::Or</a>, and <a class="el" href="classspot_1_1ltl_1_1multop.html#a7ff9fb342ce923eed135a23285d686fea134bbaa37c9a0db99c61af1f61b7f037">multop::And</a>.  <a href="classspot_1_1ltl_1_1unabbreviate__logic__visitor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1postfix__visitor.html">postfix_visitor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply an algorithm on each node of an AST, during a postfix traversal.Override one or more of the postifix_visitor::doit methods with the algorithm to apply.  <a href="classspot_1_1ltl_1_1postfix__visitor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1random__ltl.html">random_ltl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate random LTL formulae.This class recursively construct LTL formulae of a given size. The formulae will use the use atomic propositions from the set of proposition passed to the constructor, in addition to the constant and all LTL operators supported by Spot.  <a href="classspot_1_1ltl_1_1random__ltl.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1simplify__f__g__visitor.html">simplify_f_g_visitor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace <code>true U f</code> and <code>false R g</code> by <code>F f</code> and <code>G g</code>.  <a href="classspot_1_1ltl_1_1simplify__f__g__visitor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1ltl_1_1unabbreviate__ltl__visitor.html">unabbreviate_ltl_visitor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone and rewrite a formula to remove most of the abbreviated LTL and logical operators.The rewriting performed on logical operator is the same as the one done by <a class="el" href="classspot_1_1ltl_1_1unabbreviate__logic__visitor.html" title="Clone and rewrite a formula to remove most of the abbreviated logical operators.This will rewrite bin...">spot::ltl::unabbreviate_logic_visitor</a>.  <a href="classspot_1_1ltl_1_1unabbreviate__ltl__visitor.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::pair<br class="typebreak"/>
&lt; <a class="el" href="classltlyy_1_1location.html">ltlyy::location</a>, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga9bf19c38b4ae7d74e6a9633ed360c147">parse_error</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A parse diagnostic with its location.  <a href="group__ltl__io.html#ga9bf19c38b4ae7d74e6a9633ed360c147"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; <a class="el" href="group__ltl__io.html#ga9bf19c38b4ae7d74e6a9633ed360c147">parse_error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga9eb0f7867a212f92b0fd64a6ac5a12cd">parse_error_list</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of parser diagnostics, as filled by parse.  <a href="group__ltl__io.html#ga9eb0f7867a212f92b0fd64a6ac5a12cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; <a class="el" href="classspot_1_1ltl_1_1atomic__prop.html">atomic_prop</a> <br class="typebreak"/>
*, <a class="el" href="structspot_1_1ltl_1_1formula__ptr__less__than.html">formula_ptr_less_than</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__misc.html#ga305ebfb1906e717fc70cfba0fa14b4b9">atomic_prop_set</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of atomic propositions.  <a href="group__ltl__misc.html#ga305ebfb1906e717fc70cfba0fa14b4b9"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__rewriting.html#gac9e66395d0e9cb870fa7b1ca208b70ca">reduce_options</a> { <br/>
&#160;&#160;<a class="el" href="group__ltl__rewriting.html#ggac9e66395d0e9cb870fa7b1ca208b70caabff3607cc02f12d6756d0244a8f5464a">Reduce_None</a> =  0, 
<a class="el" href="group__ltl__rewriting.html#ggac9e66395d0e9cb870fa7b1ca208b70caab83ef042ab620af2f258a817e95f8f80">Reduce_Basics</a> =  1, 
<a class="el" href="group__ltl__rewriting.html#ggac9e66395d0e9cb870fa7b1ca208b70caa22d75bbadb5b030981574ae49668ad94">Reduce_Syntactic_Implications</a> =  2, 
<a class="el" href="group__ltl__rewriting.html#ggac9e66395d0e9cb870fa7b1ca208b70caaabb627af73b5817a542506be482f396d">Reduce_Eventuality_And_Universality</a> =  4, 
<br/>
&#160;&#160;<a class="el" href="group__ltl__rewriting.html#ggac9e66395d0e9cb870fa7b1ca208b70caa22286d57705e7511f13a75c05ac0a39f">Reduce_Containment_Checks</a> =  8, 
<a class="el" href="group__ltl__rewriting.html#ggac9e66395d0e9cb870fa7b1ca208b70caa0721d15d048b11cfe234f14850dbc9c5">Reduce_Containment_Checks_Stronger</a> =  16, 
<a class="el" href="group__ltl__rewriting.html#ggac9e66395d0e9cb870fa7b1ca208b70caa1629bc689540d42e2f86eea77a6cd275">Reduce_All</a> =  -1U
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for <a class="el" href="group__ltl__rewriting.html#ga31729856de4be685ad913e4e8da59344" title="Reduce a formula f.">spot::ltl::reduce</a>.  <a href="group__ltl__rewriting.html#gac9e66395d0e9cb870fa7b1ca208b70ca">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga64770999ec846fe07292163e33509da5">parse</a> (const std::string &amp;ltl_string, <a class="el" href="group__ltl__io.html#ga9eb0f7867a212f92b0fd64a6ac5a12cd">parse_error_list</a> &amp;error_list, <a class="el" href="classspot_1_1ltl_1_1environment.html">environment</a> &amp;env=default_environment::instance(), bool debug=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a formula from an LTL string.  <a href="group__ltl__io.html#ga64770999ec846fe07292163e33509da5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#gac69f09c520acfe742653158946413faf">format_parse_errors</a> (std::ostream &amp;os, const std::string &amp;ltl_string, <a class="el" href="group__ltl__io.html#ga9eb0f7867a212f92b0fd64a6ac5a12cd">parse_error_list</a> &amp;error_list)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Format diagnostics produced by <a class="el" href="group__ltl__io.html#ga64770999ec846fe07292163e33509da5" title="Build a formula from an LTL string.">spot::ltl::parse</a>.  <a href="group__ltl__io.html#gac69f09c520acfe742653158946413faf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ltl__misc.html#ga305ebfb1906e717fc70cfba0fa14b4b9">atomic_prop_set</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__misc.html#ga335fb11ef18d07a729b03ee76719ead4">atomic_prop_collect</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f, <a class="el" href="group__ltl__misc.html#ga305ebfb1906e717fc70cfba0fa14b4b9">atomic_prop_set</a> *s=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the set of atomic propositions occurring in a formula.  <a href="group__ltl__misc.html#ga335fb11ef18d07a729b03ee76719ead4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__rewriting.html#ga0f4e7d16383675691de1722ee00388a2">basic_reduce</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic rewritings.  <a href="group__ltl__rewriting.html#ga0f4e7d16383675691de1722ee00388a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__misc.html#ga937576e148ca0cea8678e2e35f95d80c">is_GF</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a formula starts with GF.  <a href="group__ltl__misc.html#ga937576e148ca0cea8678e2e35f95d80c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__misc.html#gabd383d0bbdfa61428df282309cadddc6">is_FG</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a formula starts with FG.  <a href="group__ltl__misc.html#gabd383d0bbdfa61428df282309cadddc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__essential.html#ga8e017c7cfd3dcd47b3cc1074371da6bc">clone</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone a formula.  <a href="group__ltl__essential.html#ga8e017c7cfd3dcd47b3cc1074371da6bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#a16bd0bb215f85d6aed821ecbca7e36de">reduce_tau03</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f, bool stronger=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce a formula using language containment relationships.  <a href="#a16bd0bb215f85d6aed821ecbca7e36de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__essential.html#ga7dfba082e4a6aca346befcc46f87e358">destroy</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a formula.  <a href="group__ltl__essential.html#ga7dfba082e4a6aca346befcc46f87e358"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga7e27d31b2209954c1d57d3b8b5224473">dotty</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a formula tree using dot's syntax.  <a href="group__ltl__io.html#ga7e27d31b2209954c1d57d3b8b5224473"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#gaaf316635f1320fa38885fa89e23e2098">dump</a> (std::ostream &amp;os, const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a formula tree.  <a href="group__ltl__io.html#gaaf316635f1320fa38885fa89e23e2098"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__misc.html#gabf324b4e946522d1b4caf3ce003ec903">length</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the length of a formula.The length of a formula is the number of atomic properties, constants, and operators (logical and temporal) occurring in the formula. spot::ltl::multops count only for 1, even if they have more than two operands (e.g. <code>a | b | c</code> has length 4, because <code>|</code> is represented once internally).  <a href="group__ltl__misc.html#gabf324b4e946522d1b4caf3ce003ec903"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__rewriting.html#gae5f253667eed8184ea82a34db7ae2f71">unabbreviate_logic</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone and rewrite a formula to remove most of the abbreviated logical operators.This will rewrite binary operators such as <a class="el" href="classspot_1_1ltl_1_1binop.html#a7c5967c6908151a90ff72f210bfb59a2ac5d2a034f0dd62b98fe785d0372c0c9a">binop::Implies</a>, binop::Equals, and <a class="el" href="classspot_1_1ltl_1_1binop.html#a7c5967c6908151a90ff72f210bfb59a2a71177fc6c4bfbc11a0fd7acceeed1ed5">binop::Xor</a>, using only <a class="el" href="classspot_1_1ltl_1_1unop.html#ab6cd495a942b8c203f547cccb50916bca5c70279f9221ae04c99dfcfb1d8cce21">unop::Not</a>, <a class="el" href="classspot_1_1ltl_1_1multop.html#a7ff9fb342ce923eed135a23285d686feaec9dacb72caa01e417f04a398770b16f">multop::Or</a>, and <a class="el" href="classspot_1_1ltl_1_1multop.html#a7ff9fb342ce923eed135a23285d686fea134bbaa37c9a0db99c61af1f61b7f037">multop::And</a>.  <a href="group__ltl__rewriting.html#gae5f253667eed8184ea82a34db7ae2f71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__rewriting.html#gafe4e6a149b451249b6c8bf03dedc5eeb">negative_normal_form</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f, bool negated=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the negative normal form of <em>f</em>.All negations of the formula are pushed in front of the atomic propositions.  <a href="group__ltl__rewriting.html#gafe4e6a149b451249b6c8bf03dedc5eeb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__rewriting.html#ga31729856de4be685ad913e4e8da59344">reduce</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f, int opt=Reduce_All)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce a formula <em>f</em>.  <a href="group__ltl__rewriting.html#ga31729856de4be685ad913e4e8da59344"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__misc.html#ga3210a9b433640efe1ef74e0da6c678e5">is_eventual</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a formula is a pure eventuality.Pure eventuality formulae are defined in.  <a href="group__ltl__misc.html#ga3210a9b433640efe1ef74e0da6c678e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__misc.html#ga10c79e8a8c5b58fa77cbb6dab5857083">is_universal</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a formula is purely universal.Purely universal formulae are defined in.  <a href="group__ltl__misc.html#ga10c79e8a8c5b58fa77cbb6dab5857083"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__rewriting.html#gaee8b3f409c756decaa12345b2bac6091">simplify_f_g</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace <code>true U f</code> and <code>false R g</code> by <code>F f</code> and <code>G g</code>.  <a href="group__ltl__rewriting.html#gaee8b3f409c756decaa12345b2bac6091"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__misc.html#ga0117add821f085e941eada4aa2ce4bf9">syntactic_implication</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f1, const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntactic implication.This comes from.  <a href="group__ltl__misc.html#ga0117add821f085e941eada4aa2ce4bf9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__misc.html#gad190a68d649650c2b608829dcf258ea1">syntactic_implication_neg</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f1, const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f2, bool right)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntactic implication.If right==false, true if !f1 &lt; f2, false otherwise. If right==true, true if f1 &lt; !f2, false otherwise.  <a href="group__ltl__misc.html#gad190a68d649650c2b608829dcf258ea1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#gabaa78c2c94915029a809fa2928f3da59">to_string</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f, std::ostream &amp;os, bool full_parent=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a formula as a string which is parsable unless the formula contains automaton operators (used in ELTL formulae).  <a href="group__ltl__io.html#gabaa78c2c94915029a809fa2928f3da59"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga1b4f9b4e51b1f57413e18dc5212b4236">to_string</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f, bool full_parent=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a formula as a string which is parsable unless the formula contains automaton operators (used in ELTL formulae).  <a href="group__ltl__io.html#ga1b4f9b4e51b1f57413e18dc5212b4236"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga0a8dd6d9bb385a69fabea697df9be925">to_spin_string</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f, std::ostream &amp;os, bool full_parent=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a formula as a (parsable by Spin) string.  <a href="group__ltl__io.html#ga0a8dd6d9bb385a69fabea697df9be925"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ltl__io.html#ga62c230f1cb3170370c25d8bffb4ea141">to_spin_string</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f, bool full_parent=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a formula into a (parsable by Spin) string.  <a href="group__ltl__io.html#ga62c230f1cb3170370c25d8bffb4ea141"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespot_1_1ltl.html#adcb3082ccb3a689482acbe76c25c3840">unabbreviate_ltl</a> (const <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone and rewrite a formula to remove most of the abbreviated LTL and logical operators.  <a href="#adcb3082ccb3a689482acbe76c25c3840"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a16bd0bb215f85d6aed821ecbca7e36de"></a><!-- doxytag: member="spot::ltl::reduce_tau03" ref="a16bd0bb215f85d6aed821ecbca7e36de" args="(const formula *f, bool stronger=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a>* spot::ltl::reduce_tau03 </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stronger</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reduce a formula using language containment relationships. </p>
<p>The method is taken from table 4.1 in </p>
<div class="fragment"><pre class="fragment">
    ///@TechReport{	  tauriainen.03.a83,
    ///  author	= {Heikki Tauriainen},
    ///  title = {On Translating Linear Temporal Logic into Alternating and
    ///		  Nondeterministic Automata},
    ///  institution	= {Helsinki University of Technology, Laboratory for
    ///		           Theoretical Computer Science},
    ///  address	= {Espoo, Finland},
    ///  month		= dec,
    ///  number	        = {A83},
    ///  pages		= {132},
    ///  type		= {Research Report},
    ///  year		= {2003},
    ///  note		= {Reprint of Licentiate's thesis}
    ///}
    ///
    /// (The "dagged" cells in the tables are not handled here.)
    ///
    /// If \a stronger is set, additional rules are used to further
    /// reduce some U, R, and X usages.
    /// </pre></div> 
</div>
</div>
<a class="anchor" id="adcb3082ccb3a689482acbe76c25c3840"></a><!-- doxytag: member="spot::ltl::unabbreviate_ltl" ref="adcb3082ccb3a689482acbe76c25c3840" args="(const formula *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a>* spot::ltl::unabbreviate_ltl </td>
          <td>(</td>
          <td class="paramtype">const formula *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clone and rewrite a formula to remove most of the abbreviated LTL and logical operators. </p>
<p>The rewriting performed on logical operator is the same as the one done by <a class="el" href="group__ltl__rewriting.html#gae5f253667eed8184ea82a34db7ae2f71" title="Clone and rewrite a formula to remove most of the abbreviated logical operators.This will rewrite bin...">spot::ltl::unabbreviate_logic</a>.</p>
<p>This will also rewrite unary operators such as <a class="el" href="classspot_1_1ltl_1_1unop.html#ab6cd495a942b8c203f547cccb50916bca22dc60c18bb1140957d534dab87a8e82">unop::F</a>, and <a class="el" href="classspot_1_1ltl_1_1unop.html#ab6cd495a942b8c203f547cccb50916bcafe9a76cee45f8e8d6f3d970f526090bb">unop::G</a>, using only <a class="el" href="classspot_1_1ltl_1_1binop.html#a7c5967c6908151a90ff72f210bfb59a2ab01994b5e43401a5cf70fc7ef1599119">binop::U</a>, and <a class="el" href="classspot_1_1ltl_1_1binop.html#a7c5967c6908151a90ff72f210bfb59a2a2912f480a149c4899b9f61f1a5975c38">binop::R</a>. </p>

</div>
</div>
</div>
<hr size="1">
Please <b>comment</b> this page and <b>report errors</b> about it on
<a href="http://spot.lip6.fr/wiki/RefDocComments">the RefDocComments page</a>.
<br><address style="align: right;"><small>
Generated on Mon Nov 28 2011 15:23:19 for spot by <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border=0></a> 1.7.4</small></address>
</body>
</html>
