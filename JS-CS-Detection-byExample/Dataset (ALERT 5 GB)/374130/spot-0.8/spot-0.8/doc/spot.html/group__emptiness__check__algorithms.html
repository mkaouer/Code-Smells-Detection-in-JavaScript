<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>spot: Emptiness-check algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">spot&#160;<span id="projectnumber">0.8</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Emptiness-check algorithms</div>  </div>
<div class="ingroups"><a class="el" href="group__emptiness__check.html">Emptiness-checks</a></div></div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1couvreur99__check.html">spot::couvreur99_check</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of the Couvreur99 emptiness-check algorithm.  <a href="classspot_1_1couvreur99__check.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspot_1_1couvreur99__check__shy.html">spot::couvreur99_check_shy</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A version of <a class="el" href="classspot_1_1couvreur99__check.html" title="An implementation of the Couvreur99 emptiness-check algorithm.">spot::couvreur99_check</a> that tries to visit known states first.  <a href="classspot_1_1couvreur99__check__shy.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">emptiness_check *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga9bb3670ecff03df6d792c8a315c3e75c">spot::couvreur99</a> (const tgba *a, option_map options=option_map(), const numbered_state_heap_factory *nshf=numbered_state_heap_hash_map_factory::instance())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the language of an automate is empty.  <a href="#ga9bb3670ecff03df6d792c8a315c3e75c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">emptiness_check *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#gae45e3a4c2ba4b8c0609a2afca67eabe8">spot::explicit_gv04_check</a> (const tgba *a, option_map o=option_map())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Emptiness check based on Geldenhuys and Valmari's TACAS'04 paper.  <a href="#gae45e3a4c2ba4b8c0609a2afca67eabe8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">emptiness_check *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga392d772bf851002cdda0ca34615aa54b">spot::explicit_magic_search</a> (const tgba *a, option_map o=option_map())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>.  <a href="#ga392d772bf851002cdda0ca34615aa54b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">emptiness_check *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#gadae7938a96420813bcdabb1b31295294">spot::bit_state_hashing_magic_search</a> (const tgba *a, size_t size, option_map o=option_map())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>.  <a href="#gadae7938a96420813bcdabb1b31295294"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">emptiness_check *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga054c1948b6c5076350e44a85ad580403">spot::magic_search</a> (const tgba *a, option_map o=option_map())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for the two magic_search implementations.  <a href="#ga054c1948b6c5076350e44a85ad580403"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">emptiness_check *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga8c176368673a0c009dd3e934d57fb492">spot::explicit_se05_search</a> (const tgba *a, option_map o=option_map())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an emptiness check on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>.  <a href="#ga8c176368673a0c009dd3e934d57fb492"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">emptiness_check *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#gae822266082cdb9772ce31388a6538cb9">spot::bit_state_hashing_se05_search</a> (const tgba *a, size_t size, option_map o=option_map())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>.  <a href="#gae822266082cdb9772ce31388a6538cb9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">emptiness_check *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga23a00d19bf7613222e6e41833e515c00">spot::se05</a> (const tgba *a, option_map o)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for the two se05 implementations.  <a href="#ga23a00d19bf7613222e6e41833e515c00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">emptiness_check *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga159e81f9b91f99b2a749185f47924d99">spot::explicit_tau03_search</a> (const tgba *a, option_map o=option_map())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>.  <a href="#ga159e81f9b91f99b2a749185f47924d99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">emptiness_check *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emptiness__check__algorithms.html#ga68f7245733f5fe5a86e6dd416d7746f1">spot::explicit_tau03_opt_search</a> (const tgba *a, option_map o=option_map())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>.  <a href="#ga68f7245733f5fe5a86e6dd416d7746f1"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gadae7938a96420813bcdabb1b31295294"></a><!-- doxytag: member="spot::bit_state_hashing_magic_search" ref="gadae7938a96420813bcdabb1b31295294" args="(const tgba *a, size_t size, option_map o=option_map())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">emptiness_check* spot::bit_state_hashing_magic_search </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">option_map&#160;</td>
          <td class="paramname"><em>o</em> = <code>option_map()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>The automaton <em>a</em> must have at most one acceptance condition (i.e. it is a TBA).</dd></dl>
<p>During the visit of <em>a</em>, the returned checker does not store explicitely the traversed states but uses the bit-state hashing technic presented in:</p>
<div class="fragment"><pre class="fragment">
  /// @book{Holzmann91,
  ///    author = {G.J. Holzmann},
  ///    title = {Design and Validation of Computer Protocols},
  ///    publisher = {Prentice-Hall},
  ///    address = {Englewood Cliffs, New Jersey},
  ///    year = {1991}
  /// }
  /// </pre></div><p>Consequently, the detection of an acceptence cycle is not ensured.</p>
<p>The size of the heap is limited to <br/>
 size bytes.</p>
<p>The implemented algorithm is the same as the one of <a class="el" href="group__emptiness__check__algorithms.html#ga392d772bf851002cdda0ca34615aa54b" title="Returns an emptiness checker on the spot::tgba automaton a.">spot::explicit_magic_search</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__emptiness__check__algorithms.html#ga392d772bf851002cdda0ca34615aa54b" title="Returns an emptiness checker on the spot::tgba automaton a.">spot::explicit_magic_search</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae822266082cdb9772ce31388a6538cb9"></a><!-- doxytag: member="spot::bit_state_hashing_se05_search" ref="gae822266082cdb9772ce31388a6538cb9" args="(const tgba *a, size_t size, option_map o=option_map())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">emptiness_check* spot::bit_state_hashing_se05_search </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">option_map&#160;</td>
          <td class="paramname"><em>o</em> = <code>option_map()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>The automaton <em>a</em> must have at most one acceptance condition (i.e. it is a TBA).</dd></dl>
<p>During the visit of <em>a</em>, the returned checker does not store explicitely the traversed states but uses the bit-state hashing technic presented in:</p>
<div class="fragment"><pre class="fragment">
  /// @book{Holzmann91,
  ///    author = {G.J. Holzmann},
  ///    title = {Design and Validation of Computer Protocols},
  ///    publisher = {Prentice-Hall},
  ///    address = {Englewood Cliffs, New Jersey},
  ///    year = {1991}
  /// }
  /// </pre></div><p>Consequently, the detection of an acceptence cycle is not ensured.</p>
<p>The size of the heap is limited to <br/>
 size bytes.</p>
<p>The implemented algorithm is the same as the one of <a class="el" href="group__emptiness__check__algorithms.html#ga8c176368673a0c009dd3e934d57fb492" title="Returns an emptiness check on the spot::tgba automaton a.">spot::explicit_se05_search</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__emptiness__check__algorithms.html#ga8c176368673a0c009dd3e934d57fb492" title="Returns an emptiness check on the spot::tgba automaton a.">spot::explicit_se05_search</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9bb3670ecff03df6d792c8a315c3e75c"></a><!-- doxytag: member="spot::couvreur99" ref="ga9bb3670ecff03df6d792c8a315c3e75c" args="(const tgba *a, option_map options=option_map(), const numbered_state_heap_factory *nshf=numbered_state_heap_hash_map_factory::instance())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">emptiness_check* spot::couvreur99 </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">option_map&#160;</td>
          <td class="paramname"><em>options</em> = <code>option_map()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const numbered_state_heap_factory *&#160;</td>
          <td class="paramname"><em>nshf</em> = <code>numbered_state_heap_hash_map_factory::instance()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check whether the language of an automate is empty. </p>
<p>This is based on the following paper. </p>
<div class="fragment"><pre class="fragment">
  /// @InProceedings{couvreur.99.fm,
  ///   author    = {Jean-Michel Couvreur},
  ///   title     = {On-the-fly Verification of Temporal Logic},
  ///   pages     = {253--271},
  ///   editor    = {Jeannette M. Wing and Jim Woodcock and Jim Davies},
  ///   booktitle = {Proceedings of the World Congress on Formal Methods in
  ///                the Development of Computing Systems (FM'99)},
  ///   publisher = {Springer-Verlag},
  ///   series    = {Lecture Notes in Computer Science},
  ///   volume    = {1708},
  ///   year      = {1999},
  ///   address   = {Toulouse, France},
  ///   month     = {September},
  ///   isbn      = {3-540-66587-0}
  /// }
  /// </pre></div><p>A recursive definition of the algorithm would look as follows, but the implementation is of course not recursive. (<code>&lt;Sigma, Q, delta, q, F&gt;</code> is the automaton to check, H is an associative array mapping each state to its positive DFS order or 0 if it is dead, SCC is and ACC are two stacks.)</p>
<div class="fragment"><pre class="fragment">
  /// check(&lt;Sigma, Q, delta, q, F&gt;, H, SCC, ACC)
  ///   if q is not in H   // new state
  ///       H[q] = H.size + 1
  ///       SCC.push(&lt;H[q], {}&gt;)
  ///       forall &lt;a, s&gt; : &lt;q, _, a, s&gt; in delta
  ///           ACC.push(a)
  ///           res = check(&lt;Sigma, Q, delta, s, F&gt;, H, SCC, ACC)
  ///           if res
  ///               return res
  ///       &lt;n, _&gt; = SCC.top()
  ///       if n = H[q]
  ///           SCC.pop()
  ///           mark_reachable_states_as_dead(&lt;Sigma, Q, delta, q, F&gt;, H$)
  ///       return 0
  ///   else
  ///       if H[q] = 0 // dead state
  ///           ACC.pop()
  ///           return true
  ///       else // state in stack: merge SCC
  ///           all = {}
  ///           do
  ///               &lt;n, a&gt; = SCC.pop()
  ///               all = all union a union { ACC.pop() }
  ///           until n &lt;= H[q]
  ///           SCC.push(&lt;n, all&gt;)
  ///           if all != F
  ///               return 0
  ///           return new emptiness_check_result(necessary data)
  /// </pre></div><p>check() returns 0 iff the automaton's language is empty. It returns an instance of <a class="el" href="classspot_1_1emptiness__check__result.html" title="The result of an emptiness check.">emptiness_check_result</a>. If the automaton accept a word. (Use <a class="el" href="classspot_1_1emptiness__check__result.html#a909ae24b5e8454cb966d320e997570ab" title="Return a run accepted by the automata passed to the emptiness check.">emptiness_check_result::accepting_run()</a> to extract an accepting run.)</p>
<p>There are two variants of this algorithm: <a class="el" href="classspot_1_1couvreur99__check.html" title="An implementation of the Couvreur99 emptiness-check algorithm.">spot::couvreur99_check</a> and <a class="el" href="classspot_1_1couvreur99__check__shy.html" title="A version of spot::couvreur99_check that tries to visit known states first.">spot::couvreur99_check_shy</a>. They differ in their memory usage, the number for successors computed before they are used and the way the depth first search is directed.</p>
<p><a class="el" href="classspot_1_1couvreur99__check.html" title="An implementation of the Couvreur99 emptiness-check algorithm.">spot::couvreur99_check</a> performs a straightforward depth first search. The DFS stacks store tgba_succ_iterators, so that only the iterators which really are explored are computed.</p>
<p><a class="el" href="classspot_1_1couvreur99__check__shy.html" title="A version of spot::couvreur99_check that tries to visit known states first.">spot::couvreur99_check_shy</a> tries to explore successors which are visited states first. this helps to merge SCCs and generally helps to produce shorter counter-examples. However this algorithm cannot stores unprocessed successors as tgba_succ_iterators: it must compute all successors of a state at once in order to decide which to explore first, and must keep a list of all unexplored successors in its DFS stack.</p>
<p>The <a class="el" href="group__emptiness__check__algorithms.html#ga9bb3670ecff03df6d792c8a315c3e75c" title="Check whether the language of an automate is empty.">couvreur99()</a> function is a wrapper around these two flavors of the algorithm. <em>options</em> is an option map that specifies which algorithms should be used, and how.</p>
<p>The following options are available. </p>
<ul>
<li><code>"shy"</code> : if non zero, then <a class="el" href="classspot_1_1couvreur99__check__shy.html" title="A version of spot::couvreur99_check that tries to visit known states first.">spot::couvreur99_check_shy</a> is used, otherwise (and by default) <a class="el" href="classspot_1_1couvreur99__check.html" title="An implementation of the Couvreur99 emptiness-check algorithm.">spot::couvreur99_check</a> is used.</li>
</ul>
<ul>
<li><code>"poprem"</code> : specifies how the algorithm should handle the destruction of non-accepting maximal strongly connected components. If <code>poprem</code> is non null, the algorithm will keep a list of all states of a SCC that are fully processed and should be removed once the MSCC is popped. If <code>poprem</code> is null (the default), the MSCC will be traversed again (i.e. generating the successors of the root recursively) for deletion. This is a choice between memory and speed.</li>
</ul>
<ul>
<li><code>"group"</code> : this options is used only by <a class="el" href="classspot_1_1couvreur99__check__shy.html" title="A version of spot::couvreur99_check that tries to visit known states first.">spot::couvreur99_check_shy</a>. If non null (the default), the successors of all the states that belong to the same SCC will be considered when choosing a successor. Otherwise, only the successor of the topmost state on the DFS stack are considered. </li>
</ul>

</div>
</div>
<a class="anchor" id="gae45e3a4c2ba4b8c0609a2afca67eabe8"></a><!-- doxytag: member="spot::explicit_gv04_check" ref="gae45e3a4c2ba4b8c0609a2afca67eabe8" args="(const tgba *a, option_map o=option_map())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">emptiness_check* spot::explicit_gv04_check </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">option_map&#160;</td>
          <td class="paramname"><em>o</em> = <code>option_map()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Emptiness check based on Geldenhuys and Valmari's TACAS'04 paper. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>The automaton <em>a</em> must have at most one acceptance condition.</dd></dl>
<p>The original algorithm, coming from the following paper, has only been slightly modified to work on transition-based automata. </p>
<div class="fragment"><pre class="fragment">
  /// @InProceedings{geldenhuys.04.tacas,
  ///   author  = {Jaco Geldenhuys and Antti Valmari},
  ///   title   = {Tarjan's Algorithm Makes On-the-Fly {LTL} Verification
  ///             More Efficient},
  ///   booktitle = {Proceedings of the 10th International Conference on Tools
  ///             and Algorithms for the Construction and Analysis of Systems
  ///             (TACAS'04)},
  ///   editor  = {Kurt Jensen and Andreas Podelski},
  ///   pages   = {205--219},
  ///   year    = {2004},
  ///   publisher = {Springer-Verlag},
  ///   series  = {Lecture Notes in Computer Science},
  ///   volume  = {2988},
  ///   isbn    = {3-540-21299-X}
  /// }
  /// </pre></div> 
</div>
</div>
<a class="anchor" id="ga392d772bf851002cdda0ca34615aa54b"></a><!-- doxytag: member="spot::explicit_magic_search" ref="ga392d772bf851002cdda0ca34615aa54b" args="(const tgba *a, option_map o=option_map())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">emptiness_check* spot::explicit_magic_search </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">option_map&#160;</td>
          <td class="paramname"><em>o</em> = <code>option_map()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>The automaton <em>a</em> must have at most one acceptance condition (i.e. it is a TBA).</dd></dl>
<p>During the visit of <em>a</em>, the returned checker stores explicitely all the traversed states. The method <em>check()</em> of the checker can be called several times (until it returns a null pointer) to enumerate all the visited acceptance paths. The implemented algorithm is the following:</p>
<div class="fragment"><pre class="fragment">
  /// procedure check ()
  /// begin
  ///   call dfs_blue(s0);
  /// end;
  ///
  /// procedure dfs_blue (s)
  /// begin
  ///   s.color = blue;
  ///   for all t in post(s) do
  ///     if t.color == white then
  ///       call dfs_blue(t);
  ///     end if;
  ///     if (the edge (s,t) is accepting) then
  ///       target = s;
  ///       call dfs_red(t);
  ///     end if;
  ///   end for;
  /// end;
  ///
  /// procedure dfs_red(s)
  /// begin
  ///   s.color = red;
  ///   if s == target then
  ///     report cycle
  ///   end if;
  ///   for all t in post(s) do
  ///     if t.color == blue then
  ///       call dfs_red(t);
  ///     end if;
  ///   end for;
  /// end;
  /// </pre></div><p>This algorithm is an adaptation to TBA of the one (which deals with accepting states) presented in</p>
<div class="fragment"><pre class="fragment">
  ///  Article{         courcoubetis.92.fmsd,
  ///    author        = {Costas Courcoubetis and Moshe Y. Vardi and Pierre
  ///                    Wolper and Mihalis Yannakakis},
  ///    title         = {Memory-Efficient Algorithm for the Verification of
  ///                    Temporal Properties},
  ///    journal       = {Formal Methods in System Design},
  ///    pages         = {275--288},
  ///    year          = {1992},
  ///    volume        = {1}
  ///  }
  /// </pre></div><dl class="bug"><dt><b><a class="el" href="bug.html#_bug000001">Bug:</a></b></dt><dd>The name is misleading. Magic-search is the algorithm from <code>godefroid.93.pstv</code>, not <code>courcoubetis.92.fmsd</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8c176368673a0c009dd3e934d57fb492"></a><!-- doxytag: member="spot::explicit_se05_search" ref="ga8c176368673a0c009dd3e934d57fb492" args="(const tgba *a, option_map o=option_map())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">emptiness_check* spot::explicit_se05_search </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">option_map&#160;</td>
          <td class="paramname"><em>o</em> = <code>option_map()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an emptiness check on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>The automaton <em>a</em> must have at most one acceptance condition (i.e. it is a TBA).</dd></dl>
<p>During the visit of <em>a</em>, the returned checker stores explicitely all the traversed states. The method <em>check()</em> of the checker can be called several times (until it returns a null pointer) to enumerate all the visited accepting paths. The implemented algorithm is an optimization of <a class="el" href="group__emptiness__check__algorithms.html#ga392d772bf851002cdda0ca34615aa54b" title="Returns an emptiness checker on the spot::tgba automaton a.">spot::explicit_magic_search</a> and is the following:</p>
<div class="fragment"><pre class="fragment">
  /// procedure check ()
  /// begin
  ///   call dfs_blue(s0);
  /// end;
  ///
  /// procedure dfs_blue (s)
  /// begin
  ///   s.color = cyan;
  ///   for all t in post(s) do
  ///     if t.color == white then
  ///       call dfs_blue(t);
  ///     else if t.color == cyan and
  ///             (the edge (s,t) is accepting or
  ///              (it exists a predecessor p of s in st_blue and s != t and
  ///              the arc between p and s is accepting)) then
  ///       report cycle;
  ///     end if;
  ///     if the edge (s,t) is accepting then
  ///       call dfs_red(t);
  ///     end if;
  ///   end for;
  ///   s.color = blue;
  /// end;
  ///
  /// procedure dfs_red(s)
  /// begin
  ///   if s.color == cyan then
  ///     report cycle;
  ///   end if;
  ///   s.color = red;
  ///   for all t in post(s) do
  ///     if t.color == blue then
  ///       call dfs_red(t);
  ///     end if;
  ///   end for;
  /// end;
  /// </pre></div><p>It is an adaptation to TBA of the one presented in </p>
<div class="fragment"><pre class="fragment">
  ///  @techreport{SE04,
  ///    author = {Stefan Schwoon and Javier Esparza},
  ///    institution = {Universit{\"a}t Stuttgart, Fakult\"at Informatik,
  ///    Elektrotechnik und Informationstechnik},
  ///    month = {November},
  ///    number = {2004/06},
  ///    title = {A Note on On-The-Fly Verification Algorithms},
  ///    year = {2004},
  ///    url =
  ///{http://www.fmi.uni-stuttgart.de/szs/publications/info/schwoosn.SE04.shtml}
  ///  }
  /// </pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__emptiness__check__algorithms.html#ga392d772bf851002cdda0ca34615aa54b" title="Returns an emptiness checker on the spot::tgba automaton a.">spot::explicit_magic_search</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga68f7245733f5fe5a86e6dd416d7746f1"></a><!-- doxytag: member="spot::explicit_tau03_opt_search" ref="ga68f7245733f5fe5a86e6dd416d7746f1" args="(const tgba *a, option_map o=option_map())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">emptiness_check* spot::explicit_tau03_opt_search </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">option_map&#160;</td>
          <td class="paramname"><em>o</em> = <code>option_map()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>The automaton <em>a</em> must have at least one acceptance condition.</dd></dl>
<p>During the visit of <em>a</em>, the returned checker stores explicitely all the traversed states. The implemented algorithm is the following:</p>
<div class="fragment"><pre class="fragment">
  /// procedure check ()
  /// begin
  ///   weight = 0; // the null vector
  ///   call dfs_blue(s0);
  /// end;
  ///
  /// procedure dfs_blue (s)
  /// begin
  ///   s.color = cyan;
  ///   s.acc = emptyset;
  ///   s.weight = weight;
  ///   for all t in post(s) do
  ///     let (s, l, a, t) be the edge from s to t;
  ///     if t.color == white then
  ///       for all b in a do
  ///         weight[b] = weight[b] + 1;
  ///       end for;
  ///       call dfs_blue(t);
  ///       for all b in a do
  ///         weight[b] = weight[b] - 1;
  ///       end for;
  ///     end if;
  ///     Acc = s.acc U a;
  ///     if t.color == cyan &amp;&amp;
  ///               (Acc U support(weight - t.weight) U t.acc) == all_acc then
  ///       report a cycle;
  ///     else if Acc not included in t.acc then
  ///       t.acc := t.acc U Acc;
  ///       call dfs_red(t, Acc);
  ///     end if;
  ///   end for;
  ///   s.color = blue;
  /// end;
  ///
  /// procedure dfs_red(s, Acc)
  /// begin
  ///   for all t in post(s) do
  ///     let (s, l, a, t) be the edge from s to t;
  ///     if t.color == cyan &amp;&amp;
  ///                 (Acc U support(weight - t.weight) U t.acc) == all_acc then
  ///       report a cycle;
  ///     else if t.color != white and Acc not included in t.acc then
  ///       t.acc := t.acc U Acc;
  ///       call dfs_red(t, Acc);
  ///     end if;
  ///   end for;
  /// end;
  /// </pre></div><p>This algorithm is a generalisation to TGBA of the one implemented in <a class="el" href="group__emptiness__check__algorithms.html#ga8c176368673a0c009dd3e934d57fb492" title="Returns an emptiness check on the spot::tgba automaton a.">spot::explicit_se05_search</a>. It is based on the acceptance set labelling of states used in <a class="el" href="group__emptiness__check__algorithms.html#ga159e81f9b91f99b2a749185f47924d99" title="Returns an emptiness checker on the spot::tgba automaton a.">spot::explicit_tau03_search</a>. Moreover, it introduce a slight optimisation based on vectors of integers counting for each acceptance condition how many time the condition has been visited in the path stored in the blue stack. Such a vector is associated to each state of this stack. </p>

</div>
</div>
<a class="anchor" id="ga159e81f9b91f99b2a749185f47924d99"></a><!-- doxytag: member="spot::explicit_tau03_search" ref="ga159e81f9b91f99b2a749185f47924d99" args="(const tgba *a, option_map o=option_map())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">emptiness_check* spot::explicit_tau03_search </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">option_map&#160;</td>
          <td class="paramname"><em>o</em> = <code>option_map()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an emptiness checker on the <a class="el" href="classspot_1_1tgba.html" title="A Transition-based Generalized Büchi Automaton.The acronym TGBA (Transition-based Generalized Büchi A...">spot::tgba</a> automaton <em>a</em>. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>The automaton <em>a</em> must have at least one acceptance condition.</dd></dl>
<p>During the visit of <em>a</em>, the returned checker stores explicitely all the traversed states. The implemented algorithm is the following:</p>
<div class="fragment"><pre class="fragment">
  /// procedure check ()
  /// begin
  ///   call dfs_blue(s0);
  /// end;
  ///
  /// procedure dfs_blue (s)
  /// begin
  ///   s.color = blue;
  ///   s.acc = emptyset;
  ///   for all t in post(s) do
  ///     if t.color == white then
  ///       call dfs_blue(t);
  ///     end if;
  ///   end for;
  ///   for all t in post(s) do
  ///     let (s, l, a, t) be the edge from s to t;
  ///     if s.acc U a not included in t.acc then
  ///       call dfs_red(t, a U s.acc);
  ///     end if;
  ///   end for;
  ///   if s.acc == all_acc then
  ///     report a cycle;
  ///   end if;
  /// end;
  ///
  /// procedure dfs_red(s, A)
  /// begin
  ///   s.acc = s.acc U A;
  ///   for all t in post(s) do
  ///     if t.color != white and A not included in t.acc then
  ///       call dfs_red(t, A);
  ///     end if;
  ///   end for;
  /// end;
  /// </pre></div><p>This algorithm is the one presented in</p>
<div class="fragment"><pre class="fragment">
  /// @techreport{HUT-TCS-A83,
  ///    address = {Espoo, Finland},
  ///    author = {Heikki Tauriainen},
  ///    institution = {Helsinki University of Technology, Laboratory for
  ///    Theoretical Computer Science},
  ///    month = {December},
  ///    number = {A83},
  ///    pages = {132},
  ///    title = {On Translating Linear Temporal Logic into Alternating and
  ///    Nondeterministic Automata},
  ///    type = {Research Report},
  ///    year = {2003},
  ///    url = {http://www.tcs.hut.fi/Publications/info/bibdb.HUT-TCS-A83.shtml}
  /// }
  /// </pre></div> 
</div>
</div>
<a class="anchor" id="ga054c1948b6c5076350e44a85ad580403"></a><!-- doxytag: member="spot::magic_search" ref="ga054c1948b6c5076350e44a85ad580403" args="(const tgba *a, option_map o=option_map())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">emptiness_check* spot::magic_search </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">option_map&#160;</td>
          <td class="paramname"><em>o</em> = <code>option_map()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper for the two magic_search implementations. </p>
<p>This wrapper calls explicit_magic_search_search() or <a class="el" href="group__emptiness__check__algorithms.html#gadae7938a96420813bcdabb1b31295294" title="Returns an emptiness checker on the spot::tgba automaton a.">bit_state_hashing_magic_search()</a> according to the <code>"bsh"</code> option in the <code><a class="el" href="classspot_1_1option__map.html" title="Manage a map of options.Each option is defined by a string and is associated to an integer value...">option_map</a></code>. If <code>"bsh"</code> is set and non null, its value is used as the size of the hash map. </p>

</div>
</div>
<a class="anchor" id="ga23a00d19bf7613222e6e41833e515c00"></a><!-- doxytag: member="spot::se05" ref="ga23a00d19bf7613222e6e41833e515c00" args="(const tgba *a, option_map o)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">emptiness_check* spot::se05 </td>
          <td>(</td>
          <td class="paramtype">const tgba *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">option_map&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper for the two se05 implementations. </p>
<p>This wrapper calls <a class="el" href="group__emptiness__check__algorithms.html#ga8c176368673a0c009dd3e934d57fb492" title="Returns an emptiness check on the spot::tgba automaton a.">explicit_se05_search()</a> or <a class="el" href="group__emptiness__check__algorithms.html#gae822266082cdb9772ce31388a6538cb9" title="Returns an emptiness checker on the spot::tgba automaton a.">bit_state_hashing_se05_search()</a> according to the <code>"bsh"</code> option in the <code><a class="el" href="classspot_1_1option__map.html" title="Manage a map of options.Each option is defined by a string and is associated to an integer value...">option_map</a></code>. If <code>"bsh"</code> is set and non null, its value is used as the size of the hash map. </p>

</div>
</div>
</div>
<hr size="1">
Please <b>comment</b> this page and <b>report errors</b> about it on
<a href="http://spot.lip6.fr/wiki/RefDocComments">the RefDocComments page</a>.
<br><address style="align: right;"><small>
Generated on Mon Nov 28 2011 15:23:18 for spot by <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border=0></a> 1.7.4</small></address>
</body>
</html>
