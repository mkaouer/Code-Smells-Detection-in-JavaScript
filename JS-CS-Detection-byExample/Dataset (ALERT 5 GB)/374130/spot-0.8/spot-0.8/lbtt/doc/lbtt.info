This is lbtt.info, produced by makeinfo version 4.13 from lbtt.texi.

This file documents how to use the LTL-to-Bu"chi translator testbench
`lbtt'.

   Copyright (C) 2005 Heikki Tauriainen <heikki.tauriainen@tkk.fi>

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


File: lbtt.info,  Node: Top,  Next: Copying,  Up: (dir)

`lbtt'
******

`lbtt' is a tool for testing implementations of algorithms for
translating propositional linear temporal logic formulas into Bu"chi
automata.

   This is edition 1.2.0 of the `lbtt' documentation. This edition
applies to `lbtt' versions 1.2.x.

   `lbtt' is free software, you may change and redistribute it under
the terms of the GNU General Public License.  `lbtt' comes with NO
WARRANTY. See *note Copying:: for details.

* Menu:

* Copying::                     GNU General Public License.

* Overview::                    A short introduction to `lbtt'.
* Test methods::                Description of the tests `lbtt'
                                  performs.

* Invocation::                  How to run the program.
* Interpreting the output::     Explanation of `lbtt''s output messages.
* Analyzing test results::      Working with `lbtt''s internal
                                  commands.

* Interfacing with lbtt::       Interfacing LTL-to-Bu"chi translators
                                  with `lbtt'.

* References::                  List of references.

* Definitions::                 A reference of the formal definitions of
                                  the various objects that `lbtt'
                                  manipulates.

* Configuration file option index::
* Command line option index::
* User command index::
* Concept index::


File: lbtt.info,  Node: Copying,  Next: Overview,  Prev: Top,  Up: Top

GNU GENERAL PUBLIC LICENSE
**************************

                         Version 2, June 1991

     Copyright (C) 1989, 1991 Free Software Foundation, Inc.
     59 Temple Place - Suite 330, Boston, MA  02111-1307, USA

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

Preamble
========

The licenses for most software are designed to take away your freedom
to share and change it.  By contrast, the GNU General Public License is
intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

   When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it in
new free programs; and that you know you can do these things.

   To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

   For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

   We protect your rights with two steps: (1) copyright the software,
and (2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

   Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

   Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

   The precise terms and conditions for copying, distribution and
modification follow.

    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
  0. This License applies to any program or other work which contains a
     notice placed by the copyright holder saying it may be distributed
     under the terms of this General Public License.  The "Program",
     below, refers to any such program or work, and a "work based on
     the Program" means either the Program or any derivative work under
     copyright law: that is to say, a work containing the Program or a
     portion of it, either verbatim or with modifications and/or
     translated into another language.  (Hereinafter, translation is
     included without limitation in the term "modification".)  Each
     licensee is addressed as "you".

     Activities other than copying, distribution and modification are
     not covered by this License; they are outside its scope.  The act
     of running the Program is not restricted, and the output from the
     Program is covered only if its contents constitute a work based on
     the Program (independent of having been made by running the
     Program).  Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
     source code as you receive it, in any medium, provided that you
     conspicuously and appropriately publish on each copy an appropriate
     copyright notice and disclaimer of warranty; keep intact all the
     notices that refer to this License and to the absence of any
     warranty; and give any other recipients of the Program a copy of
     this License along with the Program.

     You may charge a fee for the physical act of transferring a copy,
     and you may at your option offer warranty protection in exchange
     for a fee.

  2. You may modify your copy or copies of the Program or any portion
     of it, thus forming a work based on the Program, and copy and
     distribute such modifications or work under the terms of Section 1
     above, provided that you also meet all of these conditions:

       a. You must cause the modified files to carry prominent notices
          stating that you changed the files and the date of any change.

       b. You must cause any work that you distribute or publish, that
          in whole or in part contains or is derived from the Program
          or any part thereof, to be licensed as a whole at no charge
          to all third parties under the terms of this License.

       c. If the modified program normally reads commands interactively
          when run, you must cause it, when started running for such
          interactive use in the most ordinary way, to print or display
          an announcement including an appropriate copyright notice and
          a notice that there is no warranty (or else, saying that you
          provide a warranty) and that users may redistribute the
          program under these conditions, and telling the user how to
          view a copy of this License.  (Exception: if the Program
          itself is interactive but does not normally print such an
          announcement, your work based on the Program is not required
          to print an announcement.)

     These requirements apply to the modified work as a whole.  If
     identifiable sections of that work are not derived from the
     Program, and can be reasonably considered independent and separate
     works in themselves, then this License, and its terms, do not
     apply to those sections when you distribute them as separate
     works.  But when you distribute the same sections as part of a
     whole which is a work based on the Program, the distribution of
     the whole must be on the terms of this License, whose permissions
     for other licensees extend to the entire whole, and thus to each
     and every part regardless of who wrote it.

     Thus, it is not the intent of this section to claim rights or
     contest your rights to work written entirely by you; rather, the
     intent is to exercise the right to control the distribution of
     derivative or collective works based on the Program.

     In addition, mere aggregation of another work not based on the
     Program with the Program (or with a work based on the Program) on
     a volume of a storage or distribution medium does not bring the
     other work under the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
     under Section 2) in object code or executable form under the terms
     of Sections 1 and 2 above provided that you also do one of the
     following:

       a. Accompany it with the complete corresponding machine-readable
          source code, which must be distributed under the terms of
          Sections 1 and 2 above on a medium customarily used for
          software interchange; or,

       b. Accompany it with a written offer, valid for at least three
          years, to give any third party, for a charge no more than your
          cost of physically performing source distribution, a complete
          machine-readable copy of the corresponding source code, to be
          distributed under the terms of Sections 1 and 2 above on a
          medium customarily used for software interchange; or,

       c. Accompany it with the information you received as to the offer
          to distribute corresponding source code.  (This alternative is
          allowed only for noncommercial distribution and only if you
          received the program in object code or executable form with
          such an offer, in accord with Subsection b above.)

     The source code for a work means the preferred form of the work for
     making modifications to it.  For an executable work, complete
     source code means all the source code for all modules it contains,
     plus any associated interface definition files, plus the scripts
     used to control compilation and installation of the executable.
     However, as a special exception, the source code distributed need
     not include anything that is normally distributed (in either
     source or binary form) with the major components (compiler,
     kernel, and so on) of the operating system on which the executable
     runs, unless that component itself accompanies the executable.

     If distribution of executable or object code is made by offering
     access to copy from a designated place, then offering equivalent
     access to copy the source code from the same place counts as
     distribution of the source code, even though third parties are not
     compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
     except as expressly provided under this License.  Any attempt
     otherwise to copy, modify, sublicense or distribute the Program is
     void, and will automatically terminate your rights under this
     License.  However, parties who have received copies, or rights,
     from you under this License will not have their licenses
     terminated so long as such parties remain in full compliance.

  5. You are not required to accept this License, since you have not
     signed it.  However, nothing else grants you permission to modify
     or distribute the Program or its derivative works.  These actions
     are prohibited by law if you do not accept this License.
     Therefore, by modifying or distributing the Program (or any work
     based on the Program), you indicate your acceptance of this
     License to do so, and all its terms and conditions for copying,
     distributing or modifying the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
     Program), the recipient automatically receives a license from the
     original licensor to copy, distribute or modify the Program
     subject to these terms and conditions.  You may not impose any
     further restrictions on the recipients' exercise of the rights
     granted herein.  You are not responsible for enforcing compliance
     by third parties to this License.

  7. If, as a consequence of a court judgment or allegation of patent
     infringement or for any other reason (not limited to patent
     issues), conditions are imposed on you (whether by court order,
     agreement or otherwise) that contradict the conditions of this
     License, they do not excuse you from the conditions of this
     License.  If you cannot distribute so as to satisfy simultaneously
     your obligations under this License and any other pertinent
     obligations, then as a consequence you may not distribute the
     Program at all.  For example, if a patent license would not permit
     royalty-free redistribution of the Program by all those who
     receive copies directly or indirectly through you, then the only
     way you could satisfy both it and this License would be to refrain
     entirely from distribution of the Program.

     If any portion of this section is held invalid or unenforceable
     under any particular circumstance, the balance of the section is
     intended to apply and the section as a whole is intended to apply
     in other circumstances.

     It is not the purpose of this section to induce you to infringe any
     patents or other property right claims or to contest validity of
     any such claims; this section has the sole purpose of protecting
     the integrity of the free software distribution system, which is
     implemented by public license practices.  Many people have made
     generous contributions to the wide range of software distributed
     through that system in reliance on consistent application of that
     system; it is up to the author/donor to decide if he or she is
     willing to distribute software through any other system and a
     licensee cannot impose that choice.

     This section is intended to make thoroughly clear what is believed
     to be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
     certain countries either by patents or by copyrighted interfaces,
     the original copyright holder who places the Program under this
     License may add an explicit geographical distribution limitation
     excluding those countries, so that distribution is permitted only
     in or among countries not thus excluded.  In such case, this
     License incorporates the limitation as if written in the body of
     this License.

  9. The Free Software Foundation may publish revised and/or new
     versions of the General Public License from time to time.  Such
     new versions will be similar in spirit to the present version, but
     may differ in detail to address new problems or concerns.

     Each version is given a distinguishing version number.  If the
     Program specifies a version number of this License which applies
     to it and "any later version", you have the option of following
     the terms and conditions either of that version or of any later
     version published by the Free Software Foundation.  If the Program
     does not specify a version number of this License, you may choose
     any version ever published by the Free Software Foundation.

 10. If you wish to incorporate parts of the Program into other free
     programs whose distribution conditions are different, write to the
     author to ask for permission.  For software which is copyrighted
     by the Free Software Foundation, write to the Free Software
     Foundation; we sometimes make exceptions for this.  Our decision
     will be guided by the two goals of preserving the free status of
     all derivatives of our free software and of promoting the sharing
     and reuse of software generally.

                                NO WARRANTY
 11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO
     WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE
     LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
     HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT
     WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT
     NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
     FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE
     QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
     PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY
     SERVICING, REPAIR OR CORRECTION.

 12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
     WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY
     MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE
     LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL,
     INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
     INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
     DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU
     OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY
     OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN
     ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

                      END OF TERMS AND CONDITIONS
Appendix: How to Apply These Terms to Your New Programs
=======================================================

If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

   To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

     ONE LINE TO GIVE THE PROGRAM'S NAME AND A BRIEF IDEA OF WHAT IT DOES.
     Copyright (C) YYYY  NAME OF AUTHOR

     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.

     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
     USA.

   Also add information on how to contact you by electronic and paper
mail.

   If the program is interactive, make it output a short notice like
this when it starts in an interactive mode:

     Gnomovision version 69, Copyright (C) 19YY NAME OF AUTHOR
     Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
     This is free software, and you are welcome to redistribute it
     under certain conditions; type `show c' for details.

   The hypothetical commands `show w' and `show c' should show the
appropriate parts of the General Public License.  Of course, the
commands you use may be called something other than `show w' and `show
c'; they could even be mouse-clicks or menu items--whatever suits your
program.

   You should also get your employer (if you work as a programmer) or
your school, if any, to sign a "copyright disclaimer" for the program,
if necessary.  Here is a sample; alter the names:

     Yoyodyne, Inc., hereby disclaims all copyright interest in the program
     `Gnomovision' (which makes passes at compilers) written by James Hacker.

     SIGNATURE OF TY COON, 1 April 1989
     Ty Coon, President of Vice

   This General Public License does not permit incorporating your
program into proprietary programs.  If your program is a subroutine
library, you may consider it more useful to permit linking proprietary
applications with the library.  If this is what you want to do, use the
GNU Library General Public License instead of this License.


File: lbtt.info,  Node: Overview,  Next: Test methods,  Prev: Copying,  Up: Top

1 Overview
**********

`lbtt' is a tool for testing programs that translate formulas expressed
in propositional linear temporal logic ("LTL") into Bu"chi automata.
These finite-state automata over infinite words are used e.g. in
automata-theoretic model checking *note [VW86]::, *note [Var96]::,
where they can help in detecting errors in the specifications of
finite-state hardware or software systems. Usually the model checking
procedure involves first composing an automaton with a formal model of
a given system, and the result of the composition reveals whether any
computation path of the system violates some property that the
automaton represents.  (For an introduction to model checking
techniques in general, see, for example, *note [CGP99]::.)

   The property to be model checked can be specified as an LTL formula,
and the Bu"chi automaton used for model checking is obtained
automatically from the formula with a translation algorithm.  (For
descriptions and optimization techniques for such algorithms, see the
references, for example, *note [VW86]::, *note [Isl94]::, *note
[GPVW95]::, *note [Cou99]:: *note [DGV99]::, *note [Ete99]::, *note
[SB00]::, *note [EH00]::, *note [EWS01]::, *note [GO01]::, *note
[Gei01]::, *note [Sch01]::, *note [Wol01]::, *note [Ete02]::, *note
[GL02]::, *note [GSB02]::, *note [Thi02]::, *note [Fri03]::, *note
[GO03]::, *note [Lat03]::, *note [ST03]::.)  In practice, ensuring the
correctness of the implementation of such a translation algorithm is
crucial to guarantee the soundness of the implementation of a model
checking procedure.

   The goal of `lbtt' is to assist implementing LTL-to-Bu"chi
translation algorithms correctly by providing an automated testing
environment for LTL-to-Bu"chi translators. Testing consists of running
LTL-to-Bu"chi translators on randomly generated (or user-specified) LTL
formulas as input and then performing simple consistency checks on the
resulting automata to test whether the translators seem to function
correctly in practice. (See *note [TH02]:: for more information on the
theory behind the testing methods.) If the test results suggest that
there is an error in an implementation, `lbtt' can generate sample data
which causes a test failure and which may also be useful for debugging
the implementation.

   Additionally, the testing environment can be used for very basic
profiling of different LTL-to-Bu"chi translators to evaluate their
performance.

_Note: although `lbtt' might be able to detect inconsistent behavior in
an LTL-to-Bu"chi translator, it is only a testing tool and is therefore
incapable of formally proving any translation algorithm implementation
to be correct. Therefore, the test results should never be used as the
sole basis for any formal conclusions about the correctness of an
implementation.  _


File: lbtt.info,  Node: Test methods,  Next: Invocation,  Prev: Overview,  Up: Top

2 Test methods
**************

This chapter describes the algorithms `lbtt' uses for generating input
for the tests and introduces some terminology.  A short description of
each test is also included together with the outline of `lbtt''s
testing procedure. However, the chapter is not intended to be a
thorough introduction to the theoretical background of the different
tests; see, for example, *note [TH02]:: or *note [Tau00]:: for more
information.

* Menu:

* Random input generation::     How `lbtt' generates input for the
                                  tests.
* Testing procedure::           Outline of `lbtt''s testing
                                  procedure.
* Model checking result cross-comparison test::
                                Model checking the same LTL formula in
                                  a fixed state space using different
                                  LTL-to-Bu"chi translators should
                                  give the same model checking result.
* Model checking result consistency check::
                                Model checking two complementary LTL
                                  formulas in the same state space using
                                  an LTL-to-Bu"chi translator should
                                  give consistent results.
* Automata intersection emptiness check::
                                The intersection of the languages
                                  accepted by two Bu"chi automata
                                  constructed from two complementary
                                  LTL formulas should be empty.


File: lbtt.info,  Node: Random input generation,  Next: Testing procedure,  Prev: Test methods,  Up: Test methods

2.1 Random input generation
===========================

By default, all tests `lbtt' makes are based on randomly generated
input. However, the LTL formulas used as input for the LTL-to-Bu"chi
translators can be optionally given by the user by telling `lbtt' to
read LTL formulas from a file or from standard input (*note
`--formulafile' command line option: --formulafile.).

   Additionally, some of the tests make use of randomly generated
"state spaces", which are basically directed labeled graphs with labels
on nodes with the additional requirement of having at least one arc
leaving each node. The label of each node is a subset of a finite
collection of atomic propositions (an uninterpreted set of assertions
which may or may not hold in a state), which occur also in the LTL
formulas used in the tests.

   The following sections describe how `lbtt' generates input for the
tests and list the parameters which can be used to adjust the behavior
of the input generation algorithms.

* Menu:

* Random LTL formulas::         How `lbtt' generates random
                                  LTL formulas.
* Random state spaces::         How `lbtt' generates random
                                  state spaces.


File: lbtt.info,  Node: Random LTL formulas,  Next: Random state spaces,  Prev: Random input generation,  Up: Random input generation

2.1.1 Random LTL formulas
-------------------------

The LTL formulas used by `lbtt' are built from atomic propositions
(with names of the form `pN' for some nonnegative integer N), the
Boolean constants `true' and `false', and logical or temporal
operators. `lbtt' supports the following logical operators:

   * logical disjunction (`\/' as shown in output messages),

   * logical conjunction (`/\'),

   * logical negation (`!'),

   * logical implication (`->')

   * logical equivalence (`<->')

   * logical "exclusive or" (`xor')


and the following temporal operators:

   * "Next time" (`X'),

   * "(Strong) Until" (`U'),

   * "Weak Until" (also known as "Unless") (`W'),

   * "Finally" ("Eventually") (`<>')

   * "Before" (`B')

   * "(Weak) Release", the dual of "(Strong) Until" (`V'),

   * "Strong Release", the dual of "Weak Until" (`M'),

   * "Globally" ("Always", "Henceforth") (`[]').


See *note LTL formulas::, for a reference on the exact semantics of
these operators.

   The behavior of `lbtt''s random formula generation algorithm can be
adjusted with the following parameters:

   * Number of nodes in the parse tree of a formula (i.e., the total
     number of occurrences of propositions, Boolean constants and
     operators in the formula).

   * Number of different atomic propositions that can be used for
     generating a formula. (Note that this does not restrict the total
     number of atomic propositions in the formula, nor the number of
     occurrences of any individual proposition. However, none of the
     generated formulas will have more than this number of _different_
     atomic propositions.)

   * Priorities for the Boolean constants and atomic propositions. The
     priority of a symbol determines the relative likelihood of its
     occurrence in a generated formula. The higher the priority of a
     symbol, the more likely it is that the symbol will occur (with
     respect to the other symbols) in a generated formula; a zero
     priority will exclude the symbol altogether.

   * Priorities for the logical and temporal operators.


Note that the priorities for atomic symbols (Boolean constants and
atomic propositions) and the priorities of the logical and temporal
operators are independent, i.e., changing the priority of an atomic
symbol does not affect the likelihood of the occurrence of any logical
or temporal operator and vice versa.

   For further details, see *note The formula generation algorithm::
for a pseudocode description of the algorithm used for generating
random LTL formulas.


File: lbtt.info,  Node: The formula generation algorithm,  Prev: Random LTL formulas,  Up: Random LTL formulas

2.1.1.1 The formula generation algorithm
........................................

`lbtt' uses an algorithm similar to the one outlined in *note [DGV99]::
for generating random LTL formulas. The algorithm can be described in
pseudocode as follows:

     1  function RandomFormula(N : Integer) : LtlFormula;
     2      if N = 1 then begin
     3          P := random atomic proposition or TRUE or FALSE;
     4          return P;
     5      end
     6      else if N = 2 then begin
     7          OP := random unary operator;
     8          F := RandomFormula(1);
     9          return OP F;
     10     end
     11     else begin
     12         OP := random unary or binary operator;
     13         if OP is a unary operator then begin
     14             F := RandomFormula(N-1);
     15             return OP F;
     16         end
     17         else begin
     18             X := random integer in the interval [1,N-2];
     19             F1 := RandomFormula(X);
     20             F2 := RandomFormula(N-X-1);
     21             return (F1 OP F2);
     22         end;
     23     end;
     24 end;

   Each invocation of the algorithm returns an LTL formula with N nodes
in the formula parse tree. The behavior of the algorithm can be adjusted
by giving values for the parameters N (the number of nodes in the
formula parse tree), |AP| (the number of different atomic
propositions), and pri(SYMBOL) (the priorities for the different
symbols).

   In `lbtt''s implementation of the above algorithm, the priority of a
symbol determines the probability with which the symbol is chosen into
a generated formula each time line 3, 7 or 12 of the algorithm is
executed. For Boolean constants `true' and `false' (line 3 of the
algorithm), the probability is given by the equation

   pri(CONSTANT) / (pri(AP) + pri(`true') + pri(`false'))

where CONSTANT is either `true' or `false', and pri(AP) is the total
priority of all atomic propositions.

   The probability of choosing a particular atomic proposition into a
formula (line 3) is

   pri(AP) / (|AP| * (pri(AP) + pri(`true') + pri(`false'))),

where |AP| and pri(AP) are as defined above.

   Line 7 of the algorithm concerns choosing a unary operator (`!',
`X', `<>' or `[]') into a formula. Here the probability of choosing the
unary operator OP is given by the equation

   pri(OP) / Sum (pri(OP')),

where OP' ranges over all unary operators.

   Finally, at line 12 of the algorithm, the probability of choosing
the (unary or binary) operator OP into the formula is

   pri(OP) / Sum (pri(OP')),

where OP' ranges over all unary and binary operators (`!', `\/', `/\',
`->', `<->', `xor', `X', `U', `W', `<>', `B', `V', `M', `[]').

   An analysis of this algorithm is included in an appendix of *note
[Tau00]::.  The analysis shows how to use the operator priorities to
calculate the expected number of occurrences of an operator in a
randomly generated formula. `lbtt' can optionally compute the expected
operator distribution for a given combination of operator priorities;
see the `--showoperatordistribution' command line option (*note
`--showoperatordistribution' command line option:
--showoperatordistribution.)  for more information.

   See also the web page
`http://www.tcs.hut.fi/Software/lbtt/formulaoptions.php' for an
interface to a small database for adjusting the operator priorities
towards certain simple distributions.


File: lbtt.info,  Node: Random state spaces,  Prev: Random LTL formulas,  Up: Random input generation

2.1.2 Random state spaces
-------------------------

State spaces are needed as input for tests only in the model checking
result cross comparison test (*note Model checking result
cross-comparison test::) and the model checking result consistency check
(*note Model checking result consistency check::).  The state spaces
are directed labeled graphs, each node of which is labeled with a
randomly chosen set of atomic propositions (the propositions that hold
in the state corresponding to the graph node). In addition, each state
of the state space always has at least one successor.

   `lbtt' provides three different random state space generation
algorithms that differ in the structure of the generated state spaces.
The common parameters for each of these algorithms are:

   * Number of states in the state space.

   * Maximum number of different atomic propositions allowed in the
     label of any state of the state space.

   * The probability with which each atomic proposition should hold in
     a state of the state space (which is, for simplicity, common to
     all atomic propositions).


The different types of random state spaces that can be generated are: 

  1. Random connected graphs. These state spaces are guaranteed to have
     at least one state such that every other state of the state space
     is reachable from this state. In addition to the three above
     parameters, the behavior of the algorithm generating these state
     spaces can be adjusted by specifying a probability which
     approximates the "density" of the graph, i.e., the probability
     that there is a directed edge from a state X to another state Y,
     where X and Y are any two states in the state space. For more
     details, see *note Algorithm for generating connected graphs::.

  2. Random graphs. These state spaces are constructed simply by taking
     all pairs (X, Y) of states in the state space and connecting state
     X to state Y with a user-specified probability that approximates
     the graph density.

  3. Random paths. A random path is simply a non-branching sequence of
     states, where the last state of the sequence is connected to a
     randomly chosen state earlier in the sequence.


   `lbtt' also includes a state space generation algorithm which
systematically enumerates all "paths" (see above) of a given size with a
given number of atomic propositions in each state. If |S| is the number
of states in the path and |AP| is the number of atomic propositions in
each state of the path, it is easy to see that the number of different
paths having these parameters is

   |S| * 2^(|S| * |AP|),

a number which grows exponentially in the product of the two parameters.
Obviously, this makes the exhaustive enumeration of all paths of a
given size practicable only for very small values of |S| and |AP|.

   In practice, testing should be started using only very small state
spaces (say, with only 10-50 states and a small density) regardless of
the particular algorithm chosen for generating the state spaces. The
size of the state spaces can then be increased if `lbtt''s memory
consumption and the time spent running the tests stay within acceptable
limits.


File: lbtt.info,  Node: Algorithm for generating connected graphs,  Prev: Random state spaces,  Up: Random state spaces

2.1.2.1 Algorithm for generating connected graphs
.................................................

`lbtt' uses the following algorithm for generating random connected
graphs:

     1  function RandomGraph(N : Integer; D : Real in [0.0,1.0];
                             T : Real in [0.0,1.0]) : Graph;
     2      S := {s1, s2, ..., sn};
     3      NODESTOPROCESS := {s1};
     4      UNREACHABLENODES := {s2, s3, ..., sn};
     5      EDGES := {};
     6      while NODESTOPROCESS is not empty do begin
     7          STATE := a random node in NODESTOPROCESS;
     8          remove STATE from NODESTOPROCESS;
     9          LABEL(STATE) := {};
     10         for all P in AP do
     11             if RandomNumber(0.0, 1.0) < T then
     12                 insert P into LABEL(STATE);
     13         if UNREACHABLENODES is not empty then begin
     14             STATE' := a random node in UNREACHABLENODES;
     15             remove STATE' from UNREACHABLENODES;
     16             insert STATE' into NODESTOPROCESS;
     17             insert (STATE,STATE') into EDGES;
     18         end;
     19         for all STATE' in S do
     20             if RandomNumber(0.0, 1.0) < D then begin
     21                 insert (STATE,STATE') into EDGES;
     22                 if STATE' is in UNREACHABLENODES then begin
     23                     remove STATE' from UNREACHABLENODES;
     24                     insert STATE' into NODESTOPROCESS;
     25                 end;
     26             end;
     27         if there is no edge (STATE,STATE') in EDGES
                                          for any STATE' in S then
     28             insert (STATE,STATE) into EDGES;
     29     end;
     30     return <S, EDGES, s1, LABEL>;
     31 end;

   The algorithm receives the parameters N (number of states in the
state spaces), D (approximate density of the generated graph) and T
(the probability with which each of the propositions in AP should hold
in a state) and returns the generated state space as a quadruple <S,
EDGES, s1, LABEL>. Here S is the set of states, EDGES is the set of
directed edges between the states, s1 is a state from which every state
of the state space can be reached, and LABEL is a function which maps
each state to its label (a subset of AP).


File: lbtt.info,  Node: Testing procedure,  Next: Model checking result cross-comparison test,  Prev: Random input generation,  Up: Test methods

2.2 Testing procedure
=====================

The following figure illustrates the first two tests in `lbtt''s
testing procedure:

 [image src="testprocedure.png" text="
,,,,,,,,,,,,,,,
: State space :
'''''''''''''''
  |
  |     ,,,,,,,,,,,,,,,,,,,          ,,,,,,,,,,,,,,,,,,,,,,,,,,,,
  |     : LTL formula `f' :_____     : Negated LTL formula `!f' :
  |     '''''''T''''''T''''     \\ ___'''''''T'''''''''''T''''''''
  |            |       \\      ___X         /            |
  |            |        \\ ___/    \\______ /             |
  |            |      ___X               X_______       |
  |            |     /    \\             /        \\      |
  |            V    V      V           V          V     V
  |     ::::::::::::::::  ::::::::::::::::       ::::::::::::::::
  |     : LTL-to-Buchi :  : LTL-to-Buchi : . . . : LTL-to-Buchi :
  |     : translator 1 :  : translator 2 :       : translator n :
  |     ::::::::::::::::  ::::::::::::::::       ::::::::::::::::
  |        |        |            |   |              /       |
  |        |        |            |   |             /        |
  |        V        V            |   |            V         V
  | ,,,,,,,,,,,,, ,,,,,,,,,,,,,, |   | ,,,,,,,,,,,,, ,,,,,,,,,,,,,,
  | : Automaton : : Automaton  : |   | : Automaton : : Automaton  :
  | : 1 for `f' : : 1 for `!f' : |   | : n for `f' : : n for `!f' :
  | ''T'''''''''' '''T'''''''''' |   | ''''''''''T'' '''''''''''T''
  |   |            _/            V   V            \\_____         \\_
  |   |           /   ,,,,,,,,,,,,, ,,,,,,,,,,,,,,      \\          \\
  |   |          |    : Automaton : : Automaton  :       |          |
  |   |          |    : 2 for `f' : : 2 for `!f' :       |          |
  |   |          |    '''''''''T''' '''''''T''''''       |          |
  |   !          !             !           !             !          |
  |__________________________________________________________       |
  |   .   \\      .      \\      .    \\      .      \\      .   \\      |
  |   :    \\     :       \\     :     \\     :       \\     :    \\     |
  |   |     \\    |        \\    |      \\    |        \\    |     \\    |
  V   V      V   V         V   V       V   V         V   V      V   V
:::::::::  :::::::::     :::::::::   :::::::::     :::::::::  :::::::::
: Model :  : Model :     : Model :   : Model :     : Model :  : Model :
: check :  : check :     : check :   : check :     : check :  : check :
:::::::::  :::::::::     :::::::::   :::::::::     :::::::::  :::::::::
 |    \\         |   \\     /    |       |    \\     /   |         /    |
 |     \\        |    \\   /     |       |     \\   /    |        /     |
 |      \\       |     \\ /      |       |      \\ /     |       /      |
 |       V      V      X       V       V       X      V      V       |
 |  ###############   / \\   ###############   / \\   ###############  |
 |  # Consistency #  |   |  # Consistency #  |   |  # Consistency #  |
 |  #    check    #  |   |  #    check    #  |   |  #    check    #  |
 |  ###############  |   |  ###############  |   |  ###############  |
  \\______            |    \\_______   _______/    |            ______/
         \\           |            \\ /            |           /
          |          |             X             |          |
          |          |           _/ \\_           |          |
          V          V          V     V          V          V
         #########################   #########################
         # Cross-comparison test #   # Cross-comparison test #
         #########################   #########################
" ]

After obtaining an LTL formula f (either by reading it from a file or
by calling the random formula generation algorithm), `lbtt' invokes
each LTL-to-Bu"chi translator participating in the tests in turn to
construct a collection of Bu"chi automata for the formula f _and_ the
negated formula ! f.  Each of these automata is then composed with the
randomly generated state space, whereafter `lbtt' performs the model
checking result cross-comparison test (*note Model checking result
cross-comparison test::) and the model checking result consistency check
(*note Model checking result consistency check::) on the model checking
results, and reports all detected failures.

   The Bu"chi automata intersection emptiness check (*note Automata
intersection emptiness check::) operates as follows (note that the
LTL-to-Bu"chi translation phase is repeated in this figure only for
completeness; in reality, `lbtt' performs this phase only once):

 [image src="intersectioncheck.png" text="
        ,,,,,,,,,,,,,,,,,,,          ,,,,,,,,,,,,,,,,,,,,,,,,,,,,
        : LTL formula `f' :_____     : Negated LTL formula `!f' :
        '''''''T''''''T''''     \\ ___'''''''T'''''''''''T''''''''
               |       \\      ___X         /            |
               |        \\ ___/    \\______ /             |
               |      ___X               X_______       |
               |     /    \\             /        \\      |
               V    V      V           V          V     V
        ::::::::::::::::  ::::::::::::::::       ::::::::::::::::
        : LTL-to-Buchi :  : LTL-to-Buchi : . . . : LTL-to-Buchi :
        : translator 1 :  : translator 2 :       : translator n :
        ::::::::::::::::  ::::::::::::::::       ::::::::::::::::
           |        |            |   |              /       |
           |        |            |   |             /        |
           V        V            |   |            V         V
    ,,,,,,,,,,,,, ,,,,,,,,,,,,,, |   | ,,,,,,,,,,,,, ,,,,,,,,,,,,,,
    : Automaton : : Automaton  : |   | : Automaton : : Automaton  :
    : 1 for `f' : : 1 for `!f' : |   | : n for `f' : : n for `!f' :
    ''''''''''''' ''T''''''''''' |   | ''''''''''T'' ''''''''''''''
   /       ________/             |   |            \\_________       \\
  /       /                      V   V                      \\       \\
 /       /            ,,,,,,,,,,,,, ,,,,,,,,,,,,,,           \\       \\
|       |             : Automaton : : Automaton  :            |       |
|      / \\            : 2 for `f' : : 2 for `!f' :           / \\      |
|     |   |           ''T''''T''T'' ''T''T''''T'''          |   |     |
|     |   |             |    |  |     |  |    |             |   |     |
|     |   V             V    |  |     |  |    V             V   |     |
|     |  #################   |   \\   /   |   #################  |     |
|     |  # Intersection  #   |    \\ /    |   # Intersection  #  |     |
|     |  #   emptiness   #   |     X     |   #   emptiness   #  |     |
|     |  #     check     #   !    / \\    !   #     check     #  |     |
|\\    |  #################   :   /   \\   :   #################  |    /|
| \\    \\___________        _____/     \\_____        ___________/    / |
|  \\               \\      /  .           .  \\      /               /  |
|   \\             / \\    |   :           :   |    / \\             /   |
|    V           V   \\   |   |           |   |   /   V           V    |
|  #################  \\ /    V           V    \\ /  #################  |
|  # Intersection  #   X   #################   X   # Intersection  #  |
|  #   emptiness   #  / \\  # Intersection  #  / \\  #   emptiness   #  |
|  #     check     # |   | #   emptiness   # |   | #     check     #  |
|  ################# |   | #     check     # |   | #################  |
|\\                   |   | ################# |   |                   /|
| \\                 /     \\                 /     \\                 / |
|  V               V       V               V       V               V  |
|   #################      #################      #################   |
|   # Intersection  #      # Intersection  #      # Intersection  #   |
|   #   emptiness   #      #   emptiness   #      #   emptiness   #   |
|   #     check     #      #     check     #      #     check     #   |
|   #################      #################      #################   |
 \\                                                                   /
  \\                        #################                        /
   \\                       # Intersection  #                       /
    +--------------------->#   emptiness   #<---------------------+
                           #     check     #
                           #################
" ]

   The test procedure can then be repeated using a different LTL formula
and/or a different state space.


File: lbtt.info,  Node: Model checking result cross-comparison test,  Next: Model checking result consistency check,  Prev: Testing procedure,  Up: Test methods

2.3 Model checking result cross-comparison test
===============================================

LTL model checking can be used to test whether any of the infinite paths
starting from some state of a state space satisfies a given LTL
formula. For a fixed LTL formula, this question may have a different
answer in different states of the state space, but the answer should be
independent of the details of any (correct) implementation of the LTL
model checking procedure.

   Therefore, it is possible to test LTL-to-Bu"chi translators by
comparing the results obtained by model checking an LTL formula in a
fixed state space several times, using each time a different translator
for constructing a Bu"chi automaton from the LTL formula. Differences
in the model checking results then suggest that at least one of the
translators failed to translate the LTL formula correctly into an
automaton.

   To extract as much test data as possible from a state space, `lbtt'
will by default make the model checking result comparison "globally" in
the state space, which means using each LTL-to-Bu"chi translator to
find _all_ states in the state space with an infinite path supposedly
satisfying some LTL formula and then comparing the resulting state sets
for equality. Alternatively, the test can be performed only "locally"
in a single state of each state space (i.e., by choosing some state of
the state space and checking that all Bu"chi automata constructed using
the different translators give the same model checking result in that
state), which may speed up testing, but will reduce the number of
comparison tests. In addition, `lbtt' repeats the result
cross-comparison test for the negation of each LTL formula, since model
checking also the negated formula permits making an additional
consistency check (see below) on the results computed using each
implementation.

   Note: If the generated state spaces are paths (either random or
systematically enumerated, *note Random state spaces::), `lbtt' will
then include its internal LTL model checking algorithm (a restricted
model checking algorithm used normally in test failure analysis, *note
Analyzing test results::) into the model checking result
cross-comparison test. This is especially useful if there is only one
translation algorithm implementation available for testing (in which
case normal model checking result cross-comparison is obviously
redundant) but may be of advantage also in other cases by providing an
additional implementation to include in the tests.


File: lbtt.info,  Node: Model checking result consistency check,  Next: Automata intersection emptiness check,  Prev: Model checking result cross-comparison test,  Up: Test methods

2.4 Model checking result consistency check
===========================================

LTL model checking tells whether any of the infinite paths starting
from some state of a state space satisfies a given LTL formula. If there
are no such paths beginning from the state, it follows that all
infinite paths beginning from the state must then satisfy the
_negation_ of the same formula. Since all state spaces used by `lbtt'
always have at least one path beginning from each state of the state
space (guaranteed by the state space generation algorithms), at least
one path beginning from any state must satisfy either the formula or its
negation, i.e., it cannot be the case that none of the paths is a model
of either formula.

   However, implementation errors in an LTL-to-Bu"chi translator used
for model checking may actually lead to this inconsistent model
checking result if the translation of either of the formulas results in
an incorrect automaton, in which case `lbtt' will report an error.

   Similarly to the model checking result cross-comparison test, the
model checking result consistency check can be performed either in all
states of the state space ("globally") or only in a single state of the
state space ("locally"), with the same trade-offs between testing speed
and number of tests as described in the previous section (*note Model
checking result cross-comparison test::).


File: lbtt.info,  Node: Automata intersection emptiness check,  Prev: Model checking result consistency check,  Up: Test methods

2.5 Automata intersection emptiness check
=========================================

The semantics of LTL guarantees that no model of an LTL formula can be
the model of the negation of the same formula. In terms of Bu"chi
automata, this implies that the languages accepted by automata
constructed from two complementary LTL formulas should be disjoint.
This can be confirmed by intersecting the automata (i.e., by composing
the automata to construct a third Bu"chi automaton that accepts
precisely those inputs accepted by both of the original automata) and
checking the result for emptiness. If the intersection is found to be
nonempty, however, at least one of the LTL-to-Bu"chi translator(s) used
for constructing the original automata must have failed to perform the
translation of either formula correctly.


File: lbtt.info,  Node: Invocation,  Next: Interpreting the output,  Prev: Test methods,  Up: Top

3 Invocation
************

`lbtt' is started with the command `lbtt' with optional command line
parameters. Before starting the program, however, you need to create a
configuration file which lists the LTL-to-Bu"chi translators to be
tested and defines additional testing parameters.  *Note Configuration
file::. If no suitable configuration file is found or if the
configuration file cannot be processed successfully, `lbtt' exits with
an error message.

   After reading the configuration file, `lbtt' starts tests on the
LTL-to-Bu"chi translators listed in the configuration file (for details
about the testing procedure, see *note Test methods::). The program
exits after a predetermined number of test rounds.

   If the program is started in any of its interactive modes (see *note
Interactivity modes::), the program may occasionally pause to wait for
user input between test rounds. Type `quit <ENTER>' at the prompt to
exit `lbtt' at this point (or see *note Analyzing test results::, for
more information on how to use `lbtt''s internal commands).

* Menu:

* Configuration file::          Description of the configuration file
                                  format.
* Command line options::        List of command line options.


File: lbtt.info,  Node: Configuration file,  Next: Command line options,  Prev: Invocation,  Up: Invocation

3.1 Configuration file
======================

The configuration file of `lbtt' contains a list of the LTL-to-Bu"chi
translators to be tested along with other options which affect the way
the tests are performed. The configuration file is processed before
starting the tests. By default, `lbtt' will try to read the
configuration from the file `config' in the current working directory;
a different file name can be specified with the `--configfile=FILENAME'
command line option.

   The configuration file consists of one or more sections, each of
which provides a collection of interrelated configuration options. The
general format of the configuration file is

     SECTION-NAME
     {
       OPTION-NAME = VALUE
       OPTION-NAME = VALUE
       ...
     }

     ...

Section and option names are case-insensitive. Values can be numbers,
strings or truth values (`yes' and `no', or equivalently, `true' and
`false'). String values are case-sensitive and are subject to common
quoting and escaping rules (i.e., string values containing white space
should be enclosed in quotes, or the white space characters should be
escaped with `\').

   Comments can be included by putting a `#' symbol before them; the
end of any line containing the `#' character will be ignored when
processing the configuration file.

   The configuration file must contain at least one `Translator'
section specifying an LTL-to-Bu"chi translator. The other sections are
optional and can be used to override the default testing parameters.

* Menu:

* Translator section::            Each LTL-to-Bu"chi translator to be
                                    tested requires a separate
                                    `Translator' section in the
                                    configuration file.
* GlobalOptions section::         Options for changing the general
                                    behavior of `lbtt'.
* FormulaOptions section::        Options controlling the way random
                                    LTL formulas are generated.
* StateSpaceOptions section::     Options controlling the way random
                                    state spaces are generated.
* Sample configuration file::     An example of a configuration file.


File: lbtt.info,  Node: Translator section,  Next: GlobalOptions section,  Prev: Configuration file,  Up: Configuration file

3.1.1 The `Translator' section
------------------------------

Each LTL-to-Bu"chi translator to be tested requires a separate
`Translator' section(1) in the configuration file; there must be at
least one such section in the file.

   The translators are assumed to be accessible through external
executable files. Therefore, this section must at a minimum specify the
full file name of the executable to run in order to invoke the
translator; see *note Translator interface::, for information about the
conventions `lbtt' uses to communicate with the LTL-to-Bu"chi
translators.

   Translators specified in the configuration file are given unique
integer identifiers in the order they are listed in the file, starting
from zero. These numbers can be used when referring to the different
translators when using `lbtt''s internal commands (*note Analyzing test
results::). Alternatively, the translators can be referred to using the
names specified in the configuration file.

   The following options (in alphabetical order) are available within
this section:

`Enabled = TRUTH-VALUE'
     This option determines whether the translator should be initially
     included in or excluded from the tests. The default value is
     `Yes'. The translator can be enabled or disabled during testing
     with `lbtt''s internal commands (*note Test control commands::).

`Name = STRING'
     This option can be used to specify a unique textual identifier for
     the LTL-to-Bu"chi translator. `lbtt' will use this identifier when
     displaying various messages concerning the implementation; the
     identifier can also be used to refer to the implementation when
     working with `lbtt''s internal commands (*note Analyzing test
     results::). (If no name has been explicitly given for the
     translator, `lbtt' assigns the translator a name of the form
     `Algorithm N', where N is the running integer identifier for the
     translators.)

     The identifier `lbtt' is reserved for `lbtt''s internal model
     checking algorithm (*note Model checking result cross-comparison
     test::).

`Parameters = STRING'
     This option can be used to specify any additional parameters that
     should be passed to the translator executable whenever running it.
     (The parameter string defaults to the empty string if the option
     is not used.)

`Path = STRING'
     This option must be given a value for each translator specified in
     the configuration file. The value should be the complete file name
     of the program which is used to run the translator.


   ---------- Footnotes ----------

   (1) The `Algorithm' and `Implementation' keywords are recognized as
aliases of the `Translator' keyword.


File: lbtt.info,  Node: GlobalOptions section,  Next: FormulaOptions section,  Prev: Translator section,  Up: Configuration file

3.1.2 The `GlobalOptions' section
---------------------------------

The `GlobalOptions' section includes options that affect the general
behavior of `lbtt'. Options available within this section are (in
alphabetical order):

`ComparisonCheck = TRUTH-VALUE'
`ComparisonTest = TRUTH-VALUE'
     This option can be used to enable or disable the model checking
     result cross-comparison test (*note Model checking result
     cross-comparison test::).  The test is enabled by default.

`ConsistencyCheck = TRUTH-VALUE'
`ConsistencyTest = TRUTH-VALUE'
     This option can be used to enable or disable the model checking
     result consistency check (*note Model checking result consistency
     check::). The test is enabled by default.

`Interactive = MODE-LIST'
     This option determines when `lbtt' should pause to wait for user
     input between test rounds. The MODE-LIST is a comma-separated list
     of the following modes (with no spaces in between the modes):
    `Always'
          Pause unconditionally after each test round.

    `OnError'
          Pause testing only after failed test rounds.

    `Never'
          Run all tests without interruption.

    `OnBreak'
          Pause testing when requested by the user (for example, after
          receiving a break signal from the keyboard). If this mode is
          not specified, `lbtt' will respond to break signals by
          aborting.

     (Since the first three interactivity modes are mutually exclusive,
     it does not make sense to combine these modes with each other.)
     The default mode list consists of the value `Always', that is,
     testing is paused after every test round, and signalling a break
     will abort testing.

`IntersectionCheck = TRUTH-VALUE'
`IntersectionTest = TRUTH-VALUE'
     This option can be used to enable or disable the Bu"chi automata
     intersection emptiness check (*note Automata intersection
     emptiness check::). The test is enabled by default.

`ModelCheck = Local | Global'
     This option determines whether `lbtt' should perform model checking
     with respect to all states of each state space or only with respect
     to a single state of each state space. This affects the number of
     tests that `lbtt' makes during the model checking result
     cross-comparison test (*note Model checking result
     cross-comparison test::) and the model checking result consistency
     check (*note Model checking result consistency check::).  Global
     model checking (the default) maximizes the number of tests, but may
     require more time and memory. (Note: This option has no effect if
     none of the model checking tests is enabled.)

`Rounds = INTEGER'
     The `Rounds' option can be used to specify the number of test
     rounds to run; the default value is 10.

`TranslatorTimeout = TIME-SPECIFICATION'
     This option can be used to specify a time limit (in wall-clock
     time) after which the execution of a translator is aborted if it
     fails to produce a result within the given limit. A timeout is
     considered a test failure. The time specification is of the form
     `[HOURS]h[MINUTES]min[SECONDS]s' where HOURS, MINUTES and SECONDS
     specify the time limit in the obvious way (time units having value
     0 can be omitted). For example, a limit of `1h30min' sets the
     limit at one hour and thirty minutes.

`Verbosity = INTEGER'
     This option sets the verbosity level for output messages. The value
     can be an integer between 0 and 5 (inclusive). A value of 0 will
     suppress all messages (and is therefore useful only when storing
     test results into a log file; *note `--logfile' command line
     option: --logfile.); increasing the value results in more output.
     The default value is 3.



File: lbtt.info,  Node: FormulaOptions section,  Next: StateSpaceOptions section,  Prev: GlobalOptions section,  Up: Configuration file

3.1.3 The `FormulaOptions' section
----------------------------------

The `FormulaOptions' section defines the parameters that affect the
algorithm `lbtt' uses for generating random LTL formulas (for more
information about the algorithm, see *note Random LTL formulas::).
This section provides the following options:

`AbbreviatedOperators = TRUTH-VALUE'
     This option determines whether the generated formulas should be
     allowed to include any of the operators `->', `<->', `xor', `W',
     `<>', `B', `V', `M' or `[]' (all of which can be given definitions
     using only the operators `!', `\/', `/\', `U' and `V'). Setting
     this option to `No' assigns each of the abbreviated operators a
     zero priority, overriding any explicit priorities defined for
     these operators in the program configuration. The default value
     for the option is `Yes', so abbreviations are allowed by default.

`AndPriority = INTEGER'
     Priority of the logical conjunction operator (`/\').

`BeforePriority = INTEGER'
     Priority of the temporal operator "before" (`B'). (Note: This
     option has no effect if `AbbreviatedOperators' is set to `No'.)

`ChangeInterval = INTEGER'
     This option determines how often (in number of test rounds) `lbtt'
     should generate a new random LTL formula (or read a new formula
     from a user-specified file). A value of 0 forces `lbtt' to use a
     fixed LTL formula for all tests. The default value is 1, i.e., a
     new formula will be generated at the beginning of each test round.

`DefaultOperatorPriority = INTEGER'
     This option sets the priority for all formula operators for which
     no priority has been given explicitly in the program configuration
     (i.e., it can be used as a shorthand to initialize the priority of
     all operators).  The default value of this option is 0, so all
     operators with no explicitly given priorities are disabled by
     default.

`EquivalencePriority = INTEGER'
     Priority of the logical equivalence operator (`<->'). (Note: This
     option has no effect if `AbbreviatedOperators' is set to `No'.)

`FalsePriority = INTEGER'
     Priority of the Boolean constant `false' (with respect to
     priorities of the constant `true' and the atomic propositions).

`FinallyPriority = INTEGER'
     Priority of the temporal operator "finally" (`<>'). (Note: This
     option has no effect if `AbbreviatedOperators' is set to `No'.)

`GenerateMode = Normal | NNF'
     This option determines whether `lbtt' should generate random
     formulas directly into (a weakened version of) negation normal
     form in which the negation operator may only precede atomic
     propositions. Note that the formulas may still contain
     "abbreviated" operators if they have nonzero priorities--use
     `AbbreviatedOperators=No' or `OutputMode=NNF' if you wish to
     prevent this. The default value for this option is `Normal'.  (See
     the `OutputMode' option below for an example about the differences
     in the effects of the `GenerateMode' and `OutputMode' options.)

`GloballyPriority = INTEGER'
     Priority of the temporal operator "globally" (`[]'). (Note: This
     option has no effect if `AbbreviatedOperators' is set to `No'.)

`ImplicationPriority = INTEGER'
     Priority of the logical implication operator (`->'). (Note: This
     option has no effect if `AbbreviatedOperators' is set to `No'.)

`NextPriority = INTEGER'
     Priority of the temporal operator "next time" (`X').

`NotPriority = INTEGER'
     Priority of the logical negation operator (`!').

`OrPriority = INTEGER'
     Priority of the logical disjunction operator (`\/').

`OutputMode = Normal | NNF'
     This option determines whether `lbtt' should transform each
     generated LTL formula into (strict) negation normal form before
     passing it to LTL-to-Bu"chi translators. If the value is set to
     `NNF', `lbtt' will rewrite each generated formula into a form
     consisting of the operators `!', `\/', `/\', `U' and `V' such that
     all negations in the formula (if any) precede atomic propositions.
     The default value is `Normal'. (See also the `GenerateMode' option
     that can be used to force formulas to be generated directly into
     negation normal form.)

     The option is probably useful only if you have a translator which
     does not support the "abbreviated" operators directly, but you
     still wish to test it with formulas which describe properties
     expressed using these operators.  Note, however, that rewriting
     may change the size of the formula.

     The following table illustrates the effects of the `GenerateMode'
     and the `OutputMode' options.

       LTL formula     Can f be       OutputMode's effect on the
            f        generated if       formula passed to the
                     GenerateMode     LTL-to-Bu"chi translators
                        =NNF ?
       ------------------------------------------------------------
       (p1 V ! p0)       Yes       Normal/NNF: (p1 V ! p0)

       [] p0 -> <> p1    Yes*      Nor: [] p0 -> <> p1
                                   NNF: (true U ! p0) \/ (true U p1)

       ! <> p0            No       Nor: ! <> p0
                                   NNF: (false V ! p0)

       * only if AbbreviatedOperators=Yes

`PropositionPriority = INTEGER'
     Priority for atomic propositions with respect to the priority of
     Boolean constants. This priority is the common priority of _all_
     atomic propositions.

`Propositions = INTEGER'
     This option sets the maximum number of different atomic
     propositions in each generated LTL formula. No generated formula
     will have more than this number of different atomic propositions.
     A value of 0 will generate random formulas with only Boolean
     constants (one of which must in this case have a nonzero
     priority). The default value is 5. The names of the propositions
     are of the form `pN', where N is a nonnegative integer less than
     the maximum number of propositions.

`RandomSeed = INTEGER'
     This option specifies a seed value for generating random numbers
     for the random LTL formula generation algorithm. If this option is
     not present, the seed defaults to 1. See the next section for
     information on how to change the default seed for the random state
     space generation algorithm.

     (The reason for having two separate random seeds is to make the
     sequences of random formulas and state spaces independent of each
     other. For example, this makes it easy to repeat tests using the
     same batch of random LTL formulas, but with state spaces of
     different size.)

`ReleasePriority = INTEGER'
     Priority of the temporal "(weak) release" operator (`V').

`Size = INTEGER'
`Size = MINIMUM-SIZE-MAXIMUM-SIZE'
`Size = MINIMUM-SIZE...MAXIMUM-SIZE'
     This option defines how many nodes are allowed in the parse tree
     of each randomly generated LTL formula. If the size is given as an
     interval (by separating the bounds with `-' or `...' with no white
     space in between), `lbtt' chooses the size of each formula
     randomly in the interval using a uniform random distribution. The
     default size is 5.

`StrongReleasePriority = INTEGER'
     Priority of the temporal "strong release" operator (`M'). (Note:
     This option has no effect if `AbbreviatedOperators' is set to
     `No'.)

`UntilPriority = INTEGER'
     Priority of the temporal "(strong) until" operator (`U').

`TruePriority = INTEGER'
     Priority of the Boolean constant `true' (with respect to the
     priorities of the constant `false' and the atomic propositions).

`WeakUntilPriority = INTEGER'
     Priority of the temporal "weak until" operator (`W'). (Note: This
     option has no effect if `AbbreviatedOperators' is set to `No'.)

`XorPriority = INTEGER'
     Priority of the logical "exclusive or" operator (`xor'). (Note:
     This option has no effect if `AbbreviatedOperators' is set to
     `No'.)



File: lbtt.info,  Node: StateSpaceOptions section,  Next: Sample configuration file,  Prev: FormulaOptions section,  Up: Configuration file

3.1.4 The `StateSpaceOptions' section
-------------------------------------

The `StateSpaceOptions' section defines the parameters that affect the
way `lbtt' generates random state spaces for the model checking result
cross-comparison test (*note Model checking result cross-comparison
test::) and the model checking result consistency check (*note Model
checking result consistency check::).  See also *note Random state
spaces::, for more information about the different types of available
state spaces and the algorithms used for constructing them.  The
options available within this section are:

`ChangeInterval = INTEGER'
     This option determines how often (in number of test rounds) `lbtt'
     should generate a new random state space. A value of 0 forces
     `lbtt' to use a fixed state space for all tests. The default
     behavior is to generate a new state space at the beginning of each
     test round.

`EdgeProbability = PROBABILITY'
     This option sets the approximate probability (between 0.0 and 1.0)
     of adding a transition from any state X to some other state Y when
     generating random graphs as state spaces. The default value is
     0.2. The probability is approximate because `lbtt' still has to
     ensure that all states of each generated state spaces have at
     least one successor, which might require adding extra transitions
     to the graph.  Note: This option has no effect if `GenerateMode'
     is set to `RandomPath' or `EnumeratedPath'.

`GenerateMode = RandomConnectedGraph | RandomGraph | RandomPath | EnumeratedPath'
     This option selects the type of generated state spaces from the
     four available types. The default value is `RandomConnectedGraph'.
     See *note Random state spaces::, for more information on the
     different state space types.

     Note: Using the `RandomPath' or the `EnumeratedPath' setting
     includes `lbtt''s internal model checking algorithm into the
     various model checking tests if they are enabled. For more
     information, see *note Model checking result cross-comparison
     test::.

`Propositions = INTEGER'
     This option sets the number of atomic propositions attached to
     each state of the generated state spaces. The default value is 5.

     Usually this should probably be the same as the maximum number of
     different atomic propositions in the generated formulas (*note
     FormulaOptions section::).  If the number of propositions attached
     to each state of the state spaces is less than the maximum number
     of different propositions that may occur in the generated
     formulas, all "extra" propositions in the formulas are considered
     to be false in every state of the state space.

`RandomSeed = INTEGER'
     This option specifies a seed value for generating random numbers
     required by the random state space generation algorithm. If this
     option is not present, the seed defaults to 1. See the previous
     section for how to change the random seed used to initialize the
     random number generator for the random LTL formula generation
     algorithm.

`Size = INTEGER'
`Size = MINIMUM-SIZE-MAXIMUM-SIZE'
`Size = MINIMUM-SIZE...MAXIMUM-SIZE'
     This option sets the number of states in the generated state
     spaces. If the size is given as an interval, `lbtt' either chooses
     a random size in the interval (including its endpoints) each time
     a new state space is generated, or, if `GenerateMode' is set to
     `EnumeratedPath', enumerates all state spaces in the specified
     range systematically, starting from the minimum size. The default
     size is 20.

`TruthProbability = PROBABILITY'
     Probability (between 0.0 and 1.0) with which each individual
     atomic proposition has the value `true' in any state of the state
     space. Note: This option has no effect if `GenerateMode' is set to
     `EnumeratedPath'. The default value is 0.5.



File: lbtt.info,  Node: Sample configuration file,  Prev: StateSpaceOptions section,  Up: Configuration file

3.1.5 Sample configuration file
-------------------------------

The following configuration file sets `lbtt' up for testing two
imaginary LTL-to-Bu"chi translators.

     # Sample configuration file for lbtt

     Translator
     {
       Name = Translator\ 1
       Path = /home/lbtt-user/bin/t-1    # location of the translator
                                         # executable
       Enabled = Yes
     }

     Translator
     {
       Name = "Translator 2"
       Path = /home/lbtt-user/bin/t-2
       Parameters = "-x -y 3 -v 0"       # parameters to be passed to the
                                         # executable
       Enabled = Yes
     }

     GlobalOptions
     {
       Rounds = 100                      # 100 test rounds

       Interactive = OnError,OnBreak     # pause testing in case of an error
                                         # or when receiving a break signal

       Verbosity = 1                     # show only numeric statistics

       ComparisonTest = Yes              # enable all tests except the
       ConsistencyTest = Yes             # Bu"chi automata intersection
       IntersectionTest = No             # emptiness test

       ModelCheck = Local                # perform the tests only in a
                                         # single state of each state
                                         # space

       TranslatorTimeout = 30s           # abort the execution of a
                                         # translator if it fails to give
                                         # a result in 30 seconds
     }

     FormulaOptions
     {
       AbbreviatedOperators = Yes        # formula generation mode
       GenerateMode = Normal
       OutputMode = NNF                  # rewrite formulas in negation
                                         # normal form before passing
                                         # them to the translators

       ChangeInterval = 1                # new formula after each round

       RandomSeed = 4632912              # random seed

       Size = 5-15                       # 5 to 15 nodes in the parse
                                         # tree of each formula

       Propositions = 3                  # allow at most three different
                                         # propositions in each LTL formula

       PropositionPriority = 50          # priorities for propositional
       TruePriority = 1                  # symbols
       FalsePriority = 1

       AndPriority = 10                  # priorities for some logical
       OrPriority = 10                   # operators
       NotPriority = 10
       EquivalencePriority = 5

       NextPriority = 5                  # priorities for some temporal
       UntilPriority = 5                 # operators
       ReleasePriority = 5
       FinallyPriority = 2

       DefaultOperatorPriority = 0       # disable all the remaining
                                         # operators
     }

     StatespaceOptions
     {
       GenerateMode = RandomGraph        # generate random (not
                                         # necessarily connected) graphs
                                         # as state spaces

       ChangeInterval = 10               # new state space after every
                                         # 10th test round

       RandomSeed = 37620                # random seed

       Size = 50                         # 50 states in each state space

       Propositions = 3                  # three propositions in each
                                         # state of each state space

       EdgeProbability = 0.1             # approximate probability of
                                         # having a transition between
                                         # any two states

       TruthProbability = 0.5            # probability with which any
                                         # atomic proposition is true in
                                         # a state
     }


File: lbtt.info,  Node: Command line options,  Prev: Configuration file,  Up: Invocation

3.2 Command line options
========================

This section lists the command line options that may be used when
invoking `lbtt'. The command line options are processed only after
reading the configuration file, so they can be used to override the
settings given in the file. There are also a few options for which
there is no direct equivalent in the configuration file options.

* Menu:

* Special options::             Options available only as command line
                                  parameters.
* Global options::              Options corresponding to the
                                  `GlobalOptions' section of the
                                  configuration file.
* LTL formula options::         Options corresponding to the
                                  `FormulaOptions' section of the
                                  configuration file.
* State space options::         Options corresponding to the
                                  `StateSpaceOptions' section of the
                                  configuration file.


File: lbtt.info,  Node: Special options,  Next: Global options,  Prev: Command line options,  Up: Command line options

3.2.1 Special options
---------------------

The following list presents all command line options for which there is
no (directly) corresponding option that may be set in the program
configuration file.

`--configfile=FILE-NAME'
     This option can be used to instruct `lbtt' to read program
     configuration from another file instead of the default
     configuration file `config' in the current working directory.

`--formulafile=FILE-NAME'
     This option instructs `lbtt' to read the LTL formulas used in the
     tests from a file (or standard input) instead of generating them
     randomly. The special filename `-' refers to standard input. Each
     input formula should be followed by a newline. The formulas can be
     specified either in `lbtt''s own prefix notation (*note Format for
     LTL formulas::; also the infix notation used in output messages is
     supported) or in a variety of formats found in some LTL-to-Bu"chi
     translator implementations (Spin, LTL2BA, LTL2AUT, Temporal
     Massage Parlor, Wring, Spot, LBT), however with the restriction
     that all atomic propositions should have names of the form `pN'
     for some nonnegative integer N.

     (When using one of the alternative formats, it is recommended to
     use parentheses to avoid possible ambiguities in the precedence
     and associativity of the various operators; in `lbtt', the unary
     operators have the highest precedence, `/\' has higher precedence
     than `\/', which in turn has higher precedence than any of `->',
     `<->' or `xor', and the binary temporal operators have the lowest
     precedence. All binary logical operators are left-associative; all
     binary temporal operators are nonassociative.)

     If this option is used, all command line or configuration file
     parameters affecting the generation of random LTL formulas
     (excluding their mode of output) are ignored.

`--h'
`--help'
     These options list all the available command line parameters.

`--logfile=FILE-NAME'
     This option instructs `lbtt' to create a log of all errors
     encountered during testing. By default no log will be created.

`--profile'
     This option can be used as a shorthand for disabling all Bu"chi
     automata correctness tests.  The test report generated at the end
     of testing then shows only the running times of each tested
     LTL-to-Bu"chi translator and the sizes of the generated automata.

`--quiet'
`--silent'
     These options suppress any messages that are normally displayed
     during testing. Use the `--logfile' option (see above) with these
     options to save a test failure report into a log file.

`--showconfig'
     If this option is present on the command line, `lbtt' will write
     the current configuration to standard output (*note Configuration
     information::) and then exit.  This option can be used together
     with the `--configfile' option to test the settings defined in a
     configuration file without actually performing any tests.

`--showoperatordistribution'
     With this option `lbtt' uses the priorities defined for the LTL
     formula operators available for random LTL formula generation to
     compute the expected number of occurrences of each operator in a
     single randomly generated formula. The distribution is then
     displayed along with other configuration information when the
     program starts.

`--skip=NUMBER-OF-ROUNDS'
     This option can be used to skip the first NUMBER-OF-ROUNDS test
     rounds, i.e., begin testing from round NUMBER-OF-ROUNDS+1.

`-V'
`--version'
     This option displays the version of the `lbtt' executable.



File: lbtt.info,  Node: Global options,  Next: LTL formula options,  Prev: Special options,  Up: Command line options

3.2.2 Global options
--------------------

The following list presents the options that can be used to override the
values specified in the `GlobalOptions' section of the configuration
file.

`--comparisontest[=yes | no]'
`--nocomparisontest'
     These options enable or disable the model checking result
     cross-comparison test (*note Model checking result
     cross-comparison test::).

`--consistencytest[=yes | no]'
`--noconsistencytest'
     These options enable or disable the model checking result
     consistency check (*note Model checking result consistency
     check::).

`--disable=IMPLEMENTATION-ID[,IMPLEMENTATION-ID...]'
     This option can be used to exclude some implementations from the
     tests by specifying a comma-separated list of implementation names
     or their numeric identifiers. (The implementations are numbered in
     the order in which they appear in the configuration file, starting
     from zero. Use the `--showconfig' option, see *note Special
     options::, to obtain a list of the implementations specified in
     the configuration file, together with their identifiers.)

`--enable=IMPLEMENTATION-ID[,IMPLEMENTATION-ID...]'
     This option can be used to include implementations into the tests
     (in the case they are initially disabled in the configuration
     file).

`--globalmodelcheck'
     This option instructs `lbtt' to perform model checking globally
     (with respect to all states of each random state space) in the
     model checking result cross-comparison test and the model checking
     result consistency check. Using a global check increases the
     number of possible tests.

`--interactive[=MODE-LIST]'
`--pause[=MODE-LIST]'
     These options can be used to override whether `lbtt' should pause
     between test rounds to wait for user input. The optional MODE-LIST
     is a comma-separated list of interactivity modes (`Always',
     `OnError', `Never', `OnBreak') with no spaces in between (*note
     Interactivity modes::, for the mode descriptions). If omitted, the
     mode list defaults to `Always'.

`--intersectiontest[=yes | no]'
`--nointersectiontest'
     These options enable or disable the Bu"chi automata intersection
     emptiness check (*note Automata intersection emptiness check::).

`--localmodelcheck'
     This option instructs `lbtt' to perform model checking only with
     respect to a single state of each random state space in the model
     checking result cross-comparison test and the model checking
     result consistency check.

`--modelcheck=global | local'
     This option can be used to select the model checking mode.

`--pause[=MODE-LIST]'
     See `--interactive'.

`--rounds=NUMBER-OF-ROUNDS'
     This option can be used to override the number of test rounds to
     run.

`--translatortimeout=TIME-SPECIFICATION'
     This option can be used to override the running time limit (in
     wall-clock time) for translators (*note Timeouts::, for more
     information).

`--verbosity=INTEGER'
     This option sets the verbosity of output messages. The value must
     be between 0 and 5 (inclusive).



File: lbtt.info,  Node: LTL formula options,  Next: State space options,  Prev: Global options,  Up: Command line options

3.2.3 LTL formula options
-------------------------

The following command line options can be used to control the behavior
of `lbtt''s random LTL formula generation algorithm. They correspond to
the options available in the `FormulaOptions' section of the
configuration file.

`--abbreviatedoperators[=yes | no]'
`--noabbreviatedoperators'
     These options can be used to allow or prevent `lbtt' from using
     any of the "abbreviated" operators (`->', `<->', `xor', `W', `<>',
     `B', `M' and `[]') when generating random LTL formulas.

`--andpriority'
     This option sets the priority for logical conjunction (the `/\'
     operator).

`--beforepriority'
     This option sets the priority for the temporal "before" operator
     (`B').

`--defaultoperatorpriority'
     This option sets the default priority for all logical and temporal
     operators.

`--equivalencepriority'
     This option sets the priority for logical equivalence (the `<->'
     operator).

`--falsepriority'
     This option sets the priority for the Boolean constant `false'.

`--finallypriority'
     This option sets the priority for the temporal "finally" operator
     (`<>').

`--formulachangeinterval=NUMBER-OF-ROUNDS'
     This option determines how often (in number of test rounds) `lbtt'
     should generate a new random LTL formula. A value of 0 forces
     `lbtt' to use a fixed LTL formula for all tests.

`--formulageneratemode=normal | nnf'
     This option can be used to choose how `lbtt' should generate random
     LTL formulas. With the option `--formulageneratemode=nnf', all
     generated formulas will be in (a weakened) negation normal form in
     which all negations in the formula (if any) precede atomic
     propositions. (Note that the formulas may still contain some of
     the "abbreviated" operators if their priorities are not explicitly
     set to zero.)

`--formulaoutputmode=normal | nnf'
     This option can be used to force or prevent `lbtt' from converting
     each LTL formula into (strict) negation normal form (i.e.,
     rewriting it with the operators `!', `/\', `\/', `U' and `V')
     before passing it to the LTL-to-Bu"chi translators.

`--formulapropositions'
     This option sets the maximum number of different atomic
     propositions that `lbtt' may use for generating random LTL
     formulas.

`--formularandomseed=INTEGER'
     This option gives a seed value for generating random numbers used
     by the random LTL formula generation algorithm.

`--formulasize=INTEGER'
`--formulasize=MINIMUM-SIZE-MAXIMUM-SIZE'
`--formulasize=MINIMUM-SIZE...MAXIMUM-SIZE'
     This option sets the size of the random LTL formulas generated for
     the tests.  The size can be given either as a fixed integer or as
     an interval, in which case the size of each generated formula will
     be chosen randomly in the interval using a uniform random
     distribution.

`--generatennf'
`--nogeneratennf'
     These options can be used instead of the `--formulageneratemode'
     option to select the random formula generation mode.

`--globallypriority'
     This option sets the priority for the temporal "globally" operator
     (`[]').

`--implicationpriority'
     This option sets the priority for logical implication (the `->'
     operator).

`--nextpriority'
     This option sets the priority for the temporal "next time" operator
     (`X').

`--notpriority'
     This option sets the priority for logical negation (the `!'
     operator).

`--orpriority'
     This option sets the priority for logical disjunction (the `\/'
     operator).

`--outputnnf'
`--nooutputnnf'
     These options can be used instead of the `--formulaoutputmode'
     option to choose the format in which `lbtt' passes LTL formulas to
     LTL-to-Bu"chi translators.

`--propositionpriority'
     This option sets the priority for atomic propositions.

`--releasepriority'
     This option sets the priority for the temporal "(weak) release"
     operator (`V').

`--strongreleasepriority'
     This option sets the priority for the temporal "strong release"
     operator (`M').

`--truepriority'
     This option sets the priority for the Boolean constant `true'.

`--untilpriority'
     This option sets the priority for the temporal "(strong) until"
     operator (`U').

`--weakuntilpriority'
     This option sets the priority for the temporal "weak until"
     operator (`W').

`--xorpriority'
     This option sets the priority for the logical "exclusive or"
     operator.


   Note also the `--formulafile=FILE-NAME' option (*note
`--formulafile' option: --formulafile.), which can be used to instruct
`lbtt' to read LTL formulas from a file (or standard input) instead of
generating them randomly.


File: lbtt.info,  Node: State space options,  Prev: LTL formula options,  Up: Command line options

3.2.4 State space options
-------------------------

The following command line options affect the way in which `lbtt'
generates state spaces that are then used in the model checking tests.
They correspond to options in the `StateSpaceOptions' section of the
configuration file. See also *note Random state spaces::, for more
information about the graph generation modes.

`--edgeprobability=PROBABILITY'
     This option sets the approximate random edge probability for state
     spaces. (The option has no effect if the generated state spaces
     are random or enumerated paths.)

`--enumeratedpath'
     This option instructs `lbtt' to enumerate all paths of a given size
     as state spaces instead of generating random state spaces for
     model checking tests. The option also enables `lbtt''s internal
     model checking algorithm.

`--randomconnectedgraph'
     This option makes `lbtt' generate random connected graphs as state
     spaces for model checking tests.

`--randomgraph'
     This option makes `lbtt' generate random graphs as state spaces for
     model checking tests.

`--randompath'
     This option forces `lbtt' to generate random paths as state spaces.
     The option also enables `lbtt''s internal model checking algorithm
     in the model checking tests.

`--statespacechangeinterval=NUMBER-OF-ROUNDS'
     This option sets the frequency (in test rounds) in which new state
     spaces are generated. A value of 0 forces `lbtt' to use a fixed
     state space for all tests.

`--statespacegeneratemode=randomconnectedgraph | randomgraph | randompath | enumeratedpath'
     This option can be used instead of one of the four options above
     to select the state space generation mode.

`--statespacerandomseed=INTEGER'
     This option gives a seed value for generating random numbers
     required by the random state space generation algorithm.

`--statespacesize=INTEGER'
`--statespacesize=MINIMUM-SIZE-MAXIMUM-SIZE'
`--statespacesize=MINIMUM-SIZE...MAXIMUM-SIZE'
     This option can be used to change the size of the generated state
     spaces.

`--truthprobability=PROBABILITY'
     This option sets the probability that `lbtt' uses for choosing the
     valuation for each atomic proposition in each state of the
     randomly generated state spaces. (This option has no effect if
     using enumerated paths as state spaces.)



File: lbtt.info,  Node: Interpreting the output,  Next: Analyzing test results,  Prev: Invocation,  Up: Top

4 Interpreting the output
*************************

This chapter briefly introduces the most typical messages that `lbtt'
outputs during testing. Most of the examples in this section illustrate
the output when `lbtt' is running in its default output verbosity mode
(3). In lower verbosity modes some (or in verbosity mode 0, all) of
these messages will be suppressed; in higher verbosity modes, some
additional information about `lbtt''s internal behavior is shown.

* Menu:

* Configuration information::   The current configuration is shown
                                  before starting tests.
* Test round messages::         Conventions for reporting test
                                  results and test failures.
* Test statistics::             Shown at the end of testing.


File: lbtt.info,  Node: Configuration information,  Next: Test round messages,  Prev: Interpreting the output,  Up: Interpreting the output

4.1 Configuration information
=============================

Before starting tests, `lbtt' outputs (in verbosity modes 2 and above)
a summary of the current program configuration as obtained by reading
the program configuration file and interpreting the command line
parameters. The same summary can be obtained without running any tests
by using the `--showconfig' command line option (*note `--showconfig'
option: --showconfig.). The information will be written also to the
error log file if one was specified in the command line with the
`--logfile' option (*note `--logfile' option: --logfile.).  The summary
consists of the following information:

   * LTL-to-Bu"chi translator implementations enabled for testing.

   * List of enabled tests.

   * Random state space generation parameters.

   * Random LTL formula generation parameters (unless reading LTL
     formulas from an external source; *note `--formulafile' command
     line option: --formulafile.). This includes information about all
     enabled formula operators and their priorities. When using the
     command line option `--showoperatordistribution' (*note
     `--showoperatordistribution' option: --showoperatordistribution.),
     `lbtt' shows also the expected number of occurrence of each
     operator in each randomly generated formula.


Example:

     Program configuration:
     ----------------------

       1000 test rounds.
       Testing will be interrupted in case of an error.
       Signalling a break will interrupt testing.
       Using global model checking for tests.
       Writing error log to `error.log'.

       Implementations:
         0: `Implementation 0'
         1: `Implementation 1'

       Timeout for translators is set to 30 seconds.

       Enabled tests:
         Model checking result cross-comparison test
         Model checking result consistency check
         Bu"chi automata intersection emptiness check

       Random state spaces:
         Random graphs (50 states, 5 atomic propositions)
         New state space will be generated after every 5th round.
         Random seed: 98
         Random edge probability: 0.10
         Propositional truth probability: 0.50

       Random LTL formulas:
         5 parse tree nodes, 5 atomic propositions
         New LTL formula will be generated after every round.
         Random seed: 17991
         Atomic symbols in use (priority):
           false (5); propositions (90); true (5)
         Operators used for random LTL formula generation:
           operator  !        /\       U        V        X        \/
           priority  10       10       20       20       10       20


File: lbtt.info,  Node: Test round messages,  Next: Test statistics,  Prev: Configuration information,  Up: Interpreting the output

4.2 Test round messages
=======================

In verbosity modes 1 and 2, `lbtt' reports numeric statistics on the
generated automata in tabular form. Each row of this table contains the
following information (in this order):
   * number of the current test round (verbosity mode 1 only);

   * numeric identifier of an implementation;

   * formula identifier (`+' or `-');

   * time consumed when generating an automaton from the formula using
     the implementation;

   * number of states, transitions and acceptance conditions in the
     automaton;

   * number of states and transitions in the product automaton

   * number of accepting cycles in the state space (see below), and

   * result of the consistency check (verbosity mode 2 only).

   The following example shows a fragment of the output that `lbtt'
might produce during a test round when running in the default verbosity
mode 3.

1. Round 6 of 10

2.     Generating random state space

3.     Random LTL formula:
         formula:                   ((p1 <-> p0) U (p0 \/ ! p3))
         negated formula:           ! ((p1 <-> p0) U (p0 \/ ! p3))

       0: `Implementation 0'
         Positive formula:
4.         Bu"chi automaton:
             number of states:      6
             number of transitions: 15
             acceptance sets:       1
             computation time:      0.03      seconds (user time)
5.         Product automaton:
             number of states:      582       [97.00% of worst case (600)]
             number of transitions: 7188
6.         Accepting cycles:
             cycle reachable from   0         states
             not reachable from     100       states
7.       Negated formula:
           Bu"chi automaton:
             number of states:      4
             number of transitions: 6
             acceptance sets:       0
             computation time:      0.04      seconds (user time)
           Product automaton:
             number of states:      363       [90.75% of worst case (400)]
             number of transitions: 2581
           Accepting cycles:
             cycle reachable from   25        states
             not reachable from     75        states
8.       Result consistency check:
           result:                  failed    [75 (75.00%) of 100 test cases]

The numbered parts of the output are:

  1. Number of the test round.

  2. `lbtt' generates a new random state space for model checking
     tests. (In this case the size of the state spaces was fixed in the
     configuration; if the state space size is allowed to vary in an
     interval, `lbtt' would also show here the actual size of the
     generated state space.)

  3. Information about a random LTL formula and its negation. To
     simplify the notation, it is assumed that all unary formula
     operators have higher precedence than binary operators.

  4. Information about the Bu"chi automaton that `Implementation 0'
     generated from the positive LTL formula (number of states,
     transitions and acceptance conditions, and the amount of user time
     elapsed in generating the automaton).

  5. Information about the synchronous product of the state space and
     the Bu"chi automaton constructed from the positive formula.

  6. Model checking result information. In this case, the automaton
     cannot reach an "accepting cycle" regardless of the state of the
     state space in which the automaton could begin its execution. In
     other words, the random state space contains no states with an
     infinite path beginning from the state such that the Bu"chi
     automaton accepts the temporal interpretation of the path (the
     infinite sequence of state labels on the path).

  7. The model checking process is repeated using the negated formula as
     input for the LTL-to-Bu"chi translator `Implementation 0'.

  8. `lbtt' performs the model checking result consistency check (*note
     Model checking result consistency check::) using the model checking
     results computed for the positive and the negative formula. In
     this example, the result consistency check fails in 75 states of
     the state space. This implies that `Implementation 0' failed to
     translate one (or both) of the formulas into a Bu"chi automaton
     correctly.


   The output of phases 4--8 will be repeated for each implementation
included in the tests. After this `lbtt' proceeds to the model checking
result cross-comparison test (*note Model checking result
cross-comparison test::) and the Bu"chi automata intersection emptiness
test (*note Automata intersection emptiness check::).

   The model checking result cross-comparison test might result in the
following output (shown in verbosity modes greater than 1):

    Model checking result cross-comparison:
      result:
        failed (+)  0: `Implementation 0', 1: `Implementation 1'

   Throughout all test failure reports, `lbtt' refers to the positive
and negated formulas with the symbols `+' and `-', respectively.
Therefore, the above message indicates that the model checking results
obtained using `Implementation 0' and `Implementation 1' for the
positive formula do not agree. A similar line will be shown for all
pairs of implementations for which the test failed.

   `lbtt' also reports if the model checking result cross-comparison
could not be performed between a pair of implementations (for example,
if one of the implementations failed to generate an automaton); in this
case, the result of the test is `N/A'.

   If using enumerated or randomly generated paths as state spaces, the
model checking results are also compared against those given by
`lbtt''s internal model checking algorithm.

   A similar convention is used to report failures in the Bu"chi
automata intersection emptiness check. However, because this test is
always performed on Bu"chi automata constructed from two complementary
LTL formulas, a test failure report shows LTL formula information
beside the name of the implementation used for generating the Bu"chi
automaton from that formula.  Note that the Bu"chi automata
intersection emptiness check may fail on the automata constructed by
the same implementation; in the following example, the check failed
between the automata constructed by `Implementation 0', and the
automata constructed by `Implementation 0' and `Implementation 1' from
the positive and negative formulas, respectively.

    Bu"chi automata intersection emptiness check:
      result:
        failed      0: `Implementation 0'
        failed (+)  0: `Implementation 0', (-) 1: `Implementation 1'

   If using a log file (*note `--logfile' command line option:
--logfile.), a summary of all testing errors will be written to the
file using the output format specified above.


File: lbtt.info,  Node: Test statistics,  Prev: Test round messages,  Up: Interpreting the output

4.3 Test statistics
===================

At the end of testing, `lbtt' outputs some simple statistics computed
over all tests in verbosity modes 2 and above. If using an error log
file (*note `--logfile' command line option: --logfile.), the statistics
will be stored also in the log file. These statistics can be also
accessed during interactive testing by using the internal command
`statistics' (*note `statistics' command: statistics.).  In brief, the
statistics include:

   * Number of generated state spaces and the total number of states and
     transitions in them.

   * Number of processed LTL formulas (not counting the negations of
     each formula). If using random formulas, `lbtt' also shows the
     overall distribution of each individual proposition, Boolean
     constant and logical or temporal operator in the sample of
     randomly generated formulas.  Theoretically, in a large sample of
     random formulas, this distribution should correspond to the one
     that can be computed before testing by using the
     `--showoperatordistribution' command line option (*note
     `--showoperatordistribution' command line option:
     --showoperatordistribution.).

   * Automata statistics for each implementation:

        - number of generated Bu"chi automata and product automata

        - total and average numbers of states, transitions and
          acceptance sets in the generated Bu"chi/product automata, and

        - total and average time consumed in generating the Bu"chi
          automata.

   * Number of times that each implementation failed to generate an
     acceptable automaton from an input formula.

   * Number of failures in the model checking result consistency check
     (*note Model checking result consistency check::) for each
     implementation.

   * Number of result inconsistencies detected in pairwise comparison
     of the Bu"chi automata generated by different implementations.
     Depending on the model checking mode and which correctness tests
     are enabled, the output may include none, some or all of the
     following information:

        - Overall number of failures in the model checking result
          cross-comparison test (*note Model checking result
          cross-comparison test::) for each pair of implementations.

        - Number of failures in the model checking result
          cross-comparison test in a single fixed state of each
          generated state space (called the "initial" state of the
          state space).

        - Number of failures in the Bu"chi automata intersection
          emptiness check (*note Automata intersection emptiness
          check::) for each pair of implementations.

     Note that the pairwise inconsistency results form a symmetric
     matrix (possibly shown in several parts), which means that the
     same information is repeated on both sides of the matrix diagonal.


Where applicable, the statistics are shown separately for positive,
negative and all LTL formulas used in the tests.


File: lbtt.info,  Node: Analyzing test results,  Next: Interfacing with lbtt,  Prev: Interpreting the output,  Up: Top

5 Analyzing test results
************************

This chapter documents how to use `lbtt''s internal commands to analyze
test results.

   To use the internal commands, `lbtt' must be started in one of its
interactive modes (*note Interactivity modes::). Depending on the mode,
`lbtt' may occasionally pause (for example, after each test round, or
when a test failure is detected) between test rounds to wait for user
input by showing a prompt of the form

       ** [Round 22 of 1000] >>

* Menu:

* Command conventions::         Conventions for entering commands.
* Getting help::                Use the `help' command to access
                                  on-line help.
* Test control commands::       Commands for continuing testing,
                                  skipping tests or enabling or disabling
                                  implementations.
* Data display commands::       Commands for displaying information
                                  about Bu"chi automata, state spaces,
                                  and LTL formulas.
* Failure analysis commands::   Commands for analyzing test failures.


File: lbtt.info,  Node: Command conventions,  Next: Getting help,  Prev: Analyzing test results,  Up: Analyzing test results

5.1 Command conventions
=======================

Commands are entered by typing a command name followed by any
parameters for the command and then pressing <ENTER>.  The command
names are case-sensitive. Each parameter should be separated from the
command name and other parameters with white space.

   Command names can be abbreviated to the shortest prefix that
identifies the command unambiguously (for example, `h' could be used in
place of the `help' command).

   Some of the commands expect lists of implementation or state
identifiers as parameters. The lists can be specified as comma-separated
numbers (for example, `8') or intervals (for example, `3-11') with no
white space between the commas and the numbers or intervals that belong
to the same list. For example, assuming that the state space used in
the current test round has at least 23 states, the command `statespace
-5,8,14-18,22-' would display information about all state space states
with an identifier less than or equal to 5, together with information
about state 8, states 14 to 18 (inclusive) and all states with an
identifier greater than or equal to 22. The `*' symbol can be used as a
shorthand for all identifiers in the available range.

   `lbtt' also recognizes the symbolic names of implementations (defined
in the configuration file) in implementation identifier lists. The
names can be used in place of the numeric identifiers. Quotes or the
escape character (`\') should be used to handle white space in
identifiers.

   Some of the commands require a formula identifier as a parameter for
choosing between a positive and a negative LTL formula. The formula
identifier (`+' for positive formula, `-' for negative formula) must
follow the command name as the first parameter for the command. If the
formula identifier is omitted, the positive formula is assumed.

   The output of most commands (excluding the test control commands,
*note Test control commands::) can be redirected or appended to a file
by ending the command line with `>filename' or `>>filename',
respectively.

   Optionally, the output can be handed over to an external program by
ending the command line with `| COMMAND', where COMMAND is the command
line used for invoking the external program.  For example, the output
of the (`lbtt''s internal) command can be piped to a pager application
if the entire output does not fit on the screen by itself. Using the
pipe construct without specifying any internal command will simply
invoke the external program.


File: lbtt.info,  Node: Getting help,  Next: Test control commands,  Prev: Command conventions,  Up: Analyzing test results

5.2 Getting help
================

Use the `help' command to access on-line help. Typing `help' with no
parameters shows a list of all available commands, together with
general conventions for using the commands. The `help' command can be
optionally given a command name as a parameter to access
command-specific help.

   In command-specific help, arguments in angle brackets (<, >) denote
obligatory command parameters, while arguments in square brackets ([,
]) are optional. A vertical bar (|) denotes selection between several
alternatives. Arguments in double quotes should be entered literally
(without the quotes themselves).


File: lbtt.info,  Node: Test control commands,  Next: Data display commands,  Prev: Getting help,  Up: Analyzing test results

5.3 Test control commands
=========================

The following commands can be used to continue or abort testing, skip a
number of test rounds, enable or disable implementations for testing,
and change the verbosity of `lbtt''s output messages.

`continue [NUMBER-OF-ROUNDS]'
     Continue testing. If no argument is given, testing will be
     interrupted again when mandated by the current interactivity mode
     (*note Interactivity modes::). The optional argument
     NUMBER-OF-ROUNDS can be used to specify a number of rounds to run;
     testing is then interrupted again after the given number of test
     rounds (or in case of a new test failure if mandated by the
     current interactivity mode).

`disable [IMPLEMENTATION-ID-LIST]'
     Disable testing of a list of implementations (all implementations
     if no list of implementations is specified). `lbtt' will not
     include these implementations in the tests in subsequent test
     rounds. (See *note Command conventions::, for the syntax used for
     the list of implementations.)

`enable [IMPLEMENTATION-ID-LIST]'
     Enable testing of a list of implementations.

`quit'
     Display test statistics (*note Test statistics::) over the test
     rounds performed and then abort testing.

`skip [NUMBER-OF-ROUNDS]'
     Skip a number of test rounds and then return to wait for further
     user input.  If not explicitly specified, the number of rounds to
     skip defaults to 1.  Use the `--skip' command line option (*note
     The `--skip' command line option: --skip.) to begin testing from
     another test round than 1.

`verbosity [VERBOSITY-LEVEL]'
     Display or change the verbosity of `lbtt''s output messages. If no
     argument is given, show the current verbosity level, otherwise
     change the verbosity setting to the given value. The argument must
     be an integer between 0 and 5 (inclusive). (The new value will
     take effect when testing is resumed.)



File: lbtt.info,  Node: Data display commands,  Next: Failure analysis commands,  Prev: Test control commands,  Up: Analyzing test results

5.4 Data display commands
=========================

The following commands can be used to access test result information
and to inspect the LTL formulas, Bu"chi automata and the state space
used in the current test round.

`algorithms'
`implementations'
`translators'
     Show a list of implementations declared in the program
     configuration file and tell whether they are currently enabled for
     testing. The list also shows the numeric identifiers of the
     implementations.

`buchi ["+" | "-"] <IMPLEMENTATION-ID> [STATE-ID-LIST | "dot"]'
     Display information about the structure of the Bu"chi automaton
     generated by the implementation IMPLEMENTATION-ID from the
     positive (`+') or negative (`-') LTL formula used in the current
     test round. The implementation identifier may be optionally
     followed by a list of state identifiers to display specific states
     of the automaton (see *note Command conventions::, for details on
     how the list should be formatted), or the keyword `dot' to display
     the automaton in a format that can be given as input for the `dot'
     tool of the GraphViz graph visualization package *note [GViz]:: to
     obtain a graphical representation of the automaton.

`evaluate ["+" | "-"] [IMPLEMENTATION-ID-LIST] [STATE-ID-LIST]'
     Display the model checking results for the positive (`+') or the
     negative (`-') formula computed using a given set of
     implementations for constructing a Bu"chi automaton from the
     formula. If no implementation list is specified, show the results
     for all implementations. The implementation identifier list may
     optionally be followed by a list of (state space) state
     identifiers to restrict the output to only a subset of all states.
     (See *note Command conventions::, for more information about the
     format used for the lists.)

     This command can be used to look for states in which the model
     checking result cross-comparison test (*note Model checking result
     cross-comparison test::) failed for a pair of implementations.
     These state identifiers can then be used as input for the
     `resultanalysis' command (*note Failure analysis commands::).

     Note 1: Observe that the model checking results shown do not
     follow the "universal" semantics of LTL (common in model
     checking), by which a formula is usually considered to hold in a
     set of infinite paths beginning from a state only if _all_ paths
     in the set are accepted by the Bu"chi automaton constructed from
     the formula to be model checked. Instead, `lbtt' will mark the
     result true if _any_ of these paths is accepted by the automaton.

     Note 2: If using random or enumerated paths as state spaces, `lbtt'
     accepts also the identifier `lbtt' in the implementation
     identifier list.  This identifier can be used for accessing the
     model checking results computed using `lbtt''s internal model
     checking algorithm for paths.

`formula ["+" | "-"] ["normal" | "nnf"]'
     Display the positive (`+') or the negative (`-') LTL formula used
     for tests in the current test round either in the form in which it
     was generated (`normal' - the default) or in negation normal form
     (`nnf').

`inconsistencies [IMPLEMENTATION-ID-LIST]'
     List the state space states in which the model checking result
     consistency check (*note Model checking result consistency
     check::) failed for each implementation in the list (or all
     implementations if the list is omitted).  See *note Command
     conventions::, for information on formatting the list.  The state
     identifiers can then be used as input for the
     `consistencyanalysis' command (*note Failure analysis commands::).

`results [IMPLEMENTATION-ID-LIST]'
     Display test results (in the current test round) for each
     implementation in the list (or all implementations if the list is
     omitted).  For more information about the output, see *note Test
     round messages::; see *note Command conventions::, for information
     on how to specify the implementations.

`statespace [STATE-ID-LIST | "dot"]'
     Display information about the structure of the state space used
     for model checking tests in the current test round. The optional
     STATE-ID-LIST can be used to display only a part of the whole
     state space (see *note Command conventions::, for information on
     formatting the state list).  Alternatively, the `dot' keyword can
     be used to output the state space description in a format
     recognized by the `dot' tool of the GraphViz graph visualization
     package *note [GViz]:: that can be used to obtain a graphical
     representation of the state space.

`statistics'
     Display statistics computed over all test rounds performed since
     the program was started. This is the same information that `lbtt'
     normally outputs at the end of testing; see *note Test
     statistics::, for more information about the output that is
     displayed.



File: lbtt.info,  Node: Failure analysis commands,  Prev: Data display commands,  Up: Analyzing test results

5.5 Failure analysis commands
=============================

The first part of this section introduces the commands available for
identifying an LTL-to-Bu"chi translator that caused a failure in one of
the automata correctness tests. The second part describes the
conventions that `lbtt' uses for justifying the result of the analysis.

5.5.1 Alphabetical list of failure analysis commands
----------------------------------------------------

`buchianalysis <IMPLEMENTATION-ID> <IMPLEMENTATION-ID>'
     Analyze a failure in the Bu"chi automata intersection emptiness
     check (*note Automata intersection emptiness check::).  The two
     implementation identifiers select the Bu"chi automata for which to
     perform the analysis. The Bu"chi automata intersection emptiness
     check always involves automata constructed from the positive and
     the negative formulas used in the current test round. The first
     implementation identifier chooses an implementation that
     constructed an automaton from the positive formula, and the second
     identifier selects an implementation used for translating the
     negative formula into an automaton. (The identifiers can also be
     equal if one of the tested implementations failed the check
     against itself.)

     A failure in the Bu"chi automata intersection emptiness check
     implies that there exists an input sequence over subsets of atomic
     propositions that is accepted by both automata included in the
     analysis. `lbtt' examines the intersection of the automata to find
     a witness of such an input, checks whether this witness is a model
     of the positive formula, and tells which one of the automata is
     likely to be incorrect according to the following rules:

        * If the positive formula is found to hold in the witness, the
          automaton constructed from the negative formula is likely to
          contain an error.

        * If the witness is not a model for the positive formula, then
          the automaton constructed from the positive formula probably
          accepts the witness incorrectly.

`consistencyanalysis <IMPLEMENTATION-ID> [STATE-ID]'
     Analyze a failure in the model checking result consistency check
     (*note Model checking result consistency check::). The
     IMPLEMENTATION-ID parameter chooses the implementation to analyze.
     In addition, the optional STATE-ID parameter can be used to
     specify a state (in the state space) in which to perform the
     analysis (use the `inconsistencies' command, *note Data display
     commands::, to see a list of all states in which the check
     failed). If the state identifier is omitted, `lbtt' will try to
     find a state where the check failed.

     A failure in the model checking result consistency check implies
     the existence of a witness (i.e., a path in the state space used
     for the tests in the current test round) whose temporal
     interpretation is not accepted by either of two automata
     constructed from two complementary LTL formulas. In the analysis,
     `lbtt' finds such a witness, checks separately whether it is a
     model of the positive formula, and then tells which one of the
     automata seems to reject the witness incorrectly.

`resultanalysis ["+" | "-"] <IMPLEMENTATION-ID> <IMPLEMENTATION-ID> [STATE-ID]'
     Analyze a failure in the model checking result cross-comparison
     test (*note Model checking result cross-comparison test::) between
     two implementations on either the positive (`+') or the negative
     (`-') LTL formula used in the current test round. The
     implementation identifiers can be optionally followed by an
     identifier of a state in the state space to specify a state in
     which the analysis should be performed.  (Suitable state
     identifiers can be found by looking for inconsistencies in the
     model checking results accessible with the `evaluate' command,
     *note Data display commands::; by omitting the state identifier,
     `lbtt' will try to find a state in which the model checking result
     comparison failed between the implementations.)

     If using randomly generated or enumerated paths as state spaces,
     `lbtt' also accepts the identifier `lbtt' in place of either of the
     implementation identifiers. This instructs `lbtt' to perform the
     analysis against `lbtt''s internal model checking algorithm.

     A failure in the model checking result cross-comparison test
     suggests that the state space used in the current test round
     contains a path which is accepted by one, but rejected by another
     automaton constructed from the same LTL formula. To determine
     which one of these automata accepts or rejects the input
     incorrectly, `lbtt' finds a witness path giving contradictory
     model checking results, model checks the formula separately in the
     witness, and tells which one of the automata seems to accept or
     reject the witness incorrectly.


5.5.2 Witnesses, proofs and refutations
---------------------------------------

All of the above analysis commands use `lbtt''s internal model checking
algorithm to determine which one of the two automata involved in each
test is incorrect by checking whether an LTL formula holds in a witness
path extracted from the state space used in the current test round or
from the intersection of two Bu"chi automata. The witness path is a
sequence of consecutive states that ends in a loop, and is represented
in two parts as an initial "prefix" (which may be empty) and a "cycle"
that is considered to repeat itself indefinitely. The witness might,
for example, look as follows:

         Execution M:
           prefix:
             s3 {p0,p2,p4} --> s4
           cycle:
             s4 {p1,p3} --> s5
             s5 {p3} --> s6
             s6 {p1,p2,p3} --> s7
             s7 {p3,p4} --> s8
             s8 {p1} --> s9
             s9 {} --> s2
             s2 {} --> s3
             s3 {p0,p2,p4} --> s4

In this case, the witness (or "execution" as displayed in the output) M
consists of a single-state prefix followed by a cycle of eight states.
The atomic propositions that hold in each state are also shown in the
output.

   (The witness can be considered a small state space M = <S, R, L>
following the definition in *note State spaces::; in the example above,
S = {s2, s3, s4, s5, s6, s7, s8, s9}, R = {(s2, s3), (s3, s4), (s4,
s5), (s5, s6), (s6, s7), (s7, s8), (s8, s9), (s9, s2)}, L(s2) = L(s_9)
= {}, L(s3) = {p0, p2, p4}, L(s4) = {p1, p3}, L(s5) = {p3}, L(s6) =
{p1, p2, p3}, L(s7) = {p3, p4}, and L(s8) = {p1}.)

   In the model checking result cross-comparison test and the model
checking result consistency check, the witness is an actual path
extracted from the state space used for the tests in the current test
round. In this case, the state identifiers correspond to the states of
the state space, and can be accessed with the `statespace [STATE-ID]'
command (*note Data display commands::).

   To justify the result of the analysis, `lbtt' also displays a proof
or a refutation for the LTL formula in the witness. The proof or
refutation is constructed by a recursive examination of the subformulas
of the (positive or negative) formula used in the current test round
according to the semantics of LTL and might look as follows:

         Analysis of the formula in the execution:
           M,<s3, ...> |/= ((X p0 U ! p4) <-> p0) :
           +-> M,<s3, ...> |/= (X p0 U ! p4) :
           |   +-> M,<s3, ...> |/= X p0 :
           |   |   +-> s3 --> s4
           |   |   +-> M,<s4, ...> |/= p0
           |   +-> M,<s3, ...> |/= ! p4 :
           |       +-> M,<s3, ...> |== p4
           +-> M,<s3, ...> |== p0

The proof (or refutation) can be considered a tree of statements of the
form `M,<s, ...> |== SUBFORMULA' or `M,<s, ...> |/= SUBFORMULA'. Here,
the symbol `|==' is used to denote that the formula SUBFORMULA holds in
the (infinite) subsequence beginning at state `s' of the witness, and
the relational symbol `|/=' denotes the opposite. The children of each
proof tree node give justification for the claim in their parent node;
the children might be further expanded if the claims in them do not
directly follow from the definition of L.  In the presence of temporal
operators, the proofs may need to be based also on the structural
properties of M. These are shown as statements of the form `sn --> sm'
to indicate that M contains a transition from the state `sn' to the
state `sm' (and, since the states in M are connected into a
non-branching sequence, that this is the _only_ transition originating
from `sn').

   In the above example, `lbtt' claims that the formula `((X p0 U ! p4)
<-> p0)' does not hold in the witness presented earlier in this
section, and that this follows (by the semantics of logical
equivalence) from the claims that the subformula `(X p0 U ! p4)' does
not hold, but the subformula `p0' holds in this witness.  `(X p0 U !
p4)' does not hold in the witness, because neither `X p0' nor `! p4'
holds in the first state of the witness (p4 is included in L(s3), and
p0 is not included in L(s4), where s4 is the only successor of s3).  On
the other hand, `p0' holds in the witness because of the fact that p0
is included in L(s3).


File: lbtt.info,  Node: Interfacing with lbtt,  Next: References,  Prev: Analyzing test results,  Up: Top

6 Interfacing with `lbtt'
*************************

The output generated by `lbtt' consists of textual messages and an
optional error log file (*note `--logfile' command line option:
--logfile.). The format of the output messages is determined by the
verbosity mode; for more information, see *note Interpreting the
output::. In addition, `lbtt' returns one of the following three values
as its exit status upon normal termination:
   * 0: `lbtt' exited successfully; no errors were detected during
     testing.

   * 1: `lbtt' exited successfully; errors were detected during testing.

   * 2: An error was found when reading the program configuration or
     when processing the command line options.

   * 3: `lbtt' exited due to an unrecoverable internal error.

   The rest of this chapter gives the details on how to use `lbtt' for
testing LTL-to-Bu"chi translation algorithm implementations that are not
supported by the basic distribution. (See *note The lbtt-translate
utility:: for information on how to connect several publicly available
LTL-to-Bu"chi translator implementations to `lbtt'.)

* Menu:

* Translator interface::        `lbtt''s requirements for an
                                  LTL-to-Bu"chi translator.
* Format for LTL formulas::     How `lbtt' passes LTL formulas
                                  to the translators.
* Format for automata::         How `lbtt' expects the translators
                                  to present their output.
* The lbtt-translate utility::  An interface for two LTL-to-Bu"chi
                                  translators.


File: lbtt.info,  Node: Translator interface,  Next: Format for LTL formulas,  Up: Interfacing with lbtt

6.1 Requirements for translator executables
===========================================

`lbtt' assumes each tested LTL-to-Bu"chi translator to be accessible by
running an executable file which should read in an LTL formula from a
file, convert it into a Bu"chi automaton and then write the automaton
into another file. For this purpose, the executable should support the
following command line interface:

     PATH-TO-PROGRAM PARAMETERS INPUT-FILE OUTPUT-FILE

where PATH-TO-PROGRAM is the full name (and location) of the
executable, PARAMETERS are any optional parameters that might be needed
for running the executable, and INPUT-FILE and OUTPUT-FILE are two file
names.  The translator executable should read its input (an LTL
formula) from INPUT-FILE and write its output (a Bu"chi automaton) into
OUTPUT-FILE (without removing the input file); see *note Format for LTL
formulas:: and *note Format for automata:: for a description on how
these files should be formatted.

   The translator executable should always create an output file and
then return with a zero exit status in case no errors occur during the
translation.  `lbtt' interprets a missing output file or a nonzero exit
status as an error and will not in this case try to run any tests, even
if an automaton were successfully saved in an output file.

   To start testing the translator, add a new `Translator' section for
it into `lbtt''s configuration file (*note Configuration file::), for
example

     Translator
     {
       Name = "LTL-to-Bu"chi translator"
       Path = /home/lbtt-user/bin/ltl-to-buchi-translator
       Parameters = "-x -y -z"
       Enabled = Yes
     }


File: lbtt.info,  Node: Format for LTL formulas,  Next: Format for automata,  Prev: Translator interface,  Up: Interfacing with lbtt

6.2 Input file format for LTL formulas
======================================

`lbtt' passes each LTL formula to each LTL-to-Bu"chi translator in a
file containing an LTL formula in a prefix notation followed by a
single newline. The precise grammar for the LTL formulas (in a BNF-style
notation) is as follows:

     FORMULA  ::=  `t'
                                                  // "true"
                |  `f'
                                                  // "false"
                |  `p'[0--9]+
                                                  // atomic proposition with
                                                  // a nonnegative integer
                                                  // identifier
                |  `!' SP FORMULA
                                                  // negation
                |  `X' SP FORMULA
                                                  // "next time"
                |  `F' SP FORMULA
                                                  // "finally"
                |  `G' SP FORMULA
                                                  // "globally"
                |  `&' SP FORMULA SP FORMULA
                                                  // conjunction
                |  `|' SP FORMULA SP FORMULA
                                                  // disjunction
                |  `i' SP FORMULA SP FORMULA
                                                  // implication
                |  `e' SP FORMULA SP FORMULA
                                                  // equivalence
                |  `^' SP FORMULA SP FORMULA
                                                  // exclusive or
                |  `U' SP FORMULA SP FORMULA
                                                  // "(strong) until"
                |  `V' SP FORMULA SP FORMULA
                                                  // "(weak) release"
                |  `W' SP FORMULA SP FORMULA
                                                  // "weak until"
                |  `M' SP FORMULA SP FORMULA
                                                  // "strong release"
                |  `B' SP FORMULA SP FORMULA
                                                  // "before"
   (The quoted characters denote the characters themselves; SP denotes
any nonempty string of white space. Lines containing a // are comments
and are not part of the grammar. All atomic propositions in the formula
have a nonnegative numeric identifier.)

For example, the LTL formula (in `lbtt''s infix syntax)
     (p0 U p1) -> (<> [] (! p2 <-> p3))
   would be expressed in the form
     i U p0 p1 F G e ! p2 p3
   in an output file.

   If your translator does not support all of the above operators, edit
the configuration file (*note Configuration file::) or use the command
line options (*note Command line options::) to prevent `lbtt' from
generating random LTL formulas with these operators.


File: lbtt.info,  Node: Format for automata,  Next: The lbtt-translate utility,  Prev: Format for LTL formulas,  Up: Interfacing with lbtt

6.3 Output file format for automata
===================================

`lbtt' expects the Bu"chi automata generated by each LTL-to-Bu"chi
translator implementation to be in the format specified below. The
format encodes a generalized Bu"chi automaton (a Bu"chi automaton with
zero or more acceptance conditions) with a single initial state and
labels (guards) on transitions. For the full formal definition and
examples on how to reduce other definitions into the one used by
`lbtt', see *note Definitions::.

   The output file generated by the translator should contain an
AUTOMATON described using the following grammar (as before, quoted
characters denote the characters themselves, SP denotes any nonempty
string of white space, lines containing a // are comments that are not
part of the grammar, and `\n' corresponds to the newline character).

     AUTOMATON  ::=  NUM-STATES SP COND-SPECIFIER STATE-LIST

     NUM-STATES  ::=  [0--9]+

     COND-SPECIFIER  ::=  [0--9]+[st]*

     STATE-LIST  ::=  STATE-LIST SP STATE
                   |  // empty

The automaton description begins with a nonnegative number that gives
the number of states in the automaton. If the number of states is 0,
the automaton will not accept any input. If the number is positive, it
should be followed by a COND-SPECIFIER that determines the number and
placement of acceptance conditions in the automaton. If the number of
acceptance conditions is 0, the automaton accepts an input word if and
only if it has a run on that word according to the definition given in
the Appendix (*note Definitions::).

   The placement of acceptance conditions is specified by concatenating
a string formed from the symbols `s' and `t' to the number of
acceptance conditions (with no white space in between). The
interpretation of this string is as follows:
   * If the string is empty or does not include the symbol `t', the
     acceptance conditions of the automaton are placed exclusively on
     its states. (This alternative corresponds to the definition
     supported by `lbtt' 1.0.x.)

   * If the string is nonempty but does not include the symbol `s', the
     automaton has acceptance conditions exclusively on its transitions.

   * Otherwise, the automaton has acceptance conditions on both states
     and transitions.

   The COND-SPECIFIER is followed by a list of the descriptions of
states in the automaton. The format of this list is affected by the
choice of the placement of the acceptance conditions.  More precisely,
the choice affects the interpretation of the COND-LIST nonterminal
symbol in the following fragment of the grammar: we indicate this by
prefixing the nonterminal with either "<s>" or "<t>" to denote that the
list (together with its terminating `-1') should be omitted in automata
that do not associate acceptance conditions with states or transitions,
respectively.

     STATE  ::=  STATE-ID SP INITIAL? <s>COND-LIST TRANSITION-LIST

     STATE-ID  ::=  [0--9]+

     INITIAL?  ::=  `0'  |  `1'

     COND-LIST  ::=  SP ACCEPTANCE-CONDITION-ID COND-LIST
                  |  SP `-1'

     ACCEPTANCE-CONDITION-ID  ::=  [0--9]+

     TRANSITION-LIST  ::=  SP TRANSITION TRANSITION-LIST
                        |  SP `-1'

     TRANSITION  ::=  STATE-ID <t>COND-LIST SP GUARD-FORMULA `\n'

     GUARD-FORMULA  ::=  `t'
                                                  // "true"
                      |  `f'
                                                  // "false"
                      |  `p'[0--9]+
                                                  // atomic proposition
                      |  `!' SP GUARD-FORMULA
                                                  // negation
                      |  `&' SP GUARD-FORMULA SP GUARD-FORMULA
                                                  // conjunction
                      |  `|' SP GUARD-FORMULA SP GUARD-FORMULA
                                                  // disjunction
                      |  `i' SP GUARD-FORMULA SP GUARD-FORMULA
                                                  // implication
                      |  `e' SP GUARD-FORMULA SP GUARD-FORMULA
                                                  // equivalence
                      |  `^' SP GUARD-FORMULA SP GUARD-FORMULA
                                                  // exclusive or
   The description of each state begins with a numeric state
identifier, which can be any nonnegative integer. The state identifier
should be followed by a number telling whether the state is initial
(`1' if yes). The automaton should have exactly one initial state. If
the automaton has acceptance conditions associated with its states,
this number should then be followed by a list of acceptance condition
identifiers separated by white space. This list should be terminated
with `-1'.

   The state description should be followed by the list of transitions
starting from the state (terminated again by `-1'). Each transition
consists of a state identifier (the target state of the transition), a
list of acceptance condition identifiers (if the automaton has
acceptance conditions on transitions), and a propositional formula (1)
that encodes the symbols of the alphabet 2^AP (where AP is a finite set
of atomic propositions) on which the automaton is allowed to take the
transition. The propositional formula should be terminated with a
newline.

   The state and acceptance condition identifiers need not be
successive, and the states or acceptance conditions can be listed in
any order. The only restrictions are that the identifiers of different
states and acceptance conditions should be unique and that the total
number of different identifiers should equal NUM-STATES or NUM-CONDS,
respectively. (The same identifiers can be shared between states and
acceptance conditions, however.)

   Note that the output file should always contain a valid automaton
description if the LTL-to-Bu"chi translation was successful, even in
the case that the resulting automaton is empty (`lbtt' interprets a
missing automaton description file as an error).

   The following examples illustrate the file format. The first example
gives the description of an automaton with acceptance conditions on
states. Note that in this case the `s' is optional for describing the
placement of acceptance conditions; therefore, the automaton files used
with `lbtt' 1.0.x are upwards compatible with newer versions of the tool
(provided that each guard of a transition is terminated by a newline).

     6 2s         // an automaton with six states and two acc. conditions on states
     0 1 -1       // state 0: initial state, no acceptance conditions
     2 p1         //     transition to state 2, guard `p1'
     5 p2         //     transition to state 5, guard `p2'
     15 p3        //     transition to state 15, guard `p3'
     -1           // end of state 0
     2 0 1 -1     // state 2: non-initial state, acceptance condition 1
     2 p1         //     transition to state 2, guard `p1'
     5 p2         //     transition to state 5, guard `p2'
     15 p3        //     transition to state 15, guard `p3'
     -1           // end of state 2
     5 0 0 -1     // state 5: non-initial state, acceptance condition 0
     5 p2         //     transition to state 5, guard `p2'
     8 & p1 p2    //     transition to state 8, guard `p1 /\ p2'
     12 & p1 p3   //     transition to state 12, guard `p1 /\ p3'
     15 p3        //     transition to state 15, guard `p3'
     -1           // end of state 5
     8 0 0 -1     // state 8: non-initial state, acceptance condition 0
     5 p2         //     transition to state 5, guard `p2'
     8 & p1 p2    //     transition to state 8, guard `p1 /\ p2'
     12 & p1 p3   //     transition to state 12, guard `p1 /\ p3'
     15 p3        //     transition to state 15, guard `p3'
     -1           // end of state 8
     15 0 1 0 -1  // state 15: non-initial state, acceptance conditions 1 and 0
     2 p1         //     transition to state 2, guard `p1'
     5 p2         //     transition to state 5, guard `p2'
     15 p3        //     transition to state 15, guard `p3'
     -1           // end of state 15
     12 0 1 0 -1  // state 12: non-initial state, acceptance conditions 1 and 0
     2 p1         //     transition to state 2, guard `p1'
     5 p2         //     transition to state 5, guard `p2'
     15 p3        //     transition to state 15, guard `p3'
     -1           // end of state 12

The following example illustrates an automaton in which acceptance
conditions are placed on transitions.

     4 3t         // four states, three acceptance conditions on transitions
     5 0          // state 5: non-initial state
     84 0 -1 p1   //     transition to state 84, condition 0, guard `p1'
     27 0 -1 & p1 ! p2 // tr. to state 27, condition 0, guard `p1 /\ ! p2'
     5 -1 t       //     transition to state 5, no conditions, guard `true'
     -1           // end of state 5
     84 1         // state 84: initial state
     5 1 -1 t     //     transition to state 5, condition 1, guard `true'
     27 0 -1 p1   //     transition to state 27, condition 0, guard `p1'
     -1           // end of state 84
     49 0         // state 49: non-initial state
     5 -1 t       //     transition to state 5, no conditions, guard `true'
     49 1 4 -1 & p1 ! p2 // tr. to state 49, conds. 1 and 4, guard `p1 /\ ! p2'
     84 -1 p1     //     transition to state 84, no conditions, guard `p1'
     -1           // end of state 49
     27 0         // state 27: non-initial state
     49 -1 & p1 p3 //    transition to state 49, no conds., guard `p1 /\ p3'
     -1           // end of state 27

Automata with acceptance conditions on both states and transitions can
be specified using a combination of the above two formats, that is, by
using `st' as the acceptance condition placement specifier and
including a list of acceptance conditions both after the value
determining the initialness of a state, and after the identifier of the
target state of each transition.

   ---------- Footnotes ----------

   (1) Although not described formally in the grammar, the guard
formulas can be specified in any of the formats `lbtt' supports in its
formula input files (*note `--formulafile' command line option:
--formulafile.). Note that the formula always needs to be terminated
with a newline, though.


File: lbtt.info,  Node: The lbtt-translate utility,  Prev: Format for automata,  Up: Interfacing with lbtt

6.4 The `lbtt-translate' utility
================================

The `lbtt' source distribution includes a small utility which can be
used as a common interface for the following publicly available
LTL-to-Bu"chi translator algorithm implementations:

   * `lbt' -- an LTL-to-Bu"chi translation algorithm implementation
     based on the algorithm described in *note [GPVW95]::.  See
     `http://www.tcs.hut.fi/Software/maria/tools/lbt/' for more
     information, including the source code of the implementation.

   * SPIN *note [Hol97]:: -- a model checking tool that includes a
     module for translating LTL formulas into Bu"chi automata
     originally based on the algorithm presented in *note [GPVW95]::.
     See `http://spinroot.com/spin/whatispin.html' for more information.

   * Spot *note [DP04]:: -- a model checking library that includes a
     module for translating LTL formulas into Bu"chi automata
     incorporating optimization techniques from several different
     sources. See `http://spot.lip6.fr/' for more information.

   To use `lbtt' for testing the LTL-to-Bu"chi translators included in
these tools, you should first install the tool normally by following its
installation instructions. Then add the following `Translator' section
in `lbtt''s configuration file:

     Translator
     {
       Name = "[NAME FOR THE IMPLEMENTATION]"
       Path = "[PATH TO `LBTT-TRANSLATE']"
       Parameters = "[IMPLEMENTATION SELECTOR] [PATH TO EXECUTABLE]"
       Enabled = Yes
     }

where [PATH TO `LBTT-TRANSLATE'] contains the complete path and file
name of the `lbtt-translate' tool executable, [IMPLEMENTATION SELECTOR]
is either of the options `--lbt' or `--spin', and [PATH TO EXECUTABLE]
is the full path of the tool executable. The names of these executables
are usually (assuming a normal installation) `lbt' and `spin',
respectively.

   Note: These implementations may not have built-in support for all of
the LTL formula operators available for generating random LTL formulas
with `lbtt'. See the documentation of each translator for information
about which operators are supported, and then change the parameters in
`lbtt''s configuration file accordingly to disable the unsupported
operators (or instruct `lbtt' to read the formulas from an external
source by invoking `lbtt' with the *note `--formulafile' command line
option: --formulafile.).

   The `lbtt-translate' utility can also be invoked directly from the
shell to translate an LTL formula into a Bu"chi automaton using either
of the above translators. Use the command `lbtt-translate --help' to
see a short summary of available options.


File: lbtt.info,  Node: References,  Next: Definitions,  Prev: Interfacing with lbtt,  Up: Top

References
**********

[CGP99]
     E. Clarke Jr., O. Grumberg and D. Peled. Model checking. The MIT
     Press, 1999.

[Cou99]
     J.-M. Couvreur. On-the-fly verification of linear temporal logic.
     In Proceedings of the World Congress on Formal Methods in the
     Development of Computing Systems (FM'99), volume I, volume 1708 of
     Lecture Notes in Computer Science, pages 253--271.
     Springer-Verlag, 1999.

[DGV99]
     M. Daniele, F. Giunchiglia and M. Y. Vardi. Improved automata
     generation for linear temporal logic. In Proceedings of the 11th
     International Conference on Computer Aided Verification (CAV'99),
     volume 1633 of Lecture Notes in Computer Science, pages 249--260.
     Springer-Verlag, 1999.

[DP04]
     A. Duret-Lutz and D. Poitrenaud. SPOT: An Extensible Model
     Checking Library Using Transition-Based Generalized Bu"chi
     Automata. In Proceedings of the 12th IEEE/ACM International
     Symposium on Modeling, Analysis, and Simulation of Computer and
     Telecommunication Systems (MASCOTS 2004), pages 76-83. IEEE
     Computer Society Press, 2004.

[EH00]
     K. Etessami and G. Holzmann. Optimizing Bu"chi automata. In
     Proceedings of the 11th International Conference on Concurrency
     Theory (CONCUR 2000), volume 1877 of Lecture Notes in Computer
     Science, pages 153--167. Springer-Verlag, 2000.

[Ete99]
     K. Etessami. Stutter-invariant languages, omega-automata, and
     temporal logic. In Proceedings of the 11th International
     Conference on Computer Aided Verification (CAV'99), volume 1633 of
     Lecture Notes in Computer Science, pages 236--248.
     Springer-Verlag, 1999.

[Ete02]
     K. Etessami. A hierarchy of polynomial-time computable simulations
     for automata. In Proceedings of the 13th International Conference
     on Concurrency Theory (CONCUR 2002), volume 2421 of Lecture Notes
     in Computer Science, pages 131--144. Springer-Verlag, 2002.

[EWS01]
     K. Etessami, Th. Wilke and R. Schuller. Fair simulation relations,
     parity games, and state space reduction for Bu"chi automata. In
     Proceedings of the 28th International Colloquium on Automata,
     Languages and Programming (ICALP 2001), volume 2076 of Lecture
     Notes in Computer Science, pages 694--707. Springer-Verlag, 2001.

[Fri03]
     C. Fritz. Constructing Bu"chi automata from linear temporal logic
     using simulation relations for alternating Bu"chi automata. In
     Proceedings of the 8th International Conference on Implementation
     and Application of Automata (CIAA 2003), volume 2759 of Lecture
     Notes in Computer Science, pages 35--48. Springer-Verlag, 2003.

[GO01]
     P. Gastin and D. Oddoux. Fast LTL to Bu"chi automata translation.
     In Proceedings of the 13th International Conference on Computer
     Aided Verification (CAV 2001), volume 2102 of Lecture Notes in
     Computer Science, pages 53--65. Springer-Verlag, 2001.

[GO03]
     P. Gastin and D. Oddoux. LTL with past and two-way weak alternating
     automata. In Proceedings of the 28th International Symposium on
     Mathematical Foundations of Computer Science (MFCS 2003), volume
     2747 of Lecture Notes in Computer Science, pages 439--448.
     Springer-Verlag, 2003.

[Gei01]
     M. C. W. Geilen. On the construction of monitors for temporal logic
     properties. Electronic Notes for Theoretical Computer Science,
     55(2), 2001.

[GPVW95]
     R. Gerth, D. Peled, M. Y. Vardi and P. Wolper. Simple on-the-fly
     automatic verification of linear temporal logic. In Proceedings of
     15th IFIP WG6.1 International Symposium on Protocol Specification,
     Testing, and Verification (PSTV'95), pages 3--18.  Chapman & Hall,
     1995.

[GL02]
     D. Giannakopoulou and F. Lerda. From states to transitions:
     Improving translation of LTL formulae to Bu"chi automata. In
     Proceedings of the 22nd IFIP WG6.1 International Conference on
     Formal Techniques for Networked and Distributed Systems (FORTE
     2002), volume 2529 of Lecture Notes in Computer Science, pages
     308--326. Springer-Verlag, 2002.

[GSB02]
     S. Gurumurthy, F. Somenzi and R. Bloem. Fair simulation
     minimization.  In Proceedings of the 14th International Conference
     on Computer Aided Verification (CAV 2002), volume 2404 of Lecture
     Notes in Computer Science, pages 610--624. Springer-Verlag, 2002.

[GViz]
     GraphViz - open source graph drawing software. See
     `http://www.research.att.com/sw/tools/graphviz/'.

[Hol97]
     G. J. Holzmann. The model checker SPIN.  IEEE Transactions on
     Software Engineering, 23(5):279--295, 1997.

[Isl94]
     A. Isli. Mapping an LPTL formula into a Bu"chi alternating
     automaton accepting its models. In Temporal Logic: Proceedings of
     the ICTL Workshop, pages 85--90. Research Report MPI-I-94-230,
     Max-Planck-Institut fu"r Informatik, 1994.

[Lat03]
     T. Latvala. Efficient model checking of safety properties. In
     Proceedings of the 10th Spin Workshop on Model Checking of Software
     (SPIN 2003), volume 2648 of Lecture Notes in Computer Science,
     pages 74--88. Springer-Verlag, 2003.

[Sch01]
     K. Schneider. Improving automata generation for linear temporal
     logic by considering the automaton hierarchy. In Proceedings of
     the 8th International Conference on Logic for Programming,
     Artificial Intelligence and Reasoning (LPAR 2001), volume 2250 of
     Lecture Notes in Computer Science, pages 39--54. Springer-Verlag,
     2001.

[ST03]
     R. Sebastiani and S. Tonetta. "More deterministic" vs. "smaller"
     Bu"chi automata for efficient LTL model checking. In Proceedings
     of the 12th Advanced Research Working Conference on Correct
     Hardware Design and Verification Methods (CHARME 2003), volume
     2860 of Lecture Notes in Computer Science, pages 126--140.
     Springer-Verlag, 2003.

[SB00]
     F. Somenzi and R. Bloem. Efficient Bu"chi automata from LTL
     formulae.  In Proceedings of the 12th International Conference on
     Computer Aided Verification (CAV 2000), volume 1855 of Lecture
     Notes in Computer Science, pages 247--263. Springer-Verlag, 2000.

[Tau00]
     H. Tauriainen. Automated testing of Bu"chi automata translators
     for linear temporal logic. Research report A66, Laboratory for
     Theoretical Computer Science, Helsinki University of Technology,
     Espoo, Finland, 2000. Available on the WWW at
     `http://www.tcs.hut.fi/Publications/info/bibdb.HUT-TCS-A66.shtml'

[TH02]
     H. Tauriainen and K. Heljanko. Testing LTL formula translation
     into Bu"chi automata.  International Journal on Software Tools for
     Technology Transfer (STTT) 4(1):57--70, 2002.

[Thi02]
     X. Thirioux. Simple and efficient translation from LTL formulas to
     B"uchi automata. Electronic Notes in Theoretical Computer Science,
     66(2), 2002.

[Var96]
     M. Y. Vardi. An automata-theoretic approach to linear temporal
     logic.  In Logics for Concurrency: Structure versus Automata,
     volume 1043 of Lecture Notes in Computer Science, pages 238--265.
     Springer-Verlag, 1996.

[VW86]
     M. Y. Vardi and P. Wolper. An automata-theoretic approach to
     automatic program verification. In Proceedings of the First IEEE
     Symposium on Logic in Computer Science (LICS'86), pages 332--344.
     IEEE Computer Society Press, 1986.

[Wol01]
     P. Wolper. Constructing automata from temporal logic formulas: A
     tutorial.  In Lectures on Formal Methods and Performance Analysis:
     First EEF/Euro Summer School on Trends in Computer Science,
     Revised Lectures, volume 2090 of Lecture Notes in Computer
     Science, pages 261--277. Springer-Verlag, 2001.



File: lbtt.info,  Node: Definitions,  Next: Configuration file option index,  Prev: References,  Up: Top

Appendix A Definitions
**********************

This appendix reviews the formal definitions of the objects that `lbtt'
manipulates.

* Menu:

* LTL formulas::                `lbtt' uses traditional semantics
                                  for propositional linear temporal
                                  logic.
* Generalized automata::        The Bu"chi automata used by `lbtt'
                                  have one initial state, labels on
                                  transitions and zero or more
                                  acceptance conditions.
* State spaces::                State spaces are Kripke structures
                                  with a total transition relation.


File: lbtt.info,  Node: LTL formulas,  Next: Generalized automata,  Prev: Definitions,  Up: Definitions

A.1 LTL formulas
================

`lbtt' uses the traditional definition for propositional linear
temporal logic. Let AP be a finite set of atomic propositions.  The set
of propositional linear temporal logic formulas is defined inductively
as follows:

   * All atomic propositions in AP and the Boolean constant `true' are
     LTL formulas.

   * If `f1' and `f2' are LTL formulas, then `! f1', `X f1', `(f1 \/
     f2)' and `(f1 U f2)' are LTL formulas.


   The semantics of linear temporal logic (i.e., a satisfiability
relation) is defined over infinite sequences x = <y(0), y(1), y(2), ...>
over subsets of AP as follows:

   * x satisfies `true' for all sequences x.

   * x satisfies an atomic proposition `p' if and only if `p' belongs
     to y(0), the first element of the sequence x.

   * x satisfies `! f' if and only if it is not the case that x
     satisfies `f'.

   * x satisfies `f1 \/ f2' if and only if x satisfies `f1' or x
     satisfies `f2'.

   * x satisfies `X f' if and only if <y(1), y(2), y(3), ...> satisfies
     `f'.

   * x satisfies `f1 U f2' if and only if there exists an i >= 0 such
     that <y(i), y(i+1), y(i+2), ...> satisfies `f2' and for all 0 <= j
     < i, <y(j), y(j+1), y(j+2), ...> satisfies `f1'.


   `lbtt' also supports the following operators and Boolean constants,
the definitions of which can be given in terms of the previously defined
operators:

   * "false": `false' := `! true'

   * logical conjunction: `(f1 /\ f2)' := `! (! f1 \/ ! f2)'

   * logical implication: `(f1 -> f2)' := `(! f1 \/ f2)'

   * logical equivalence: `(f1 <-> f2)' := `((f1 -> f2) /\ (f2 -> f1))'

   * logical "exclusive or": `(f1 xor f2)' := `! (f1 <-> f2)'

   * temporal "finally": `<> f' := `(true U f)'

   * temporal "globally": `[] f' := `! <> ! f'

   * temporal "(weak) release": `(f1 V f2)' := `! (! f1 U ! f2)'

   * temporal "weak until": `(f1 W f2)' := `((f1 U f2) \/ [] f1)'

   * temporal "strong release": `(f1 M f2)' := `((f1 V f2) /\ <> f1)'

   * temporal "before": `(f1 B f2)' := `! (! f1 U f2)'



File: lbtt.info,  Node: Generalized automata,  Next: State spaces,  Prev: LTL formulas,  Up: Definitions

A.2 Generalized automata
========================

`lbtt' uses internally finite-state automata on infinite words (Bu"chi
automata) over the alphabet 2^AP (where AP is a finite set of atomic
propositions) with one initial state, labels on transitions and zero or
more acceptance conditions.

A.2.1 Formal definition of generalized automata
-----------------------------------------------

Formally, a generalized Bu"chi automaton can be represented as a
tuple(1) <S, Q, R, q, F, L>, where

   * S is the finite _alphabet_ (S = 2^AP in this case),

   * Q is the finite set of _states_,

   * R (a subset of Q x 2^S x 2^F x Q) is the set of _transitions_
     (each of which consists of four components called the _start
     state_, the _guard_, the _acceptance component_, and the _target
     state_, respectively),

   * q is the _initial state_,

   * F = {f1, f2, ..., fn} (for some finite n) is the set of
     _acceptance conditions_ (a "nongeneralized" Bu"chi automaton has
     exactly one acceptance condition), and

   * L: Q -> 2^F is a _labeling function_ that associates each state of
     the automaton with a set of acceptance conditions.


   A _run_ of a Bu"chi automaton on an infinite sequence <x(0), x(1),
x(2), ...> over the alphabet 2^AP is an infinite sequence of pairs of
states and transitions <(q(0),t(0)), (q(1),t(1)), (q(2),t(2)) ...>
(where each q(i) is a state in Q and each t(i) is a transition in R)
such that q(0) = q and for all i >= 0, t(i) = <q(i), X(i), Y(i),
q(i+1)> in R such that x(i) belongs to X(i).  (Because the relation R
is not necessarily a function from Q x 2^S x 2^F to Q, the automaton
may have many runs on the same input.)

   A run <(q(0),t(0)), (q(1),t(1)), (q(2),t(2)), ...> (where t(i) = <
q(i), X(i), Y(i), q(i+1) > for all i) is _accepting_ if and only if
additionally, for each acceptance condition f in F, f is in L(q(i)) or
f is in Y(i) for infinitely many i.

   The automaton _accepts_ an infinite sequence <x(0), x(1), x(2), ...>
over the alphabet 2^AP if and only if the automaton has at least one
accepting run on this sequence.

A.2.2 Transition label encoding
-------------------------------

When working with automata on words over the alphabet 2^AP, the guards
of transitions can be expressed as propositional formulas by
identifying a set of symbols from this alphabet with the set of models
of a propositional formula. A transition can then be seen as a rule "if
in state q(i) and the next input symbol x(i) is a model of the
propositional formula guarding the transition, the automaton can move
to state q(i+1)".  In the context of Bu"chi automata constructed from
LTL formulas, this often allows for a compact representation for the
transitions.

A.2.3 Converting between equivalent definitions
-----------------------------------------------

Many LTL-to-Bu"chi translation algorithms presented in the literature
(for example, *note [GPVW95]::) are based on a slightly different
definition for generalized Bu"chi automata, where the automata can have
several initial states, acceptance is determined using a family of sets
of states, and the guards of transitions are replaced with an
additional state labeling that associates a set of LTL formulas with
each state. These automata can easily be described using the above
definition through the following steps:

  1. Add a new state (associated with an empty set of LTL formulas)
     into the automaton and add transitions from it to each initial
     state of the original automaton. Make the new state the (only)
     initial state of the automaton.

  2. For each state of the (modified) automaton, construct a
     conjunction of all propositional constraints (all formulas with no
     temporal operators) associated with the state and make the
     conjunction the guard of each transition coming into the state
     (the acceptance component of each transition remains empty). Then
     remove the association between states and sets of formulas.

  3. If Q1, Q2, ..., Qk (subsets of Q) are the sets of states
     determining acceptance in the original automaton, let fi = Qi for
     all 1 <= 1 <= k, and let L(q) = {fi | q is a member of fi} for all
     states q.

   ---------- Footnotes ----------

   (1) This definition differs from those commonly found in the
literature by specifying the acceptance conditions in terms of a
separate set that is independent of the other components of the
automaton, together with an explicit labeling function for the states.
This is to allow the definition to correspond more accurately to the
automata that can be described in input files.


File: lbtt.info,  Node: State spaces,  Prev: Generalized automata,  Up: Definitions

A.3 State spaces
================

`lbtt' uses randomly generated state spaces in the model checking
result cross-comparison test (*note Model checking result
cross-comparison test::) and the model checking result consistency check
(*note Model checking result consistency check::). Formally, the state
spaces are (finite) Kripke structures with a total transition relation,
i.e., directed graphs with a set of atomic propositions attached to
each state, with each state having at least one immediate successor
(which may be the state itself). The precise definition is as follows
(as before, let AP be a finite set of atomic propositions).

   A state space can be represented as a tuple <S, R, L>, where

   * S is the finite set of _states_,

   * R (a subset of S x S) is the _transition relation_, and

   * L: S -> 2^AP is the _labeling function_ which maps each state to a
     set of atomic propositions that hold in the state.



File: lbtt.info,  Node: Configuration file option index,  Next: Command line option index,  Prev: Definitions,  Up: Top

Configuration file option index
*******************************

 [index ]
* Menu:

* AbbreviatedOperators [FormulaOptions]: FormulaOptions section.
                                                              (line  12)
* AndPriority [FormulaOptions]:          FormulaOptions section.
                                                              (line  22)
* BeforePriority [FormulaOptions]:       FormulaOptions section.
                                                              (line  25)
* ChangeInterval [FormulaOptions]:       FormulaOptions section.
                                                              (line  29)
* ChangeInterval [StateSpaceOptions]:    StateSpaceOptions section.
                                                              (line  16)
* ComparisonCheck [GlobalOptions]:       GlobalOptions section.
                                                              (line  12)
* ComparisonTest [GlobalOptions]:        GlobalOptions section.
                                                              (line  12)
* ConsistencyCheck [GlobalOptions]:      GlobalOptions section.
                                                              (line  18)
* ConsistencyTest [GlobalOptions]:       GlobalOptions section.
                                                              (line  18)
* DefaultOperatorPriority [FormulaOptions]: FormulaOptions section.
                                                              (line  36)
* EdgeProbability [StateSpaceOptions]:   StateSpaceOptions section.
                                                              (line  23)
* Enabled [Translator]:                  Translator section.  (line  28)
* EquivalencePriority [FormulaOptions]:  FormulaOptions section.
                                                              (line  44)
* FalsePriority [FormulaOptions]:        FormulaOptions section.
                                                              (line  48)
* FinallyPriority [FormulaOptions]:      FormulaOptions section.
                                                              (line  52)
* GenerateMode [FormulaOptions]:         FormulaOptions section.
                                                              (line  56)
* GenerateMode [StateSpaceOptions]:      StateSpaceOptions section.
                                                              (line  33)
* GloballyPriority [FormulaOptions]:     FormulaOptions section.
                                                              (line  67)
* ImplicationPriority [FormulaOptions]:  FormulaOptions section.
                                                              (line  71)
* Interactive [GlobalOptions]:           GlobalOptions section.
                                                              (line  23)
* IntersectionCheck [GlobalOptions]:     GlobalOptions section.
                                                              (line  49)
* IntersectionTest [GlobalOptions]:      GlobalOptions section.
                                                              (line  49)
* ModelCheck [GlobalOptions]:            GlobalOptions section.
                                                              (line  54)
* Name [Translator]:                     Translator section.  (line  34)
* NextPriority [FormulaOptions]:         FormulaOptions section.
                                                              (line  75)
* NotPriority [FormulaOptions]:          FormulaOptions section.
                                                              (line  78)
* OrPriority [FormulaOptions]:           FormulaOptions section.
                                                              (line  81)
* OutputMode [FormulaOptions]:           FormulaOptions section.
                                                              (line  84)
* Parameters [Translator]:               Translator section.  (line  49)
* Path [Translator]:                     Translator section.  (line  55)
* PropositionPriority [FormulaOptions]:  FormulaOptions section.
                                                              (line 119)
* Propositions [FormulaOptions]:         FormulaOptions section.
                                                              (line 124)
* Propositions [StateSpaceOptions]:      StateSpaceOptions section.
                                                              (line  45)
* RandomSeed [FormulaOptions]:           FormulaOptions section.
                                                              (line 134)
* RandomSeed [StateSpaceOptions]:        StateSpaceOptions section.
                                                              (line  57)
* ReleasePriority [FormulaOptions]:      FormulaOptions section.
                                                              (line 147)
* Rounds [GlobalOptions]:                GlobalOptions section.
                                                              (line  66)
* Size [FormulaOptions]:                 FormulaOptions section.
                                                              (line 152)
* Size [StateSpaceOptions]:              StateSpaceOptions section.
                                                              (line  67)
* StrongReleasePriority [FormulaOptions]: FormulaOptions section.
                                                              (line 160)
* TranslatorTimeout [GlobalOptions]:     GlobalOptions section.
                                                              (line  70)
* TruePriority [FormulaOptions]:         FormulaOptions section.
                                                              (line 168)
* TruthProbability [StateSpaceOptions]:  StateSpaceOptions section.
                                                              (line  76)
* UntilPriority [FormulaOptions]:        FormulaOptions section.
                                                              (line 165)
* Verbosity [GlobalOptions]:             GlobalOptions section.
                                                              (line  80)
* WeakUntilPriority [FormulaOptions]:    FormulaOptions section.
                                                              (line 172)
* XorPriority [FormulaOptions]:          FormulaOptions section.
                                                              (line 176)


File: lbtt.info,  Node: Command line option index,  Next: User command index,  Prev: Configuration file option index,  Up: Top

Command line option index
*************************

 [index ]
* Menu:

* --abbreviatedoperators:                LTL formula options. (line  13)
* --andpriority:                         LTL formula options. (line  18)
* --beforepriority:                      LTL formula options. (line  22)
* --comparisontest:                      Global options.      (line  12)
* --configfile:                          Special options.     (line  11)
* --consistencytest:                     Global options.      (line  18)
* --defaultoperatorpriority:             LTL formula options. (line  26)
* --disable:                             Global options.      (line  23)
* --edgeprobability:                     State space options. (line  13)
* --enable:                              Global options.      (line  32)
* --enumeratedpath:                      State space options. (line  18)
* --equivalencepriority:                 LTL formula options. (line  30)
* --falsepriority:                       LTL formula options. (line  34)
* --finallypriority:                     LTL formula options. (line  37)
* --formulachangeinterval:               LTL formula options. (line  41)
* --formulafile:                         Special options.     (line  16)
* --formulageneratemode:                 LTL formula options. (line  46)
* --formulaoutputmode:                   LTL formula options. (line  55)
* --formulapropositions:                 LTL formula options. (line  61)
* --formularandomseed:                   LTL formula options. (line  66)
* --formulasize:                         LTL formula options. (line  72)
* --generatennf:                         LTL formula options. (line  80)
* --globallypriority:                    LTL formula options. (line  84)
* --globalmodelcheck:                    Global options.      (line  37)
* --help:                                Special options.     (line  43)
* --implicationpriority:                 LTL formula options. (line  88)
* --interactive:                         Global options.      (line  45)
* --intersectiontest:                    Global options.      (line  54)
* --localmodelcheck:                     Global options.      (line  58)
* --logfile:                             Special options.     (line  46)
* --modelcheck:                          Global options.      (line  64)
* --nextpriority:                        LTL formula options. (line  92)
* --noabbreviatedoperators:              LTL formula options. (line  13)
* --nocomparisontest:                    Global options.      (line  12)
* --noconsistencytest:                   Global options.      (line  18)
* --nogeneratennf:                       LTL formula options. (line  80)
* --nointersectiontest:                  Global options.      (line  54)
* --nooutputnnf:                         LTL formula options. (line 105)
* --notpriority:                         LTL formula options. (line  96)
* --orpriority:                          LTL formula options. (line 100)
* --outputnnf:                           LTL formula options. (line 105)
* --pause:                               Global options.      (line  67)
* --profile:                             Special options.     (line  50)
* --propositionpriority:                 LTL formula options. (line 110)
* --quiet:                               Special options.     (line  57)
* --randomconnectedgraph:                State space options. (line  24)
* --randomgraph:                         State space options. (line  28)
* --randompath:                          State space options. (line  32)
* --releasepriority:                     LTL formula options. (line 113)
* --rounds:                              Global options.      (line  70)
* --showconfig:                          Special options.     (line  62)
* --showoperatordistribution:            Special options.     (line  69)
* --silent:                              Special options.     (line  57)
* --skip:                                Special options.     (line  77)
* --statespacechangeinterval:            State space options. (line  37)
* --statespacegeneratemode:              State space options. (line  42)
* --statespacerandomseed:                State space options. (line  46)
* --statespacesize:                      State space options. (line  52)
* --strongreleasepriority:               LTL formula options. (line 117)
* --translatortimeout:                   Global options.      (line  74)
* --truepriority:                        LTL formula options. (line 121)
* --truthprobability:                    State space options. (line  56)
* --untilpriority:                       LTL formula options. (line 124)
* --verbosity:                           Global options.      (line  79)
* --version:                             Special options.     (line  82)
* --weakuntilpriority:                   LTL formula options. (line 128)
* --xorpriority:                         LTL formula options. (line 132)
* -h:                                    Special options.     (line  43)
* -V:                                    Special options.     (line  82)


File: lbtt.info,  Node: User command index,  Next: Concept index,  Prev: Command line option index,  Up: Top

User command index
******************

 [index ]
* Menu:

* algorithms:                            Data display commands.
                                                               (line 13)
* buchi:                                 Data display commands.
                                                               (line 19)
* buchianalysis:                         Failure analysis commands.
                                                               (line 15)
* consistencyanalysis:                   Failure analysis commands.
                                                               (line 45)
* continue:                              Test control commands.
                                                               (line 11)
* disable:                               Test control commands.
                                                               (line 20)
* enable:                                Test control commands.
                                                               (line 27)
* evaluate:                              Data display commands.
                                                               (line 31)
* formula:                               Data display commands.
                                                               (line 62)
* help:                                  Getting help.         (line  6)
* implementations:                       Data display commands.
                                                               (line 13)
* inconsistencies:                       Data display commands.
                                                               (line 68)
* quit:                                  Test control commands.
                                                               (line 30)
* resultanalysis:                        Failure analysis commands.
                                                               (line 65)
* results:                               Data display commands.
                                                               (line 77)
* skip:                                  Test control commands.
                                                               (line 34)
* statespace:                            Data display commands.
                                                               (line 84)
* statistics:                            Data display commands.
                                                               (line 95)
* translators:                           Data display commands.
                                                               (line 13)
* verbosity:                             Test control commands.
                                                               (line 41)


File: lbtt.info,  Node: Concept index,  Prev: User command index,  Up: Top

Concept index
*************

 [index ]
* Menu:

* ! (LTL formula operator):              Random LTL formulas. (line  15)
* ! (operator semantics in LTL):         LTL formulas.        (line  27)
* -> (LTL formula operator):             Random LTL formulas. (line  17)
* -> (operator semantics in LTL):        LTL formulas.        (line  49)
* /\ (LTL formula operator):             Random LTL formulas. (line  13)
* /\ (operator semantics in LTL):        LTL formulas.        (line  47)
* <-> (LTL formula operator):            Random LTL formulas. (line  19)
* <-> (operator semantics in LTL):       LTL formulas.        (line  51)
* \/ (LTL formula operator):             Random LTL formulas. (line  11)
* \/ (operator semantics in LTL):        LTL formulas.        (line  30)
* _and_ (LTL formula operator):          Random LTL formulas. (line  13)
* _and_ (operator semantics in LTL):     LTL formulas.        (line  47)
* _not_ (LTL formula operator):          Random LTL formulas. (line  15)
* _or_ (LTL formula operator):           Random LTL formulas. (line  11)
* _or_ (operator semantics in LTL):      LTL formulas.        (line  30)
* abbreviated LTL formula operators <1>: LTL formula options. (line  13)
* abbreviated LTL formula operators:     FormulaOptions section.
                                                              (line  12)
* Algorithm section (configuration file): Translator section. (line   6)
* always (LTL formula operator):         Random LTL formulas. (line  40)
* always (operator semantics in LTL):    LTL formulas.        (line  57)
* analyzing test failures, Bu"chi automata intersection emptiness check: Failure analysis commands.
                                                              (line  15)
* analyzing test failures, model checking result consistency check: Failure analysis commands.
                                                              (line  45)
* analyzing test failures, model checking result cross-comparison test: Failure analysis commands.
                                                              (line  65)
* atomic proposition:                    Random input generation.
                                                              (line  16)
* atomic propositions, computing probabilities for: The formula generation algorithm.
                                                              (line  53)
* atomic propositions, priorities for <1>: LTL formula options.
                                                              (line  11)
* atomic propositions, priorities for <2>: FormulaOptions section.
                                                              (line  11)
* atomic propositions, priorities for <3>: The formula generation algorithm.
                                                              (line  53)
* atomic propositions, priorities for:   Random LTL formulas. (line  60)
* B (LTL formula operator):              Random LTL formulas. (line  34)
* B (operator semantics in LTL):         LTL formulas.        (line  65)
* before (LTL formula operator):         Random LTL formulas. (line  34)
* before (operator semantics in LTL):    LTL formulas.        (line  65)
* Bu"chi automata intersection emptiness check: Automata intersection emptiness check.
                                                              (line   6)
* Bu"chi automata intersection emptiness check, failure analysis: Failure analysis commands.
                                                              (line  15)
* Bu"chi automata, formal definition:    Generalized automata.
                                                              (line   6)
* Bu"chi automata, LTL-to-Bu"chi translator output file format: Format for automata.
                                                              (line   6)
* changing verbosity of output <1>:      Test control commands.
                                                              (line  41)
* changing verbosity of output <2>:      Global options.      (line  79)
* changing verbosity of output:          GlobalOptions section.
                                                              (line  80)
* commands, abbreviating:                Command conventions. (line  11)
* commands, conventions for entering:    Command conventions. (line   6)
* commands, entering lists of numbers:   Command conventions. (line  15)
* commands, getting help:                Getting help.        (line   6)
* commands, invoking external programs:  Command conventions. (line  44)
* commands, LTL formula identifiers:     Command conventions. (line  33)
* commands, redirecting output:          Command conventions. (line  39)
* commands, test control:                Test control commands.
                                                              (line   6)
* commands, writing output to a pipe:    Command conventions. (line  44)
* comments in configuration file:        Configuration file.  (line  34)
* configuration file, Algorithm section: Translator section.  (line   6)
* configuration file, changing the name of: Special options.  (line  11)
* configuration file, comments:          Configuration file.  (line  34)
* configuration file, example:           Sample configuration file.
                                                              (line   6)
* configuration file, formatting:        Configuration file.  (line   6)
* configuration file, FormulaOptions section: FormulaOptions section.
                                                              (line   6)
* configuration file, GlobalOption section: GlobalOptions section.
                                                              (line   6)
* configuration file, Implementation section: Translator section.
                                                              (line   6)
* configuration file, minimal requirements <1>: Translator section.
                                                              (line   6)
* configuration file, minimal requirements: Configuration file.
                                                              (line  38)
* configuration file, option values:     Configuration file.  (line  27)
* configuration file, StateSpaceOptions section: StateSpaceOptions section.
                                                              (line   6)
* configuration file, Translator section: Translator section. (line   6)
* configuration information:             Configuration information.
                                                              (line   6)
* conjunction (LTL formula operator):    Random LTL formulas. (line  13)
* conjunction (operator semantics in LTL): LTL formulas.      (line  47)
* constants, computing probabilities for: The formula generation algorithm.
                                                              (line  42)
* constants, priorities for <1>:         LTL formula options. (line  11)
* constants, priorities for <2>:         FormulaOptions section.
                                                              (line  11)
* constants, priorities for <3>:         The formula generation algorithm.
                                                              (line  42)
* constants, priorities for:             Random LTL formulas. (line  60)
* conventions for entering commands:     Command conventions. (line   6)
* conventions for writing configuration files: Configuration file.
                                                              (line   6)
* default operator priority <1>:         LTL formula options. (line  26)
* default operator priority:             FormulaOptions section.
                                                              (line  36)
* density (of a state space) <1>:        StateSpaceOptions section.
                                                              (line  23)
* density (of a state space):            Random state spaces. (line  31)
* disabling LTL-to-Bu"chi translators <1>: Test control commands.
                                                              (line  20)
* disabling LTL-to-Bu"chi translators <2>: Global options.    (line  23)
* disabling LTL-to-Bu"chi translators:   Translator section.  (line  28)
* disjunction (LTL formula operator):    Random LTL formulas. (line  11)
* disjunction (operator semantics in LTL): LTL formulas.      (line  30)
* enabling and disabling tests <1>:      Global options.      (line  12)
* enabling and disabling tests <2>:      Special options.     (line  50)
* enabling and disabling tests:          GlobalOptions section.
                                                              (line  12)
* enabling LTL-to-Bu"chi translators <1>: Test control commands.
                                                              (line  27)
* enabling LTL-to-Bu"chi translators <2>: Global options.     (line  32)
* enabling LTL-to-Bu"chi translators:    Translator section.  (line  28)
* enumerated path <1>:                   State space options. (line  18)
* enumerated path <2>:                   StateSpaceOptions section.
                                                              (line  33)
* enumerated path:                       Random state spaces. (line  51)
* equivalence (LTL formula operator):    Random LTL formulas. (line  19)
* equivalence (operator semantics in LTL): LTL formulas.      (line  51)
* eventually (LTL formula operator):     Random LTL formulas. (line  32)
* eventually (operator semantics in LTL): LTL formulas.       (line  55)
* exclusive or (LTL formula operator):   Random LTL formulas. (line  21)
* exclusive or (operator semantics in LTL): LTL formulas.     (line  53)
* exiting lbtt:                          Invocation.          (line  19)
* f (Boolean constant semantics in LTL): LTL formulas.        (line  45)
* F (LTL formula operator):              Random LTL formulas. (line  32)
* F (operator semantics in LTL):         LTL formulas.        (line  55)
* failure analysis, Bu"chi automata intersection check: Failure analysis commands.
                                                              (line  15)
* failure analysis, model checking result consistency check: Failure analysis commands.
                                                              (line  45)
* failure analysis, model checking result cross-comparison test: Failure analysis commands.
                                                              (line  65)
* false (Boolean constant semantics in LTL): LTL formulas.    (line  45)
* file formats, formula input file for lbtt: Special options. (line  16)
* file formats, LTL-to-Bu"chi translator input file: Format for LTL formulas.
                                                              (line   6)
* file formats, LTL-to-Bu"chi translator output file: Format for automata.
                                                              (line   6)
* finally (LTL formula operator):        Random LTL formulas. (line  32)
* finally (operator semantics in LTL):   LTL formulas.        (line  55)
* formula size:                          Random LTL formulas. (line  49)
* FormulaOptions section (configuration file): FormulaOptions section.
                                                              (line   6)
* G (LTL formula operator):              Random LTL formulas. (line  40)
* G (operator semantics in LTL):         LTL formulas.        (line  57)
* generalized Bu"chi automata, formal definition: Generalized automata.
                                                              (line   6)
* generalized Bu"chi automata, LTL-to-Bu"chi translator output file format: Format for automata.
                                                              (line   6)
* global model checking <1>:             Global options.      (line  37)
* global model checking <2>:             GlobalOptions section.
                                                              (line  54)
* global model checking <3>:             Model checking result consistency check.
                                                              (line  22)
* global model checking:                 Model checking result cross-comparison test.
                                                              (line  21)
* globally (LTL formula operator):       Random LTL formulas. (line  40)
* globally (operator semantics in LTL):  LTL formulas.        (line  57)
* GlobalOptions section (configuration file): GlobalOptions section.
                                                              (line   6)
* graph density <1>:                     StateSpaceOptions section.
                                                              (line  23)
* graph density:                         Random state spaces. (line  31)
* GraphViz:                              Data display commands.
                                                              (line  27)
* henceforth (LTL formula operator):     Random LTL formulas. (line  40)
* henceforth (operator semantics in LTL): LTL formulas.       (line  57)
* identifiers for LTL-to-Bu"chi translators: Translator section.
                                                              (line  17)
* Implementation section (configuration file): Translator section.
                                                              (line   6)
* implication (LTL formula operator):    Random LTL formulas. (line  17)
* implication (operator semantics in LTL): LTL formulas.      (line  49)
* interactivity modes <1>:               Global options.      (line  45)
* interactivity modes:                   GlobalOptions section.
                                                              (line  23)
* interfacing LTL-to-Bu"chi translators with lbtt <1>: The lbtt-translate utility.
                                                              (line   6)
* interfacing LTL-to-Bu"chi translators with lbtt: Interfacing with lbtt.
                                                              (line   6)
* internal model checking algorithm <1>: Test round messages. (line 134)
* internal model checking algorithm <2>: StateSpaceOptions section.
                                                              (line  38)
* internal model checking algorithm:     Model checking result cross-comparison test.
                                                              (line  37)
* invoking lbtt:                         Invocation.          (line   6)
* lbt:                                   The lbtt-translate utility.
                                                              (line  10)
* lbtt (executable file):                Invocation.          (line   6)
* lbtt-translate (executable file):      The lbtt-translate utility.
                                                              (line   6)
* local model checking <1>:              Global options.      (line  58)
* local model checking <2>:              GlobalOptions section.
                                                              (line  54)
* local model checking <3>:              Model checking result consistency check.
                                                              (line  22)
* local model checking:                  Model checking result cross-comparison test.
                                                              (line  21)
* log file for test failures:            Special options.     (line  46)
* LTL formula operators, abbreviated <1>: LTL formula options.
                                                              (line  13)
* LTL formula operators, abbreviated:    FormulaOptions section.
                                                              (line  12)
* LTL formula operators, supported:      Random LTL formulas. (line  11)
* LTL formula, displaying with user command: Data display commands.
                                                              (line  62)
* LTL formula, generation algorithm:     The formula generation algorithm.
                                                              (line   6)
* LTL formula, identifiers in commands:  Command conventions. (line  33)
* LTL formula, LTL-to-Bu"chi translator input file format: Format for LTL formulas.
                                                              (line   6)
* LTL formula, output modes <1>:         LTL formula options. (line  55)
* LTL formula, output modes:             FormulaOptions section.
                                                              (line  84)
* LTL formula, parameters for generation algorithm <1>: LTL formula options.
                                                              (line  11)
* LTL formula, parameters for generation algorithm <2>: FormulaOptions section.
                                                              (line  11)
* LTL formula, parameters for generation algorithm: Random LTL formulas.
                                                              (line  46)
* LTL formula, random:                   Random LTL formulas. (line   6)
* LTL formula, reading from a file or standard input: Special options.
                                                              (line  16)
* LTL formula, size:                     Random LTL formulas. (line  49)
* LTL-to-Bu"chi translators, automaton output file format: Format for automata.
                                                              (line   6)
* LTL-to-Bu"chi translators, disabling <1>: Test control commands.
                                                              (line  20)
* LTL-to-Bu"chi translators, disabling <2>: Global options.   (line  23)
* LTL-to-Bu"chi translators, disabling:  Translator section.  (line  28)
* LTL-to-Bu"chi translators, enabling <1>: Test control commands.
                                                              (line  27)
* LTL-to-Bu"chi translators, enabling <2>: Global options.    (line  32)
* LTL-to-Bu"chi translators, enabling:   Translator section.  (line  28)
* LTL-to-Bu"chi translators, identifiers: Translator section. (line  17)
* LTL-to-Bu"chi translators, interface requirements: Translator interface.
                                                              (line   6)
* LTL-to-Bu"chi translators, interfacing with <1>: The lbtt-translate utility.
                                                              (line   6)
* LTL-to-Bu"chi translators, interfacing with: Interfacing with lbtt.
                                                              (line   6)
* LTL-to-Bu"chi translators, LTL formula input file format: Format for LTL formulas.
                                                              (line   6)
* M (LTL formula operator):              Random LTL formulas. (line  38)
* M (operator semantics in LTL):         LTL formulas.        (line  63)
* minimal requirements for configuration files: Configuration file.
                                                              (line  38)
* model checking:                        Overview.            (line   6)
* model checking modes <1>:              Global options.      (line  37)
* model checking modes <2>:              GlobalOptions section.
                                                              (line  54)
* model checking modes <3>:              Model checking result consistency check.
                                                              (line  22)
* model checking modes:                  Model checking result cross-comparison test.
                                                              (line  21)
* model checking result consistency check: Model checking result consistency check.
                                                              (line   6)
* model checking result consistency check, failure analysis: Failure analysis commands.
                                                              (line  45)
* model checking result cross-comparison test: Model checking result cross-comparison test.
                                                              (line   6)
* model checking result cross-comparison test, failure analysis: Failure analysis commands.
                                                              (line  65)
* negation (LTL formula operator):       Random LTL formulas. (line  15)
* negation (operator semantics in LTL):  LTL formulas.        (line  27)
* negation normal form <1>:              LTL formula options. (line  46)
* negation normal form:                  FormulaOptions section.
                                                              (line  56)
* next time (LTL formula operator):      Random LTL formulas. (line  26)
* next time (operator semantics in LTL): LTL formulas.        (line  33)
* numeric values in configuration file:  Configuration file.  (line  27)
* operators, abbreviated <1>:            LTL formula options. (line  13)
* operators, abbreviated:                FormulaOptions section.
                                                              (line  12)
* operators, computing distribution for <1>: Test statistics. (line  17)
* operators, computing distribution for: Special options.     (line  69)
* operators, computing probabilities for: The formula generation algorithm.
                                                              (line  60)
* operators, precedence in input files:  Special options.     (line  28)
* operators, precedence in output messages: Test round messages.
                                                              (line  77)
* operators, priorities for <1>:         LTL formula options. (line  11)
* operators, priorities for <2>:         FormulaOptions section.
                                                              (line  11)
* operators, priorities for <3>:         The formula generation algorithm.
                                                              (line  60)
* operators, priorities for:             Random LTL formulas. (line  60)
* parameters for random LTL formula generation algorithm <1>: LTL formula options.
                                                              (line  11)
* parameters for random LTL formula generation algorithm <2>: FormulaOptions section.
                                                              (line  11)
* parameters for random LTL formula generation algorithm: Random LTL formulas.
                                                              (line  46)
* parameters for random state space generation algorithm <1>: State space options.
                                                              (line  12)
* parameters for random state space generation algorithm <2>: StateSpaceOptions section.
                                                              (line  15)
* parameters for random state space generation algorithm: Random state spaces.
                                                              (line  19)
* priorities for formula constants, atomic propositions and operators <1>: LTL formula options.
                                                              (line  11)
* priorities for formula constants, atomic propositions and operators <2>: FormulaOptions section.
                                                              (line  11)
* priorities for formula constants, atomic propositions and operators <3>: The formula generation algorithm.
                                                              (line  42)
* priorities for formula constants, atomic propositions and operators: Random LTL formulas.
                                                              (line  60)
* probabilities for formula constants and atomic propositions: The formula generation algorithm.
                                                              (line  42)
* probabilities for formula operators:   The formula generation algorithm.
                                                              (line  60)
* proof for an LTL formula:              Failure analysis commands.
                                                              (line 139)
* quitting lbtt <1>:                     Test control commands.
                                                              (line  30)
* quitting lbtt:                         Invocation.          (line  19)
* random connected graph <1>:            State space options. (line  24)
* random connected graph <2>:            StateSpaceOptions section.
                                                              (line  33)
* random connected graph:                Random state spaces. (line  31)
* random connected graph, generation algorithm: Algorithm for generating connected graphs.
                                                              (line   6)
* random graph <1>:                      State space options. (line  28)
* random graph <2>:                      StateSpaceOptions section.
                                                              (line  33)
* random graph:                          Random state spaces. (line  41)
* random LTL formula:                    Random LTL formulas. (line   6)
* random LTL formula, computing operator distribution: Special options.
                                                              (line  69)
* random LTL formula, generation algorithm: The formula generation algorithm.
                                                              (line   6)
* random LTL formula, generation modes <1>: LTL formula options.
                                                              (line  46)
* random LTL formula, generation modes:  FormulaOptions section.
                                                              (line  56)
* random LTL formula, output modes <1>:  LTL formula options. (line  55)
* random LTL formula, output modes:      FormulaOptions section.
                                                              (line  84)
* random LTL formula, parameters for generation algorithm <1>: LTL formula options.
                                                              (line  11)
* random LTL formula, parameters for generation algorithm <2>: FormulaOptions section.
                                                              (line  11)
* random LTL formula, parameters for generation algorithm: Random LTL formulas.
                                                              (line  46)
* random LTL formula, random seed for generation algorithm: FormulaOptions section.
                                                              (line 134)
* random LTL formula, size:              Random LTL formulas. (line  49)
* random path <1>:                       State space options. (line  32)
* random path <2>:                       StateSpaceOptions section.
                                                              (line  33)
* random path:                           Random state spaces. (line  46)
* random seed, LTL formula generation algorithm <1>: LTL formula options.
                                                              (line  66)
* random seed, LTL formula generation algorithm: FormulaOptions section.
                                                              (line 134)
* random seed, state space generation algorithm: StateSpaceOptions section.
                                                              (line  57)
* random state space:                    Random state spaces. (line   6)
* random state space, algorithm for generating random connected graphs: Algorithm for generating connected graphs.
                                                              (line   6)
* random state space, density <1>:       StateSpaceOptions section.
                                                              (line  23)
* random state space, density:           Random state spaces. (line  31)
* random state space, generation parameters <1>: State space options.
                                                              (line  12)
* random state space, generation parameters <2>: StateSpaceOptions section.
                                                              (line  15)
* random state space, generation parameters: Random state spaces.
                                                              (line  19)
* random state space, random seed for generation algorithm <1>: State space options.
                                                              (line  46)
* random state space, random seed for generation algorithm: StateSpaceOptions section.
                                                              (line  57)
* redirecting command output:            Command conventions. (line  39)
* refutation for an LTL formula:         Failure analysis commands.
                                                              (line 139)
* release (LTL formula operator):        Random LTL formulas. (line  36)
* release (operator semantics in LTL):   LTL formulas.        (line  59)
* skipping test rounds <1>:              Test control commands.
                                                              (line  34)
* skipping test rounds:                  Special options.     (line  77)
* SPIN:                                  The lbtt-translate utility.
                                                              (line  15)
* Spot:                                  The lbtt-translate utility.
                                                              (line  20)
* starting lbtt:                         Invocation.          (line   6)
* state space <1>:                       Random state spaces. (line   6)
* state space:                           Random input generation.
                                                              (line  12)
* state space, algorithm for generating random connected graphs: Algorithm for generating connected graphs.
                                                              (line   6)
* state space, density <1>:              StateSpaceOptions section.
                                                              (line  23)
* state space, density:                  Random state spaces. (line  31)
* state space, displaying with an user command: Data display commands.
                                                              (line  84)
* state space, formal definition:        State spaces.        (line   6)
* state space, generation modes <1>:     State space options. (line  18)
* state space, generation modes <2>:     StateSpaceOptions section.
                                                              (line  33)
* state space, generation modes:         Random state spaces. (line  29)
* state space, generation parameters <1>: State space options.
                                                              (line  12)
* state space, generation parameters <2>: StateSpaceOptions section.
                                                              (line  15)
* state space, generation parameters:    Random state spaces. (line  19)
* state space, random:                   Random state spaces. (line   6)
* StateSpaceOptions section (configuration file): StateSpaceOptions section.
                                                              (line   6)
* string values in configuration file:   Configuration file.  (line  27)
* strong release (LTL formula operator): Random LTL formulas. (line  38)
* strong release (operator semantics in LTL): LTL formulas.   (line  63)
* strong until (LTL formula operator):   Random LTL formulas. (line  28)
* strong until (operator semantics in LTL): LTL formulas.     (line  36)
* supported LTL formula operators:       Random LTL formulas. (line  11)
* suppressing output:                    Special options.     (line  57)
* t (Boolean constant semantics in LTL): LTL formulas.        (line  11)
* testing procedure:                     Testing procedure.   (line   6)
* tests, aborting:                       Invocation.          (line  19)
* tests, against internal model checking algorithm <1>: Test round messages.
                                                              (line 134)
* tests, against internal model checking algorithm <2>: StateSpaceOptions section.
                                                              (line  38)
* tests, against internal model checking algorithm: Model checking result cross-comparison test.
                                                              (line  37)
* tests, Bu"chi automata intersection emptiness check: Automata intersection emptiness check.
                                                              (line   6)
* tests, controlling with user commands: Test control commands.
                                                              (line   6)
* tests, enabling and disabling <1>:     Global options.      (line  12)
* tests, enabling and disabling <2>:     Special options.     (line  50)
* tests, enabling and disabling:         GlobalOptions section.
                                                              (line  12)
* tests, failure analysis:               Failure analysis commands.
                                                              (line  15)
* tests, failure report format:          Test round messages. (line 122)
* tests, model checking result consistency check: Model checking result consistency check.
                                                              (line   6)
* tests, model checking result cross-comparison test: Model checking result cross-comparison test.
                                                              (line   6)
* tests, output example:                 Test round messages. (line  31)
* tests, profiling LTL-to-Bu"chi translators: Special options.
                                                              (line  50)
* tests, skipping test rounds <1>:       Test control commands.
                                                              (line  34)
* tests, skipping test rounds:           Special options.     (line  77)
* tests, starting:                       Invocation.          (line   6)
* tests, statistics:                     Test statistics.     (line   6)
* timeouts for translators:              GlobalOptions section.
                                                              (line  70)
* Translator section (configuration file): Translator section.
                                                              (line   6)
* true (Boolean constant semantics in LTL): LTL formulas.     (line  11)
* truth values in configuration file:    Configuration file.  (line  27)
* U (LTL formula operator):              Random LTL formulas. (line  28)
* U (operator semantics in LTL):         LTL formulas.        (line  36)
* unless (LTL formula operator):         Random LTL formulas. (line  30)
* unless (operator semantics in LTL):    LTL formulas.        (line  61)
* until (LTL formula operator):          Random LTL formulas. (line  28)
* until (operator semantics in LTL):     LTL formulas.        (line  36)
* using a test failure log file:         Special options.     (line  46)
* using the internal model checking algorithm <1>: StateSpaceOptions section.
                                                              (line  38)
* using the internal model checking algorithm: Model checking result cross-comparison test.
                                                              (line  37)
* V (LTL formula operator):              Random LTL formulas. (line  36)
* V (operator semantics in LTL):         LTL formulas.        (line  59)
* verbosity, changing <1>:               Test control commands.
                                                              (line  41)
* verbosity, changing <2>:               Global options.      (line  79)
* verbosity, changing:                   GlobalOptions section.
                                                              (line  80)
* W (LTL formula operator):              Random LTL formulas. (line  30)
* W (operator semantics in LTL):         LTL formulas.        (line  61)
* weak release (LTL formula operator):   Random LTL formulas. (line  36)
* weak release (operator semantics in LTL): LTL formulas.     (line  59)
* weak until (LTL formula operator):     Random LTL formulas. (line  30)
* weak until (operator semantics in LTL): LTL formulas.       (line  61)
* witness:                               Failure analysis commands.
                                                              (line  28)
* X (LTL formula operator):              Random LTL formulas. (line  26)
* X (operator semantics in LTL):         LTL formulas.        (line  33)
* xor (LTL formula operator):            Random LTL formulas. (line  21)
* xor (operator semantics in LTL):       LTL formulas.        (line  53)



Tag Table:
Node: Top896
Node: Copying2341
Node: Overview21508
Node: Test methods24415
Node: Random input generation26125
Node: Random LTL formulas27461
Node: The formula generation algorithm30169
Node: Random state spaces33693
Node: Algorithm for generating connected graphs37003
Node: Testing procedure39421
Node: Model checking result cross-comparison test48049
Node: Model checking result consistency check50743
Node: Automata intersection emptiness check52328
Node: Invocation53273
Node: Configuration file54617
Node: Translator section56969
Ref: Translator section-Footnote-159703
Node: GlobalOptions section59812
Ref: Interactivity modes60684
Ref: Timeouts62757
Node: FormulaOptions section63730
Node: StateSpaceOptions section71898
Node: Sample configuration file75974
Node: Command line options80085
Node: Special options81234
Ref: --formulafile81778
Ref: --logfile83357
Ref: --showconfig84023
Ref: --showoperatordistribution84382
Ref: --skip84774
Node: Global options85016
Node: LTL formula options88267
Node: State space options93124
Node: Interpreting the output95601
Node: Configuration information96499
Node: Test round messages99294
Node: Test statistics106203
Node: Analyzing test results109337
Node: Command conventions110592
Node: Getting help113237
Node: Test control commands113998
Node: Data display commands116091
Ref: statistics120982
Node: Failure analysis commands121278
Node: Interfacing with lbtt130694
Node: Translator interface132396
Node: Format for LTL formulas134158
Node: Format for automata137225
Ref: Format for automata-Footnote-1147454
Node: The lbtt-translate utility147748
Node: References150497
Ref: [CGP99]150618
Ref: [Cou99]150715
Ref: [DGV99]151018
Ref: [DP04]151334
Ref: [EH00]151704
Ref: [Ete99]151967
Ref: [Ete02]152261
Ref: [EWS01]152549
Ref: [Fri03]152905
Ref: [GO01]153262
Ref: [GO03]153538
Ref: [Gei01]153850
Ref: [GPVW95]154018
Ref: [GL02]154325
Ref: [GSB02]154706
Ref: [GViz]154990
Ref: [Hol97]155109
Ref: [Isl94]155234
Ref: [Lat03]155494
Ref: [Sch01]155753
Ref: [ST03]156117
Ref: [SB00]156490
Ref: [Tau00]156773
Ref: [TH02]157111
Ref: [Thi02]157310
Ref: [Var96]157481
Ref: [VW86]157724
Ref: [Wol01]157979
Node: Definitions158313
Node: LTL formulas159129
Node: Generalized automata161294
Ref: Generalized automata-Footnote-1165642
Node: State spaces166023
Node: Configuration file option index167048
Node: Command line option index173498
Node: User command index178740
Node: Concept index181601

End Tag Table
