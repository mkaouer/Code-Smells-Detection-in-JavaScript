<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>spot: spot Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<h1>spot Namespace Reference</h1>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1bdd__allocator.html">bdd_allocator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Manage ranges of variables. </em> <a href="classspot_1_1bdd__allocator.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Map BDD variables to formulae. </em> <a href="classspot_1_1bdd__dict.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structspot_1_1bdd__less__than.html">bdd_less_than</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison functor for BDDs. </em> <a href="structspot_1_1bdd__less__than.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1emptiness__check.html">emptiness_check</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether the language of an automate is empty. </em> <a href="classspot_1_1emptiness__check.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structspot_1_1emptiness__check_1_1connected__component.html">emptiness_check::connected_component</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structspot_1_1emptiness__check_1_1connected__component__set.html">emptiness_check::connected_component_set</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structspot_1_1magic__search.html">magic_search</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Emptiness check on <a class="el" href="classspot_1_1tgba__tba__proxy.html">spot::tgba_tba_proxy</a> automata using the Magic Search algorithm. </em> <a href="structspot_1_1magic__search.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structspot_1_1magic__search_1_1magic.html">magic_search::magic</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Records whether a state has be seen with the magic bit on or off. </em> <a href="structspot_1_1magic__search_1_1magic.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structspot_1_1magic__search_1_1magic__state.html">magic_search::magic_state</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A state for the <a class="el" href="structspot_1_1magic__search.html">spot::magic_search</a> algorithm. </em> <a href="structspot_1_1magic__search_1_1magic__state.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1minato__isop.html">minato_isop</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate an irredundant sum-of-products (ISOP) form of a BDD function. </em> <a href="classspot_1_1minato__isop.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structspot_1_1minato__isop_1_1local__vars.html">minato_isop::local_vars</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal variables for <a class="el" href="classspot_1_1minato__isop.html">minato_isop</a>. </em> <a href="structspot_1_1minato__isop_1_1local__vars.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structspot_1_1ptr__hash.html">ptr_hash</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A hash function for pointers. </em> <a href="structspot_1_1ptr__hash.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1state.html">state</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract class for states. </em> <a href="classspot_1_1state.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1state__bdd.html">state_bdd</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A state whose representation is a BDD. </em> <a href="classspot_1_1state__bdd.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1state__explicit.html">state_explicit</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">States used by <a class="el" href="classspot_1_1tgba__explicit.html">spot::tgba_explicit</a>. </em> <a href="classspot_1_1state__explicit.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1state__product.html">state_product</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A state for <a class="el" href="classspot_1_1tgba__product.html">spot::tgba_product</a>. </em> <a href="classspot_1_1state__product.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structspot_1_1state__ptr__equal.html">state_ptr_equal</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An Equivalence Relation for <code>state*</code>. </em> <a href="structspot_1_1state__ptr__equal.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structspot_1_1state__ptr__hash.html">state_ptr_hash</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hash Function for <code>state*</code>. </em> <a href="structspot_1_1state__ptr__hash.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structspot_1_1state__ptr__less__than.html">state_ptr_less_than</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Strict Weak Ordering for <code>state*</code>. </em> <a href="structspot_1_1state__ptr__less__than.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structspot_1_1string__hash.html">string_hash</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A hash function for strings. </em> <a href="structspot_1_1string__hash.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1tgba.html">tgba</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A Transition-based Generalized Büchi Automaton. </em> <a href="classspot_1_1tgba.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1tgba__bdd__concrete.html">tgba_bdd_concrete</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A concrete <a class="el" href="classspot_1_1tgba.html">spot::tgba</a> implemented using BDDs. </em> <a href="classspot_1_1tgba__bdd__concrete.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1tgba__bdd__concrete__factory.html">tgba_bdd_concrete_factory</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper class to build a <a class="el" href="classspot_1_1tgba__bdd__concrete.html">spot::tgba_bdd_concrete</a> object. </em> <a href="classspot_1_1tgba__bdd__concrete__factory.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structspot_1_1tgba__bdd__core__data.html">tgba_bdd_core_data</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Core data for a TGBA encoded using BDDs. </em> <a href="structspot_1_1tgba__bdd__core__data.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1tgba__bdd__factory.html">tgba_bdd_factory</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract class for <a class="el" href="classspot_1_1tgba__bdd__concrete.html">spot::tgba_bdd_concrete</a> factories. </em> <a href="classspot_1_1tgba__bdd__factory.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1tgba__explicit.html">tgba_explicit</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Explicit representation of a <a class="el" href="classspot_1_1tgba.html">spot::tgba</a>. </em> <a href="classspot_1_1tgba__explicit.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structspot_1_1tgba__explicit_1_1transition.html">tgba_explicit::transition</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Explicit transitions (used by <a class="el" href="classspot_1_1tgba__explicit.html">spot::tgba_explicit</a>). </em> <a href="structspot_1_1tgba__explicit_1_1transition.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1tgba__explicit__succ__iterator.html">tgba_explicit_succ_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Successor iterators used by <a class="el" href="classspot_1_1tgba__explicit.html">spot::tgba_explicit</a>. </em> <a href="classspot_1_1tgba__explicit__succ__iterator.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1tgba__product.html">tgba_product</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A lazy product. (States are computed on the fly.). </em> <a href="classspot_1_1tgba__product.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1tgba__reachable__iterator.html">tgba_reachable_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate over all reachable states of a <a class="el" href="classspot_1_1tgba.html">spot::tgba</a>. </em> <a href="classspot_1_1tgba__reachable__iterator.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1tgba__reachable__iterator__breadth__first.html">tgba_reachable_iterator_breadth_first</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An implementation of <a class="el" href="classspot_1_1tgba__reachable__iterator.html">spot::tgba_reachable_iterator</a> that browses states breadth first. </em> <a href="classspot_1_1tgba__reachable__iterator__breadth__first.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1tgba__reachable__iterator__depth__first.html">tgba_reachable_iterator_depth_first</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An implementation of <a class="el" href="classspot_1_1tgba__reachable__iterator.html">spot::tgba_reachable_iterator</a> that browses states depth first. </em> <a href="classspot_1_1tgba__reachable__iterator__depth__first.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1tgba__succ__iterator.html">tgba_succ_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate over the successors of a state. </em> <a href="classspot_1_1tgba__succ__iterator.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1tgba__succ__iterator__concrete.html">tgba_succ_iterator_concrete</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A concrete iterator over successors of a TGBA state. </em> <a href="classspot_1_1tgba__succ__iterator__concrete.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1tgba__succ__iterator__product.html">tgba_succ_iterator_product</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate over the successors of a product computed on the fly. </em> <a href="classspot_1_1tgba__succ__iterator__product.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1tgba__tba__proxy.html">tgba_tba_proxy</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Degeneralize a <a class="el" href="classspot_1_1tgba.html">spot::tgba</a> on the fly. </em> <a href="classspot_1_1tgba__tba__proxy.html#_details">More...</a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef std::pair&lt; <a class="el" href="classyy_1_1Location.html">yy::Location</a>,<br>
 std::string &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot.html#a0">tgba_parse_error</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A parse diagnostic with its location. </em> <a href="#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef std::list&lt; <a class="el" href="namespacespot.html#a0">tgba_parse_error</a> &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot.html#a1">tgba_parse_error_list</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A list of parser diagnostics, as filled by parse. </em> <a href="#a1"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>const  char *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot.html#a2">version</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return Spot's version. </em> <a href="#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>std::ostream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot.html#a3">bdd_print_sat</a> (std::ostream &amp;os, const  <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print a BDD as a list of literals. </em> <a href="#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>std::string&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot.html#a4">bdd_format_sat</a> (const  <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Format a BDD as a list of literals. </em> <a href="#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>std::ostream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot.html#a5">bdd_print_acc</a> (std::ostream &amp;os, const  <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print a BDD as a list of acceptance conditions. </em> <a href="#a5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>std::ostream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot.html#a6">bdd_print_accset</a> (std::ostream &amp;os, const  <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print a BDD as a set of acceptance conditions. </em> <a href="#a6"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>std::ostream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot.html#a7">bdd_print_set</a> (std::ostream &amp;os, const  <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print a BDD as a set. </em> <a href="#a7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>std::string&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot.html#a8">bdd_format_set</a> (const  <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Format a BDD as a set. </em> <a href="#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>std::ostream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot.html#a9">bdd_print_formula</a> (std::ostream &amp;os, const  <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print a BDD as a formula. </em> <a href="#a9"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>std::string&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot.html#a10">bdd_format_formula</a> (const  <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Format a BDD as a formula. </em> <a href="#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>std::ostream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot.html#a11">bdd_print_dot</a> (std::ostream &amp;os, const  <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print a BDD as a diagram in dotty format. </em> <a href="#a11"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>std::ostream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot.html#a12">bdd_print_table</a> (std::ostream &amp;os, const  <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, bdd b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print a BDD as a table. </em> <a href="#a12"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>bdd&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot.html#a13">formula_to_bdd</a> (const  <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f, <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *d, void *for_me)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>const  <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot.html#a14">bdd_to_formula</a> (bdd f, const  <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *d)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classspot_1_1tgba__bdd__concrete.html">tgba_bdd_concrete</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot.html#a15">product</a> (const  <a class="el" href="classspot_1_1tgba__bdd__concrete.html">tgba_bdd_concrete</a> *left, const  <a class="el" href="classspot_1_1tgba__bdd__concrete.html">tgba_bdd_concrete</a> *right)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplies two tgba::tgba_bdd_concrete automata. </em> <a href="#a15"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>std::ostream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot.html#a16">dotty_reachable</a> (std::ostream &amp;os, const  <a class="el" href="classspot_1_1tgba.html">tgba</a> *g)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print reachable states in dot format. </em> <a href="#a16"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classspot_1_1tgba__explicit.html">tgba_explicit</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot.html#a17">tgba_dupexp_bfs</a> (const  <a class="el" href="classspot_1_1tgba.html">tgba</a> *aut)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classspot_1_1tgba__explicit.html">tgba_explicit</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot.html#a18">tgba_dupexp_dfs</a> (const  <a class="el" href="classspot_1_1tgba.html">tgba</a> *aut)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>std::ostream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot.html#a19">lbtt_reachable</a> (std::ostream &amp;os, const  <a class="el" href="classspot_1_1tgba.html">tgba</a> *g)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print reachable states in LBTT format. </em> <a href="#a19"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classspot_1_1tgba__explicit.html">tgba_explicit</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot.html#a20">ltl_to_tgba_fm</a> (const  <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f, <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build a <a class="el" href="classspot_1_1tgba__explicit.html">spot::tgba_explicit</a>* from an LTL formula. </em> <a href="#a20"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classspot_1_1tgba__bdd__concrete.html">tgba_bdd_concrete</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot.html#a21">ltl_to_tgba_lacim</a> (const  <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a> *f, <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>std::ostream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot.html#a22">tgba_save_reachable</a> (std::ostream &amp;os, const  <a class="el" href="classspot_1_1tgba.html">tgba</a> *g)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save reachable states in text format. </em> <a href="#a22"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classspot_1_1tgba__explicit.html">tgba_explicit</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot.html#a23">tgba_parse</a> (const  std::string &amp;filename, <a class="el" href="namespacespot.html#a1">tgba_parse_error_list</a> &amp;error_list, <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *dict, <a class="el" href="classspot_1_1ltl_1_1environment.html">ltl::environment</a> &amp;env=ltl::default_environment::instance(), bool debug=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build a <a class="el" href="classspot_1_1tgba__explicit.html">spot::tgba_explicit</a> from a text file. </em> <a href="#a23"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot.html#a24">format_tgba_parse_errors</a> (std::ostream &amp;os, <a class="el" href="namespacespot.html#a1">tgba_parse_error_list</a> &amp;error_list)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Format diagnostics produced by <a class="el" href="namespacespot.html#a23">spot::tgba_parse</a>. </em> <a href="#a24"></a><em><br><br></td></tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="a0" doxytag="spot::tgba_parse_error" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef std::pair&lt;<a class="el" href="classyy_1_1Location.html">yy::Location</a>, std::string&gt; <a class="el" href="namespacespot.html#a0">spot::tgba_parse_error</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A parse diagnostic with its location. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="spot::tgba_parse_error_list" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef std::list&lt;<a class="el" href="namespacespot.html#a0">tgba_parse_error</a>&gt; <a class="el" href="namespacespot.html#a1">spot::tgba_parse_error_list</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A list of parser diagnostics, as filled by parse. 
<p>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a10" doxytag="spot::bdd_format_formula" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> std::string bdd_format_formula </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const bdd_dict *&nbsp;</td>
          <td class="mdname" nowrap> <em>dict</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bdd&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Format a BDD as a formula. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dict</em>&nbsp;</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td valign=top><em>b</em>&nbsp;</td><td>The BDD to print. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The BDD formated as a string. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="spot::bdd_format_sat" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> std::string bdd_format_sat </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const bdd_dict *&nbsp;</td>
          <td class="mdname" nowrap> <em>dict</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bdd&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Format a BDD as a list of literals. 
<p>
This assumes that <em>b</em> is a conjunction of literals. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dict</em>&nbsp;</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td valign=top><em>b</em>&nbsp;</td><td>The BDD to print. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The BDD formated as a string. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="spot::bdd_format_set" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> std::string bdd_format_set </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const bdd_dict *&nbsp;</td>
          <td class="mdname" nowrap> <em>dict</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bdd&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Format a BDD as a set. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dict</em>&nbsp;</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td valign=top><em>b</em>&nbsp;</td><td>The BDD to print. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The BDD formated as a string. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="spot::bdd_print_acc" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> std::ostream&amp; bdd_print_acc </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::ostream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>os</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bdd_dict *&nbsp;</td>
          <td class="mdname" nowrap> <em>dict</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bdd&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Print a BDD as a list of acceptance conditions. 
<p>
This is used when saving a TGBA. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>os</em>&nbsp;</td><td>The output stream. </td></tr>
    <tr><td valign=top><em>dict</em>&nbsp;</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td valign=top><em>b</em>&nbsp;</td><td>The BDD to print. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The BDD formated as a string. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="spot::bdd_print_accset" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> std::ostream&amp; bdd_print_accset </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::ostream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>os</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bdd_dict *&nbsp;</td>
          <td class="mdname" nowrap> <em>dict</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bdd&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Print a BDD as a set of acceptance conditions. 
<p>
This is used when saving a TGBA. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>os</em>&nbsp;</td><td>The output stream. </td></tr>
    <tr><td valign=top><em>dict</em>&nbsp;</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td valign=top><em>b</em>&nbsp;</td><td>The BDD to print. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The BDD formated as a string. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="spot::bdd_print_dot" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> std::ostream&amp; bdd_print_dot </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::ostream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>os</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bdd_dict *&nbsp;</td>
          <td class="mdname" nowrap> <em>dict</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bdd&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Print a BDD as a diagram in dotty format. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>os</em>&nbsp;</td><td>The output stream. </td></tr>
    <tr><td valign=top><em>dict</em>&nbsp;</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td valign=top><em>b</em>&nbsp;</td><td>The BDD to print. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="spot::bdd_print_formula" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> std::ostream&amp; bdd_print_formula </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::ostream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>os</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bdd_dict *&nbsp;</td>
          <td class="mdname" nowrap> <em>dict</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bdd&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Print a BDD as a formula. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>os</em>&nbsp;</td><td>The output stream. </td></tr>
    <tr><td valign=top><em>dict</em>&nbsp;</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td valign=top><em>b</em>&nbsp;</td><td>The BDD to print. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="spot::bdd_print_sat" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> std::ostream&amp; bdd_print_sat </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::ostream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>os</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bdd_dict *&nbsp;</td>
          <td class="mdname" nowrap> <em>dict</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bdd&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Print a BDD as a list of literals. 
<p>
This assumes that <em>b</em> is a conjunction of literals. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>os</em>&nbsp;</td><td>The output stream. </td></tr>
    <tr><td valign=top><em>dict</em>&nbsp;</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td valign=top><em>b</em>&nbsp;</td><td>The BDD to print. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="spot::bdd_print_set" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> std::ostream&amp; bdd_print_set </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::ostream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>os</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bdd_dict *&nbsp;</td>
          <td class="mdname" nowrap> <em>dict</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bdd&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Print a BDD as a set. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>os</em>&nbsp;</td><td>The output stream. </td></tr>
    <tr><td valign=top><em>dict</em>&nbsp;</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td valign=top><em>b</em>&nbsp;</td><td>The BDD to print. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="spot::bdd_print_table" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> std::ostream&amp; bdd_print_table </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::ostream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>os</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bdd_dict *&nbsp;</td>
          <td class="mdname" nowrap> <em>dict</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bdd&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Print a BDD as a table. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>os</em>&nbsp;</td><td>The output stream. </td></tr>
    <tr><td valign=top><em>dict</em>&nbsp;</td><td>The dictionary to use, to lookup variables. </td></tr>
    <tr><td valign=top><em>b</em>&nbsp;</td><td>The BDD to print. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="spot::bdd_to_formula" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const <a class="el" href="classspot_1_1ltl_1_1formula.html">ltl::formula</a>* bdd_to_formula </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bdd&nbsp;</td>
          <td class="mdname" nowrap> <em>f</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bdd_dict *&nbsp;</td>
          <td class="mdname" nowrap> <em>d</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="spot::dotty_reachable" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> std::ostream&amp; dotty_reachable </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::ostream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>os</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const tgba *&nbsp;</td>
          <td class="mdname" nowrap> <em>g</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Print reachable states in dot format. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a24" doxytag="spot::format_tgba_parse_errors" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool format_tgba_parse_errors </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::ostream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>os</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>tgba_parse_error_list &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>error_list</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Format diagnostics produced by <a class="el" href="namespacespot.html#a23">spot::tgba_parse</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>os</em>&nbsp;</td><td>Where diagnostics should be output. </td></tr>
    <tr><td valign=top><em>error_list</em>&nbsp;</td><td>The error list filled by <a class="el" href="namespacespot_1_1ltl.html#a2">spot::ltl::parse</a> while parsing <em>ltl_string</em>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><code>true</code> iff any diagnostic was output. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="spot::formula_to_bdd" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bdd formula_to_bdd </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const ltl::formula *&nbsp;</td>
          <td class="mdname" nowrap> <em>f</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bdd_dict *&nbsp;</td>
          <td class="mdname" nowrap> <em>d</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>for_me</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="spot::lbtt_reachable" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> std::ostream&amp; lbtt_reachable </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::ostream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>os</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const tgba *&nbsp;</td>
          <td class="mdname" nowrap> <em>g</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Print reachable states in LBTT format. 
<p>
Note that LBTT expects an automaton with transition labeled by propositional formulae, and generalized Büchi acceptance conditions on <b>states</b>. This is unlike our <a class="el" href="classspot_1_1tgba.html">spot::tgba</a> automata which put both generalized acceptance conditions and propositional formulae) on <b>transitions</b>.<p>
This algorithm will therefore produce an automata where acceptance conditions have been moved from each transition to previous state. In the worst case, doing so will multiply the number of states and transitions of the automata by <code>2^|Acc|</code>. where <code>|Acc|</code> is the number of acceptance conditions used by the automata. (It can be a bit more because LBTT allows only for one initial state: <a class="el" href="namespacespot.html#a19">lbtt_reachable()</a> may also have to create an additional state in case the source initial state had to be split.) You have been warned.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>g</em>&nbsp;</td><td>The automata to print. </td></tr>
    <tr><td valign=top><em>os</em>&nbsp;</td><td>Where to print. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="spot::ltl_to_tgba_fm" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classspot_1_1tgba__explicit.html">tgba_explicit</a>* ltl_to_tgba_fm </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const ltl::formula *&nbsp;</td>
          <td class="mdname" nowrap> <em>f</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bdd_dict *&nbsp;</td>
          <td class="mdname" nowrap> <em>dict</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Build a <a class="el" href="classspot_1_1tgba__explicit.html">spot::tgba_explicit</a>* from an LTL formula. 
<p>
This is based on the following paper. <div class="fragment"><pre>
      @InProceedings{couvreur.99.fm,
        author	  = {Jean-Michel Couvreur},
        title     = {On-the-fly Verification of Temporal Logic},
        pages     = {253--271},
        editor	  = {Jeannette M. Wing and Jim Woodcock and Jim Davies},
        booktitle = {Proceedings of the World Congress on Formal Methods in the
      		     Development of Computing Systems (FM'99)},
        publisher = {Springer-Verlag},
        series	  = {Lecture Notes in Computer Science},
        volume	  = {1708},
        year      = {1999},
        address	  = {Toulouse, France},
        month	  = {September},
        isbn      = {3-540-66587-0}
      }
      </pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="spot::ltl_to_tgba_lacim" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classspot_1_1tgba__bdd__concrete.html">tgba_bdd_concrete</a>* ltl_to_tgba_lacim </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const ltl::formula *&nbsp;</td>
          <td class="mdname" nowrap> <em>f</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bdd_dict *&nbsp;</td>
          <td class="mdname" nowrap> <em>dict</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Build a <a class="el" href="classspot_1_1tgba__bdd__concrete.html">spot::tgba_bdd_concrete</a> from an LTL formula.<p>
This is based on the following paper. <div class="fragment"><pre>
      @InProceedings{   couvreur.00.lacim,
        author        = {Jean-Michel Couvreur},
        title         = {Un point de vue symbolique sur la logique temporelle
                        lin{\'e}aire},
        booktitle     = {Actes du Colloque LaCIM 2000},
        month         = {August},
        year          = {2000},
        pages         = {131--140},
        volume        = {27},
        series        = {Publications du LaCIM},
        publisher     = {Universit{\'e} du Qu{\'e}bec {\`a} Montr{\'e}al},
        editor        = {Pierre Leroux}
      }
      </pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="spot::product" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classspot_1_1tgba__bdd__concrete.html">tgba_bdd_concrete</a>* product </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const tgba_bdd_concrete *&nbsp;</td>
          <td class="mdname" nowrap> <em>left</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const tgba_bdd_concrete *&nbsp;</td>
          <td class="mdname" nowrap> <em>right</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Multiplies two tgba::tgba_bdd_concrete automata. 
<p>
This function build the resulting product, as another tgba::tgba_bdd_concrete automaton.     </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="spot::tgba_dupexp_bfs" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classspot_1_1tgba__explicit.html">tgba_explicit</a>* tgba_dupexp_bfs </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const tgba *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>aut</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Build an explicit automata from all states of <em>aut</em>, numbering states in bread first order as they are processed.     </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="spot::tgba_dupexp_dfs" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classspot_1_1tgba__explicit.html">tgba_explicit</a>* tgba_dupexp_dfs </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const tgba *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>aut</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Build an explicit automata from all states of <em>aut</em>, numbering states in depth first order as they are processed.     </td>
  </tr>
</table>
<a class="anchor" name="a23" doxytag="spot::tgba_parse" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classspot_1_1tgba__explicit.html">tgba_explicit</a>* tgba_parse </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const std::string &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>filename</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>tgba_parse_error_list &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>error_list</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bdd_dict *&nbsp;</td>
          <td class="mdname" nowrap> <em>dict</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>ltl::environment &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>env</em> = ltl::default_environment::instance(), </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>debug</em> = false</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Build a <a class="el" href="classspot_1_1tgba__explicit.html">spot::tgba_explicit</a> from a text file. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>filename</em>&nbsp;</td><td>The name of the file to parse. </td></tr>
    <tr><td valign=top><em>error_list</em>&nbsp;</td><td>A list that will be filled with parse errors that occured during parsing. </td></tr>
    <tr><td valign=top><em>dict</em>&nbsp;</td><td>The BDD dictionary where to use. </td></tr>
    <tr><td valign=top><em>env</em>&nbsp;</td><td>The environment into which parsing should take place. </td></tr>
    <tr><td valign=top><em>debug</em>&nbsp;</td><td>When true, causes the parser to trace its execution. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A pointer to the tgba built from <em>filename</em>, or 0 if the file could not be opened.</dd></dl>
Note that the parser usually tries to recover from errors. It can return an non zero value even if it encountered error during the parsing of <em>filename</em>. If you want to make sure <em>filename</em> was parsed succesfully, check <em>error_list</em> for emptiness.<p>
<dl compact><dt><b>Warning:</b></dt><dd>This function is not reentrant. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a22" doxytag="spot::tgba_save_reachable" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> std::ostream&amp; tgba_save_reachable </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::ostream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>os</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const tgba *&nbsp;</td>
          <td class="mdname" nowrap> <em>g</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Save reachable states in text format. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="spot::version" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const char* version </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return Spot's version. 
<p>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Mon Dec 1 11:36:08 2003 for spot by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
