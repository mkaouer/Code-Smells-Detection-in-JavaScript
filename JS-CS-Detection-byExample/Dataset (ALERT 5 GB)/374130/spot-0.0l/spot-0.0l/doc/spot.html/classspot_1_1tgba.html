<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>spot: spot::tgba class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<h1>spot::tgba Class Reference</h1>A Transition-based Generalized Büchi Automaton.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="tgba_8hh-source.html">tgba.hh</a>&gt;</code>
<p>
Inheritance diagram for spot::tgba:<p><center><img src="classspot_1_1tgba__inherit__graph.png" border="0" usemap="#spot_1_1tgba__inherit__map" alt="Inheritance graph"></center>
<map name="spot_1_1tgba__inherit__map">
<area href="classspot_1_1tgba__bdd__concrete.html" shape="rect" coords="7,87,167,105" alt="">
<area href="classspot_1_1tgba__explicit.html" shape="rect" coords="191,87,311,105" alt="">
<area href="classspot_1_1tgba__product.html" shape="rect" coords="335,87,457,105" alt="">
<area href="classspot_1_1tgba__tba__proxy.html" shape="rect" coords="481,87,620,105" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center>Collaboration diagram for spot::tgba:<p><center><img src="classspot_1_1tgba__coll__graph.png" border="0" usemap="#spot_1_1tgba__coll__map" alt="Collaboration graph"></center>
<map name="spot_1_1tgba__coll__map">
<area href="classspot_1_1state.html" shape="rect" coords="7,17,79,35" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center><a href="classspot_1_1tgba-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1tgba.html#spot_1_1tgbaa0">~tgba</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual <a class="el" href="classspot_1_1state.html">state</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1tgba.html#spot_1_1tgbaa1">get_init_state</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the initial state of the automaton. </em> <a href="#spot_1_1tgbaa1"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual <a class="el" href="classspot_1_1tgba__succ__iterator.html">tgba_succ_iterator</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1tgba.html#spot_1_1tgba__explicita17">succ_iter</a> (const  <a class="el" href="classspot_1_1state.html">state</a> *local_state, const  <a class="el" href="classspot_1_1state.html">state</a> *global_state=0, const  <a class="el" href="classspot_1_1tgba.html">tgba</a> *global_automaton=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the successors of <em>local_state</em>. </em> <a href="#spot_1_1tgba__explicita17"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>bdd&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1tgba.html#spot_1_1tgba__tba__proxya10">support_conditions</a> (const  <a class="el" href="classspot_1_1state.html">state</a> *<a class="el" href="classspot_1_1state.html">state</a>) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a formula that must hold whatever successor is taken. </em> <a href="#spot_1_1tgba__tba__proxya10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>bdd&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1tgba.html#spot_1_1tgba__tba__proxya11">support_variables</a> (const  <a class="el" href="classspot_1_1state.html">state</a> *<a class="el" href="classspot_1_1state.html">state</a>) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the conjunctions of variables tested by the outgoing transitions of <em>state</em>. </em> <a href="#spot_1_1tgba__tba__proxya11"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1tgba.html#spot_1_1tgbaa5">get_dict</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the dictionary associated to the automaton. </em> <a href="#spot_1_1tgbaa5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual std::string&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1tgba.html#spot_1_1tgba__explicita20">format_state</a> (const  <a class="el" href="classspot_1_1state.html">state</a> *<a class="el" href="classspot_1_1state.html">state</a>) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Format the state as a string for printing. </em> <a href="#spot_1_1tgba__explicita20"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual <a class="el" href="classspot_1_1state.html">state</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1tgba.html#spot_1_1tgba__explicita21">project_state</a> (const  <a class="el" href="classspot_1_1state.html">state</a> *s, const  <a class="el" href="classspot_1_1tgba.html">tgba</a> *t) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Project a state on an automata. </em> <a href="#spot_1_1tgba__explicita21"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual bdd&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1tgba.html#spot_1_1tgbaa8">all_acceptance_conditions</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the set of all acceptance conditions used by this automaton. </em> <a href="#spot_1_1tgbaa8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual bdd&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1tgba.html#spot_1_1tgbaa9">neg_acceptance_conditions</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the conjuction of all negated acceptance variables. </em> <a href="#spot_1_1tgbaa9"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1tgba.html#spot_1_1tgbab0">tgba</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual bdd&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1tgba.html#spot_1_1tgba__explicitb4">compute_support_conditions</a> (const  <a class="el" href="classspot_1_1state.html">state</a> *<a class="el" href="classspot_1_1state.html">state</a>) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do the actual computation of <a class="el" href="classspot_1_1tgba.html#spot_1_1tgba__tba__proxya10">tgba::support_conditions()</a>. </em> <a href="#spot_1_1tgba__explicitb4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual bdd&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1tgba.html#spot_1_1tgba__explicitb5">compute_support_variables</a> (const  <a class="el" href="classspot_1_1state.html">state</a> *<a class="el" href="classspot_1_1state.html">state</a>) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do the actual computation of <a class="el" href="classspot_1_1tgba.html#spot_1_1tgba__tba__proxya11">tgba::support_variables()</a>. </em> <a href="#spot_1_1tgba__explicitb5"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>const  <a class="el" href="classspot_1_1state.html">state</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1tgba.html#spot_1_1tgbar0">last_support_conditions_input_</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>bdd&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1tgba.html#spot_1_1tgbar1">last_support_conditions_output_</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>const  <a class="el" href="classspot_1_1state.html">state</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1tgba.html#spot_1_1tgbar2">last_support_variables_input_</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>bdd&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1tgba.html#spot_1_1tgbar3">last_support_variables_output_</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A Transition-based Generalized Büchi Automaton. 
<p>
The acronym TGBA (Transition-based Generalized Büchi Automaton) was coined by Dimitra Giannakopoulou and Flavio Lerda in "From States to Transitions: Improving Translation of LTL Formulae to Büchi Automata". (FORTE'02)<p>
TGBAs are transition-based, meanings their labels are put on arcs, not on nodes. They use Generalized Büchi acceptance conditions: there are several acceptance sets (of transitions), and a path can be accepted only if it traverse at least one transition of each set infinitely often.<p>
Browsing such automaton can be achieved using two functions. <code>get_init_state</code>, and <code>succ_iter</code>. The former returns the initial state while the latter allows to explore the successor states of any state.<p>
Note that although this is a transition-based automata, we never represent transitions! Transition informations are obtained by querying the iterator over the successors of a state. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="spot_1_1tgbab0" doxytag="spot::tgba::tgba" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spot::tgba::tgba </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="spot_1_1tgbaa0" doxytag="spot::tgba::~tgba" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual spot::tgba::~<a class="el" href="classspot_1_1tgba.html">tgba</a> </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="spot_1_1tgbaa8" doxytag="spot::tgba::all_acceptance_conditions" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual bdd spot::tgba::all_acceptance_conditions </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the set of all acceptance conditions used by this automaton. 
<p>
The goal of the emptiness check is to ensure that a strongly connected component walks through each of these acceptiong conditions. I.e., the union of the acceptiong conditions of all transition in the SCC should be equal to the result of this function. 
<p>
Implemented in <a class="el" href="classspot_1_1tgba__bdd__concrete.html#spot_1_1tgba__bdd__concretea10">spot::tgba_bdd_concrete</a>, <a class="el" href="classspot_1_1tgba__explicit.html#spot_1_1tgba__explicita15">spot::tgba_explicit</a>, <a class="el" href="classspot_1_1tgba__product.html#spot_1_1tgba__producta7">spot::tgba_product</a>, and <a class="el" href="classspot_1_1tgba__tba__proxy.html#spot_1_1tgba__tba__proxya7">spot::tgba_tba_proxy</a>.    </td>
  </tr>
</table>
<a class="anchor" name="spot_1_1tgba__explicitb4" doxytag="spot::tgba::compute_support_conditions" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual bdd spot::tgba::compute_support_conditions </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classspot_1_1state.html">state</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>state</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [protected, pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Do the actual computation of <a class="el" href="classspot_1_1tgba.html#spot_1_1tgba__tba__proxya10">tgba::support_conditions()</a>. 
<p>

<p>
Implemented in <a class="el" href="classspot_1_1tgba__bdd__concrete.html#spot_1_1tgba__bdd__concreteb0">spot::tgba_bdd_concrete</a>, <a class="el" href="classspot_1_1tgba__product.html#spot_1_1tgba__productb0">spot::tgba_product</a>, and <a class="el" href="classspot_1_1tgba__tba__proxy.html#spot_1_1tgba__tba__proxyb0">spot::tgba_tba_proxy</a>.    </td>
  </tr>
</table>
<a class="anchor" name="spot_1_1tgba__explicitb5" doxytag="spot::tgba::compute_support_variables" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual bdd spot::tgba::compute_support_variables </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classspot_1_1state.html">state</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>state</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [protected, pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Do the actual computation of <a class="el" href="classspot_1_1tgba.html#spot_1_1tgba__tba__proxya11">tgba::support_variables()</a>. 
<p>

<p>
Implemented in <a class="el" href="classspot_1_1tgba__bdd__concrete.html#spot_1_1tgba__bdd__concreteb1">spot::tgba_bdd_concrete</a>, <a class="el" href="classspot_1_1tgba__product.html#spot_1_1tgba__productb1">spot::tgba_product</a>, and <a class="el" href="classspot_1_1tgba__tba__proxy.html#spot_1_1tgba__tba__proxyb1">spot::tgba_tba_proxy</a>.    </td>
  </tr>
</table>
<a class="anchor" name="spot_1_1tgba__explicita20" doxytag="spot::tgba::format_state" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual std::string spot::tgba::format_state </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classspot_1_1state.html">state</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>state</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Format the state as a string for printing. 
<p>
This formating is the responsability of the automata who owns the state. 
<p>
Implemented in <a class="el" href="classspot_1_1tgba__bdd__concrete.html#spot_1_1tgba__bdd__concretea7">spot::tgba_bdd_concrete</a>, <a class="el" href="classspot_1_1tgba__product.html#spot_1_1tgba__producta5">spot::tgba_product</a>, and <a class="el" href="classspot_1_1tgba__tba__proxy.html#spot_1_1tgba__tba__proxya5">spot::tgba_tba_proxy</a>.    </td>
  </tr>
</table>
<a class="anchor" name="spot_1_1tgbaa5" doxytag="spot::tgba::get_dict" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="classspot_1_1bdd__dict.html">bdd_dict</a>* spot::tgba::get_dict </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the dictionary associated to the automaton. 
<p>
State are represented as BDDs. The dictionary allows to map BDD variables back to formulae, and vice versa. This is useful when dealing with several automata (which may use the same BDD variable for different formula), or simply when printing. 
<p>
Implemented in <a class="el" href="classspot_1_1tgba__bdd__concrete.html#spot_1_1tgba__bdd__concretea8">spot::tgba_bdd_concrete</a>, <a class="el" href="classspot_1_1tgba__explicit.html#spot_1_1tgba__explicita13">spot::tgba_explicit</a>, <a class="el" href="classspot_1_1tgba__product.html#spot_1_1tgba__producta4">spot::tgba_product</a>, and <a class="el" href="classspot_1_1tgba__tba__proxy.html#spot_1_1tgba__tba__proxya4">spot::tgba_tba_proxy</a>.    </td>
  </tr>
</table>
<a class="anchor" name="spot_1_1tgbaa1" doxytag="spot::tgba::get_init_state" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="classspot_1_1state.html">state</a>* spot::tgba::get_init_state </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the initial state of the automaton. 
<p>
The state has been allocated with <code>new</code>. It is the responsability of the caller to <code>delete</code> it when no longer needed. 
<p>
Implemented in <a class="el" href="classspot_1_1tgba__bdd__concrete.html#spot_1_1tgba__bdd__concretea4">spot::tgba_bdd_concrete</a>, <a class="el" href="classspot_1_1tgba__explicit.html#spot_1_1tgba__explicita11">spot::tgba_explicit</a>, <a class="el" href="classspot_1_1tgba__product.html#spot_1_1tgba__producta2">spot::tgba_product</a>, and <a class="el" href="classspot_1_1tgba__tba__proxy.html#spot_1_1tgba__tba__proxya2">spot::tgba_tba_proxy</a>.    </td>
  </tr>
</table>
<a class="anchor" name="spot_1_1tgbaa9" doxytag="spot::tgba::neg_acceptance_conditions" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual bdd spot::tgba::neg_acceptance_conditions </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the conjuction of all negated acceptance variables. 
<p>
For instance if the automaton uses variables <code>Acc[a]</code>, <code>Acc[b]</code> and <code>Acc[c]</code> to describe acceptance sets, this function should return <code>!Acc[a]&amp;!Acc[b]&amp;!Acc[c]</code>.<p>
This is useful when making products: each operand's condition set should be augmented with the <a class="el" href="classspot_1_1tgba.html#spot_1_1tgbaa9">neg_acceptance_conditions()</a> of the other operand. 
<p>
Implemented in <a class="el" href="classspot_1_1tgba__bdd__concrete.html#spot_1_1tgba__bdd__concretea11">spot::tgba_bdd_concrete</a>, <a class="el" href="classspot_1_1tgba__explicit.html#spot_1_1tgba__explicita16">spot::tgba_explicit</a>, <a class="el" href="classspot_1_1tgba__product.html#spot_1_1tgba__producta8">spot::tgba_product</a>, and <a class="el" href="classspot_1_1tgba__tba__proxy.html#spot_1_1tgba__tba__proxya8">spot::tgba_tba_proxy</a>.    </td>
  </tr>
</table>
<a class="anchor" name="spot_1_1tgba__explicita21" doxytag="spot::tgba::project_state" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="classspot_1_1state.html">state</a>* spot::tgba::project_state </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classspot_1_1state.html">state</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>s</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classspot_1_1tgba.html">tgba</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>t</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Project a state on an automata. 
<p>
This converts <em>s</em>, into that corresponding <a class="el" href="classspot_1_1state.html">spot::state</a> for <em>t</em>. This is useful when you have the state of a product, and want restrict this state to a specific automata occuring in the product.<p>
It goes without saying that <em>s</em> and <em>t</em> should be compatible (i.e., <em>s</em> is a state of <em>t</em>).<p>
<dl compact><dt><b>Returns:</b></dt><dd>0 if the projection fails (<em>s</em> is unrelated to <em>t</em>), or a new <code>state*</code> (the projected state) that must be deleted by the caller. </dd></dl>

<p>
Reimplemented in <a class="el" href="classspot_1_1tgba__product.html#spot_1_1tgba__producta6">spot::tgba_product</a>, and <a class="el" href="classspot_1_1tgba__tba__proxy.html#spot_1_1tgba__tba__proxya6">spot::tgba_tba_proxy</a>.    </td>
  </tr>
</table>
<a class="anchor" name="spot_1_1tgba__explicita17" doxytag="spot::tgba::succ_iter" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="classspot_1_1tgba__succ__iterator.html">tgba_succ_iterator</a>* spot::tgba::succ_iter </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classspot_1_1state.html">state</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>local_state</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classspot_1_1state.html">state</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>global_state</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classspot_1_1tgba.html">tgba</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>global_automaton</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get an iterator over the successors of <em>local_state</em>. 
<p>
The iterator has been allocated with <code>new</code>. It is the responsability of the caller to <code>delete</code> it when no longer needed.<p>
During synchornized products, additional informations are passed about the entire product and its state. Recall that products can be nested, forming a tree of spot::tgba where most values are computed on demand. <em>global_automaton</em> designate the root spot::tgba, and <em>global_state</em> its state. This two objects can be used by <a class="el" href="classspot_1_1tgba.html#spot_1_1tgba__explicita17">succ_iter()</a> to restrict the set of successors to compute.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>local_state</em>&nbsp;</td><td>The state whose successors are to be explored. This pointer is not adopted in any way by <code>succ_iter</code>, and it is still the caller's responsability to delete it when appropriate (this can be done during the lifetime of the iterator). </td></tr>
    <tr><td valign=top><em>global_state</em>&nbsp;</td><td>In a product, the state of the global product automaton. Otherwise, 0. Like <em>locale_state</em>, <em>global_state</em> is not adopted by <code>succ_iter</code>. </td></tr>
    <tr><td valign=top><em>global_automaton</em>&nbsp;</td><td>In a product, the state of the global product automaton. Otherwise, 0. </td></tr>
  </table>
</dl>

<p>
Implemented in <a class="el" href="classspot_1_1tgba__bdd__concrete.html#spot_1_1tgba__bdd__concretea6">spot::tgba_bdd_concrete</a>, <a class="el" href="classspot_1_1tgba__product.html#spot_1_1tgba__producta3">spot::tgba_product</a>, and <a class="el" href="classspot_1_1tgba__tba__proxy.html#spot_1_1tgba__tba__proxya3">spot::tgba_tba_proxy</a>.    </td>
  </tr>
</table>
<a class="anchor" name="spot_1_1tgba__tba__proxya10" doxytag="spot::tgba::support_conditions" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bdd spot::tgba::support_conditions </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classspot_1_1state.html">state</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>state</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get a formula that must hold whatever successor is taken. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>A formula which must be verified for all successors of <em>state</em>.</dd></dl>
This can be as simple as <code>bddtrue</code>, or more completely the disjunction of the condition of all successors. This is used as an hint by <code><a class="el" href="classspot_1_1tgba.html#spot_1_1tgba__explicita17">succ_iter()</a></code> to reduce the number of successor to compute in a product.<p>
Sub classes should implement <a class="el" href="classspot_1_1tgba.html#spot_1_1tgba__explicitb4">compute_support_conditions()</a>, this function is just a wrapper that will cache the last return value for efficiency.     </td>
  </tr>
</table>
<a class="anchor" name="spot_1_1tgba__tba__proxya11" doxytag="spot::tgba::support_variables" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bdd spot::tgba::support_variables </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classspot_1_1state.html">state</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>state</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the conjunctions of variables tested by the outgoing transitions of <em>state</em>. 
<p>
All variables tested by outgoing transitions must be returned. This is mandatory.<p>
This is used as an hint by some <code><a class="el" href="classspot_1_1tgba.html#spot_1_1tgba__explicita17">succ_iter()</a></code> to reduce the number of successor to compute in a product.<p>
Sub classes should implement <a class="el" href="classspot_1_1tgba.html#spot_1_1tgba__explicitb5">compute_support_variables()</a>, this function is just a wrapper that will cache the last return value for efficiency.     </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="spot_1_1tgbar0" doxytag="spot::tgba::last_support_conditions_input_" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const <a class="el" href="classspot_1_1state.html">state</a>* <a class="el" href="classspot_1_1tgba.html#spot_1_1tgbar0">spot::tgba::last_support_conditions_input_</a><code> [mutable, private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="spot_1_1tgbar1" doxytag="spot::tgba::last_support_conditions_output_" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bdd <a class="el" href="classspot_1_1tgba.html#spot_1_1tgbar1">spot::tgba::last_support_conditions_output_</a><code> [mutable, private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="spot_1_1tgbar2" doxytag="spot::tgba::last_support_variables_input_" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const <a class="el" href="classspot_1_1state.html">state</a>* <a class="el" href="classspot_1_1tgba.html#spot_1_1tgbar2">spot::tgba::last_support_variables_input_</a><code> [mutable, private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="spot_1_1tgbar3" doxytag="spot::tgba::last_support_variables_output_" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bdd <a class="el" href="classspot_1_1tgba.html#spot_1_1tgbar3">spot::tgba::last_support_variables_output_</a><code> [mutable, private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="tgba_8hh-source.html">tgba.hh</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Mon Dec 1 11:36:33 2003 for spot by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
