<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>spot: spot::ltl Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<h1>spot::ltl Namespace Reference</h1>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1ltl_1_1atomic__prop.html">atomic_prop</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomic propositions. </em> <a href="classspot_1_1ltl_1_1atomic__prop.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1ltl_1_1binop.html">binop</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Binary operator. </em> <a href="classspot_1_1ltl_1_1binop.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1ltl_1_1clone__visitor.html">clone_visitor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clone a formula. </em> <a href="classspot_1_1ltl_1_1clone__visitor.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structspot_1_1ltl_1_1const__visitor.html">const_visitor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Formula visitor that cannot modify the formula. </em> <a href="structspot_1_1ltl_1_1const__visitor.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1ltl_1_1constant.html">constant</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A constant (True or False). </em> <a href="classspot_1_1ltl_1_1constant.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1ltl_1_1default__environment.html">default_environment</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A laxist environment. </em> <a href="classspot_1_1ltl_1_1default__environment.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1ltl_1_1environment.html">environment</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An environment that describe atomic propositions. </em> <a href="classspot_1_1ltl_1_1environment.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An LTL formula. </em> <a href="classspot_1_1ltl_1_1formula.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1ltl_1_1multop.html">multop</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multi-operand operators. </em> <a href="classspot_1_1ltl_1_1multop.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structspot_1_1ltl_1_1multop_1_1paircmp.html">multop::paircmp</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison functor used internally by <a class="el" href="classspot_1_1ltl_1_1multop.html">ltl::multop</a>. </em> <a href="structspot_1_1ltl_1_1multop_1_1paircmp.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1ltl_1_1postfix__visitor.html">postfix_visitor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply an algorithm on each node of an AST, during a postfix traversal. </em> <a href="classspot_1_1ltl_1_1postfix__visitor.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1ltl_1_1ref__formula.html">ref_formula</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A reference-counted LTL formula. </em> <a href="classspot_1_1ltl_1_1ref__formula.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1ltl_1_1unabbreviate__logic__visitor.html">unabbreviate_logic_visitor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clone and rewrite a formula to remove most of the abbreviated logical operators. </em> <a href="classspot_1_1ltl_1_1unabbreviate__logic__visitor.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1ltl_1_1unabbreviate__ltl__visitor.html">unabbreviate_ltl_visitor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clone and rewrite a formula to remove most of the abbreviated LTL and logical operators. </em> <a href="classspot_1_1ltl_1_1unabbreviate__ltl__visitor.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classspot_1_1ltl_1_1unop.html">unop</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unary operator. </em> <a href="classspot_1_1ltl_1_1unop.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structspot_1_1ltl_1_1visitor.html">visitor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Formula visitor that can modify the formula. </em> <a href="structspot_1_1ltl_1_1visitor.html#_details">More...</a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef std::pair&lt; <a class="el" href="classyy_1_1Location.html">yy::Location</a>,<br>
 std::string &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot_1_1ltl.html#a0">parse_error</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A parse diagnostic with its location. </em> <a href="#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef std::list&lt; <a class="el" href="namespacespot_1_1ltl.html#a0">parse_error</a> &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot_1_1ltl.html#a1">parse_error_list</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A list of parser diagnostics, as filled by parse. </em> <a href="#a1"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot_1_1ltl.html#a2">parse</a> (const  std::string &amp;ltl_string, <a class="el" href="namespacespot_1_1ltl.html#a1">parse_error_list</a> &amp;error_list, <a class="el" href="classspot_1_1ltl_1_1environment.html">environment</a> &amp;env=default_environment::instance(), bool debug=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build a formula from an LTL string. </em> <a href="#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot_1_1ltl.html#a3">format_parse_errors</a> (std::ostream &amp;os, const  std::string &amp;ltl_string, <a class="el" href="namespacespot_1_1ltl.html#a1">parse_error_list</a> &amp;error_list)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Format diagnostics produced by <a class="el" href="namespacespot_1_1ltl.html#a2">spot::ltl::parse</a>. </em> <a href="#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot_1_1ltl.html#a4">clone</a> (const  <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clone a formula. </em> <a href="#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot_1_1ltl.html#a5">destroy</a> (const  <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys a formula. </em> <a href="#a5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>std::ostream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot_1_1ltl.html#a6">dotty</a> (std::ostream &amp;os, const  <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a formula tree using dot's syntax. </em> <a href="#a6"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>std::ostream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot_1_1ltl.html#a7">dump</a> (std::ostream &amp;os, const  <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dump a formula tree. </em> <a href="#a7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot_1_1ltl.html#a8">unabbreviate_logic</a> (const  <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clone and rewrite a formula to remove most of the abbreviated logical operators. </em> <a href="#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot_1_1ltl.html#a9">negative_normal_form</a> (const  <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f, bool negated=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build the negative normal form of <em>f</em>. </em> <a href="#a9"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>std::ostream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot_1_1ltl.html#a10">to_string</a> (const  <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f, std::ostream &amp;os)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output a formula as a (parsable) string. </em> <a href="#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>std::string&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot_1_1ltl.html#a11">to_string</a> (const  <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a formula into a (parsable) string. </em> <a href="#a11"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacespot_1_1ltl.html#a12">unabbreviate_ltl</a> (const  <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a> *f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clone and rewrite a formula to remove most of the abbreviated LTL and logical operators. </em> <a href="#a12"></a><em><br><br></td></tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="a0" doxytag="spot::ltl::parse_error" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef std::pair&lt;<a class="el" href="classyy_1_1Location.html">yy::Location</a>, std::string&gt; <a class="el" href="namespacespot_1_1ltl.html#a0">spot::ltl::parse_error</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A parse diagnostic with its location. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="spot::ltl::parse_error_list" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef std::list&lt;<a class="el" href="namespacespot_1_1ltl.html#a0">parse_error</a>&gt; <a class="el" href="namespacespot_1_1ltl.html#a1">spot::ltl::parse_error_list</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A list of parser diagnostics, as filled by parse. 
<p>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a4" doxytag="spot::ltl::clone" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a>* clone </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const formula *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>f</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Clone a formula. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="spot::ltl::destroy" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void destroy </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const formula *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>f</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destroys a formula. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="spot::ltl::dotty" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> std::ostream&amp; dotty </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::ostream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>os</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const formula *&nbsp;</td>
          <td class="mdname" nowrap> <em>f</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write a formula tree using dot's syntax. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>os</em>&nbsp;</td><td>The stream where it should be output. </td></tr>
    <tr><td valign=top><em>f</em>&nbsp;</td><td>The formula to translate.</td></tr>
  </table>
</dl>
<code>dot</code> is part of the GraphViz package <a href="http://www.research.att.com/sw/tools/graphviz/">http://www.research.att.com/sw/tools/graphviz/</a>     </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="spot::ltl::dump" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> std::ostream&amp; dump </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::ostream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>os</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const formula *&nbsp;</td>
          <td class="mdname" nowrap> <em>f</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Dump a formula tree. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>os</em>&nbsp;</td><td>The stream where it should be output. </td></tr>
    <tr><td valign=top><em>f</em>&nbsp;</td><td>The formula to dump.</td></tr>
  </table>
</dl>
This is useful to display a formula when debugging.     </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="spot::ltl::format_parse_errors" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool format_parse_errors </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::ostream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>os</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const std::string &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>ltl_string</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>parse_error_list &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>error_list</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Format diagnostics produced by <a class="el" href="namespacespot_1_1ltl.html#a2">spot::ltl::parse</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>os</em>&nbsp;</td><td>Where diagnostics should be output. </td></tr>
    <tr><td valign=top><em>ltl_string</em>&nbsp;</td><td>The string that were parsed. </td></tr>
    <tr><td valign=top><em>error_list</em>&nbsp;</td><td>The error list filled by <a class="el" href="namespacespot_1_1ltl.html#a2">spot::ltl::parse</a> while parsing <em>ltl_string</em>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><code>true</code> iff any diagnostic was output. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="spot::ltl::negative_normal_form" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a>* negative_normal_form </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const formula *&nbsp;</td>
          <td class="mdname" nowrap> <em>f</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>negated</em> = false</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Build the negative normal form of <em>f</em>. 
<p>
All negations of the formula are pushed in front of the atomic propositions.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>f</em>&nbsp;</td><td>The formula to normalize. </td></tr>
    <tr><td valign=top><em>negated</em>&nbsp;</td><td>If <code>true</code>, return the negative normal form of <code>!f</code> </td></tr>
  </table>
</dl>
Note that this will not remove abbreviated operators. If you want to remove abbreviations, call <a class="el" href="namespacespot_1_1ltl.html#a8">spot::ltl::unabbreviate_logic</a> or <a class="el" href="namespacespot_1_1ltl.html#a12">spot::ltl::unabbreviate_ltl</a> first. (Calling these functions after <a class="el" href="namespacespot_1_1ltl.html#a9">spot::ltl::negative_normal_form</a> would likely produce a formula which is not in negative normal form.)     </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="spot::ltl::parse" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a>* parse </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const std::string &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>ltl_string</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>parse_error_list &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>error_list</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>environment &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>env</em> = default_environment::instance(), </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>debug</em> = false</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Build a formula from an LTL string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>ltl_string</em>&nbsp;</td><td>The string to parse. </td></tr>
    <tr><td valign=top><em>error_list</em>&nbsp;</td><td>A list that will be filled with parse errors that occured during parsing. </td></tr>
    <tr><td valign=top><em>env</em>&nbsp;</td><td>The environment into which parsing should take place. </td></tr>
    <tr><td valign=top><em>debug</em>&nbsp;</td><td>When true, causes the parser to trace its execution. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A pointer to the formula built from <em>ltl_string</em>, or 0 if the input was unparsable.</dd></dl>
Note that the parser usually tries to recover from errors. It can return an non zero value even if it encountered error during the parsing of <em>ltl_string</em>. If you want to make sure <em>ltl_string</em> was parsed succesfully, check <em>error_list</em> for emptiness.<p>
<dl compact><dt><b>Warning:</b></dt><dd>This function is not reentrant. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="spot::ltl::to_string" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> std::string to_string </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const formula *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>f</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert a formula into a (parsable) string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>f</em>&nbsp;</td><td>The formula to translate. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="spot::ltl::to_string" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> std::ostream&amp; to_string </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const formula *&nbsp;</td>
          <td class="mdname" nowrap> <em>f</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>std::ostream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>os</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Output a formula as a (parsable) string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>f</em>&nbsp;</td><td>The formula to translate. </td></tr>
    <tr><td valign=top><em>os</em>&nbsp;</td><td>The stream where it should be output. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="spot::ltl::unabbreviate_logic" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a>* unabbreviate_logic </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const formula *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>f</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Clone and rewrite a formula to remove most of the abbreviated logical operators. 
<p>
This will rewrite binary operators such as <a class="el" href="classspot_1_1ltl_1_1binop.html#spot_1_1ltl_1_1binopw5spot_1_1ltl_1_1binopw1">binop::Implies</a>, binop::Equals, and <a class="el" href="classspot_1_1ltl_1_1binop.html#spot_1_1ltl_1_1binopw5spot_1_1ltl_1_1binopw0">binop::Xor</a>, using only <a class="el" href="classspot_1_1ltl_1_1unop.html#spot_1_1ltl_1_1unopw4spot_1_1ltl_1_1unopw0">unop::Not</a>, <a class="el" href="classspot_1_1ltl_1_1multop.html#spot_1_1ltl_1_1multopw3spot_1_1ltl_1_1multopw1">multop::Or</a>, and <a class="el" href="classspot_1_1ltl_1_1multop.html#spot_1_1ltl_1_1multopw3spot_1_1ltl_1_1multopw2">multop::And</a>.     </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="spot::ltl::unabbreviate_ltl" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classspot_1_1ltl_1_1formula.html">formula</a>* unabbreviate_ltl </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const formula *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>f</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Clone and rewrite a formula to remove most of the abbreviated LTL and logical operators. 
<p>
The rewriting performed on logical operator is the same as the one done by <a class="el" href="namespacespot_1_1ltl.html#a8">spot::ltl::unabbreviate_logic</a>.<p>
This will also rewrite unary operators such as <a class="el" href="classspot_1_1ltl_1_1unop.html#spot_1_1ltl_1_1unopw4spot_1_1ltl_1_1unopw2">unop::F</a>, and <a class="el" href="classspot_1_1ltl_1_1unop.html#spot_1_1ltl_1_1unopw4spot_1_1ltl_1_1unopw3">unop::G</a>, using only <a class="el" href="classspot_1_1ltl_1_1binop.html#spot_1_1ltl_1_1binopw5spot_1_1ltl_1_1binopw3">binop::U</a>, and <a class="el" href="classspot_1_1ltl_1_1binop.html#spot_1_1ltl_1_1binopw5spot_1_1ltl_1_1binopw4">binop::R</a>.     </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Mon Dec 1 11:37:19 2003 for spot by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
