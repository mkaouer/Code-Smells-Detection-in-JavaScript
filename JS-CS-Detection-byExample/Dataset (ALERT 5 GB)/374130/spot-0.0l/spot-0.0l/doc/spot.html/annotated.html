<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>spot: Annotated Index</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindexHL" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<h1>spot Class List</h1>Here are the classes, structs, unions and interfaces with brief descriptions:<table>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1atomic__prop.html">spot::ltl::atomic_prop</a></td><td class="indexvalue">Atomic propositions </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1bdd__allocator.html">spot::bdd_allocator</a></td><td class="indexvalue">Manage ranges of variables </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1bdd__dict.html">spot::bdd_dict</a></td><td class="indexvalue">Map BDD variables to formulae </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1bdd__less__than.html">spot::bdd_less_than</a></td><td class="indexvalue">Comparison functor for BDDs </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1binop.html">spot::ltl::binop</a></td><td class="indexvalue">Binary operator </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1clone__visitor.html">spot::ltl::clone_visitor</a></td><td class="indexvalue">Clone a formula </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1ltl_1_1const__visitor.html">spot::ltl::const_visitor</a></td><td class="indexvalue">Formula visitor that cannot modify the formula </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1constant.html">spot::ltl::constant</a></td><td class="indexvalue">A constant (True or False) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1default__environment.html">spot::ltl::default_environment</a></td><td class="indexvalue">A laxist environment </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1emptiness__check.html">spot::emptiness_check</a></td><td class="indexvalue">Check whether the language of an automate is empty </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1emptiness__check_1_1connected__component.html">spot::emptiness_check::connected_component</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1emptiness__check_1_1connected__component__set.html">spot::emptiness_check::connected_component_set</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1environment.html">spot::ltl::environment</a></td><td class="indexvalue">An environment that describe atomic propositions </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1formula.html">spot::ltl::formula</a></td><td class="indexvalue">An LTL formula </td></tr>
  <tr><td class="indexkey"><a class="el" href="classyy_1_1Location.html">yy::Location</a></td><td class="indexvalue">Abstract a <a class="el" href="classyy_1_1Location.html">Location</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1magic__search.html">spot::magic_search</a></td><td class="indexvalue">Emptiness check on <a class="el" href="classspot_1_1tgba__tba__proxy.html">spot::tgba_tba_proxy</a> automata using the Magic Search algorithm </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1magic__search_1_1magic.html">spot::magic_search::magic</a></td><td class="indexvalue">Records whether a state has be seen with the magic bit on or off </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1magic__search_1_1magic__state.html">spot::magic_search::magic_state</a></td><td class="indexvalue">A state for the <a class="el" href="structspot_1_1magic__search.html">spot::magic_search</a> algorithm </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1minato__isop.html">spot::minato_isop</a></td><td class="indexvalue">Generate an irredundant sum-of-products (ISOP) form of a BDD function </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1minato__isop_1_1local__vars.html">spot::minato_isop::local_vars</a></td><td class="indexvalue">Internal variables for <a class="el" href="classspot_1_1minato__isop.html">minato_isop</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1multop.html">spot::ltl::multop</a></td><td class="indexvalue">Multi-operand operators </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1ltl_1_1multop_1_1paircmp.html">spot::ltl::multop::paircmp</a></td><td class="indexvalue">Comparison functor used internally by <a class="el" href="classspot_1_1ltl_1_1multop.html">ltl::multop</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classyy_1_1Position.html">yy::Position</a></td><td class="indexvalue">Abstract a <a class="el" href="classyy_1_1Position.html">Position</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1postfix__visitor.html">spot::ltl::postfix_visitor</a></td><td class="indexvalue">Apply an algorithm on each node of an AST, during a postfix traversal </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1ptr__hash.html">spot::ptr_hash&lt; T &gt;</a></td><td class="indexvalue">A hash function for pointers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1ref__formula.html">spot::ltl::ref_formula</a></td><td class="indexvalue">A reference-counted LTL formula </td></tr>
  <tr><td class="indexkey"><a class="el" href="classyy_1_1Slice.html">yy::Slice&lt; T, S &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classyy_1_1Stack.html">yy::Stack&lt; T, S &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1state.html">spot::state</a></td><td class="indexvalue">Abstract class for states </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1state__bdd.html">spot::state_bdd</a></td><td class="indexvalue">A state whose representation is a BDD </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1state__explicit.html">spot::state_explicit</a></td><td class="indexvalue">States used by <a class="el" href="classspot_1_1tgba__explicit.html">spot::tgba_explicit</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1state__product.html">spot::state_product</a></td><td class="indexvalue">A state for <a class="el" href="classspot_1_1tgba__product.html">spot::tgba_product</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1state__ptr__equal.html">spot::state_ptr_equal</a></td><td class="indexvalue">An Equivalence Relation for <code>state*</code> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1state__ptr__hash.html">spot::state_ptr_hash</a></td><td class="indexvalue">Hash Function for <code>state*</code> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1state__ptr__less__than.html">spot::state_ptr_less_than</a></td><td class="indexvalue">Strict Weak Ordering for <code>state*</code> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1string__hash.html">spot::string_hash</a></td><td class="indexvalue">A hash function for strings </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba.html">spot::tgba</a></td><td class="indexvalue">A Transition-based Generalized Büchi Automaton </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__bdd__concrete.html">spot::tgba_bdd_concrete</a></td><td class="indexvalue">A concrete <a class="el" href="classspot_1_1tgba.html">spot::tgba</a> implemented using BDDs </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__bdd__concrete__factory.html">spot::tgba_bdd_concrete_factory</a></td><td class="indexvalue">Helper class to build a <a class="el" href="classspot_1_1tgba__bdd__concrete.html">spot::tgba_bdd_concrete</a> object </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1tgba__bdd__core__data.html">spot::tgba_bdd_core_data</a></td><td class="indexvalue">Core data for a TGBA encoded using BDDs </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__bdd__factory.html">spot::tgba_bdd_factory</a></td><td class="indexvalue">Abstract class for <a class="el" href="classspot_1_1tgba__bdd__concrete.html">spot::tgba_bdd_concrete</a> factories </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__explicit.html">spot::tgba_explicit</a></td><td class="indexvalue">Explicit representation of a <a class="el" href="classspot_1_1tgba.html">spot::tgba</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1tgba__explicit_1_1transition.html">spot::tgba_explicit::transition</a></td><td class="indexvalue">Explicit transitions (used by <a class="el" href="classspot_1_1tgba__explicit.html">spot::tgba_explicit</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__explicit__succ__iterator.html">spot::tgba_explicit_succ_iterator</a></td><td class="indexvalue">Successor iterators used by <a class="el" href="classspot_1_1tgba__explicit.html">spot::tgba_explicit</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__product.html">spot::tgba_product</a></td><td class="indexvalue">A lazy product. (States are computed on the fly.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__reachable__iterator.html">spot::tgba_reachable_iterator</a></td><td class="indexvalue">Iterate over all reachable states of a <a class="el" href="classspot_1_1tgba.html">spot::tgba</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__reachable__iterator__breadth__first.html">spot::tgba_reachable_iterator_breadth_first</a></td><td class="indexvalue">An implementation of <a class="el" href="classspot_1_1tgba__reachable__iterator.html">spot::tgba_reachable_iterator</a> that browses states breadth first </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__reachable__iterator__depth__first.html">spot::tgba_reachable_iterator_depth_first</a></td><td class="indexvalue">An implementation of <a class="el" href="classspot_1_1tgba__reachable__iterator.html">spot::tgba_reachable_iterator</a> that browses states depth first </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__succ__iterator.html">spot::tgba_succ_iterator</a></td><td class="indexvalue">Iterate over the successors of a state </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__succ__iterator__concrete.html">spot::tgba_succ_iterator_concrete</a></td><td class="indexvalue">A concrete iterator over successors of a TGBA state </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__succ__iterator__product.html">spot::tgba_succ_iterator_product</a></td><td class="indexvalue">Iterate over the successors of a product computed on the fly </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1tgba__tba__proxy.html">spot::tgba_tba_proxy</a></td><td class="indexvalue">Degeneralize a <a class="el" href="classspot_1_1tgba.html">spot::tgba</a> on the fly </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1unabbreviate__logic__visitor.html">spot::ltl::unabbreviate_logic_visitor</a></td><td class="indexvalue">Clone and rewrite a formula to remove most of the abbreviated logical operators </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1unabbreviate__ltl__visitor.html">spot::ltl::unabbreviate_ltl_visitor</a></td><td class="indexvalue">Clone and rewrite a formula to remove most of the abbreviated LTL and logical operators </td></tr>
  <tr><td class="indexkey"><a class="el" href="classspot_1_1ltl_1_1unop.html">spot::ltl::unop</a></td><td class="indexvalue">Unary operator </td></tr>
  <tr><td class="indexkey"><a class="el" href="structspot_1_1ltl_1_1visitor.html">spot::ltl::visitor</a></td><td class="indexvalue">Formula visitor that can modify the formula </td></tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Mon Dec 1 11:36:08 2003 for spot by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
