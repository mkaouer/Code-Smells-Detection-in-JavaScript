This is lbtt.info, produced by makeinfo version 4.6 from
/home/adl/proj/spot/lbtt/doc/lbtt.texi.

   This file documents how to use the LTL-to-Bu"chi translator
testbench `lbtt'.

   Copyright (C) 2003 Heikki Tauriainen <heikki.tauriainen@hut.fi>

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


File: lbtt.info,  Node: Top,  Next: Copying,  Prev: (dir),  Up: (dir)

`lbtt'
******

`lbtt' is a tool for testing implementations of algorithms for
translating propositional linear temporal logic formulas into Bu"chi
automata.

   This is edition 1.0.1 of the `lbtt' documentation. This edition
applies to `lbtt' versions 1.0.x.

   `lbtt' is free software, you may change and redistribute it under
the terms of the GNU General Public License.  `lbtt' comes with NO
WARRANTY. See *Note Copying:: for details.

* Menu:

* Copying::                     GNU General Public License.

* Overview::                    A short introduction to `lbtt'.
* Test methods::                Description of the tests `lbtt'
				  performs.

* Invocation::                  How to run the program.
* Interpreting the output::     Explanation of `lbtt''s output messages.
* Analyzing test results::      Working with `lbtt''s internal
				  commands.

* Interfacing with lbtt::       Interfacing LTL-to-Bu"chi translators
				  with `lbtt'.
* References::                  List of references.

* Definitions::                 A reference of the formal definitions of
				  the various objects that `lbtt'
				  manipulates.

* Configuration file option index::
* Command line option index::
* User command index::
* Concept index::


File: lbtt.info,  Node: Copying,  Next: Overview,  Prev: Top,  Up: Top

GNU GENERAL PUBLIC LICENSE
**************************

                         Version 2, June 1991

     Copyright (C) 1989, 1991 Free Software Foundation, Inc.
     59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
     
     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

Preamble
========

The licenses for most software are designed to take away your freedom
to share and change it.  By contrast, the GNU General Public License is
intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

   When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it in
new free programs; and that you know you can do these things.

   To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

   For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

   We protect your rights with two steps: (1) copyright the software,
and (2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

   Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

   Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

   The precise terms and conditions for copying, distribution and
modification follow.

    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
  0. This License applies to any program or other work which contains a
     notice placed by the copyright holder saying it may be distributed
     under the terms of this General Public License.  The "Program",
     below, refers to any such program or work, and a "work based on
     the Program" means either the Program or any derivative work under
     copyright law: that is to say, a work containing the Program or a
     portion of it, either verbatim or with modifications and/or
     translated into another language.  (Hereinafter, translation is
     included without limitation in the term "modification".)  Each
     licensee is addressed as "you".

     Activities other than copying, distribution and modification are
     not covered by this License; they are outside its scope.  The act
     of running the Program is not restricted, and the output from the
     Program is covered only if its contents constitute a work based on
     the Program (independent of having been made by running the
     Program).  Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
     source code as you receive it, in any medium, provided that you
     conspicuously and appropriately publish on each copy an appropriate
     copyright notice and disclaimer of warranty; keep intact all the
     notices that refer to this License and to the absence of any
     warranty; and give any other recipients of the Program a copy of
     this License along with the Program.

     You may charge a fee for the physical act of transferring a copy,
     and you may at your option offer warranty protection in exchange
     for a fee.

  2. You may modify your copy or copies of the Program or any portion
     of it, thus forming a work based on the Program, and copy and
     distribute such modifications or work under the terms of Section 1
     above, provided that you also meet all of these conditions:

       a. You must cause the modified files to carry prominent notices
          stating that you changed the files and the date of any change.

       b. You must cause any work that you distribute or publish, that
          in whole or in part contains or is derived from the Program
          or any part thereof, to be licensed as a whole at no charge
          to all third parties under the terms of this License.

       c. If the modified program normally reads commands interactively
          when run, you must cause it, when started running for such
          interactive use in the most ordinary way, to print or display
          an announcement including an appropriate copyright notice and
          a notice that there is no warranty (or else, saying that you
          provide a warranty) and that users may redistribute the
          program under these conditions, and telling the user how to
          view a copy of this License.  (Exception: if the Program
          itself is interactive but does not normally print such an
          announcement, your work based on the Program is not required
          to print an announcement.)

     These requirements apply to the modified work as a whole.  If
     identifiable sections of that work are not derived from the
     Program, and can be reasonably considered independent and separate
     works in themselves, then this License, and its terms, do not
     apply to those sections when you distribute them as separate
     works.  But when you distribute the same sections as part of a
     whole which is a work based on the Program, the distribution of
     the whole must be on the terms of this License, whose permissions
     for other licensees extend to the entire whole, and thus to each
     and every part regardless of who wrote it.

     Thus, it is not the intent of this section to claim rights or
     contest your rights to work written entirely by you; rather, the
     intent is to exercise the right to control the distribution of
     derivative or collective works based on the Program.

     In addition, mere aggregation of another work not based on the
     Program with the Program (or with a work based on the Program) on
     a volume of a storage or distribution medium does not bring the
     other work under the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
     under Section 2) in object code or executable form under the terms
     of Sections 1 and 2 above provided that you also do one of the
     following:

       a. Accompany it with the complete corresponding machine-readable
          source code, which must be distributed under the terms of
          Sections 1 and 2 above on a medium customarily used for
          software interchange; or,

       b. Accompany it with a written offer, valid for at least three
          years, to give any third party, for a charge no more than your
          cost of physically performing source distribution, a complete
          machine-readable copy of the corresponding source code, to be
          distributed under the terms of Sections 1 and 2 above on a
          medium customarily used for software interchange; or,

       c. Accompany it with the information you received as to the offer
          to distribute corresponding source code.  (This alternative is
          allowed only for noncommercial distribution and only if you
          received the program in object code or executable form with
          such an offer, in accord with Subsection b above.)

     The source code for a work means the preferred form of the work for
     making modifications to it.  For an executable work, complete
     source code means all the source code for all modules it contains,
     plus any associated interface definition files, plus the scripts
     used to control compilation and installation of the executable.
     However, as a special exception, the source code distributed need
     not include anything that is normally distributed (in either
     source or binary form) with the major components (compiler,
     kernel, and so on) of the operating system on which the executable
     runs, unless that component itself accompanies the executable.

     If distribution of executable or object code is made by offering
     access to copy from a designated place, then offering equivalent
     access to copy the source code from the same place counts as
     distribution of the source code, even though third parties are not
     compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
     except as expressly provided under this License.  Any attempt
     otherwise to copy, modify, sublicense or distribute the Program is
     void, and will automatically terminate your rights under this
     License.  However, parties who have received copies, or rights,
     from you under this License will not have their licenses
     terminated so long as such parties remain in full compliance.

  5. You are not required to accept this License, since you have not
     signed it.  However, nothing else grants you permission to modify
     or distribute the Program or its derivative works.  These actions
     are prohibited by law if you do not accept this License.
     Therefore, by modifying or distributing the Program (or any work
     based on the Program), you indicate your acceptance of this
     License to do so, and all its terms and conditions for copying,
     distributing or modifying the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
     Program), the recipient automatically receives a license from the
     original licensor to copy, distribute or modify the Program
     subject to these terms and conditions.  You may not impose any
     further restrictions on the recipients' exercise of the rights
     granted herein.  You are not responsible for enforcing compliance
     by third parties to this License.

  7. If, as a consequence of a court judgment or allegation of patent
     infringement or for any other reason (not limited to patent
     issues), conditions are imposed on you (whether by court order,
     agreement or otherwise) that contradict the conditions of this
     License, they do not excuse you from the conditions of this
     License.  If you cannot distribute so as to satisfy simultaneously
     your obligations under this License and any other pertinent
     obligations, then as a consequence you may not distribute the
     Program at all.  For example, if a patent license would not permit
     royalty-free redistribution of the Program by all those who
     receive copies directly or indirectly through you, then the only
     way you could satisfy both it and this License would be to refrain
     entirely from distribution of the Program.

     If any portion of this section is held invalid or unenforceable
     under any particular circumstance, the balance of the section is
     intended to apply and the section as a whole is intended to apply
     in other circumstances.

     It is not the purpose of this section to induce you to infringe any
     patents or other property right claims or to contest validity of
     any such claims; this section has the sole purpose of protecting
     the integrity of the free software distribution system, which is
     implemented by public license practices.  Many people have made
     generous contributions to the wide range of software distributed
     through that system in reliance on consistent application of that
     system; it is up to the author/donor to decide if he or she is
     willing to distribute software through any other system and a
     licensee cannot impose that choice.

     This section is intended to make thoroughly clear what is believed
     to be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
     certain countries either by patents or by copyrighted interfaces,
     the original copyright holder who places the Program under this
     License may add an explicit geographical distribution limitation
     excluding those countries, so that distribution is permitted only
     in or among countries not thus excluded.  In such case, this
     License incorporates the limitation as if written in the body of
     this License.

  9. The Free Software Foundation may publish revised and/or new
     versions of the General Public License from time to time.  Such
     new versions will be similar in spirit to the present version, but
     may differ in detail to address new problems or concerns.

     Each version is given a distinguishing version number.  If the
     Program specifies a version number of this License which applies
     to it and "any later version", you have the option of following
     the terms and conditions either of that version or of any later
     version published by the Free Software Foundation.  If the Program
     does not specify a version number of this License, you may choose
     any version ever published by the Free Software Foundation.

 10. If you wish to incorporate parts of the Program into other free
     programs whose distribution conditions are different, write to the
     author to ask for permission.  For software which is copyrighted
     by the Free Software Foundation, write to the Free Software
     Foundation; we sometimes make exceptions for this.  Our decision
     will be guided by the two goals of preserving the free status of
     all derivatives of our free software and of promoting the sharing
     and reuse of software generally.

                                NO WARRANTY

 11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO
     WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE
     LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
     HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT
     WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT
     NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
     FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE
     QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
     PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY
     SERVICING, REPAIR OR CORRECTION.

 12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
     WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY
     MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE
     LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL,
     INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
     INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
     DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU
     OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY
     OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN
     ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

                      END OF TERMS AND CONDITIONS

Appendix: How to Apply These Terms to Your New Programs
=======================================================

If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

   To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

     ONE LINE TO GIVE THE PROGRAM'S NAME AND A BRIEF IDEA OF WHAT IT DOES.
     Copyright (C) YYYY  NAME OF AUTHOR
     
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
     
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
     
     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
     USA.

   Also add information on how to contact you by electronic and paper
mail.

   If the program is interactive, make it output a short notice like
this when it starts in an interactive mode:

     Gnomovision version 69, Copyright (C) 19YY NAME OF AUTHOR
     Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
     This is free software, and you are welcome to redistribute it
     under certain conditions; type `show c' for details.

   The hypothetical commands `show w' and `show c' should show the
appropriate parts of the General Public License.  Of course, the
commands you use may be called something other than `show w' and `show
c'; they could even be mouse-clicks or menu items--whatever suits your
program.

   You should also get your employer (if you work as a programmer) or
your school, if any, to sign a "copyright disclaimer" for the program,
if necessary.  Here is a sample; alter the names:

     Yoyodyne, Inc., hereby disclaims all copyright interest in the program
     `Gnomovision' (which makes passes at compilers) written by James Hacker.
     
     SIGNATURE OF TY COON, 1 April 1989
     Ty Coon, President of Vice

   This General Public License does not permit incorporating your
program into proprietary programs.  If your program is a subroutine
library, you may consider it more useful to permit linking proprietary
applications with the library.  If this is what you want to do, use the
GNU Library General Public License instead of this License.


File: lbtt.info,  Node: Overview,  Next: Test methods,  Prev: Copying,  Up: Top

Overview
********

`lbtt' is a tool for automatic testing of programs which translate
formulas expressed in propositional linear temporal logic ("LTL") into
Bu"chi automata. These finite-state automata over infinite words are
used e.g. in automata-theoretic model checking *Note [VW86]::, *Note
[Var96]::, where they can help in detecting errors in the
specifications of finite-state hardware or software systems. Usually
the model checking procedure involves first composing an automaton with
a formal model of a given system, and the result of the composition
reveals whether any execution path of the system violates some property
that the automaton represents.  (For an introduction to model checking
techniques in general, see, for example, *Note [CGP99]::.)

   The property to be model checked is often specified as an LTL
formula, and the Bu"chi automaton used for model checking is obtained
automatically from the formula with a translation algorithm. (Detailed
descriptions and optimization techniques for such algorithms can be
found, for example, in *Note [GPVW95]::, *Note [Cou99]:: *Note
[DGV99]::, *Note [Ete99]::, *Note [SB00]::, *Note [EH00]::, *Note
[EWS01]::, *Note [GO01]::.)  In practice, the implementation
correctness of such a translation algorithm is crucial to the soundness
of the model checking procedure.

   The goal of `lbtt' is to assist in the correct implementation of
LTL-to-Bu"chi translation algorithms by providing an automated testing
environment for LTL-to-Bu"chi translators. Testing consists of running
LTL-to-Bu"chi translators on randomly generated (or user-specified) LTL
formulas as input and then performing simple consistency checks on the
resulting automata to test whether the translators seem to operate
correctly in practice. (See *Note [TH02]:: for more information on the
theory behind the testing methods.) If the tests suggest an
implementation error in a translator, `lbtt' can generate sample data
which causes a test failure and which may also be useful for debugging
the implementation.

   Additionally, the testing environment can be used for very basic
profiling of different LTL-to-Bu"chi translators to evaluate their
performance.

_ Note: although `lbtt' might be able to detect implementation errors
in an LTL-to-Bu"chi translator, it is only a testing tool and is
therefore incapable of formally proving any translation algorithm
implementation to be correct. Therefore, the test results should never
be used as the sole basis for any formal conclusions about the
correctness of an implementation.  _


File: lbtt.info,  Node: Test methods,  Next: Invocation,  Prev: Overview,  Up: Top

Test methods
************

This chapter describes the algorithms `lbtt' uses for generating input
for the tests and introduces some terminology.  A short description of
each test is also included together with the outline of `lbtt''s
testing procedure. However, the chapter is not intended to be a
thorough introduction to the theoretical background of the different
tests; see, for example, *Note [TH02]:: or *Note [Tau00]:: for more
information.

* Menu:

* Random input generation::     How `lbtt' generates input for the
				  tests.
* Testing procedure::           Outline of `lbtt''s testing
				  procedure.
* Model checking result cross-comparison test::
				Model checking the same LTL formula in
				  a fixed state space using different
				  LTL-to-Bu"chi translators should
				  give the same model checking result.
* Model checking result consistency check::
				Model checking two complementary LTL
				  formulas in the same state space using
				  an LTL-to-Bu"chi translator should
				  give consistent results.
* Buchi automata intersection emptiness check::
				The intersection of the languages
				  accepted by two Bu"chi automata
				  constructed from two complementary
				  LTL formulas should be empty.


File: lbtt.info,  Node: Random input generation,  Next: Testing procedure,  Prev: Test methods,  Up: Test methods

Random input generation
=======================

By default, all tests `lbtt' makes are based on randomly generated
input. However, the LTL formulas used as input for the LTL-to-Bu"chi
translators can be optionally given by the user by telling `lbtt' to
read LTL formulas from a file (*note `--formulafile' command line
option: --formulafile.).

   Additionally, some of the tests make use of randomly generated
"state spaces", which are basically directed labelled graphs with
labels on nodes with the additional requirement of having at least one
arc leaving each node. The label of each node is a subset of a finite
collection of atomic propositions (representing a set of conditions
which may or may not hold in a state), which occur also in the LTL
formulas used in the tests.

   The following sections describe how `lbtt' generates input for the
tests and list the parameters which can be used to adjust the behavior
of the input generation algorithms.

* Menu:

* Random LTL formulas::         How `lbtt' generates random
				  LTL formulas.
* Random state spaces::         How `lbtt' generates random
				  state spaces.


File: lbtt.info,  Node: Random LTL formulas,  Next: Random state spaces,  Prev: Random input generation,  Up: Random input generation

Random LTL formulas
-------------------

The LTL formulas used by `lbtt' are built from atomic propositions
(with names of the form `pN' for some nonnegative integer N), the
Boolean constants `true' and `false', and logical or temporal
operators. `lbtt' supports the following logical operators:

   * logical disjunction (`\/' as shown in output messages),

   * logical conjunction (`/\'),

   * logical negation (`!'),

   * logical implication (`->')

   * logical equivalence (`<->')

   * logical "exclusive or" (`xor')


and the following temporal operators:

   * "Next time" (`X'),

   * "(Strong) Until" (`U'),

   * "Weak Until" (also known as "Unless") (`W'),

   * "Finally" ("Eventually") (`<>')

   * "Before" (`B')

   * "(Weak) Release", the dual of "(Strong) Until" (`V'),

   * "Strong Release", the dual of "Weak Until" (`M'),

   * "Globally" ("Always", "Henceforth") (`[]').


See *Note LTL formulas::, for a reference on the exact semantics of
these operators.

   The behavior of `lbtt''s random formula generation algorithm can be
adjusted with the following parameters:

   * Number of nodes in the parse tree of a formula (i.e., the total
     number of occurrences of propositions, Boolean constants and
     operators in the formula).

   * Number of different atomic propositions that can be used for
     generating a formula. (Note that this does not restrict the total
     number of atomic propositions in the formula, nor the number of
     occurrences of any individual proposition. However, none of the
     generated formulas will have more than this number of _different_
     atomic propositions.)

   * Priorities for the Boolean constants and atomic propositions. The
     priority of a symbol determines the relative likelihood of its
     occurrence in a generated formula. The higher the priority of a
     symbol, the more likely it will occur (with respect to the other
     symbols) in a generated formula; a zero priority will exclude the
     symbol altogether.

   * Priorities for the logical and temporal operators.


Note that the priorities for atomic symbols (Boolean constants and
atomic propositions) and the priorities of the logical and temporal
operators are independent, i.e., changing the priority of an atomic
symbol does not affect the occurrence likelihood of any logical or
temporal operator and vice versa.

   For further details, see *Note The formula generation algorithm::
for a pseudocode description of the algorithm used for generating
random LTL formulas.


File: lbtt.info,  Node: The formula generation algorithm,  Prev: Random LTL formulas,  Up: Random LTL formulas

The formula generation algorithm
................................

`lbtt' uses an algorithm similar to the one outlined in *Note [DGV99]::
for generating random LTL formulas. The algorithm can be described in
pseudocode as follows:

     1  function RandomFormula(N : Integer) : LtlFormula;
     2      if N = 1 then begin
     3          P := random atomic proposition or TRUE or FALSE;
     4          return P;
     5      end
     6      else if N = 2 then begin
     7          OP := random unary operator;
     8          F := RandomFormula(1);
     9          return OP F;
     10     end
     11     else begin
     12         OP := random unary or binary operator;
     13         if OP is a unary operator then begin
     14             F := RandomFormula(N-1);
     15             return OP F;
     16         end
     17         else begin
     18             X := random integer in the interval [1,N-2];
     19             F1 := RandomFormula(X);
     20             F2 := RandomFormula(N-X-1);
     21             return (F1 OP F2);
     22         end;
     23     end;
     24 end;

   Each invocation of the algorithm returns an LTL formula with N nodes
in the formula parse tree. The behavior of the algorithm can be adjusted
by giving values for the parameters N (the number of nodes in the
formula parse tree), |AP| (the number of different atomic
propositions), and pri(SYMBOL) (the priorities for the different
symbols).

   In `lbtt''s implementation of the above algorithm, the priority of a
symbol determines the probability with which the symbol is chosen into
a generated formula each time line 3, 7 or 12 of the algorithm is
executed. For Boolean constants `true' and `false' (line 3 of the
algorithm), the probability is given by the equation

   pri(CONSTANT) / (pri(AP) + pri(`true') + pri(`false'))

where CONSTANT is either `true' or `false', and pri(AP) is the total
priority of all atomic propositions.

   The probability of choosing a particular atomic proposition into a
formula (line 3) is

   pri(AP) / (|AP| * (pri(AP) + pri(`true') + pri(`false'))),

where |AP| and pri(AP) are as defined above.

   Line 7 of the algorithm concerns choosing a unary operator (`!',
`X', `<>' or `[]') into a formula. Here the probability of choosing the
unary operator OP is given by the equation

   pri(OP) / Sum (pri(OP')),

where OP' ranges over all unary operators.

   Finally, at line 12 of the algorithm, the probability of choosing
the (unary or binary) operator OP into the formula is

   pri(OP) / Sum (pri(OP')),

where OP' ranges over all unary and binary operators (`!', `\/', `/\',
`->', `<->', `xor', `X', `U', `W', `<>', `B', `V', `M', `[]').

   An analysis of this algorithm is included in an appendix of *Note
[Tau00]::.  The analysis shows how to use the operator priorities to
calculate the expected number of occurrences of an operator in a
randomly generated formula. `lbtt' can optionally compute the expected
operator distribution for a given combination of operator priorities;
see the `--showoperatordistribution' command line option (*note
`--showoperatordistribution' command line option:
--showoperatordistribution.)  for more information.


File: lbtt.info,  Node: Random state spaces,  Prev: Random LTL formulas,  Up: Random input generation

Random state spaces
-------------------

State spaces are needed as input for tests only in the model checking
result cross comparison test (*note Model checking result
cross-comparison test::) and the model checking result consistency check
(*note Model checking result consistency check::).  The state spaces
are directed labelled graphs, each node of which is labelled with a
randomly chosen set of atomic propositions (the propositions that hold
in the state corresponding to the graph node). In addition, each state
of the state space always has at least one successor.

   `lbtt' provides three different random state space generation
algorithms that differ in the structure of the generated state spaces.
The common parameters for each of these algorithms are:

   * Number of states in the state space.

   * Maximum number of different atomic propositions allowed in the
     label of any state of the state space.

   * The probability with which each atomic proposition should hold in
     a state of the state space (which is, for simplicity, common to
     all atomic propositions).


The different types of random state spaces that can be generated are:

  1. Random connected graphs. These state spaces are guaranteed to have
     at least one state such that every other state of the state space
     is reachable from this state. In addition to the three above
     parameters, the behavior of the algorithm generating these state
     spaces can be adjusted by specifying a probability which
     approximates the "density" of the graph, i.e., the probability
     that there is a directed edge from a state X to another state Y,
     where X and Y are any two states in the state space. For more
     details, see *Note Algorithm for generating connected graphs::.

  2. Random graphs. These state spaces are constructed simply by taking
     all pairs (X, Y) of states in the state space and connecting state
     X to state Y with a user-specified probability that approximates
     the graph density.

  3. Random paths. A random path is simply a non-branching sequence of
     states, where the last state of the sequence is connected to a
     randomly chosen state earlier in the sequence.


   `lbtt' also includes a state space generation algorithm which
systematically enumerates all "paths" (see above) of a given size with a
given number of atomic propositions in each state. If |S| is the number
of states in the path and |AP| is the number of atomic propositions in
each state of the path, it is easy to see that the number of different
paths having these parameters is

   |S| * 2^(|S| * |AP|),

a number which grows exponentially in the product of the two parameters.
Obviously, this makes the exhaustive enumeration of all paths of a
given size practicable only for very small values of |S| and |AP|.

   In practice, you should always start testing using only very small
state spaces (say, with only 10-50 states and a small density)
regardless of the particular algorithm chosen for generating the state
spaces. The size of the state spaces can then be increased if `lbtt''s
memory consumption stays within acceptable limits.


File: lbtt.info,  Node: Algorithm for generating connected graphs,  Prev: Random state spaces,  Up: Random state spaces

Algorithm for generating connected graphs
.........................................

`lbtt' uses the following algorithm for generating random connected
graphs:

     1  function RandomGraph(N : Integer; D : Real in [0.0,1.0];
     			T : Real in [0.0,1.0]) : Graph;
     2      S := {s1, s2, ..., sn};
     3      NODESTOPROCESS := {s1};
     4      UNREACHABLENODES := {s2, s3, ..., sn};
     5      EDGES := {};
     6      while NODESTOPROCESS is not empty do begin
     7          STATE := a random node in NODESTOPROCESS;
     8          remove STATE from NODESTOPROCESS;
     9          LABEL(STATE) := {};
     10         for all P in AP do
     11             if RandomNumber(0.0, 1.0) < T then
     12                 insert P into LABEL(STATE);
     13         if UNREACHABLENODES is not empty then begin
     14             STATE' := a random node in UNREACHABLENODES;
     15             remove STATE' from UNREACHABLENODES;
     16             insert STATE' into NODESTOPROCESS;
     17             insert (STATE,STATE') into EDGES;
     18         end;
     19         for all STATE' in S do
     20             if RandomNumber(0.0, 1.0) < D then begin
     21                 insert (STATE,STATE') into EDGES;
     22                 if STATE' is in UNREACHABLENODES then begin
     23                     remove STATE' from UNREACHABLENODES;
     24                     insert STATE' into NODESTOPROCESS;
     25                 end;
     26             end;
     27         if there is no edge (STATE,STATE') in EDGES
     				     for any STATE' in S then
     28             insert (STATE,STATE) into EDGES;
     29     end;
     30     return <S, EDGES, s1, LABEL>;
     31 end;

   The algorithm receives the parameters N (number of states in the
state spaces), D (approximate density of the generated graph) and T
(the probability with which each of the propositions in AP should hold
in a state) and returns the generated state space as a quadruple <S,
EDGES, s1, LABEL>. Here S is the set of states, EDGES is the set of
directed edges between the states, s1 is a state from which every state
of the state space can be reached, and LABEL is a function which maps
each state to its label (a subset of AP).


File: lbtt.info,  Node: Testing procedure,  Next: Model checking result cross-comparison test,  Prev: Random input generation,  Up: Test methods

Testing procedure
=================

The following figure illustrates the first two tests in `lbtt''s
testing procedure:

 [image src=testprocedure.png text=",,,,,,,,,,,,,,,
: State space :
'''''''''''''''
  |
  |     ,,,,,,,,,,,,,,,,,,,          ,,,,,,,,,,,,,,,,,,,,,,,,,,,,
  |     : LTL formula `f' :_____     : Negated LTL formula `!f' :
  |     '''''''T''''''T''''     \\ ___'''''''T'''''''''''T''''''''
  |            |       \\      ___X         /            |
  |            |        \\ ___/    \\______ /             |
  |            |      ___X               X_______       |
  |            |     /    \\             /        \\      |
  |            V    V      V           V          V     V
  |     ::::::::::::::::  ::::::::::::::::       ::::::::::::::::
  |     : LTL-to-Buchi :  : LTL-to-Buchi : . . . : LTL-to-Buchi :
  |     : translator 1 :  : translator 2 :       : translator n :
  |     ::::::::::::::::  ::::::::::::::::       ::::::::::::::::
  |        |        |            |   |              /       |
  |        |        |            |   |             /        |
  |        V        V            |   |            V         V
  | ,,,,,,,,,,,,, ,,,,,,,,,,,,,, |   | ,,,,,,,,,,,,, ,,,,,,,,,,,,,,
  | : Automaton : : Automaton  : |   | : Automaton : : Automaton  :
  | : 1 for `f' : : 1 for `!f' : |   | : n for `f' : : n for `!f' :
  | ''T'''''''''' '''T'''''''''' |   | ''''''''''T'' '''''''''''T''
  |   |            _/            V   V            \\_____         \\_
  |   |           /   ,,,,,,,,,,,,, ,,,,,,,,,,,,,,      \\          \\
  |   |          |    : Automaton : : Automaton  :       |          |
  |   |          |    : 2 for `f' : : 2 for `!f' :       |          |
  |   |          |    '''''''''T''' '''''''T''''''       |          |
  |   !          !             !           !             !          |
  |__________________________________________________________       |
  |   .   \\      .      \\      .    \\      .      \\      .   \\      |
  |   :    \\     :       \\     :     \\     :       \\     :    \\     |
  |   |     \\    |        \\    |      \\    |        \\    |     \\    |
  V   V      V   V         V   V       V   V         V   V      V   V
:::::::::  :::::::::     :::::::::   :::::::::     :::::::::  :::::::::
: Model :  : Model :     : Model :   : Model :     : Model :  : Model :
: check :  : check :     : check :   : check :     : check :  : check :
:::::::::  :::::::::     :::::::::   :::::::::     :::::::::  :::::::::
 |    \\         |   \\     /    |       |    \\     /   |         /    |
 |     \\        |    \\   /     |       |     \\   /    |        /     |
 |      \\       |     \\ /      |       |      \\ /     |       /      |
 |       V      V      X       V       V       X      V      V       |
 |  ###############   / \\   ###############   / \\   ###############  |
 |  # Consistency #  |   |  # Consistency #  |   |  # Consistency #  |
 |  #    check    #  |   |  #    check    #  |   |  #    check    #  |
 |  ###############  |   |  ###############  |   |  ###############  |
  \\______            |    \\_______   _______/    |            ______/
         \\           |            \\ /            |           /
          |          |             X             |          |
          |          |           _/ \\_           |          |
          V          V          V     V          V          V
         #########################   #########################
         # Cross-comparison test #   # Cross-comparison test #
         #########################   #########################
" ]

After obtaining an LTL formula f (either by reading it from a file or
by calling the random formula generation algorithm), `lbtt' invokes
each LTL-to-Bu"chi translator participating in the tests in turn to
construct a collection of Bu"chi automata for the formula f _and_ the
negated formula ! f.  Each of these automata is then composed with the
randomly generated state space, whereafter `lbtt' performs the model
checking result cross-comparison test (*note Model checking result
cross-comparison test::) and the model checking result consistency check
(*note Model checking result consistency check::) on the model checking
results, and reports all detected failures.

   The Bu"chi automata intersection emptiness check (*note Buchi
automata intersection emptiness check::) operates as follows (note that
the LTL-to-Bu"chi translation phase is repeated in this figure only for
completeness; in reality, `lbtt' performs this phase only once):

 [image src=intersectioncheck.png text="        ,,,,,,,,,,,,,,,,,,,          ,,,,,,,,,,,,,,,,,,,,,,,,,,,,
        : LTL formula `f' :_____     : Negated LTL formula `!f' :
        '''''''T''''''T''''     \\ ___'''''''T'''''''''''T''''''''
               |       \\      ___X         /            |
               |        \\ ___/    \\______ /             |
               |      ___X               X_______       |
               |     /    \\             /        \\      |
               V    V      V           V          V     V
        ::::::::::::::::  ::::::::::::::::       ::::::::::::::::
        : LTL-to-Buchi :  : LTL-to-Buchi : . . . : LTL-to-Buchi :
        : translator 1 :  : translator 2 :       : translator n :
        ::::::::::::::::  ::::::::::::::::       ::::::::::::::::
           |        |            |   |              /       |
           |        |            |   |             /        |
           V        V            |   |            V         V
    ,,,,,,,,,,,,, ,,,,,,,,,,,,,, |   | ,,,,,,,,,,,,, ,,,,,,,,,,,,,,
    : Automaton : : Automaton  : |   | : Automaton : : Automaton  :
    : 1 for `f' : : 1 for `!f' : |   | : n for `f' : : n for `!f' :
    ''''''''''''' ''T''''''''''' |   | ''''''''''T'' ''''''''''''''
   /       ________/             |   |            \\_________       \\
  /       /                      V   V                      \\       \\ 
 /       /            ,,,,,,,,,,,,, ,,,,,,,,,,,,,,           \\       \\
|       |             : Automaton : : Automaton  :            |       |
|      / \\            : 2 for `f' : : 2 for `!f' :           / \\      |
|     |   |           ''T''''T''T'' ''T''T''''T'''          |   |     |
|     |   |             |    |  |     |  |    |             |   |     |
|     |   V             V    |  |     |  |    V             V   |     |
|     |  #################   |   \\   /   |   #################  |     |
|     |  # Intersection  #   |    \\ /    |   # Intersection  #  |     |
|     |  #   emptiness   #   |     X     |   #   emptiness   #  |     |
|     |  #     check     #   !    / \\    !   #     check     #  |     |
|\\    |  #################   :   /   \\   :   #################  |    /|
| \\    \\___________        _____/     \\_____        ___________/    / |
|  \\               \\      /  .           .  \\      /               /  |
|   \\             / \\    |   :           :   |    / \\             /   |
|    V           V   \\   |   |           |   |   /   V           V    |
|  #################  \\ /    V           V    \\ /  #################  |
|  # Intersection  #   X   #################   X   # Intersection  #  |
|  #   emptiness   #  / \\  # Intersection  #  / \\  #   emptiness   #  |
|  #     check     # |   | #   emptiness   # |   | #     check     #  |
|  ################# |   | #     check     # |   | #################  |
|\\                   |   | ################# |   |                   /|
| \\                 /     \\                 /     \\                 / |
|  V               V       V               V       V               V  |
|   #################      #################      #################   |
|   # Intersection  #      # Intersection  #      # Intersection  #   |
|   #   emptiness   #      #   emptiness   #      #   emptiness   #   |
|   #     check     #      #     check     #      #     check     #   |
|   #################      #################      #################   |
 \\                                                                   /
  \\                        #################                        /
   \\                       # Intersection  #                       /
    +--------------------->#   emptiness   #<---------------------+
                           #     check     #
                           #################
" ]

   The test procedure can then be repeated using a different LTL formula
and/or a different state space.


File: lbtt.info,  Node: Model checking result cross-comparison test,  Next: Model checking result consistency check,  Prev: Testing procedure,  Up: Test methods

Model checking result cross-comparison test
===========================================

LTL model checking can be used to test whether any of the infinite paths
starting from some state of a state space satisfies a given LTL
formula. For a fixed LTL formula, this question may have a different
answer in different states of the state space, but the answer should be
independent of the details of any (correct) implementation of the LTL
model checking procedure.

   Therefore, it is possible to test LTL-to-Bu"chi translators by
comparing the results obtained by model checking an LTL formula in a
fixed state space several times, using each time a different translator
for constructing a Bu"chi automaton from the LTL formula. Differences
in the model checking results then suggest that at least one of the
translators failed to translate the LTL formula correctly into an
automaton.

   To extract as much test data as possible from a state space, `lbtt'
will by default make the model checking result comparison "globally" in
the state space, which means using each LTL-to-Bu"chi translator to
find _all_ states in the state space with an infinite path supposedly
satisfying some LTL formula and then comparing the resulting state sets
for equality. Alternatively, the test can be performed only "locally"
in a single state of each state space (i.e., by choosing some state of
the state space and checking that all Bu"chi automata constructed using
the different translators give the same model checking result in that
state), which may speed up testing, but will reduce the number of
comparison tests. In addition, `lbtt' repeats the result
cross-comparison test for the negation of each LTL formula, since model
checking also the negated formula permits making an additional
consistency check (see below) on the results computed using each
implementation.

   Note: If the generated state spaces are paths (either random or
systematically enumerated, *note Random state spaces::), `lbtt' will
then include its internal LTL model checking algorithm (a restricted
model checking algorithm used normally in test failure analysis, *note
Analyzing test results::) into the model checking result
cross-comparison test. This is especially useful if there is only one
translation algorithm implementation available for testing (in which
case normal model checking result cross-comparison is obviously
redundant) but may be of advantage also in other cases by providing an
additional implementation to include in the tests.


File: lbtt.info,  Node: Model checking result consistency check,  Next: Buchi automata intersection emptiness check,  Prev: Model checking result cross-comparison test,  Up: Test methods

Model checking result consistency check
=======================================

LTL model checking tells whether any of the infinite paths starting
from some state of a state space satisfies a given LTL formula. If there
are no such paths beginning from the state, it follows that all
infinite paths beginning from the state must then satisfy the
_negation_ of the same formula. Since all state spaces used by `lbtt'
always have at least one path beginning from each state of the state
space (guaranteed by the state space generation algorithms), at least
one path beginning from any state must satisfy either the formula or its
negation, i.e., it cannot be the case that none of the paths is a model
of either formula.

   However, implementation errors in an LTL-to-Bu"chi translator used
for model checking may actually lead to this inconsistent model
checking result if the translation of either of the formulas results in
an incorrect automaton, in which case `lbtt' will report an error.

   Similarly to the model checking result cross-comparison test, the
model checking result consistency check can be performed either in all
states of the state space ("globally") or only in a single state of the
state space ("locally"), with the same trade-offs between testing speed
and number of tests as described in the previous section (*note Model
checking result cross-comparison test::).


File: lbtt.info,  Node: Buchi automata intersection emptiness check,  Prev: Model checking result consistency check,  Up: Test methods

Buchi automata intersection emptiness check
===========================================

The semantics of LTL guarantee that no model of an LTL formula can be
the model of the negation of the same formula. In terms of Bu"chi
automata, this implies that the languages accepted by automata
constructed from two complementary LTL formulas should be disjoint.
This can be confirmed by intersecting the automata (i.e., by composing
the automata to construct a third Bu"chi automaton that accepts
precisely those inputs accepted by both of the original automata) and
checking the result for emptiness. If the intersection is found to be
nonempty, however, at least one of the LTL-to-Bu"chi translator(s) used
for constructing the original automata must have failed to perform the
translation of either formula correctly.


File: lbtt.info,  Node: Invocation,  Next: Interpreting the output,  Prev: Test methods,  Up: Top

Invocation
**********

`lbtt' is started with the command `lbtt' with optional command line
parameters. Before starting the program, however, you need to create a
configuration file which lists the LTL-to-Bu"chi translators to be
tested and defines additional testing parameters.  *Note Configuration
file::. If no suitable configuration file is found or if the
configuration file cannot be processed successfully, `lbtt' exits with
an error message.

   After reading the configuration file `lbtt' starts tests on the
LTL-to-Bu"chi translators listed in the configuration file (for details
about the testing procedure, see *Note Test methods::). The program
exits after a predetermined number of test rounds.

   If the program is started in any of its interactive modes (see *Note
Interactivity modes::), the program may occasionally pause to wait for
user input between test rounds. Type `quit <ENTER>' at the prompt to
exit `lbtt' at this point (or see *Note Analyzing test results::, for
more information on how to use `lbtt''s internal commands).

* Menu:

* Configuration file::          Description of the configuration file
				  format.
* Command line options::        List of command line options.


File: lbtt.info,  Node: Configuration file,  Next: Command line options,  Prev: Invocation,  Up: Invocation

Configuration file
==================

The configuration file of `lbtt' contains a list of the LTL-to-Bu"chi
translators to be tested along with other options which affect the way
the tests are performed. The configuration file is processed before
starting the tests. By default, `lbtt' will try to read the
configuration from the file `config' in the current working directory;
a different file name can be specified with the `--configfile=FILENAME'
command line option.

   The configuration file consists of one or more sections, each of
which provides a collection of interrelated configuration options. The
general format of the configuration file is

     SECTION-NAME
     {
       OPTION-NAME = VALUE
       OPTION-NAME = VALUE
       ...
     }
     
     ...

Section and option names are case-insensitive. Values can be numbers,
strings or truth values (`yes' and `no', or equivalently, `true' and
`false'). String values are case-sensitive and must be always enclosed
in quotes (`"').  The backslash (`\') is treated as an escape character
(to be used e.g. if the string itself contains quotes; use `\\' to get
a backslash).

   Comments can be included by putting a `#' symbol before them; the
end of any line containing the `#' character will be ignored when
processing the configuration file.

   The configuration file must contain at least one `Algorithm' section
specifying an LTL-to-Bu"chi translator. The other sections are optional
and can be used to override the default testing parameters.

* Menu:

* Algorithm section::           Each LTL-to-Bu"chi translator to be
				    tested requires a separate
				    `Algorithm' section in the
				    configuration file.
* GlobalOptions section::       Options for changing the general
				    behavior of `lbtt'.
* FormulaOptions section::      Options controlling the way random
				    LTL formulas are generated.
* StateSpaceOptions section::   Options controlling the way random
				    state spaces are generated.
* Sample configuration file::   An example of a configuration file.


File: lbtt.info,  Node: Algorithm section,  Next: GlobalOptions section,  Prev: Configuration file,  Up: Configuration file

The `Algorithm' section
-----------------------

Each LTL-to-Bu"chi translator to be tested requires a separate
`Algorithm' section in the configuration file; there must be at least
one such section in the file. The translators are assumed to be
accessible through external executable files. Therefore, this section
must at a minimum specify the full file name of the executable to run
in order to invoke the translator; see *Note Translator interface::,
for information about the conventions `lbtt' uses to communicate with
the LTL-to-Bu"chi translators.

   Translators specified in the configuration file are given unique
integer identifiers in the order they are listed in the configuration
file, starting from zero. These numbers must be used when referring to
the different translators when using `lbtt''s internal commands (*note
Analyzing test results::).

   The following options (in alphabetical order) are available within
this section:

`Enabled = TRUTH-VALUE'
     This option determines whether the translator should be initially
     included in or excluded from the tests. The default value is
     `Yes'. The translator can be enabled or disabled during testing
     with `lbtt''s internal commands (*note Test control commands::).

`Name = STRING'
     This option can be used to specify a textual identifier for the
     LTL-to-Bu"chi translator. This identifier will then be used when
     displaying various messages concerning the implementation. (If no
     name has been explicitly given for the translator, `lbtt' assigns
     the translator a name of the form `Algorithm N', where N is the
     running integer identifier for the translators.)

`Parameters = STRING'
     This option can be used to specify any additional parameters that
     should be passed to the translator executable whenever running it.
     (The default value of this option is the empty string.)

`Path = STRING'
     This option must be given a value for each translator specified in
     the configuration file. The value should be the complete file name
     of the program which is used to run the translator.



File: lbtt.info,  Node: GlobalOptions section,  Next: FormulaOptions section,  Prev: Algorithm section,  Up: Configuration file

The `GlobalOptions' section
---------------------------

The `GlobalOptions' section includes options that affect the general
behavior of `lbtt'. Options available within this section are (in
alphabetical order):

`ComparisonCheck = TRUTH-VALUE'
`ComparisonTest = TRUTH-VALUE'
     This option can be used to enable or disable the model checking
     result cross-comparison test (*note Model checking result
     cross-comparison test::).  The test is enabled by default.

`ConsistencyCheck = TRUTH-VALUE'
`ConsistencyTest = TRUTH-VALUE'
     This option can be used to enable or disable the model checking
     result consistency check (*note Model checking result consistency
     check::). The test is enabled by default.

`Interactive = Always | OnError | Never'
     The interactivity mode determines whether `lbtt' should pause to
     wait for user input between test rounds. A value of `Always' causes
     `lbtt' to pause unconditionally after each test round, `OnError'
     will interrupt testing only after failed test rounds, and `Never'
     will simply run all tests without interruption.

     The default value for this option is `Always'.

`IntersectionCheck = TRUTH-VALUE'
`IntersectionTest = TRUTH-VALUE'
     This option can be used to enable or disable the Bu"chi automata
     intersection emptiness check (*note Buchi automata intersection
     emptiness check::).  The test is enabled by default.

`ModelCheck = Local | Global'
     This option determines whether `lbtt' should perform model checking
     with respect to all states of each state space or only with respect
     to a single state of each state space. This affects the number of
     tests that `lbtt' makes during the model checking result
     cross-comparison test (*note Model checking result
     cross-comparison test::) and the model checking result consistency
     check (*note Model checking result consistency check::).  Global
     model checking (the default) maximizes the number of tests, but may
     require more time and memory. (Note: This option has no effect if
     none of the model checking tests is enabled.)

`Rounds = INTEGER'
     The `Rounds' option can be used to specify the number of test
     rounds to run; the default value is 10.

`Verbosity = INTEGER'
     This option sets the verbosity level for output messages. The value
     can be an integer between 0 and 5 (inclusive). A value of 0 will
     suppress all messages (and is therefore useful only when storing
     test results into a log file; *note `--logfile' command line
     option: --logfile.); increasing the value results in more output.
     The default value is 3.



File: lbtt.info,  Node: FormulaOptions section,  Next: StateSpaceOptions section,  Prev: GlobalOptions section,  Up: Configuration file

The `FormulaOptions' section
----------------------------

The `FormulaOptions' section defines the parameters that affect the
algorithm `lbtt' uses for generating random LTL formulas (for more
information about the algorithm, see *Note Random LTL formulas::).
This section provides the following options:

`AbbreviatedOperators = TRUTH-VALUE'
     This option determines whether the generated formulas should be
     allowed to include any of the operators `->', `<->', `xor', `W',
     `<>', `B', `V', `M' or `[]' (all of which can be given definitions
     using only the operators `!', `\/', `/\', `U' and `V'). Setting
     this option to `No' assigns each of the abbreviated operators a
     zero priority, overriding any explicit priorities defined for
     these operators in the program configuration. The default value
     for the option is `Yes', so abbreviations are allowed by default.

`AndPriority = INTEGER'
     Priority of the logical conjunction operator (`/\').

`BeforePriority = INTEGER'
     Priority of the temporal operator "before" (`B'). (Note: This
     option has no effect if `AbbreviatedOperators' is set to `No'.)

`ChangeInterval = INTEGER'
     This option determines how often (in number of test rounds) `lbtt'
     should generate a new random LTL formula (or read a new formula
     from a user-specified file). A value of 0 forces `lbtt' to use a
     fixed LTL formula for all tests. The default value is 1, i.e., a
     new formula will be generated at the beginning of each test round.

`DefaultOperatorPriority = INTEGER'
     This option sets the priority for all formula operators for which
     no priority has been given explicitly in the program configuration
     (i.e., it can be used as a shorthand to initialize the priority of
     all operators).  The default value of this option is 0, so all
     operators with no explicitly given priorities are disabled by
     default.

`EquivalencePriority = INTEGER'
     Priority of the logical equivalence operator (`<->'). (Note: This
     option has no effect if `AbbreviatedOperators' is set to `No'.)

`FalsePriority = INTEGER'
     Priority of the Boolean constant `false' (with respect to
     priorities of the constant `true' and the atomic propositions).

`FinallyPriority = INTEGER'
     Priority of the temporal operator "finally" (`<>'). (Note: This
     option has no effect if `AbbreviatedOperators' is set to `No'.)

`GenerateMode = Normal | NNF'
     This option determines whether `lbtt' should generate random
     formulas directly into (a weakened version of) negation normal
     form in which the negation operator may only precede atomic
     propositions. Note that the formulas may still contain
     "abbreviated" operators if they have nonzero priorities--use
     `AbbreviatedOperators=No' or `OutputMode=NNF' if you wish to
     prevent this. The default value for this option is `Normal'.  (See
     the `OutputMode' option below for an example about the differences
     in the effects of the `GenerateMode' and `OutputMode' options.)

`GloballyPriority = INTEGER'
     Priority of the temporal operator "globally" (`[]'). (Note: This
     option has no effect if `AbbreviatedOperators' is set to `No'.)

`ImplicationPriority = INTEGER'
     Priority of the logical implication operator (`->'). (Note: This
     option has no effect if `AbbreviatedOperators' is set to `No'.)

`NextPriority = INTEGER'
     Priority of the temporal operator "next time" (`X').

`NotPriority = INTEGER'
     Priority of the logical negation operator (`!').

`OrPriority = INTEGER'
     Priority of the logical disjunction operator (`\/').

`OutputMode = Normal | NNF'
     This option determines whether `lbtt' should transform each
     generated LTL formula into (strict) negation normal form before
     passing it to LTL-to-Bu"chi translators. If the value is set to
     `NNF', `lbtt' will rewrite each generated formula into a form
     consisting of the operators `!', `\/', `/\', `U' and `V' such that
     all negations in the formula (if any) precede atomic propositions.
     The default value is `Normal'. (See also the `GenerateMode' option
     that can be used to force formulas to be generated directly into
     negation normal form.)

     The option is probably useful only if you have a translator which
     does not support the "abbreviated" operators directly, but you
     still wish to test it with formulas which describe properties
     expressed using these operators.  Note, however, that rewriting
     may change the size of the formula.

     The following table illustrates the effects of the `GenerateMode'
     and the `OutputMode' options.

       LTL formula     Can f be       OutputMode's effect on the
            f        generated if       formula passed to the
     		GenerateMode     LTL-to-Bu"chi translators
     		   =NNF ?
       -------------------------------------------------------------
       (p1 V ! p0)       Yes       Normal/NNF: (p1 V ! p0)
     
       [] p0 -> <> p1    Yes*      Nor: [] p0 -> <> p1
     			      NNF: (true U ! p0) \/ (true U p1)
     
       ! <> p0            No       Nor: ! <> p0
     			      NNF: (false V ! p0)
     
       * only if AbbreviatedOperators=Yes

`PropositionPriority = INTEGER'
     Priority for atomic propositions with respect to the priority of
     Boolean constants. This priority is the common priority of _all_
     atomic propositions.

`Propositions = INTEGER'
     This option sets the maximum number of different atomic
     propositions in each generated LTL formula. No generated formula
     will have more than this number of different atomic propositions.
     A value of 0 will generate random formulas with only Boolean
     constants (one of which must in this case have a nonzero
     priority). The default value is 5. The names of the propositions
     are of the form `pN', where N is a nonnegative integer less than
     the maximum number of propositions.

`RandomSeed = INTEGER'
     This option specifies a seed value for generating random numbers
     for the random LTL formula generation algorithm. If this option is
     not present, the seed defaults to 1. See the next section for
     information on how to change the default seed for the random state
     space generation algorithm.

     (The reason for having two separate random seeds is to make the
     sequences of random formulas and state spaces independent of each
     other. For example, this makes it easy to repeat tests using the
     same batch of random LTL formulas, but with state spaces of
     different size.)

`ReleasePriority = INTEGER'
     Priority of the temporal "(weak) release" operator (`V').

`Size = INTEGER'
`Size = MINIMUM-SIZE...MAXIMUM-SIZE'
     This option defines how many nodes are allowed in the parse tree
     of each randomly generated LTL formula. If the size is given as an
     interval (by separating the bounds with three dots with no white
     space in between), `lbtt' chooses the size of each formula
     randomly in the interval using a uniform random distribution. The
     default size is 5.

`StrongReleasePriority = INTEGER'
     Priority of the temporal "strong release" operator (`M'). (Note:
     This option has no effect if `AbbreviatedOperators' is set to
     `No'.)

`UntilPriority = INTEGER'
     Priority of the temporal "(strong) until" operator (`U').

`TruePriority = INTEGER'
     Priority of the Boolean constant `true' (with respect to the
     priorities of the constant `false' and the atomic propositions).

`WeakUntilPriority = INTEGER'
     Priority of the temporal "weak until" operator (`W'). (Note: This
     option has no effect if `AbbreviatedOperators' is set to `No'.)

`XorPriority = INTEGER'
     Priority of the logical "exclusive or" operator (`xor'). (Note:
     This option has no effect if `AbbreviatedOperators' is set to
     `No'.)



File: lbtt.info,  Node: StateSpaceOptions section,  Next: Sample configuration file,  Prev: FormulaOptions section,  Up: Configuration file

The `StateSpaceOptions' section
-------------------------------

The `StateSpaceOptions' section defines the parameters that affect the
way `lbtt' generates random state spaces for the model checking result
cross-comparison test (*note Model checking result cross-comparison
test::) and the model checking result consistency check (*note Model
checking result consistency check::).  See also *Note Random state
spaces::, for more information about the different types of available
state spaces and the algorithms used for constructing them.  The
options available within this section are:

`ChangeInterval = INTEGER'
     This option determines how often (in number of test rounds) `lbtt'
     should generate a new random state space. A value of 0 forces
     `lbtt' to use a fixed state space for all tests. The default
     behavior is to generate a new state space at the beginning of each
     test round.

`EdgeProbability = PROBABILITY'
     This option sets the approximate probability (between 0.0 and 1.0)
     of adding a transition from any state X to some other state Y when
     generating random graphs as state spaces. The default value is
     0.2. The probability is approximate because `lbtt' still has to
     ensure that all states of each generated state spaces have at
     least one successor, which might require adding extra transitions
     to the graph.  Note: This option has no effect if `GenerateMode'
     is set to `RandomPath' or `EnumeratedPath'.

`GenerateMode = RandomConnectedGraph | RandomGraph | RandomPath | EnumeratedPath'
     This option selects the type of generated state spaces from the
     four available types. The default value is `RandomConnectedGraph'.
     See *Note Random state spaces::, for more information on the
     different state space types.

     Note: Using the `RandomPath' or the `EnumeratedPath' setting
     includes `lbtt''s internal model checking algorithm into the
     various model checking tests if they are enabled. For more
     information, see *Note Model checking result cross-comparison
     test::.

`Propositions = INTEGER'
     This option sets the number of atomic propositions attached to
     each state of the generated state spaces. The default value is 5.

     Usually this should probably be the same as the maximum number of
     different atomic propositions in the generated formulas (*note
     FormulaOptions section::).  If the number of propositions attached
     to each state of the state spaces is less than the maximum number
     of different propositions that may occur in the generated
     formulas, all "extra" propositions in the formulas are considered
     to be false in every state of the state space.

`RandomSeed = INTEGER'
     This option specifies a seed value for generating random numbers
     required by the random state space generation algorithm. If this
     option is not present, the seed defaults to 1. See the previous
     section for how to change the random seed used to initialize the
     random number generator for the random LTL formula generation
     algorithm.

`Size = INTEGER'
`Size = MINIMUM-SIZE...MAXIMUM-SIZE'
     This option sets the number of states in the generated state
     spaces. If the size is given as an interval, `lbtt' either chooses
     a random size in the interval (including its endpoints) each time
     a new state space is generated, or, if `GenerateMode' is set to
     `EnumeratedPath', enumerates all state spaces in the specified
     range systematically, starting from the minimum size. The default
     size is 20.

`TruthProbability = PROBABILITY'
     Probability (between 0.0 and 1.0) with which each individual
     atomic proposition has the value `true' in any state of the state
     space. Note: This option has no effect if `GenerateMode' is set to
     `EnumeratedPath'. The default value is 0.5.



File: lbtt.info,  Node: Sample configuration file,  Prev: StateSpaceOptions section,  Up: Configuration file

Sample configuration file
-------------------------

The following configuration file sets `lbtt' up for testing two
imaginary LTL-to-Bu"chi translators.

     # Sample configuration file for lbtt
     
     Algorithm
     {
       Name = "Translator 1"
       Path = "~/lbtt/bin/t-1"           # location of the translator
     				    # executable
       Enabled = Yes
     }
     
     Algorithm
     {
       Name = "Translator 2"
       Path = "~/lbtt/bin/t-2"
       Parameters = "-x -y 3 -v 0"       # parameters to be passed to the
     				    # `~/lbtt/bin/t-2' executable
       Enabled = Yes
     }
     
     GlobalOptions
     {
       Rounds = 100                      # 100 test rounds
     
       Interactive = OnError             # pause only in case of an error
     
       Verbosity = 1                     # suppress most of the output
     
       ComparisonTest = Yes              # enable all tests except the
       ConsistencyTest = Yes             # Bu"chi automata intersection
       IntersectionTest = No             # emptiness test
     
       ModelCheck = Local                # perform the tests only in a
     				    # single state of each state
     				    # space
     }
     
     FormulaOptions
     {
       AbbreviatedOperators = Yes        # formula generation mode
       GenerateMode = Normal
       OutputMode = Normal
     
       ChangeInterval = 1                # new formula after each test
     				    # round
     
       RandomSeed = 4632912              # random seed
     
       Size = 5...15                     # 5 to 15 nodes in the parse
     				    # tree of each formula
     
       Propositions = 3                  # max. 3 different propositions
     				    # in each LTL formula
     
       PropositionPriority = 50          # priorities for propositional
       TruePriority = 1                  # symbols
       FalsePriority = 1
     
       AndPriority = 10                  # priorities for some logical
       OrPriority = 10                   # operators
       NotPriority = 10
     
       NextPriority = 5                  # priorities for some temporal
       UntilPriority = 5                 # operators
       ReleasePriority = 5
     
       DefaultOperatorPriority = 0       # disable all the remaining
     				    # operators
     }
     
     StatespaceOptions
     {
       GenerateMode = RandomGraph        # generate random (not
     				    # necessarily connected) graphs
     				    # as state spaces
     
       ChangeInterval = 10               # new state space after every
     				    # 10th test round
     
       RandomSeed = 37620                # random seed
     
       Size = 50                         # 50 states in each state space
     
       Propositions = 3                  # 3 propositions in each state
     				    # of each state space
     
       EdgeProbability = 0.1             # approximate probability of
     				    # having a transition between
     				    # any two states
     
       TruthProbability = 0.5            # probability with which any
     				    # atomic proposition is true in
     				    # a state
     }


File: lbtt.info,  Node: Command line options,  Prev: Configuration file,  Up: Invocation

Command line options
====================

This section lists the command line options that may be used when
invoking `lbtt'. The command line options are processed only after
reading the configuration file, so they can be used to override the
settings given in the file. There are also a few options for which
there is no direct equivalent in the configuration file options.

* Menu:

* Special options::             Options available only as command line
				  parameters.
* Global options::              Options corresponding to the
				  `GlobalOptions' section of the
				  configuration file.
* LTL formula options::         Options corresponding to the
				  `FormulaOptions' section of the
				  configuration file.
* State space options::         Options corresponding to the
				  `StateSpaceOptions' section of the
				  configuration file.


File: lbtt.info,  Node: Special options,  Next: Global options,  Prev: Command line options,  Up: Command line options

Special options
---------------

The following list presents all command line options for which there is
no (directly) corresponding option that may be set in the program
configuration file.

`--configfile=FILE-NAME'
     This option can be used to instruct `lbtt' to read program
     configuration from another file instead of the default
     configuration file `config' in the current working directory.

`--formulafile=FILE-NAME'
     This option instructs `lbtt' to read the LTL formulas used in the
     tests from a file instead of generating them randomly. The file
     should contain LTL formulas separated from each other with white
     space. Currently the only supported format for the formulas is the
     same prefix notation that `lbtt' uses for its output files (*note
     Format for LTL formulas::, for details).

     If this option is used, all LTL formula generation parameters in
     the command line or in the configuration file are ignored.

`--h'
`--help'
     These options list all the available command line parameters.

`--logfile=FILE-NAME'
     This option instructs `lbtt' to create a log of all errors
     encountered during testing. By default no log will be created.

`--profile'
     This option can be used as a shorthand for disabling all Bu"chi
     automata correctness tests. The test report generated at the end
     of testing then shows only the running times of each tested
     LTL-to-Bu"chi translator and the sizes of the generated automata.

`--quiet'
`--silent'
     These options suppress any messages that are normally displayed
     during testing. These options also imply the `--nopause' option,
     i.e., all tests will be run without interruption. Use the
     `--logfile' option (see above) with these options to save a test
     failure report into a log file.

`--showconfig'
     If this option is present on the command line, `lbtt' will write
     the current configuration to standard output (*note Configuration
     information::) and then exit.  This option can be used together
     with the `--configfile' option to test the settings defined in a
     configuration file without actually performing any tests.

`--showoperatordistribution'
     With this option `lbtt' uses the priorities defined for the LTL
     formula operators available for random LTL formula generation to
     compute the expected number of occurrences of each operator in a
     single randomly generated formula. The distribution is then
     displayed along with other configuration information when the
     program starts.

`--skip=NUMBER-OF-ROUNDS'
     This option can be used to skip the first NUMBER-OF-ROUNDS test
     rounds, i.e., begin testing from round NUMBER-OF-ROUNDS+1.

`--version'
     This option displays the version of the `lbtt' executable.



File: lbtt.info,  Node: Global options,  Next: LTL formula options,  Prev: Special options,  Up: Command line options

Global options
--------------

The following list presents the options that can be used to override the
values specified in the `GlobalOptions' section of the configuration
file.

`--comparisontest'
`--nocomparisontest'
     These options enable or disable the model checking result
     cross-comparison test (*note Model checking result
     cross-comparison test::).

`--consistencytest'
`--noconsistencytest'
     These options enable or disable the model checking result
     consistency check (*note Model checking result consistency
     check::).

`--disable=IMPLEMENTATION-ID[,IMPLEMENTATION-ID...]'
     This option can be used to exclude some implementations from the
     tests by specifying a comma-separated list of integers (the
     implementation identifiers).  The implementations are numbered in
     the order in which they appear in the configuration file, starting
     from zero. (The `--showconfig' option, see *Note Special
     options::, can be used to obtain a list of the implementations
     specified in the configuration file, together with their
     identifiers.)

`--enable=IMPLEMENTATION-ID[,IMPLEMENTATION-ID...]'
     This option can be used to include implementations into the tests
     (in the case they are initially disabled in the configuration
     file).

`--globalmodelcheck'
     This option instructs `lbtt' to perform model checking globally
     (with respect to all states of each random state space) in the
     model checking result cross-comparison test and the model checking
     result consistency check. Using a global check increases the
     number of possible tests.

`--interactive=always | onerror | never'
     This option can be used to override whether `lbtt' should pause
     between test rounds to wait for user input.

`--intersectiontest'

`--nointersectiontest'
     These options enable or disable the Bu"chi automata intersection
     emptiness check (*note Buchi automata intersection emptiness
     check::).

`--localmodelcheck'
     This option instructs `lbtt' to perform model checking only with
     respect to a single state of each random state space in the model
     checking result cross-comparison test and the model checking
     result consistency check.

`--modelcheck=global | local'
     This option can be used to select the model checking mode.

`--nopause'
     This option forces `lbtt' to run all tests without interruption.

`--pause'
     This option forces `lbtt' to pause between each test round to wait
     for user commands.

`--pauseonerror'
     Using this option will cause testing to be paused each time an
     error occurs during testing, giving the user an opportunity to
     analyze the error situation using `lbtt''s internal commands
     before proceeding to the next test round.

`--rounds=NUMBER-OF-ROUNDS'
     This option can be used to override the number of test rounds to
     run.

`--verbosity=INTEGER'
     This option sets the verbosity of output messages. The value must
     be between 0 and 5 (inclusive).



File: lbtt.info,  Node: LTL formula options,  Next: State space options,  Prev: Global options,  Up: Command line options

LTL formula options
-------------------

The following command line options can be used to control the behavior
of `lbtt''s random LTL formula generation algorithm. They correspond to
the options available in the `FormulaOptions' section of the
configuration file.

`--abbreviatedoperators'
`--noabbreviatedoperators'
     These options can be used to allow or prevent `lbtt' from using
     any of the "abbreviated" operators (`->', `<->', `xor', `W', `<>',
     `B', `M' and `[]') when generating random LTL formulas.

`--andpriority'
     This option sets the priority for logical conjunction (the `/\'
     operator).

`--beforepriority'
     This option sets the priority for the temporal "before" operator
     (`B').

`--defaultoperatorpriority'
     This option sets the default priority for all logical and temporal
     operators.

`--equivalencepriority'
     This option sets the priority for logical equivalence (the `<->'
     operator).

`--falsepriority'
     This option sets the priority for the Boolean constant `false'.

`--finallypriority'
     This option sets the priority for the temporal "finally" operator
     (`<>').

`--formulachangeinterval=NUMBER-OF-ROUNDS'
     This option determines how often (in number of test rounds) `lbtt'
     should generate a new random LTL formula. A value of 0 forces
     `lbtt' to use a fixed LTL formula for all tests.

`--formulageneratemode=normal | nnf'
     This option can be used to choose how `lbtt' should generate random
     LTL formulas. With the option `--formulageneratemode=nnf', all
     generated formulas will be in (a weakened) negation normal form in
     which all negations in the formula (if any) precede atomic
     propositions. (Note that the formulas may still contain some of
     the "abbreviated" operators if their priorities are not explicitly
     set to zero.)

`--formulaoutputmode=normal | nnf'
     This option can be used to force or prevent `lbtt' from converting
     each LTL formula into (strict) negation normal form (i.e.,
     rewriting it with the operators `!', `/\', `\/', `U' and `V')
     before passing it to the LTL-to-Bu"chi translators.

`--formulapropositions'
     This option sets the maximum number of different atomic
     propositions that `lbtt' may use for generating random LTL
     formulas.

`--formularandomseed=INTEGER'
     This option gives a seed value for generating random numbers used
     by the random LTL formula generation algorithm.

`--formulasize=INTEGER'
`--formulasize=MINIMUM-SIZE...MAXIMUM-SIZE'
     This option sets the size of the random LTL formulas generated for
     the tests.  The size can be given either as a fixed integer or as
     an interval, in which case the size of each generated formula will
     be chosen randomly in the interval using a uniform random
     distribution.

`--generatennf'
`--nogeneratennf'
     These options can be used instead of the `--formulageneratemode'
     option to select the random formula generation mode.

`--globallypriority'
     This option sets the priority for the temporal "globally" operator
     (`[]').

`--implicationpriority'
     This option sets the priority for logical implication (the `->'
     operator).

`--nextpriority'
     This option sets the priority for the temporal "next time" operator
     (`X').

`--notpriority'
     This option sets the priority for logical negation (the `!'
     operator).

`--orpriority'
     This option sets the priority for logical disjunction (the `\/'
     operator).

`--outputnnf'
`--nooutputnnf'
     These options can be used instead of the `--formulaoutputmode'
     option to choose the format in which `lbtt' passes LTL formulas to
     LTL-to-Bu"chi translators.

`--propositionpriority'
     This option sets the priority for atomic propositions.

`--releasepriority'
     This option sets the priority for the temporal "(weak) release"
     operator (`V').

`--strongreleasepriority'
     This option sets the priority for the temporal "strong release"
     operator (`M').

`--truepriority'
     This option sets the priority for the Boolean constant `true'.

`--untilpriority'
     This option sets the priority for the temporal "(strong) until"
     operator (`U').

`--weakuntilpriority'
     This option sets the priority for the temporal "weak until"
     operator (`W').

`--xorpriority'
     This option sets the priority for the logical "exclusive or"
     operator.


   Note also the `--formulafile=FILE-NAME' option (*note
`--formulafile' option: --formulafile.), which can be used to instruct
`lbtt' to read LTL formulas from a file instead of generating them
randomly.


File: lbtt.info,  Node: State space options,  Prev: LTL formula options,  Up: Command line options

State space options
-------------------

The following command line options affect the way in which `lbtt'
generates state spaces that are then used in the model checking tests.
They correspond to options in the `StateSpaceOptions' section of the
configuration file. See also *Note Random state spaces::, for more
information about the graph generation modes.

`--edgeprobability=PROBABILITY'
     This option sets the approximate random edge probability for state
     spaces. (The option has no effect if the generated state spaces
     are random or enumerated paths.)

`--enumeratedpath'
     This option instructs `lbtt' to enumerate all paths of a given size
     as state spaces instead of generating random state spaces for
     model checking tests. The option also enables `lbtt''s internal
     model checking algorithm.

`--randomconnectedgraph'
     This option makes `lbtt' generate random connected graphs as state
     spaces for model checking tests.

`--randomgraph'
     This option makes `lbtt' generate random graphs as state spaces for
     model checking tests.

`--randompath'
     This option forces `lbtt' to generate random paths as state spaces.
     The option also enables `lbtt''s internal model checking algorithm
     in the model checking tests.

`--statespacechangeinterval=NUMBER-OF-ROUNDS'
     This option sets the frequency (in test rounds) in which new state
     spaces are generated. A value of 0 forces `lbtt' to use a fixed
     state space for all tests.

`--statespacegeneratemode=randomconnectedgraph | randomgraph | randompath | enumeratedpath'
     This option can be used instead of one of the four options above
     to select the state space generation mode.

`--statespacerandomseed=INTEGER'
     This option gives a seed value for generating random numbers
     required by the random state space generation algorithm.

`--statespacesize=INTEGER'
`--statespacesize=MINIMUM-SIZE...MAXIMUM-SIZE'
     This option can be used to change the size of the generated state
     spaces.

`--truthprobability=PROBABILITY'
     This option sets the probability that `lbtt' uses for choosing the
     valuation for each atomic proposition in each state of the
     randomly generated state spaces. (This option has no effect is
     using enumerated paths as state spaces.)



File: lbtt.info,  Node: Interpreting the output,  Next: Analyzing test results,  Prev: Invocation,  Up: Top

Interpreting the output
***********************

This chapter briefly intoduces the most typical messages that `lbtt'
outputs during testing when running in its default output verbosity
mode (3). In lower verbosity modes some (or all) of these messages will
be suppressed; higher verbosity modes show information about `lbtt''s
internal behavior.

* Menu:

* Configuration information::   The current configuration is shown
				  before starting tests.
* Test round messages::         Conventions for reporting test
				  results and test failures.
* Test statistics::             Shown at the end of testing.


File: lbtt.info,  Node: Configuration information,  Next: Test round messages,  Prev: Interpreting the output,  Up: Interpreting the output

Configuration information
=========================

Before starting tests, `lbtt' shows a short summary of the current
program configuration as obtained by reading the program configuration
file and interpreting the command line parameters. The same summary can
be obtained without running any tests by using the `--showconfig'
command line option (*note `--showconfig' option: --showconfig.). The
information will be written also to the error log file if one was
specified in the command line with the `--logfile' option (*note
`--logfile' option: --logfile.).  The summary consists of the following
information:

   * LTL-to-Bu"chi translator implementations enabled for testing.

   * List of enabled tests.

   * Random state space generation parameters.

   * Random LTL formula generation parameters (unless reading LTL
     formulas from a file; *note `--formulafile' command line option:
     --formulafile.).  This includes information about all enabled
     formula operators and their priorities. When using the command
     line option `--showoperatordistribution' (*note
     `--showoperatordistribution' option: --showoperatordistribution.),
     `lbtt' shows also the expected number of occurrence of each
     operator in each randomly generated formula.


Example:

     Program configuration:
     ----------------------
     
       1000 test rounds.
       Testing will be interrupted in case of an error.
       Using global model checking for tests.
       Writing error log to `error.log'.
     
       Implementations:
         0: `Implementation 0'
         1: `Implementation 1'
     
       Enabled tests:
         Model checking result cross-comparison test
         Model checking result consistency check
         Bu"chi automata intersection emptiness check
     
       Random state spaces:
         Random connected graphs (50 states, 5 atomic propositions)
         New state space will be generated after every 5th round.
         Random seed: 98
         Random edge probability: 0.10
         Propositional truth probability: 0.50
     
       Random LTL formulas:
         5 parse tree nodes, 5 atomic propositions
         New LTL formula will be generated after every round.
         Random seed: 17991
         Atomic symbols in use (priority):
           false (5); propositions (90); true (5)
         Operators used for random LTL formula generation:
           operator  !        /\       U        V        X        \/
           priority  10       20       20       20       10       20


File: lbtt.info,  Node: Test round messages,  Next: Test statistics,  Prev: Configuration information,  Up: Interpreting the output

Test round messages
===================

The following example shows a fragment of the output that `lbtt' might
produce during a test round:

1. Round 6 of 10

2.     Generating random state space

3.     Random LTL formula:
         formula:                   ((p1 <-> p0) U (p0 \/ ! p3))
         negated formula:           ! ((p1 <-> p0) U (p0 \/ ! p3))

       0: `Implementation 0'
         Positive formula:
4.         Bu"chi automaton:
             number of states:      6
             number of transitions: 15
             acceptance sets:       1
             computation time:      0.03      seconds (user time)
5.         Product automaton:
             number of states:      582       [97.00% of worst case (600)]
             number of transitions: 7188
6.         Accepting cycles:
             cycle reachable from   0         states
             not reachable from     100       states
7.       Negated formula:
           Bu"chi automaton:
             number of states:      4
             number of transitions: 6
             acceptance sets:       0
             computation time:      0.04      seconds (user time)
           Product automaton:
             number of states:      363       [90.75% of worst case (400)]
             number of transitions: 2581
           Accepting cycles:
             cycle reachable from   25        states
             not reachable from     75        states
8.       Result consistency check:
           result:                  failed    [75 (75.00%) of 100 test cases]

The numbered parts of the output are:

  1. Number of the test round.

  2. `lbtt' generates a new random state space for model checking
     tests. (In this case the size of the state spaces was fixed in the
     configuration; if the state space size is allowed to vary in an
     interval, `lbtt' would also show here the actual size of the
     generated state space.)

  3. Information about a random LTL formula and its negation. Note that
     in the printed output, it is assumed (to remove some parentheses)
     that all unary formula operators have strictly higher precedence
     than binary operators.

  4. Information about the Bu"chi automaton that `Implementation 0'
     generated from the positive LTL formula (number of states,
     transitions and acceptance conditions).

  5. Information about the synchronous product of the state space and
     the Bu"chi automaton constructed from the positive formula.

  6. Model checking result information. In this case, the automaton
     cannot reach an "accepting cycle" regardless of the state of the
     state space in which the automaton could begin its execution. In
     other words, the random state space contains no states with an
     infinite path beginning from the state such that the Bu"chi
     automaton accepts the temporal interpretation of the path (the
     infinite sequence of state labels on the path).

     (If the implementation used for translating the positive formula
     `((p1 <-> p0) U (p0 \/ ! p3))' into a Bu"chi automaton is known to
     be correct, the result would then also indicate that no infinite
     path in the state space satisfies the formula.)

  7. The model checking process is repeated using the negated formula as
     input for the LTL-to-Bu"chi translator `Implementation 0'.

  8. `lbtt' performs the model checking result consistency check (*note
     Model checking result consistency check::) using the model checking
     results computed for the positive and the negative formula. In
     this case, the result consistency check fails in 75 states of the
     state space. This implies that `Implementation 0' failed to
     translate one (or both) of the formulas into a Bu"chi automaton
     correctly.


   The output of phases 4--8 will be repeated for each implementation
included in the tests. After this `lbtt' proceeds to the model checking
result cross-comparison test (*note Model checking result
cross-comparison test::) and the Bu"chi automata intersection emptiness
test (*note Buchi automata intersection emptiness check::).

   The model checking result cross-comparison test might result in the
following output:

    Model checking result cross-comparison:
      result:
        failed (+)  0: `Implementation 0', 1: `Implementation 1'

   Throughout all test failure reports, `lbtt' refers to the positive
and negated formulas with the symbols `+' and `-', respectively.
Therefore, the above message indicates that the model checking results
obtained using `Implementation 0' and `Implementation 1' for the
positive formula do not agree. A similar line will be shown for all
pairs of implementations for which the test failed.

   `lbtt' also reports if the model checking result cross-comparison
could not be performed between a pair of implementations (for example,
if one of the implementations failed to generate an automaton); in this
case, the result of the test is `N/A'.

   If using enumerated or randomly generated paths as state spaces, the
model checking results are also compared against those given by
`lbtt''s internal model checking algorithm. In the output, the internal
implementation has the name `lbtt' and no numeric identifier.

   A similar convention is used to report failures in the Bu"chi
automata intersection emptiness check. However, because this test is
always performed on Bu"chi automata constructed from two complementary
LTL formulas, a test failure report shows LTL formula information
beside the name of the implementation used for generating the Bu"chi
automaton from that formula.  Note that the Bu"chi automata
intersection emptiness check may fail on the automata constructed by
the same implementation; in the following example, the check failed
between the automata constructed by `Implementation 0', and the
automata constructed by `Implementation 0' and `Implementation 1' from
the positive and negative formulas, respectively.

    Bu"chi automata intersection emptiness check:
      result:
        failed      0: `Implementation 0'
        failed (+)  0: `Implementation 0', (-) 1: `Implementation 1'

   If using a log file (*note `--logfile' command line option:
--logfile.), a summary of all testing errors will be written to the
file using the output format specified above.


File: lbtt.info,  Node: Test statistics,  Prev: Test round messages,  Up: Interpreting the output

Test statistics
===============

At the end of testing, `lbtt' outputs some simple statistics computed
over all tests. If using an error log file (*note `--logfile' command
line option: --logfile.), the statistics will be stored also in the log
file. These statistics can be also accessed during interactive testing
by using the internal command `statistics' (*note `statistics' command:
statistics.).  In brief, the statistics include:

   * Number of generated state spaces and the total number of states and
     transitions in them.

   * Number of processed LTL formulas (not counting the negations of
     each formula). If using random formulas, `lbtt' also shows the
     overall distribution of each individual proposition, Boolean
     constant and logical or temporal operator in the sample of
     randomly generated formulas.  Theoretically, in a large sample of
     random formulas, this distribution should correspond to the one
     that can be computed before testing by using the
     `--showoperatordistribution' command line option (*note
     `--showoperatordistribution' command line option:
     --showoperatordistribution.).

   * Automata statistics for each implementation:

        - number of generated Bu"chi automata and product automata

        - total and average numbers of states, transitions and
          acceptance sets in the generated Bu"chi/product automata, and

        - total and average time consumed in generating the Bu"chi
          automata.

   * Number of times that each implementation failed to generate an
     acceptable automaton from an input formula.

   * Number of failures in the model checking result consistency check
     (*note Model checking result consistency check::) for each
     implementation.

   * Number of result inconsistencies detected in pairwise comparison
     of the Bu"chi automata generated by different implementations.
     Depending on the model checking mode and which correctness tests
     are enabled, the output may include none, some or all of the
     following information:

        - Overall number of failures in the model checking result
          cross-comparison test (*note Model checking result
          cross-comparison test::) for each pair of implementations.

        - Number of failures in the model checking result
          cross-comparison test in a single fixed state of each
          generated state space (called the "initial" state of the
          state space).

        - Number of failures in the Bu"chi automata intersection
          emptiness check (*note Buchi automata intersection emptiness
          check::) for each pair of implementations.

     Note that the pairwise inconsistency results form a symmetric
     matrix (although `lbtt' might display the matrix in several
     parts), which means that the same information is repeated on both
     sides of the matrix diagonal.


Where applicable, the statistics are shown separately for positive,
negative and all LTL formulas used in the tests.


File: lbtt.info,  Node: Analyzing test results,  Next: Interfacing with lbtt,  Prev: Interpreting the output,  Up: Top

Analyzing test results
**********************

This chapter documents how to use `lbtt''s internal commands to analyze
test results.

   To use the internal commands, `lbtt' must be started in one of its
interactive modes (*note Interactivity modes::). Depending on the mode,
`lbtt' may occasionally pause (either after each test round or only in
case a test failure is detected) between test rounds to wait for user
input by showing a prompt of the form

       ** [Round 22 of 1000] >>

* Menu:

* Command conventions::         Conventions for entering commands.
* Getting help::                Use the `help' command to access
				  on-line help.
* Test control commands::       Commands for continuing testing,
				  skipping tests or enabling or disabling
				  implementations.
* Data display commands::       Commands for displaying information
				  about Bu"chi automata, state spaces,
				  and LTL formulas.
* Failure analysis commands::   Commands for analyzing test failures.


File: lbtt.info,  Node: Command conventions,  Next: Getting help,  Prev: Analyzing test results,  Up: Analyzing test results

Command conventions
===================

Commands are entered by typing a command name followed by any
parameters for the command and then pressing <ENTER>.  The command
names are case-sensitive. Each parameter should be separated from the
command name and other parameters with white space.

   Command names can be abbreviated to the shortest prefix that
identifies the command unambiguously (for example, `h' could be used in
place of the `help' command).

   Some of the commands accept or require lists of implementation or
state identifiers as parameters. The lists can be specified as
comma-separated numbers (for example, `8') or intervals (for example,
`3-11') with no white space between the commas and the numbers or
intervals that belong to the same list. For example, assuming that the
state space used in the current test round has at least 23 states, the
command `statespace -5,8,14-18,22-' would display information about all
state space states with an identifier less than or equal to 5, together
with information about state 8, states 14 to 18 (inclusive) and all
states with an identifier greater than or equal to 22. The `*' symbol
can be used as a shorthand for all identifiers in the available range.

   Some of the commands require a formula identifier as a parameter for
choosing between a positive and a negative LTL formula. The formula
identifier (`+' for positive formula, `-' for negative formula) must
follow the command name as the first parameter for the command. If the
formula identifier is omitted, the positive formula is assumed.

   The output of most commands (excluding the test control commands,
*note Test control commands::) can be redirected or appended to a file
by ending the command line with `>filename' or `>>filename',
respectively.

   Optionally, the output can be written to a pipe (to be processed by
an external program) instead of a file. This is done by ending the
command line with `| COMMAND', where COMMAND is the command line for the
external program intended to process the output produced by `lbtt'.
For example, the output of the (`lbtt''s internal) command can be piped
to a pager application if the entire output does not fit on the screen
by itself. Using the pipe construct _without_ specifying any internal
command will simply invoke the external program.


File: lbtt.info,  Node: Getting help,  Next: Test control commands,  Prev: Command conventions,  Up: Analyzing test results

Getting help
============

Use the `help' command to access on-line help. Typing `help' with no
parameters shows a list of all available commands, together with
general conventions for using the commands. The `help' command can be
optionally given a command name as a parameter to access
command-specific help.

   In command-specific help, arguments in angle brackets (`<', `>')
denote obligatory command parameters, while arguments in square brackets
(`[', `]') are optional. A vertical bar (`|') denotes selection between
several alternatives. Arguments in double quotes should be entered
literally (without the quotes themselves).


File: lbtt.info,  Node: Test control commands,  Next: Data display commands,  Prev: Getting help,  Up: Analyzing test results

Test control commands
=====================

The following commands can be used to continue or abort testing, skip a
number of test rounds, enable or disable implementations for testing,
and change the verbosity of `lbtt''s output messages.

`continue [NUMBER-OF-ROUNDS]'
     Continue testing. If no argument is given, testing will be
     interrupted again when the current interactivity mode requires it
     (*note Interactivity modes::). The optional argument
     NUMBER-OF-ROUNDS can be used to specify a number of rounds to run;
     testing is then interrupted again after the given number of test
     rounds (or in case of a new test failure if this is required by
     the current interactivity mode).

`disable [IMPLEMENTATION-ID-LIST]'
     Disable testing of a list of implementations or all
     implementations if no list of implementations is specified. `lbtt'
     will not include these implementations in the tests in subsequent
     test rounds. (See *Note Command conventions::, for the syntax used
     for the list of implementations.)

`enable [IMPLEMENTATION-ID-LIST]'
     Enable testing of a list of implementations.

`quit'
     Display test statistics (*note Test statistics::) over the test
     rounds performed and then abort testing.

`skip [NUMBER-OF-ROUNDS]'
     Skip a number of test rounds and then return to wait for further
     user input.  If not explicitly specified, the number of rounds to
     skip defaults to 1.  Use the `--skip' command line option (*note
     The `--skip' command line option: --skip.) to begin testing from
     another test round than 1.

`verbosity [VERBOSITY-LEVEL]'
     Display or change the verbosity of `lbtt''s output messages. If no
     argument is given, show the current verbosity level, otherwise
     change the verbosity setting to the given value. The argument must
     be an integer between 0 and 5 (inclusive). (The new value will
     take effect when testing is resumed.)



File: lbtt.info,  Node: Data display commands,  Next: Failure analysis commands,  Prev: Test control commands,  Up: Analyzing test results

Data display commands
=====================

The following commands can be used to access test result information
and to inspect the LTL formulas, Bu"chi automata and the state space
used in the current test round.

`algorithms'
     Show a list of implementations declared in the program
     configuration file and whether they are currently enabled for
     testing. The list also shows the numeric identifiers of the
     implementations. These identifiers should be used with commands
     that accept or require implementation identifier lists as
     arguments.

`buchi [+ | -] IMPLEMENTATION-ID [STATE-ID-LIST | dot]'
     Display information about the structure of the Bu"chi automaton
     generated by the implementation IMPLEMENTATION-ID from the
     positive (`+') or negative (`-') LTL formula used in the current
     test round. The implementation identifier may be optionally
     followed by a list of state identifiers to display only certain
     states of the automaton (see *Note Command conventions::, for
     details on how the list should be formatted), or the keyword `dot'
     to display the automaton in a format that can be given as input
     for the `dot' tool of the GraphViz graph visualization package
     *Note [GViz]:: to obtain a graphical representation of the
     automaton.

`evaluate [+ | -] [IMPLEMENTATION-ID-LIST] [STATE-ID-LIST]'
     Display the model checking results for the positive (`+') or the
     negative (`-') formula computed using a given set of
     implementations for constructing a Bu"chi automaton from the
     formula. If no implementation list is specified, show the results
     for all implementations. The implementation identifier list may
     optionally be followed by a list of (state space) state
     identifiers to restrict the output to only a subset of all states.
     (See *Note Command conventions::, for more information about the
     format used for the lists.)

     This command can be used to look for states in which the model
     checking result cross-comparison test (*note Model checking result
     cross-comparison test::) failed for a pair of implementations.
     These state identifiers can then be used as input for the
     `resultanalysis' command (*note Failure analysis commands::).

     Note 1: Observe that the model checking results shown do not
     follow the "traditional" semantics of LTL, by which a formula is
     usually considered to hold in a set of infinite paths beginning
     from a state only if _all_ paths in the set are accepted by the
     Bu"chi automaton constructed from the formula to be model checked.
     Instead, `lbtt' will mark the result as true if even _one_ of
     these paths is accepted by the automaton.

     Note 2: If using random or enumerated paths as state spaces, `lbtt'
     accepts also the symbol `p' in the implementation identifier list.
     This symbol can be used for accessing the model checking results
     computed using `lbtt''s internal "path" model checking algorithm.

`formula [+ | -]'
     Display the positive (`+') or the negative (`-') LTL formula used
     for tests in the current test round.

`inconsistencies [IMPLEMENTATION-ID-LIST]'
     List the state space states in which the model checking result
     consistency check (*note Model checking result consistency
     check::) failed for each implementation in the list (or all
     implementations if the list is omitted).  See *Note Command
     conventions::, for information on formatting the list.  The state
     identifiers can then be used as input for the
     `consistencyanalysis' command (*note Failure analysis commands::).

`results [IMPLEMENTATION-ID-LIST]'
     Display test results for each implementation in the list (or all
     implementations if the list is omitted) in a format very similar
     to test messages shown when running `lbtt' in its default
     verbosity mode 3.  For more information about the output, see
     *Note Test round messages::; see *Note Command conventions::, for
     information on how to specify the implementations.

`statespace [STATE-ID-LIST | dot]'
     Display information about the structure of the state space used
     for model checking tests in the current test round. The optional
     STATE-ID-LIST can be used to display only a part of the whole
     state space (see *Note Command conventions::, for information on
     formatting the state list).  Alternatively, the `dot' keyword can
     be used to output the state space description in a format
     recognized by the `dot' tool of the GraphViz graph visualization
     package *Note [GViz]:: to obtain a graphical representation of the
     state space.

`statistics'
     Display statistics computed over all test rounds performed since
     the program was started. This is the same information that `lbtt'
     normally outputs at the end of testing; see *Note Test
     statistics::, for more information about the output that is
     displayed.



File: lbtt.info,  Node: Failure analysis commands,  Prev: Data display commands,  Up: Analyzing test results

Failure analysis commands
=========================

The first part of this section introduces the commands available for
identifying an LTL-to-Bu"chi translator that caused a failure in one of
the automata correctness tests. The second part describes the
conventions that `lbtt' uses for justifying the result of the analysis.

Alphabetical list of failure analysis commands
----------------------------------------------

`buchianalysis IMPLEMENTATION-ID IMPLEMENTATION-ID'
     Analyze a failure in the Bu"chi automata intersection emptiness
     check (*note Buchi automata intersection emptiness check::).  The
     two implementation identifiers select the Bu"chi automata for which
     to perform the analysis. The Bu"chi automata intersection emptiness
     check always involves automata constructed from the positive and
     the negative formulas used in the current test round. The first
     implementation identifier chooses an implementation that
     constructed an automaton from the positive formula, and the second
     identifier selects an implementation used for translating the
     negative formula into an automaton. (The identifiers can also be
     equal if one of the tested implementations failed the check
     against itself.)

     A failure in the Bu"chi automata intersection emptiness check
     implies that there exists an input sequence over subsets of atomic
     propositions that is accepted by both automata included in the
     analysis. `lbtt' examines the intersection of the automata to find
     a witness of such an input, model checks the positive formula in
     the witness, and tells which one of the automata is likely to be
     incorrect according to the following rules:

        * If the positive formula is found to hold in the witness, the
          automaton constructed from the negative formula is likely to
          contain an error.

        * If the witness is not a model for the positive formula, then
          the automaton constructed from the positive formula probably
          accepts the witness incorrectly.

`consistencyanalysis IMPLEMENTATION-ID [STATE-ID]'
     Analyze a failure in the model checking result consistency check
     (*note Model checking result consistency check::). The
     IMPLEMENTATION-ID parameter chooses the implementation to analyze.
     In addition, the optional STATE-ID parameter can be used to
     specify a state space state in which to perform the analysis (use
     the `inconsistencies' command, *Note Data display commands::, to
     see a list of all state space states in which the check failed).
     If the state identifier is not present, `lbtt' will try to find a
     state where the check failed.

     A failure in the model checking result consistency check implies
     the existence of a witness (i.e., a path in the state space used
     for the tests in the current test round) whose temporal
     interpretation is not accepted by either of two automata
     constructed from two complementary LTL formulas. In the analysis,
     `lbtt' finds such a witness, model checks the positive formula in
     the witness separately, and tells which one of the automata seems
     to reject the witness incorrectly.

`resultanalysis [+ | -] IMPLEMENTATION-ID IMPLEMENTATION-ID [STATE-ID]'
     Analyze a failure in the model checking result cross-comparison
     test (*note Model checking result cross-comparison test::) between
     two implementations on either the positive (`+') or the negative
     (`-') LTL formula used in the current test round. The
     implementation identifiers can be optionally followed by a state
     space state identifier to specify a state in which the analysis
     should be performed. (Suitable state identifiers can be found by
     looking for inconsistencies in the model checking results
     accessible with the `evaluate' command, *Note Data display
     commands::; by omitting the state identifier, `lbtt' will try to
     find a state in which the model checking result comparison failed
     between the implementations.)

     If using randomly generated or enumerated paths as state spaces,
     `lbtt' also accepts the symbol `p' in place of either of the
     implementation identifiers. This instructs `lbtt' to perform the
     analysis against `lbtt''s internal model checking algorithm.

     A failure in the model checking result cross-comparison test
     suggests that the state space used in the current test round
     contains a path which is accepted by one, but rejected by another
     automaton constructed from the same LTL formula. To determine
     which one of these automata accepts or rejects the input
     incorrectly, `lbtt' finds a witness path giving contradictory
     model checking results, model checks the formula separately in the
     witness, and tells which one of the automata seems to accept or
     reject the witness incorrectly.


Witnesses, proofs and refutations
---------------------------------

All of the above analysis commands use `lbtt''s internal model checking
algorithm to determine which one of the two automata involved in each
test is incorrect by checking whether an LTL formula holds in a witness
path extracted from the state space used in the current test round or
from the intersection of two Bu"chi automata. The witness path is a
linear sequence of states that ends in a loop, and is represented in
two parts as an initial "prefix" (which may be empty) and a "cycle"
that is considered to repeat itself indefinitely. The witness might
look as follows:

         Execution M:
           prefix:      < s0  {p0, p4},
     		     s2  {p1, p2, p3, p4} >
           cycle:       < s34  {p0, p1, p2, p3, p4},
     		     s42  {p4},
     		     s44  {p1, p4} >

In this case, the witness (or "execution" as displayed in the output) M
consists of a prefix of two states followed by a cycle of three states.
Each state is associated with a set of atomic propositions that hold in
the state.

   (The witness can be considered a small state space M = <S, R, L>
following the definition in *Note State spaces::; in the example above,
S = {s0, s2, s34, s42, s44}, R = {(s0, s2), (s2, s34), (s34, s42),
(s42, s44), (s44, s34)}, L(s0) = {p0, p4}, L(s2) = {p1, p2, p3, p4},
L(s34) = {p0, p1, p2, p3, p4}, L(s42) = {p4}, and L(s44) = {p1, p4}.)

   In the model checking result cross-comparison test and the model
checking result consistency check, the witness is an actual path
extracted from the state space used for the tests in the current test
round. In this case, the state identifiers correspond to the states of
the state space, and can be accessed with the `statespace [STATE-ID]'
command (*note Data display commands::).

   To justify the result of the analysis, `lbtt' also displays a proof
or a refutation for the LTL formula in the witness. The proof or
refutation is constructed by a recursive examination of the subformulas
of the (positive or negative) formula used in the current test round
according to the semantics of LTL and might look as follows:

         Analysis of the formula in the execution:
           M,<s0, ...> |== ((p1 U p4) <-> (! p1 -> [] p4)) :
           +-> M,<s0, ...> |== (p1 U p4) :
           |   +-> M,<s0, ...> |== p4
           +-> M,<s0, ...> |== (! p1 -> [] p4) :
     	  +-> M,<s0, ...> |== [] p4 :
     	      +-> M,<s0, ...> |== p4
     	      +-> s0 --> s2
     	      +-> M,<s2, ...> |== p4
     	      +-> s2 --> s34
     	      +-> M,<s34, ...> |== p4
     	      +-> s34 --> s42
     	      +-> M,<s42, ...> |== p4
     	      +-> s42 --> s44
     	      +-> M,<s44, ...> |== p4
     	      +-> s44 --> s34

The proof (or refutation) can be considered a tree of statements of the
form `M,<s, ...> |== SUBFORMULA' or `M,<s, ...> |/= SUBFORMULA'. Here,
the symbol `|==' is used to denote that the formula SUBFORMULA holds in
the (infinite) subsequence beginning at state `s' of the witness, and
the relational symbol `|/=' denotes the opposite. The children of each
proof tree node give justification for the claim in their parent node;
the children might be further expanded if the claims in them do not
directly follow from the definition of M. In the presence of temporal
operators, the proofs may need to be based also on the structural
properties of M. These are shown as statements of the form `sn --> sm'
to indicate that M contains a transition from the state `sn' to the
state `sm' (and, since the states in M are connected into a linear
sequence, that this is the _only_ transition originating from `sn').

   In the above example, `lbtt' claims that the formula `((p1 U p4) <->
(! p1 -> [] p4))' holds in the witness presented earlier in this
section, and that this follows (by the semantics of logical
equivalence) from the claims that the subformulas `(p1 U p4)' and `(!
p1 -> [] p4)' both hold in the same witness.  `(p1 U p4)' holds in the
witness because of the fact that p4 is included in L(s0), and the truth
of the implication `(! p1 -> [] p4)' is justified by the property that
p4 holds in all states of the (only) infinite sequence beginning at the
state s0, which can be seen from the proof.


File: lbtt.info,  Node: Interfacing with lbtt,  Next: References,  Prev: Analyzing test results,  Up: Top

Interfacing LTL-to-Bu"chi translators with `lbtt'
*************************************************

This chapter gives the details on how to use `lbtt' for testing
LTL-to-Bu"chi translation algorithm implementations that are not
supported by the basic distribution. (See *Note The lbtt-translate
utility:: for information on how to connect several publicly available
LTL-to-Bu"chi translator implementations to `lbtt'.)

* Menu:

* Translator interface::        `lbtt''s requirements for an
				  LTL-to-Bu"chi translator.
* Format for LTL formulas::     How `lbtt' passes LTL formulas
				  to the translators.
* Buchi automata::            How `lbtt' expects the translators
				  to present their output.
* The lbtt-translate utility::  An interface for two LTL-to-Bu"chi
				  translators.


File: lbtt.info,  Node: Translator interface,  Next: Format for LTL formulas,  Prev: Interfacing with lbtt,  Up: Interfacing with lbtt

Translator interface requirements
=================================

`lbtt' assumes each tested LTL-to-Bu"chi translator to be accessible by
running an executable file which should read in an LTL formula from a
file, convert it into a Bu"chi automaton and then write the automaton
into another file. For this purpose, the executable should support the
following command line interface:

     PATH-TO-PROGRAM PARAMETERS INPUT-FILE OUTPUT-FILE

where PATH-TO-PROGRAM is the full name (and location) of the
executable, PARAMETERS are any optional parameters that might be needed
for running the executable, and INPUT-FILE and OUTPUT-FILE are two file
names.  The translator executable should read its input (an LTL
formula) from INPUT-FILE and write its output (a Bu"chi automaton) into
OUTPUT-FILE (without removing the input file); see *Note Format for LTL
formulas:: and *Note Buchi automata:: for a description on how these
files should be formatted.

   The translator executable should always create an output file and
then return with a zero exit status in case no errors occur during the
translation.  `lbtt' interprets a missing output file or any non-zero
exit status as an error and will not in this case try to run any tests,
even if an automaton were successfully saved in an output file.

   To start testing the translator, add a new `Algorithm' section for
it into `lbtt''s configuration file (*note Configuration file::), for
example

     Algorithm
     {
       Name = "LTL-to-Bu"chi translator"
       Path = "~/bin/ltl-to-buchi-translator"
       Parameters = "-x -y -z"
       Enabled = Yes
     }


File: lbtt.info,  Node: Format for LTL formulas,  Next: Buchi automata,  Prev: Translator interface,  Up: Interfacing with lbtt

Input file format for LTL formulas
==================================

`lbtt' passes each LTL formula to each LTL-to-Bu"chi translator in a
file containing an LTL formula in a prefix notation followed by a
single newline. The precise grammar for the LTL formulas (in a BNF-style
notation) is as follows:

     FORMULA  ::=  `t'
     					     // "true"
     	   |  `f'
     					     // "false"
     	   |  `p'[0--9]+
     					     // atomic proposition with
     					     // a nonnegative integer
     					     // identifier
     	   |  `!' SP FORMULA
     					     // negation
     	   |  `X' SP FORMULA
     					     // "next time"
     	   |  `F' SP FORMULA
     					     // "finally"
     	   |  `G' SP FORMULA
     					     // "globally"
     	   |  `&' SP FORMULA SP FORMULA
     					     // conjunction
     	   |  `|' SP FORMULA SP FORMULA
     					     // disjunction
     	   |  `i' SP FORMULA SP FORMULA
     					     // implication
     	   |  `e' SP FORMULA SP FORMULA
     					     // equivalence
     	   |  `^' SP FORMULA SP FORMULA
     					     // exclusive or
     	   |  `U' SP FORMULA SP FORMULA
     					     // "(strong) until"
     	   |  `V' SP FORMULA SP FORMULA
     					     // "(weak) release"
     	   |  `W' SP FORMULA SP FORMULA
     					     // "weak until"
     	   |  `M' SP FORMULA SP FORMULA
     					     // "strong release"
     	   |  `B' SP FORMULA SP FORMULA
     					     // "before"

(The quoted characters denote the characters themselves; SP denotes any
nonempty string of white space. Lines containing a // are comments and
are not part of the grammar. All atomic propositions in the formula
have a nonnegative numeric identifier.)

For example, the LTL formula (in `lbtt''s infix syntax)
     (p0 U p1) -> (<> [] (! p2 <-> p3))

would be expressed in the form
     i U p0 p1 F G e ! p2 p3

in an output file.

   If your translator does not support all of the above operators, edit
the configuration file (*note Configuration file::) or use the command
line options (*note Command line options::) to prevent `lbtt' from
generating random LTL formulas with these operators.


File: lbtt.info,  Node: Buchi automata,  Next: The lbtt-translate utility,  Prev: Format for LTL formulas,  Up: Interfacing with lbtt

Output file format for Bu"chi automata
======================================

`lbtt' expects the Bu"chi automata generated by each LTL-to-Bu"chi
translator implementation to be in the format specified below. The
format encodes a generalized Bu"chi automaton (a Bu"chi automaton with
zero or more acceptance conditions) with a single initial state and
labels on transitions. For the full formal definition and some general
guidelines on how to convert your automata to support the definition,
see *Note Definitions::.

   The output file generated by the translator should contain an
AUTOMATON described using the following grammar:

     AUTOMATON  ::=  NUMBER-OF-STATES SP NUMBER-OF-ACCEPTANCE-CONDITIONS STATES
     
     NUMBER-OF-STATES  ::=  [0--9]+
     
     NUMBER-OF-ACCEPTANCE-CONDITIONS  ::=  [0--9]+
     
     STATES  ::=  STATES SP STATE
     	   |  // empty
     
     STATE  ::=  STATE-ID SP INITIAL? ACCEPTANCE-CONDITIONS SP `-1' TRANSITIONS SP `-1'
     
     STATE-ID  ::=  [0--9]+
     
     INITIAL?  ::=  `0'  |  `1'
     
     ACCEPTANCE-CONDITIONS  ::=  ACCEPTANCE-CONDITIONS SP ACCEPTANCE-SET-ID
     			|  // empty
     
     ACCEPTANCE-SET-ID  ::=  [0--9]+
     
     TRANSITIONS  ::=  TRANSITIONS SP TRANSITION
     	       |  // empty
     
     TRANSITION  ::=  STATE-ID SP GUARD-FORMULA
     
     GUARD-FORMULA  ::=  `t'
     					     // "true"
     		 |  `f'
     					     // "false"
     		 |  `p'[0--9]+
     					     // atomic proposition
     		 |  `!' SP GUARD-FORMULA
     					     // negation
     		 |  `&' SP GUARD-FORMULA SP GUARD-FORMULA
     					     // conjunction
     		 |  `|' SP GUARD-FORMULA SP GUARD-FORMULA
     					     // disjunction
     		 |  `i' SP GUARD-FORMULA SP GUARD-FORMULA
     					     // implication
     		 |  `e' SP GUARD-FORMULA SP GUARD-FORMULA
     					     // equivalence
     		 |  `^' SP GUARD-FORMULA SP GUARD-FORMULA
     					     // exclusive or

(The quoted characters denote the characters themselves; SP denotes any
non-empty string of white space. Lines containing a // are comments and
are not part of the grammar.)

   The automaton description begins with two nonnegative numbers, the
first one of which gives the number of states in the automaton, and the
second one tells the number of acceptance conditions in the automaton.
If the number of states is 0, the automaton will not accept any input.
If the number of acceptance conditions is 0, the automaton accepts an
input word if and only if it has a run on that word according to the
definition given in the Appendix (*note Definitions::).

   If the number of states is greater than zero, the acceptance
condition count should be followed by a list of states. The description
of each state begins with a numeric state identifier, which can be any
nonnegative integer. The state identifier should be followed by a
number telling whether the state is initial (`1' if yes). The automaton
should have exactly one initial state.  This number is then followed by
a list of the identifiers of the acceptance conditions to which the
state belongs. This list should be terminated with `-1'.

   The state and acceptance condition identifiers need not be
successive, and the states or acceptance conditions can be listed in
any order. The only restrictions are that the identifiers of different
states and acceptance conditions should be unique and that the total
number of different identifiers should equal NUMBER-OF-STATES or
NUMBER-OF-ACCEPTANCE-CONDITIONS, respectively. (The same identifiers
can be shared between states and acceptance conditions, however.)

   Finally, the acceptance condition list of each state should be
followed by a list of transitions (terminated again by `-1'). Each
transition consists of a state identifier (the target state of the
transition) and a propositional formula that encodes the symbols of the
alphabet 2^AP (where AP is a finite set of atomic propositions) on
which the automaton is allowed to take the transition.

   Note that the output file should always contain a valid automaton
description if the LTL-to-Bu"chi translation was successful, even in
the case that the resulting automaton is empty (`lbtt' interprets a
missing automaton description file as an error).

   The following example illustrates the file format.

     6 2          // an automaton with six states and two acceptance conditions
     0 1 -1       // state 0: initial state, no acceptance conditions
     2 p1         //     transition to state 2, guard `p1'
     5 p2         //     transition to state 5, guard `p2'
     15 p3        //     transition to state 15, guard `p3'
     -1           // end of state 0
     2 0 1 -1     // state 2: non-initial state, acceptance condition 1
     2 p1         //     transition to state 2, guard `p1'
     5 p2         //     transition to state 5, guard `p2'
     15 p3        //     transition to state 15, guard `p3'
     -1           // end of state 2
     5 0 0 -1     // state 5: non-initial state, acceptance condition 0
     5 p2         //     transition to state 5, guard `p2'
     8 & p1 p2    //     transition to state 8, guard `p1 /\ p2'
     12 & p1 p3   //     transition to state 12, guard `p1 /\ p3'
     15 p3        //     transition to state 15, guard `p3'
     -1           // end of state 5
     8 0 0 -1     // state 8: non-initial state, acceptance condition 0
     5 p2         //     transition to state 5, guard `p2'
     8 & p1 p2    //     transition to state 8, guard `p1 /\ p2'
     12 & p1 p3   //     transition to state 12, guard `p1 /\ p3'
     15 p3        //     transition to state 15, guard `p3'
     -1           // end of state 8
     15 0 1 0 -1  // state 15: non-initial state, acceptance conditions 1 and 0
     2 p1         //     transition to state 2, guard `p1'
     5 p2         //     transition to state 5, guard `p2'
     15 p3        //     transition to state 15, guard `p3'
     -1           // end of state 15
     12 0 1 0 -1  // state 12: non-initial state, acceptance conditions 1 and 0
     2 p1         //     transition to state 2, guard `p1'
     5 p2         //     transition to state 5, guard `p2'
     15 p3        //     transition to state 15, guard `p3'
     -1           // end of state 12


File: lbtt.info,  Node: The lbtt-translate utility,  Prev: Buchi automata,  Up: Interfacing with lbtt

The `lbtt-translate' utility
============================

The `lbtt' source distribution includes a small utility which can be
used as a common interface for the following publicly available
LTL-to-Bu"chi translator algorithm implementations:

   * `lbt' -- a free LTL-to-Bu"chi translation algorithm implementation
     based on the algorithm described in *Note [GPVW95]::.  See
     <http://www.tcs.hut.fi/Software/maria/tools/lbt/> for more
     information, including the source code of the implementation.

   * SPIN *Note [Hol97]:: -- a model checking tool that includes a
     module for translating LTL formulas into Bu"chi automata
     originally based on the algorithm presented in *Note [GPVW95]::.
     See <http://spinroot.com/spin/whatispin.html> for more information.


   To use `lbtt' for testing the LTL-to-Bu"chi translators included in
these tools, you should first install the tool normally by following its
installation instructions. Then add the following `Algorithm' section in
`lbtt''s configuration file:

     Algorithm
     {
       Name = "NAME FOR THE IMPLEMENTATION"
       Path = "PATH-TO-`LBTT-TRANSLATE' IMPLEMENTATION-SELECTOR PATH-TO-EXECUTABLE"
       Enabled = Yes
     }

where PATH-TO-`LBTT-TRANSLATE' contains the complete path and file name
of the `lbtt-translate' tool executable, IMPLEMENTATION-SELECTOR is
either of the options `--lbt' or `--spin', and PATH-TO-EXECUTABLE is
the full path of the tool executable. The names of these executables
are usually (assuming a normal installation) `lbt' and `spin',
respectively.

   Note: These implementations may not have built-in support for all of
the LTL formula operators available for generating random LTL formulas
with `lbtt'. See the documentation of each translator for information
about which operators are supported, and then change the parameters in
`lbtt''s configuration file accordingly to disable the unsupported
operators.

   The `lbtt-translate' utility can also be invoked directly from the
shell to translate an LTL formula into a Bu"chi automaton using either
of the above translators. Use the command `lbtt-translate --help' to
see a short summary of available options.


File: lbtt.info,  Node: References,  Next: Definitions,  Prev: Interfacing with lbtt,  Up: Top

References
**********

 [CGP99]
     E. Clarke Jr., O. Grumberg and D. Peled. Model checking. The MIT
     Press, 1999.

 [Cou99]
     J-M. Couvreur. On-the-fly verification of linear temporal logic. In
     Proceedings of the World Congress on Formal Methods in the
     Development of Computing Systems (FM'99), volume I, volume 1708 of
     Lecture Notes in Computer Science, pages 253--271.
     Springer-Verlag, 1999.

 [DGV99]
     M. Daniele, F. Giunchiglia and M. Y. Vardi. Improved automata
     generation for linear temporal logic. In Proceedings of the 11th
     International Conference on Computer Aided Verification (CAV'99),
     volume 1633 of Lecture Notes in Computer Science, pages 249--260.
     Springer-Verlag, 1999.

 [EH00]
     K. Etessami and G. Holzmann. Optimizing Bu"chi automata. In
     Proceedings of the 11th International Conference on Concurrency
     Theory (CONCUR'2000), volume 1877 of Lecture Notes in Computer
     Science, pages 153--167. Springer-Verlag, 2000.

 [Ete99]
     K. Etessami. Stutter-invariant languages, omega-automata, and
     temporal logic. In Proceedings of the 11th Conference on Computer
     Aided Verification (CAV'99), volume 1633 of Lecture Notes in
     Computer Science, pages 236--248. Springer-Verlag, 1999.

 [EWS01]
     K. Etessami, Th. Wilke and R. Schuller. Fair simulation relations,
     parity games, and state space reduction for Bu"chi automata. In
     Proceedings of the 28th International Colloquium on Automata,
     Languages and Programming (ICALP'2001), volume 2076 of Lecture
     Notes in Computer Science, pages 694--707. Springer-Verlag, 2001.

 [GO01]
     P. Gastin and D. Oddoux. Fast LTL to Bu"chi automata translation.
     In Proceedings of the 13th International Conference on Computer
     Aided Verification (CAV'01), volume 2102 of Lecture Notes in
     Computer Science, pages 53--65. Springer-Verlag, 2001.

 [GPVW95]
     R. Gerth, D. Peled, M. Y. Vardi and P. Wolper. Simple on-the-fly
     automatic verification of linear temporal logic. In Proceedings of
     15th Workshop Protocol Specification, Testing, and Verification
     (PSTV'95), pages 3--18. Chapman & Hall, 1995.

 [GViz]
     GraphViz - open source graph drawing software. See
     <http://www.research.att.com/sw/tools/graphviz/>.

 [Hol97]
     G. Holzmann. The model checker SPIN.  IEEE Transactions on
     Software Engineering, 23(5):279--295, 1997.

 [SB00]
     F. Somenzi and R. Bloem. Efficient Bu"chi automata from LTL
     formulae.  In Proceedings of the 12th International Conference on
     Computer Aided Verification (CAV'00), volume 1855 of Lecture Notes
     in Computer Science, pages 247--263. Springer-Verlag, 2000.

 [Tau00]
     H. Tauriainen. Automated testing of Bu"chi automata translators
     for linear temporal logic. Research report A66, Laboratory for
     Theoretical Computer Science, Helsinki University of Technology,
     Espoo, Finland, 2000. Available on the WWW at
     <http://www.tcs.hut.fi/Publications/info/bibdb.HUT-TCS-A66.shtml>

 [TH02]
     H. Tauriainen and K. Heljanko. Testing LTL formula translation
     into Bu"chi automata.  International Journal on Software Tools for
     Technology Transfer (STTT) 4(1):57--70, 2002.

 [Var96]
     M. Y. Vardi. An automata-theoretic approach to linear temporal
     logic.  In Logics for Concurrency: Structure versus Automata,
     volume 1043 of Lecture Notes in Computer Science, pages 238--265.
     Springer-Verlag, 1996.

 [VW86]
     M. Y. Vardi and P. Wolper. An automata-theoretic approach to
     automatic program verification. In Proceedings of the 1st IEEE
     Symposium on Logic in Computer Science (LICS'86), pages 332--344.
     IEEE Computer Society Press, 1986.



File: lbtt.info,  Node: Definitions,  Next: Configuration file option index,  Prev: References,  Up: Top

Definitions
***********

This appendix reviews the formal definitions of the objects that `lbtt'
manipulates.

* Menu:

* LTL formulas::                `lbtt' uses traditional semantics
				  for propositional linear temporal
				  logic.
* Generalized Buchi automata::  The Bu"chi automata used by `lbtt'
				  have one initial state, labels on
				  transitions and zero or more
				  acceptance conditions.
* State spaces::                State spaces are Kripke structures
				  with a total transition relation.


File: lbtt.info,  Node: LTL formulas,  Next: Generalized Buchi automata,  Prev: Definitions,  Up: Definitions

LTL formulas
============

`lbtt' uses the traditional definition for propositional linear
temporal logic. Let AP be a finite set of atomic propositions.  The set
of propositional linear temporal logic formulas is defined inductively
as follows:

   * All atomic propositions in AP and the Boolean constant `true' are
     LTL formulas.

   * If `f1' and `f2' are LTL formulas, then `! f1', `X f1', `(f1 \/
     f2)' and `(f1 U f2)' are LTL formulas.


   The semantics of linear temporal logic (i.e., a satisfiability
relation) is defined over infinite sequences x = <y(0), y(1), y(2), ...>
over subsets of AP as follows:

   * x satisfies `true' for all sequences x.

   * x satisfies an atomic proposition `p' if and only if `p' belongs
     to y(0), the first element of the sequence x.

   * x satisfies `! f' if and only if it is not the case that x
     satisfies `f'.

   * x satisfies `f1 \/ f2' if and only if x satisfies `f1' or x
     satisfies `f2'.

   * x satisfies `X f' if and only if <y(1), y(2), y(3), ...> satisfies
     `f'.

   * x satisfies `f1 U f2' if and only if there exists an i >= 0 such
     that <y(i), y(i+1), y(i+2), ...> satisfies `f2' and for all 0 <= j
     < i, <y(j), y(j+1), y(j+2), ...> satisfies `f1'.


   `lbtt' also supports the following operators and Boolean constants,
the definitions of which can be given in terms of the previously defined
operators:

   * "false": `false' := `! true'

   * logical conjunction: `(f1 /\ f2)' := `! (! f1 \/ ! f2)'

   * logical implication: `(f1 -> f2)' := `(! f1 \/ f2)'

   * logical equivalence: `(f1 <-> f2)' := `((f1 -> f2) /\ (f2 -> f1))'

   * logical "exclusive or": `(f1 xor f2)' := `! (f1 <-> f2)'

   * temporal "finally": `<> f' := `(true U f)'

   * temporal "globally": `[] f' := `! <> ! f'

   * temporal "(weak) release": `(f1 V f2)' := `! (! f1 U ! f2)'

   * temporal "weak until": `(f1 W f2)' := `((f1 U f2) \/ [] f1)'

   * temporal "strong release": `(f1 M f2)' := `((f1 V f2) /\ <> f1)'

   * temporal "before": `(f1 B f2)' := `! (! f1 U f2)'



File: lbtt.info,  Node: Generalized Buchi automata,  Next: State spaces,  Prev: LTL formulas,  Up: Definitions

Generalized Bu"chi automata
===========================

`lbtt' uses internally finite-state automata on infinite words (Bu"chi
automata) over the alphabet 2^AP (where AP is a finite set of atomic
propositions) with one initial state, labels on transitions and zero or
more acceptance conditions.

Formal definition of generalized Bu"chi automata
------------------------------------------------

Formally, a generalized Bu"chi automaton can be represented as a tuple
<S, Q, R, q, F>, where

   * S is the _alphabet_ (S = 2^AP in this case),

   * Q is the set of _states_,

   * R (a subset of Q x 2^S x Q) is the _transition relation_,

   * q is the _initial state_, and

   * F, a collection of subsets of Q, is the set of _acceptance
     conditions_. (A "nongeneralized" Bu"chi automaton has exactly one
     acceptance condition.)


   A _run_ of a Bu"chi automaton on an infinite sequence <x(0), x(1),
x(2), ...> over the alphabet 2^AP is an infinite sequence of states
<q(0), q(1), q(2), ...>  (where each q(i) is a state in Q) such that
q(0) = q and for all i >= 0, there is a triple <q(i), X, q(i+1)> in R
such that x(i) belongs to X.  Because R is not necessarily a function
from Q x 2^S to Q, the automaton may have many runs on the same input.

   A run <q(0), q(1), q(2), ...> is _accepting_ if and only if
additionally for each acceptance condition C(j) in F, there is a state
q(j) in C(j) that occurs infinitely often in the run. The automaton
_accepts_ an infinite sequence <x(0), x(1), x(2), ...> over the
alphabet 2^AP if and only if the automaton has at least one accepting
run on this sequence.

Transition label encoding
-------------------------

In practice, a transition label of a Bu"chi automaton can be expressed
as a propositional formula, since these formulas readily encode sets of
subsets of the alphabet 2^AP, namely, the models of the formula. A
transition can then be seen as a rule "if in state q(i) and the next
input symbol x(i) is a model of the propositional formula guarding the
transition, the automaton can move to state q(i+1)".  In the context of
Bu"chi automata constructed from LTL formulas, this often allows for a
compact representation for the transitions.

Converting between equivalent definitions
-----------------------------------------

Many LTL-to-Bu"chi translation algorithms presented in the literature
(for example, *Note [GPVW95]::) use a slightly different definition for
generalized Bu"chi automata, which permits a Bu"chi automaton to have
several initial states and places the labels on states instead of
transitions. However, these Bu"chi automata can be easily converted
into an equivalent Bu"chi automaton in the above format with the
following steps (we assume here that each state of the automaton is
labelled with a set of LTL formulas that should hold in that state):

  1. Add a new state (with an empty label) into the automaton and add
     transitions from it to each initial state of the original
     automaton. Make the new state the (only) initial state of the
     automaton.

  2. For each state of the (modified) automaton, construct a
     conjunction of all propositional constraints (i.e., all formulas
     with no temporal operators) in the label of the state and copy the
     conjunction onto each transition coming into the state. Then
     remove all labels from the states.

   Conversions from other definitions can be handled in a similar way.
In some cases (e.g., if the acceptance conditions are subsets of
transitions instead of subsets of states), the conversion may also
require making copies of some states and then adjusting the transition
labels appropriately.


File: lbtt.info,  Node: State spaces,  Prev: Generalized Buchi automata,  Up: Definitions

State spaces
============

`lbtt' uses randomly generated state spaces in the model checking
result cross-comparison test (*note Model checking result
cross-comparison test::) and the model checking result consistency check
(*note Model checking result consistency check::). Formally, the state
spaces are Kripke structures with a total transition relation, i.e.,
directed graphs with a set of atomic propositions attached to each
state, with each state having at least one immediate successor (which
may be the state itself). The precise definition is as follows (as
before, let AP be a finite set of atomic propositions).

   A state space can be represented as a tuple <S, R, L>, where

   * S is the set of _states_,

   * R (a subset of S x S) is the _transition relation_, and

   * L (a function from S to 2^AP) is the _labeling function_ which
     maps each state to a set of atomic propositions that hold in the
     state.



File: lbtt.info,  Node: Configuration file option index,  Next: Command line option index,  Prev: Definitions,  Up: Top

Configuration file option index
*******************************

* Menu:

* AbbreviatedOperators [FormulaOptions]: FormulaOptions section.
* AndPriority [FormulaOptions]:          FormulaOptions section.
* BeforePriority [FormulaOptions]:       FormulaOptions section.
* ChangeInterval [FormulaOptions]:       FormulaOptions section.
* ChangeInterval [StateSpaceOptions]:    StateSpaceOptions section.
* ComparisonCheck [GlobalOptions]:       GlobalOptions section.
* ComparisonTest [GlobalOptions]:        GlobalOptions section.
* ConsistencyCheck [GlobalOptions]:      GlobalOptions section.
* ConsistencyTest [GlobalOptions]:       GlobalOptions section.
* DefaultOperatorPriority [FormulaOptions]: FormulaOptions section.
* EdgeProbability [StateSpaceOptions]:   StateSpaceOptions section.
* Enabled [Algorithm]:                   Algorithm section.
* EquivalencePriority [FormulaOptions]:  FormulaOptions section.
* FalsePriority [FormulaOptions]:        FormulaOptions section.
* FinallyPriority [FormulaOptions]:      FormulaOptions section.
* GenerateMode [FormulaOptions]:         FormulaOptions section.
* GenerateMode [StateSpaceOptions]:      StateSpaceOptions section.
* GloballyPriority [FormulaOptions]:     FormulaOptions section.
* ImplicationPriority [FormulaOptions]:  FormulaOptions section.
* Interactive [GlobalOptions]:           GlobalOptions section.
* IntersectionCheck [GlobalOptions]:     GlobalOptions section.
* IntersectionTest [GlobalOptions]:      GlobalOptions section.
* ModelCheck [GlobalOptions]:            GlobalOptions section.
* Name [Algorithm]:                      Algorithm section.
* NextPriority [FormulaOptions]:         FormulaOptions section.
* NotPriority [FormulaOptions]:          FormulaOptions section.
* OrPriority [FormulaOptions]:           FormulaOptions section.
* OutputMode [FormulaOptions]:           FormulaOptions section.
* Parameters [Algorithm]:                Algorithm section.
* Path [Algorithm]:                      Algorithm section.
* PropositionPriority [FormulaOptions]:  FormulaOptions section.
* Propositions [FormulaOptions]:         FormulaOptions section.
* Propositions [StateSpaceOptions]:      StateSpaceOptions section.
* RandomSeed [FormulaOptions]:           FormulaOptions section.
* RandomSeed [StateSpaceOptions]:        StateSpaceOptions section.
* ReleasePriority [FormulaOptions]:      FormulaOptions section.
* Rounds [GlobalOptions]:                GlobalOptions section.
* Size [FormulaOptions]:                 FormulaOptions section.
* Size [StateSpaceOptions]:              StateSpaceOptions section.
* StrongReleasePriority [FormulaOptions]: FormulaOptions section.
* TruePriority [FormulaOptions]:         FormulaOptions section.
* TruthProbability [StateSpaceOptions]:  StateSpaceOptions section.
* UntilPriority [FormulaOptions]:        FormulaOptions section.
* Verbosity [GlobalOptions]:             GlobalOptions section.
* WeakUntilPriority [FormulaOptions]:    FormulaOptions section.
* XorPriority [FormulaOptions]:          FormulaOptions section.


File: lbtt.info,  Node: Command line option index,  Next: User command index,  Prev: Configuration file option index,  Up: Top

Command line option index
*************************

* Menu:

* --abbreviatedoperators:                LTL formula options.
* --andpriority:                         LTL formula options.
* --beforepriority:                      LTL formula options.
* --comparisontest:                      Global options.
* --configfile:                          Special options.
* --consistencytest:                     Global options.
* --defaultoperatorpriority:             LTL formula options.
* --disable:                             Global options.
* --edgeprobability:                     State space options.
* --enable:                              Global options.
* --enumeratedpath:                      State space options.
* --equivalencepriority:                 LTL formula options.
* --falsepriority:                       LTL formula options.
* --finallypriority:                     LTL formula options.
* --formulachangeinterval:               LTL formula options.
* --formulafile:                         Special options.
* --formulageneratemode:                 LTL formula options.
* --formulaoutputmode:                   LTL formula options.
* --formulapropositions:                 LTL formula options.
* --formularandomseed:                   LTL formula options.
* --formulasize:                         LTL formula options.
* --generatennf:                         LTL formula options.
* --globallypriority:                    LTL formula options.
* --globalmodelcheck:                    Global options.
* --help:                                Special options.
* --implicationpriority:                 LTL formula options.
* --interactive:                         Global options.
* --intersectiontest:                    Global options.
* --localmodelcheck:                     Global options.
* --logfile:                             Special options.
* --modelcheck:                          Global options.
* --nextpriority:                        LTL formula options.
* --noabbreviatedoperators:              LTL formula options.
* --nocomparisontest:                    Global options.
* --noconsistencytest:                   Global options.
* --nogeneratennf:                       LTL formula options.
* --nointersectiontest:                  Global options.
* --nooutputnnf:                         LTL formula options.
* --nopause:                             Global options.
* --notpriority:                         LTL formula options.
* --orpriority:                          LTL formula options.
* --outputnnf:                           LTL formula options.
* --pause:                               Global options.
* --pauseonerror:                        Global options.
* --profile:                             Special options.
* --propositionpriority:                 LTL formula options.
* --quiet:                               Special options.
* --randomconnectedgraph:                State space options.
* --randomgraph:                         State space options.
* --randompath:                          State space options.
* --releasepriority:                     LTL formula options.
* --rounds:                              Global options.
* --showconfig:                          Special options.
* --showoperatordistribution:            Special options.
* --silent:                              Special options.
* --skip:                                Special options.
* --statespacechangeinterval:            State space options.
* --statespacegeneratemode:              State space options.
* --statespacerandomseed:                State space options.
* --statespacesize:                      State space options.
* --strongreleasepriority:               LTL formula options.
* --truepriority:                        LTL formula options.
* --truthprobability:                    State space options.
* --untilpriority:                       LTL formula options.
* --verbosity:                           Global options.
* --version:                             Special options.
* --weakuntilpriority:                   LTL formula options.
* --xorpriority:                         LTL formula options.
* -h:                                    Special options.


File: lbtt.info,  Node: User command index,  Next: Concept index,  Prev: Command line option index,  Up: Top

User command index
******************

* Menu:

* algorithms:                            Data display commands.
* buchi:                                 Data display commands.
* buchianalysis:                         Failure analysis commands.
* consistencyanalysis:                   Failure analysis commands.
* continue:                              Test control commands.
* disable:                               Test control commands.
* enable:                                Test control commands.
* evaluate:                              Data display commands.
* formula:                               Data display commands.
* help:                                  Getting help.
* inconsistencies:                       Data display commands.
* quit:                                  Test control commands.
* resultanalysis:                        Failure analysis commands.
* results:                               Data display commands.
* skip:                                  Test control commands.
* statespace:                            Data display commands.
* statistics:                            Data display commands.
* verbosity:                             Test control commands.


File: lbtt.info,  Node: Concept index,  Prev: User command index,  Up: Top

Concept index
*************

* Menu:

* ! (LTL formula operator):              Random LTL formulas.
* ! (operator semantics in LTL):         LTL formulas.
* -> (LTL formula operator):             Random LTL formulas.
* -> (operator semantics in LTL):        LTL formulas.
* /\ (LTL formula operator):             Random LTL formulas.
* /\ (operator semantics in LTL):        LTL formulas.
* <-> (LTL formula operator):            Random LTL formulas.
* <-> (operator semantics in LTL):       LTL formulas.
* \/ (LTL formula operator):             Random LTL formulas.
* \/ (operator semantics in LTL):        LTL formulas.
* _and_ (LTL formula operator):          Random LTL formulas.
* _and_ (operator semantics in LTL):     LTL formulas.
* _not_ (LTL formula operator):          Random LTL formulas.
* _or_ (LTL formula operator):           Random LTL formulas.
* _or_ (operator semantics in LTL):      LTL formulas.
* abbreviated LTL formula operators <1>: LTL formula options.
* abbreviated LTL formula operators:     FormulaOptions section.
* Algorithm section (configuration file): Algorithm section.
* always (LTL formula operator):         Random LTL formulas.
* always (operator semantics in LTL):    LTL formulas.
* analyzing test failures, Bu"chi automata intersection emptiness check: Failure analysis commands.
* analyzing test failures, model checking result consistency check: Failure analysis commands.
* analyzing test failures, model checking result cross-comparison test: Failure analysis commands.
* atomic proposition:                    Random input generation.
* atomic propositions, computing probabilities for: The formula generation algorithm.
* atomic propositions, priorities for <1>: LTL formula options.
* atomic propositions, priorities for <2>: FormulaOptions section.
* atomic propositions, priorities for <3>: The formula generation algorithm.
* atomic propositions, priorities for:   Random LTL formulas.
* B (LTL formula operator):              Random LTL formulas.
* B (operator semantics in LTL):         LTL formulas.
* before (LTL formula operator):         Random LTL formulas.
* before (operator semantics in LTL):    LTL formulas.
* Bu"chi automata intersection emptiness check: Buchi automata intersection emptiness check.
* Bu"chi automata intersection emptiness check, failure analysis: Failure analysis commands.
* Bu"chi automata, formal definition:    Generalized Buchi automata.
* Bu"chi automata, LTL-to-Bu"chi translator output file format: Buchi automata.
* changing verbosity of output <1>:      Test control commands.
* changing verbosity of output <2>:      Global options.
* changing verbosity of output:          GlobalOptions section.
* commands, abbreviating:                Command conventions.
* commands, conventions for entering:    Command conventions.
* commands, entering lists of numbers:   Command conventions.
* commands, getting help:                Getting help.
* commands, invoking external programs:  Command conventions.
* commands, LTL formula identifiers:     Command conventions.
* commands, redirecting output:          Command conventions.
* commands, test control:                Test control commands.
* commands, writing output to a pipe:    Command conventions.
* comments in configuration file:        Configuration file.
* configuration file, Algorithm section: Algorithm section.
* configuration file, changing the name of: Special options.
* configuration file, comments:          Configuration file.
* configuration file, example:           Sample configuration file.
* configuration file, formatting:        Configuration file.
* configuration file, FormulaOptions section: FormulaOptions section.
* configuration file, GlobalOption section: GlobalOptions section.
* configuration file, minimal requirements <1>: Algorithm section.
* configuration file, minimal requirements: Configuration file.
* configuration file, option values:     Configuration file.
* configuration file, StateSpaceOptions section: StateSpaceOptions section.
* configuration information:             Configuration information.
* conjunction (LTL formula operator):    Random LTL formulas.
* conjunction (operator semantics in LTL): LTL formulas.
* constants, computing probabilities for: The formula generation algorithm.
* constants, priorities for <1>:         LTL formula options.
* constants, priorities for <2>:         FormulaOptions section.
* constants, priorities for <3>:         The formula generation algorithm.
* constants, priorities for:             Random LTL formulas.
* conventions for entering commands:     Command conventions.
* conventions for writing configuration files: Configuration file.
* default operator priority <1>:         LTL formula options.
* default operator priority:             FormulaOptions section.
* density (of a state space) <1>:        StateSpaceOptions section.
* density (of a state space):            Random state spaces.
* disabling LTL-to-Bu"chi translators <1>: Test control commands.
* disabling LTL-to-Bu"chi translators <2>: Global options.
* disabling LTL-to-Bu"chi translators:   Algorithm section.
* disjunction (LTL formula operator):    Random LTL formulas.
* disjunction (operator semantics in LTL): LTL formulas.
* enabling and disabling tests <1>:      Global options.
* enabling and disabling tests <2>:      Special options.
* enabling and disabling tests:          GlobalOptions section.
* enabling LTL-to-Bu"chi translators <1>: Test control commands.
* enabling LTL-to-Bu"chi translators <2>: Global options.
* enabling LTL-to-Bu"chi translators:    Algorithm section.
* enumerated path <1>:                   State space options.
* enumerated path <2>:                   StateSpaceOptions section.
* enumerated path:                       Random state spaces.
* equivalence (LTL formula operator):    Random LTL formulas.
* equivalence (operator semantics in LTL): LTL formulas.
* eventually (LTL formula operator):     Random LTL formulas.
* eventually (operator semantics in LTL): LTL formulas.
* exclusive or (LTL formula operator):   Random LTL formulas.
* exclusive or (operator semantics in LTL): LTL formulas.
* exiting lbtt:                          Invocation.
* f (Boolean constant semantics in LTL): LTL formulas.
* F (LTL formula operator):              Random LTL formulas.
* F (operator semantics in LTL):         LTL formulas.
* failure analysis, Bu"chi automata intersection check: Failure analysis commands.
* failure analysis, model checking result consistency check: Failure analysis commands.
* failure analysis, model checking result cross-comparison test: Failure analysis commands.
* false (Boolean constant semantics in LTL): LTL formulas.
* file formats, formula input file for lbtt: Special options.
* file formats, LTL-to-Bu"chi translator input file: Format for LTL formulas.
* file formats, LTL-to-Bu"chi translator output file: Buchi automata.
* finally (LTL formula operator):        Random LTL formulas.
* finally (operator semantics in LTL):   LTL formulas.
* formula size:                          Random LTL formulas.
* FormulaOptions section (configuration file): FormulaOptions section.
* G (LTL formula operator):              Random LTL formulas.
* G (operator semantics in LTL):         LTL formulas.
* generalized Bu"chi automata, formal definition: Generalized Buchi automata.
* generalized Bu"chi automata, LTL-to-Bu"chi translator output file format: Buchi automata.
* global model checking <1>:             Global options.
* global model checking <2>:             GlobalOptions section.
* global model checking <3>:             Model checking result consistency check.
* global model checking:                 Model checking result cross-comparison test.
* globally (LTL formula operator):       Random LTL formulas.
* globally (operator semantics in LTL):  LTL formulas.
* GlobalOptions section (configuration file): GlobalOptions section.
* graph density <1>:                     StateSpaceOptions section.
* graph density:                         Random state spaces.
* GraphViz:                              Data display commands.
* henceforth (LTL formula operator):     Random LTL formulas.
* henceforth (operator semantics in LTL): LTL formulas.
* identifiers for LTL-to-Bu"chi translators: Algorithm section.
* implication (LTL formula operator):    Random LTL formulas.
* implication (operator semantics in LTL): LTL formulas.
* interactivity modes <1>:               Global options.
* interactivity modes:                   GlobalOptions section.
* interfacing LTL-to-Bu"chi translators with lbtt <1>: The lbtt-translate utility.
* interfacing LTL-to-Bu"chi translators with lbtt: Interfacing with lbtt.
* internal model checking algorithm <1>: Test round messages.
* internal model checking algorithm <2>: StateSpaceOptions section.
* internal model checking algorithm:     Model checking result cross-comparison test.
* invoking lbtt:                         Invocation.
* lbt:                                   The lbtt-translate utility.
* lbtt (executable file):                Invocation.
* lbtt-translate (executable file):      The lbtt-translate utility.
* local model checking <1>:              Global options.
* local model checking <2>:              GlobalOptions section.
* local model checking <3>:              Model checking result consistency check.
* local model checking:                  Model checking result cross-comparison test.
* log file for test failures:            Special options.
* LTL formula operators, abbreviated <1>: LTL formula options.
* LTL formula operators, abbreviated:    FormulaOptions section.
* LTL formula operators, supported:      Random LTL formulas.
* LTL formula, displaying with user command: Data display commands.
* LTL formula, generation algorithm:     The formula generation algorithm.
* LTL formula, identifiers in commands:  Command conventions.
* LTL formula, LTL-to-Bu"chi translator input file format: Format for LTL formulas.
* LTL formula, output modes <1>:         LTL formula options.
* LTL formula, output modes:             FormulaOptions section.
* LTL formula, parameters for generation algorithm <1>: LTL formula options.
* LTL formula, parameters for generation algorithm <2>: FormulaOptions section.
* LTL formula, parameters for generation algorithm: Random LTL formulas.
* LTL formula, random:                   Random LTL formulas.
* LTL formula, reading from a file:      Special options.
* LTL formula, size:                     Random LTL formulas.
* LTL-to-Bu"chi translators, automaton output file format: Buchi automata.
* LTL-to-Bu"chi translators, disabling <1>: Test control commands.
* LTL-to-Bu"chi translators, disabling <2>: Global options.
* LTL-to-Bu"chi translators, disabling:  Algorithm section.
* LTL-to-Bu"chi translators, enabling <1>: Test control commands.
* LTL-to-Bu"chi translators, enabling <2>: Global options.
* LTL-to-Bu"chi translators, enabling:   Algorithm section.
* LTL-to-Bu"chi translators, identifiers: Algorithm section.
* LTL-to-Bu"chi translators, interface requirements: Translator interface.
* LTL-to-Bu"chi translators, interfacing with <1>: The lbtt-translate utility.
* LTL-to-Bu"chi translators, interfacing with: Interfacing with lbtt.
* LTL-to-Bu"chi translators, LTL formula input file format: Format for LTL formulas.
* M (LTL formula operator):              Random LTL formulas.
* M (operator semantics in LTL):         LTL formulas.
* minimal requirements for configuration files: Configuration file.
* model checking:                        Overview.
* model checking modes <1>:              Global options.
* model checking modes <2>:              GlobalOptions section.
* model checking modes <3>:              Model checking result consistency check.
* model checking modes:                  Model checking result cross-comparison test.
* model checking result consistency check: Model checking result consistency check.
* model checking result consistency check, failure analysis: Failure analysis commands.
* model checking result cross-comparison test: Model checking result cross-comparison test.
* model checking result cross-comparison test, failure analysis: Failure analysis commands.
* negation (LTL formula operator):       Random LTL formulas.
* negation (operator semantics in LTL):  LTL formulas.
* negation normal form <1>:              LTL formula options.
* negation normal form:                  FormulaOptions section.
* next time (LTL formula operator):      Random LTL formulas.
* next time (operator semantics in LTL): LTL formulas.
* numeric values in configuration file:  Configuration file.
* operators, abbreviated <1>:            LTL formula options.
* operators, abbreviated:                FormulaOptions section.
* operators, computing distribution for <1>: Test statistics.
* operators, computing distribution for: Special options.
* operators, computing probabilities for: The formula generation algorithm.
* operators, precedence:                 Test round messages.
* operators, priorities for <1>:         LTL formula options.
* operators, priorities for <2>:         FormulaOptions section.
* operators, priorities for <3>:         The formula generation algorithm.
* operators, priorities for:             Random LTL formulas.
* parameters for random LTL formula generation algorithm <1>: LTL formula options.
* parameters for random LTL formula generation algorithm <2>: FormulaOptions section.
* parameters for random LTL formula generation algorithm: Random LTL formulas.
* parameters for random state space generation algorithm <1>: State space options.
* parameters for random state space generation algorithm <2>: StateSpaceOptions section.
* parameters for random state space generation algorithm: Random state spaces.
* priorities for formula constants, atomic propositions and operators <1>: LTL formula options.
* priorities for formula constants, atomic propositions and operators <2>: FormulaOptions section.
* priorities for formula constants, atomic propositions and operators <3>: The formula generation algorithm.
* priorities for formula constants, atomic propositions and operators: Random LTL formulas.
* probabilities for formula constants and atomic propositions: The formula generation algorithm.
* probabilities for formula operators:   The formula generation algorithm.
* proof for an LTL formula:              Failure analysis commands.
* quitting lbtt <1>:                     Test control commands.
* quitting lbtt:                         Invocation.
* random connected graph <1>:            State space options.
* random connected graph <2>:            StateSpaceOptions section.
* random connected graph:                Random state spaces.
* random connected graph, generation algorithm: Algorithm for generating connected graphs.
* random graph <1>:                      State space options.
* random graph <2>:                      StateSpaceOptions section.
* random graph:                          Random state spaces.
* random LTL formula:                    Random LTL formulas.
* random LTL formula, computing operator distribution: Special options.
* random LTL formula, generation algorithm: The formula generation algorithm.
* random LTL formula, generation modes <1>: LTL formula options.
* random LTL formula, generation modes:  FormulaOptions section.
* random LTL formula, output modes <1>:  LTL formula options.
* random LTL formula, output modes:      FormulaOptions section.
* random LTL formula, parameters for generation algorithm <1>: LTL formula options.
* random LTL formula, parameters for generation algorithm <2>: FormulaOptions section.
* random LTL formula, parameters for generation algorithm: Random LTL formulas.
* random LTL formula, random seed for generation algorithm: FormulaOptions section.
* random LTL formula, size:              Random LTL formulas.
* random path <1>:                       State space options.
* random path <2>:                       StateSpaceOptions section.
* random path:                           Random state spaces.
* random seed, LTL formula generation algorithm <1>: LTL formula options.
* random seed, LTL formula generation algorithm: FormulaOptions section.
* random seed, state space generation algorithm: StateSpaceOptions section.
* random state space:                    Random state spaces.
* random state space, algorithm for generating random connected graphs: Algorithm for generating connected graphs.
* random state space, density <1>:       StateSpaceOptions section.
* random state space, density:           Random state spaces.
* random state space, generation parameters <1>: State space options.
* random state space, generation parameters <2>: StateSpaceOptions section.
* random state space, generation parameters: Random state spaces.
* random state space, random seed for generation algorithm <1>: State space options.
* random state space, random seed for generation algorithm: StateSpaceOptions section.
* redirecting command output:            Command conventions.
* refutation for an LTL formula:         Failure analysis commands.
* release (LTL formula operator):        Random LTL formulas.
* release (operator semantics in LTL):   LTL formulas.
* skipping test rounds <1>:              Test control commands.
* skipping test rounds:                  Special options.
* SPIN:                                  The lbtt-translate utility.
* starting lbtt:                         Invocation.
* state space <1>:                       Random state spaces.
* state space:                           Random input generation.
* state space, algorithm for generating random connected graphs: Algorithm for generating connected graphs.
* state space, density <1>:              StateSpaceOptions section.
* state space, density:                  Random state spaces.
* state space, displaying with an user command: Data display commands.
* state space, formal definition:        State spaces.
* state space, generation modes <1>:     State space options.
* state space, generation modes <2>:     StateSpaceOptions section.
* state space, generation modes:         Random state spaces.
* state space, generation parameters <1>: State space options.
* state space, generation parameters <2>: StateSpaceOptions section.
* state space, generation parameters:    Random state spaces.
* state space, random:                   Random state spaces.
* StateSpaceOptions section (configuration file): StateSpaceOptions section.
* string values in configuration file:   Configuration file.
* strong release (LTL formula operator): Random LTL formulas.
* strong release (operator semantics in LTL): LTL formulas.
* strong until (LTL formula operator):   Random LTL formulas.
* strong until (operator semantics in LTL): LTL formulas.
* supported LTL formula operators:       Random LTL formulas.
* suppressing output:                    Special options.
* t (Boolean constant semantics in LTL): LTL formulas.
* testing procedure:                     Testing procedure.
* tests, aborting:                       Invocation.
* tests, against internal model checking algorithm <1>: Test round messages.
* tests, against internal model checking algorithm <2>: StateSpaceOptions section.
* tests, against internal model checking algorithm: Model checking result cross-comparison test.
* tests, Bu"chi automata intersection emptiness check: Buchi automata intersection emptiness check.
* tests, controlling with user commands: Test control commands.
* tests, enabling and disabling <1>:     Global options.
* tests, enabling and disabling <2>:     Special options.
* tests, enabling and disabling:         GlobalOptions section.
* tests, failure analysis:               Failure analysis commands.
* tests, failure report format:          Test round messages.
* tests, model checking result consistency check: Model checking result consistency check.
* tests, model checking result cross-comparison test: Model checking result cross-comparison test.
* tests, output example:                 Test round messages.
* tests, profiling LTL-to-Bu"chi translators: Special options.
* tests, skipping test rounds <1>:       Test control commands.
* tests, skipping test rounds:           Special options.
* tests, starting:                       Invocation.
* tests, statistics:                     Test statistics.
* true (Boolean constant semantics in LTL): LTL formulas.
* truth values in configuration file:    Configuration file.
* U (LTL formula operator):              Random LTL formulas.
* U (operator semantics in LTL):         LTL formulas.
* unless (LTL formula operator):         Random LTL formulas.
* unless (operator semantics in LTL):    LTL formulas.
* until (LTL formula operator):          Random LTL formulas.
* until (operator semantics in LTL):     LTL formulas.
* using a test failure log file:         Special options.
* using the internal model checking algorithm <1>: StateSpaceOptions section.
* using the internal model checking algorithm: Model checking result cross-comparison test.
* V (LTL formula operator):              Random LTL formulas.
* V (operator semantics in LTL):         LTL formulas.
* verbosity, changing <1>:               Test control commands.
* verbosity, changing <2>:               Global options.
* verbosity, changing:                   GlobalOptions section.
* W (LTL formula operator):              Random LTL formulas.
* W (operator semantics in LTL):         LTL formulas.
* weak release (LTL formula operator):   Random LTL formulas.
* weak release (operator semantics in LTL): LTL formulas.
* weak until (LTL formula operator):     Random LTL formulas.
* weak until (operator semantics in LTL): LTL formulas.
* witness:                               Failure analysis commands.
* X (LTL formula operator):              Random LTL formulas.
* X (operator semantics in LTL):         LTL formulas.
* xor (LTL formula operator):            Random LTL formulas.
* xor (operator semantics in LTL):       LTL formulas.



Tag Table:
Node: Top927
Node: Copying2245
Node: Overview21439
Node: Test methods24092
Node: Random input generation25412
Node: Random LTL formulas26660
Node: The formula generation algorithm29330
Node: Random state spaces32642
Node: Algorithm for generating connected graphs35911
Node: Testing procedure38264
Node: Model checking result cross-comparison test46885
Node: Model checking result consistency check49571
Node: Buchi automata intersection emptiness check51154
Node: Invocation52108
Node: Configuration file53419
Node: Algorithm section55587
Node: GlobalOptions section57832
Ref: Interactivity modes58691
Node: FormulaOptions section60625
Node: StateSpaceOptions section68690
Node: Sample configuration file72719
Node: Command line options75996
Node: Special options76941
Ref: --formulafile77473
Ref: --logfile78117
Ref: --showconfig78891
Ref: --showoperatordistribution79250
Ref: --skip79642
Node: Global options79879
Node: LTL formula options83039
Node: State space options87811
Node: Interpreting the output90231
Node: Configuration information90953
Node: Test round messages93631
Node: Test statistics100073
Node: Analyzing test results103205
Node: Command conventions104317
Node: Getting help106772
Node: Test control commands107535
Node: Data display commands109629
Ref: statistics114481
Node: Failure analysis commands114777
Node: Interfacing with lbtt124080
Node: Translator interface124985
Node: Format for LTL formulas126741
Node: Buchi automata129012
Node: The lbtt-translate utility135417
Node: References137707
Ref: [CGP99]137828
Ref: [Cou99]137926
Ref: [DGV99]138229
Ref: [EH00]138546
Ref: [Ete99]138810
Ref: [EWS01]139086
Ref: [GO01]139443
Ref: [GPVW95]139718
Ref: [GViz]139991
Ref: [Hol97]140111
Ref: [SB00]140234
Ref: [Tau00]140516
Ref: [TH02]140855
Ref: [Var96]141055
Ref: [VW86]141299
Node: Definitions141554
Node: LTL formulas142180
Node: Generalized Buchi automata144343
Node: State spaces148124
Node: Configuration file option index149153
Node: Command line option index152336
Node: User command index156674
Node: Concept index157990

End Tag Table
