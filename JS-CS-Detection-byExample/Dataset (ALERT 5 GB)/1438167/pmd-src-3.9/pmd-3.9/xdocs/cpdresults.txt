=====================================================================
Found a 121 line (629 tokens) duplication in the following files: 
Starting at line 265 of /usr/local/java/src/java/nio/DirectCharBufferU.java
Starting at line 265 of /usr/local/java/src/java/nio/DirectCharBufferS.java
	    DirectCharBufferS sb = (DirectCharBufferS)src;

	    int spos = sb.position();
	    int slim = sb.limit();
	    assert (spos <= slim);
	    int srem = (spos <= slim ? slim - spos : 0);

	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);

	    if (srem > rem)
		throw new BufferOverflowException();
 	    unsafe.copyMemory(sb.ix(spos), ix(pos), srem << 1);
 	    sb.position(spos + srem);
 	    position(pos + srem);
	} else if (!src.isDirect()) {

	    int spos = src.position();
	    int slim = src.limit();
	    assert (spos <= slim);
	    int srem = (spos <= slim ? slim - spos : 0);

	    put(src.hb, src.offset + spos, srem);
	    src.position(spos + srem);

	} else {
	    super.put(src);
	}
	return this;



    }

    public CharBuffer put(char[] src, int offset, int length) {

	if ((length << 1) > Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {
	    checkBounds(offset, length, src.length);
	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);
	    if (length > rem)
		throw new BufferOverflowException();

	    if (order() != ByteOrder.nativeOrder()) 
		Bits.copyFromCharArray(src, offset << 1,
					    ix(pos), length << 1);
	    else
		Bits.copyFromByteArray(src, offset << 1,
				       ix(pos), length << 1);
	    position(pos + length);
	} else {
	    super.put(src, offset, length);
	}
	return this;



    }
    
    public CharBuffer compact() {

	int pos = position();
	int lim = limit();
	assert (pos <= lim);
	int rem = (pos <= lim ? lim - pos : 0);

 	unsafe.copyMemory(ix(pos), ix(0), rem << 1);
 	position(rem);
	limit(capacity());
	return this;



    }

    public boolean isDirect() {
	return true;
    }

    public boolean isReadOnly() {
	return false;
    }




    public String toString(int start, int end) {
	if ((end > limit()) || (start > end))
	    throw new IndexOutOfBoundsException();
	try {
	    int len = end - start;
	    char[] ca = new char[len];
	    CharBuffer cb = CharBuffer.wrap(ca);
	    CharBuffer db = this.duplicate();
	    db.position(start);
	    db.limit(end);
	    cb.put(db);
	    return new String(ca);
	} catch (StringIndexOutOfBoundsException x) {
	    throw new IndexOutOfBoundsException();
	}
    }


    // --- Methods to support CharSequence ---

    public CharSequence subSequence(int start, int end) {
	int len = length();
	int pos = position();
	assert (pos <= len);
	pos = (pos <= len ? pos : len);

	if ((start < 0) || (end > len) || (start > end))
	    throw new IndexOutOfBoundsException();
	int sublen = end - start;
 	int off = (pos + start) << 1;
	return new DirectCharBufferS(this, -1, 0, sublen, sublen, off);
=====================================================================
Found a 294 line (531 tokens) duplication in the following files: 
Starting at line 486 of /usr/local/java/src/java/lang/StrictMath.java
Starting at line 575 of /usr/local/java/src/java/lang/Math.java
    public static int round(float a) {
	return (int)floor(a + 0.5f);
    }

    /**
     * Returns the closest <code>long</code> to the argument. The result 
     * is rounded to an integer by adding 1/2, taking the floor of the 
     * result, and casting the result to type <code>long</code>. In other 
     * words, the result is equal to the value of the expression:
     * <p><pre>(long)Math.floor(a + 0.5d)</pre>
     * <p>
     * Special cases:
     * <ul><li>If the argument is NaN, the result is 0.
     * <li>If the argument is negative infinity or any value less than or 
     * equal to the value of <code>Long.MIN_VALUE</code>, the result is 
     * equal to the value of <code>Long.MIN_VALUE</code>. 
     * <li>If the argument is positive infinity or any value greater than or 
     * equal to the value of <code>Long.MAX_VALUE</code>, the result is 
     * equal to the value of <code>Long.MAX_VALUE</code>.</ul> 
     *
     * @param   a   a floating-point value to be rounded to a 
     *		<code>long</code>.
     * @return  the value of the argument rounded to the nearest
     *          <code>long</code> value.
     * @see     java.lang.Long#MAX_VALUE
     * @see     java.lang.Long#MIN_VALUE
     */
    public static long round(double a) {
	return (long)floor(a + 0.5d);
    }

    private static Random randomNumberGenerator;

    private static synchronized void initRNG() {
        if (randomNumberGenerator == null) 
            randomNumberGenerator = new Random();
    }

    /**
     * Returns a <code>double</code> value with a positive sign, greater 
     * than or equal to <code>0.0</code> and less than <code>1.0</code>. 
     * Returned values are chosen pseudorandomly with (approximately) 
     * uniform distribution from that range. 
     * <p>
     * When this method is first called, it creates a single new 
     * pseudorandom-number generator, exactly as if by the expression 
     * <blockquote><pre>new java.util.Random</pre></blockquote>
     * This new pseudorandom-number generator is used thereafter for all 
     * calls to this method and is used nowhere else. 
     * <p>
     * This method is properly synchronized to allow correct use by more 
     * than one thread. However, if many threads need to generate 
     * pseudorandom numbers at a great rate, it may reduce contention for 
     * each thread to have its own pseudorandom-number generator.
     *  
     * @return  a pseudorandom <code>double</code> greater than or equal 
     * to <code>0.0</code> and less than <code>1.0</code>.
     * @see     java.util.Random#nextDouble()
     */
    public static double random() {
        if (randomNumberGenerator == null) initRNG();
        return randomNumberGenerator.nextDouble();
    }

    /**
     * Returns the absolute value of an <code>int</code> value.
     * If the argument is not negative, the argument is returned.
     * If the argument is negative, the negation of the argument is returned. 
     * <p>
     * Note that if the argument is equal to the value of 
     * <code>Integer.MIN_VALUE</code>, the most negative representable 
     * <code>int</code> value, the result is that same value, which is 
     * negative. 
     *
     * @param   a   the argument whose absolute value is to be determined
     * @return  the absolute value of the argument.
     * @see     java.lang.Integer#MIN_VALUE
     */
    public static int abs(int a) {
	return (a < 0) ? -a : a;
    }

    /**
     * Returns the absolute value of a <code>long</code> value.
     * If the argument is not negative, the argument is returned.
     * If the argument is negative, the negation of the argument is returned. 
     * <p>
     * Note that if the argument is equal to the value of 
     * <code>Long.MIN_VALUE</code>, the most negative representable 
     * <code>long</code> value, the result is that same value, which is 
     * negative. 
     *
     * @param   a   the argument whose absolute value is to be determined
     * @return  the absolute value of the argument.
     * @see     java.lang.Long#MIN_VALUE
     */
    public static long abs(long a) {
	return (a < 0) ? -a : a;
    }

    /**
     * Returns the absolute value of a <code>float</code> value.
     * If the argument is not negative, the argument is returned.
     * If the argument is negative, the negation of the argument is returned.
     * Special cases:
     * <ul><li>If the argument is positive zero or negative zero, the 
     * result is positive zero. 
     * <li>If the argument is infinite, the result is positive infinity. 
     * <li>If the argument is NaN, the result is NaN.</ul>
     * In other words, the result is the same as the value of the expression: 
     * <p><pre>Float.intBitsToFloat(0x7fffffff & Float.floatToIntBits(a))</pre>
     *
     * @param   a   the argument whose absolute value is to be determined
     * @return  the absolute value of the argument.
     */
    public static float abs(float a) {
        return (a <= 0.0F) ? 0.0F - a : a;
    }
  
    /**
     * Returns the absolute value of a <code>double</code> value.
     * If the argument is not negative, the argument is returned.
     * If the argument is negative, the negation of the argument is returned.
     * Special cases:
     * <ul><li>If the argument is positive zero or negative zero, the result 
     * is positive zero. 
     * <li>If the argument is infinite, the result is positive infinity. 
     * <li>If the argument is NaN, the result is NaN.</ul>
     * In other words, the result is the same as the value of the expression: 
     * <p><code>Double.longBitsToDouble((Double.doubleToLongBits(a)&lt;&lt;1)&gt;&gt;&gt;1)</code> 
     *
     * @param   a   the argument whose absolute value is to be determined
     * @return  the absolute value of the argument.
     */
    public static double abs(double a) {
        return (a <= 0.0D) ? 0.0D - a : a;
    }

    /**
     * Returns the greater of two <code>int</code> values. That is, the 
     * result is the argument closer to the value of 
     * <code>Integer.MAX_VALUE</code>. If the arguments have the same value, 
     * the result is that same value.
     *
     * @param   a   an argument.
     * @param   b   another argument.
     * @return  the larger of <code>a</code> and <code>b</code>.
     * @see     java.lang.Long#MAX_VALUE
     */
    public static int max(int a, int b) {
	return (a >= b) ? a : b;
    }

    /**
     * Returns the greater of two <code>long</code> values. That is, the 
     * result is the argument closer to the value of 
     * <code>Long.MAX_VALUE</code>. If the arguments have the same value, 
     * the result is that same value. 
     *
     * @param   a   an argument.
     * @param   b   another argument.
     * @return  the larger of <code>a</code> and <code>b</code>.
     * @see     java.lang.Long#MAX_VALUE
     */
    public static long max(long a, long b) {
	return (a >= b) ? a : b;
    }

    private static long negativeZeroFloatBits = Float.floatToIntBits(-0.0f);
    private static long negativeZeroDoubleBits = Double.doubleToLongBits(-0.0d);

    /**
     * Returns the greater of two <code>float</code> values.  That is,
     * the result is the argument closer to positive infinity. If the
     * arguments have the same value, the result is that same
     * value. If either value is NaN, then the result is NaN.  Unlike
     * the the numerical comparison operators, this method considers
     * negative zero to be strictly smaller than positive zero. If one
     * argument is positive zero and the other negative zero, the
     * result is positive zero.
     *
     * @param   a   an argument.
     * @param   b   another argument.
     * @return  the larger of <code>a</code> and <code>b</code>.
     */
    public static float max(float a, float b) {
        if (a != a) return a;	// a is NaN
	if ((a == 0.0f) && (b == 0.0f)
	    && (Float.floatToIntBits(a) == negativeZeroFloatBits)) {
	    return b;
	}
	return (a >= b) ? a : b;
    }

    /**
     * Returns the greater of two <code>double</code> values.  That
     * is, the result is the argument closer to positive infinity. If
     * the arguments have the same value, the result is that same
     * value. If either value is NaN, then the result is NaN.  Unlike
     * the the numerical comparison operators, this method considers
     * negative zero to be strictly smaller than positive zero. If one
     * argument is positive zero and the other negative zero, the
     * result is positive zero.
     *
     * @param   a   an argument.
     * @param   b   another argument.
     * @return  the larger of <code>a</code> and <code>b</code>.
     */
    public static double max(double a, double b) {
        if (a != a) return a;	// a is NaN
	if ((a == 0.0d) && (b == 0.0d)
	    && (Double.doubleToLongBits(a) == negativeZeroDoubleBits)) {
	    return b;
	}
	return (a >= b) ? a : b;
    }

    /**
     * Returns the smaller of two <code>int</code> values. That is,
     * the result the argument closer to the value of
     * <code>Integer.MIN_VALUE</code>.  If the arguments have the same
     * value, the result is that same value.
     *
     * @param   a   an argument.
     * @param   b   another argument.
     * @return  the smaller of <code>a</code> and <code>b</code>.
     * @see     java.lang.Long#MIN_VALUE
     */
    public static int min(int a, int b) {
	return (a <= b) ? a : b;
    }

    /**
     * Returns the smaller of two <code>long</code> values. That is,
     * the result is the argument closer to the value of
     * <code>Long.MIN_VALUE</code>. If the arguments have the same
     * value, the result is that same value.
     *
     * @param   a   an argument.
     * @param   b   another argument.
     * @return  the smaller of <code>a</code> and <code>b</code>.
     * @see     java.lang.Long#MIN_VALUE
     */
    public static long min(long a, long b) {
	return (a <= b) ? a : b;
    }

    /**
     * Returns the smaller of two <code>float</code> values.  That is,
     * the result is the value closer to negative infinity. If the
     * arguments have the same value, the result is that same
     * value. If either value is NaN, then the result is NaN.  Unlike
     * the the numerical comparison operators, this method considers
     * negative zero to be strictly smaller than positive zero.  If
     * one argument is positive zero and the other is negative zero,
     * the result is negative zero.
     *
     * @param   a   an argument.
     * @param   b   another argument.
     * @return  the smaller of <code>a</code> and <code>b.</code>
     */
    public static float min(float a, float b) {
        if (a != a) return a;	// a is NaN
	if ((a == 0.0f) && (b == 0.0f)
	    && (Float.floatToIntBits(b) == negativeZeroFloatBits)) {
	    return b;
	}
	return (a <= b) ? a : b;
    }

    /**
     * Returns the smaller of two <code>double</code> values.  That
     * is, the result is the value closer to negative infinity. If the
     * arguments have the same value, the result is that same
     * value. If either value is NaN, then the result is NaN.  Unlike
     * the the numerical comparison operators, this method considers
     * negative zero to be strictly smaller than positive zero. If one
     * argument is positive zero and the other is negative zero, the
     * result is negative zero.
     *
     * @param   a   an argument.
     * @param   b   another argument.
     * @return  the smaller of <code>a</code> and <code>b</code>.
     */
    public static double min(double a, double b) {
        if (a != a) return a;	// a is NaN
	if ((a == 0.0d) && (b == 0.0d)
	    && (Double.doubleToLongBits(b) == negativeZeroDoubleBits)) {
	    return b;
	}
	return (a <= b) ? a : b;
    }

}
=====================================================================
Found a 27 line (523 tokens) duplication in the following files: 
Starting at line 610 of /usr/local/java/src/java/util/BitSet.java
Starting at line 2294 of /usr/local/java/src/java/math/BigInteger.java
    final static byte trailingZeroTable[] = {
      -25, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
	5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
	6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
	5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
	7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
	5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
	6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
	5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0};

    /**
     * Returns the number of bits in the two's complement representation
     * of this BigInteger that differ from its sign bit.  This method is
     * useful when implementing bit-vector style sets atop BigIntegers.
     *
     * @return number of bits in the two's complement representation
     *         of this BigInteger that differ from its sign bit.
     */
    public int bitCount() {
=====================================================================
Found a 64 line (506 tokens) duplication in the following files: 
Starting at line 2243 of /usr/local/java/src/java/awt/geom/AffineTransform.java
Starting at line 2544 of /usr/local/java/src/java/awt/geom/AffineTransform.java
	switch (state) {
	default:
	    stateError();
	    /* NOTREACHED */
	case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
	    M00 = m00; M01 = m01; M02 = m02;
	    M10 = m10; M11 = m11; M12 = m12;
	    while (--numPts >= 0) {
		double x = srcPts[srcOff++];
		double y = srcPts[srcOff++];
		dstPts[dstOff++] = (float) (M00 * x + M01 * y + M02);
		dstPts[dstOff++] = (float) (M10 * x + M11 * y + M12);
	    }
	    return;
	case (APPLY_SHEAR | APPLY_SCALE):
	    M00 = m00; M01 = m01;
	    M10 = m10; M11 = m11;
	    while (--numPts >= 0) {
		double x = srcPts[srcOff++];
		double y = srcPts[srcOff++];
		dstPts[dstOff++] = (float) (M00 * x + M01 * y);
		dstPts[dstOff++] = (float) (M10 * x + M11 * y);
	    }
	    return;
	case (APPLY_SHEAR | APPLY_TRANSLATE):
	    M01 = m01; M02 = m02;
	    M10 = m10; M12 = m12;
	    while (--numPts >= 0) {
		double x = srcPts[srcOff++];
		dstPts[dstOff++] = (float) (M01 * srcPts[srcOff++] + M02);
		dstPts[dstOff++] = (float) (M10 * x + M12);
	    }
	    return;
	case (APPLY_SHEAR):
	    M01 = m01; M10 = m10;
	    while (--numPts >= 0) {
		double x = srcPts[srcOff++];
		dstPts[dstOff++] = (float) (M01 * srcPts[srcOff++]);
		dstPts[dstOff++] = (float) (M10 * x);
	    }
	    return;
	case (APPLY_SCALE | APPLY_TRANSLATE):
	    M00 = m00; M02 = m02;
	    M11 = m11; M12 = m12;
	    while (--numPts >= 0) {
		dstPts[dstOff++] = (float) (M00 * srcPts[srcOff++] + M02);
		dstPts[dstOff++] = (float) (M11 * srcPts[srcOff++] + M12);
	    }
	    return;
	case (APPLY_SCALE):
	    M00 = m00; M11 = m11;
	    while (--numPts >= 0) {
		dstPts[dstOff++] = (float) (M00 * srcPts[srcOff++]);
		dstPts[dstOff++] = (float) (M11 * srcPts[srcOff++]);
	    }
	    return;
	case (APPLY_TRANSLATE):
	    M02 = m02; M12 = m12;
	    while (--numPts >= 0) {
		dstPts[dstOff++] = (float) (srcPts[srcOff++] + M02);
		dstPts[dstOff++] = (float) (srcPts[srcOff++] + M12);
	    }
	    return;
	case (APPLY_IDENTITY):
=====================================================================
Found a 136 line (455 tokens) duplication in the following files: 
Starting at line 265 of /usr/local/java/src/java/nio/DirectFloatBufferS.java
Starting at line 265 of /usr/local/java/src/java/nio/DirectFloatBufferU.java
	    DirectFloatBufferU sb = (DirectFloatBufferU)src;

	    int spos = sb.position();
	    int slim = sb.limit();
	    assert (spos <= slim);
	    int srem = (spos <= slim ? slim - spos : 0);

	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);

	    if (srem > rem)
		throw new BufferOverflowException();
 	    unsafe.copyMemory(sb.ix(spos), ix(pos), srem << 2);
 	    sb.position(spos + srem);
 	    position(pos + srem);
	} else if (!src.isDirect()) {

	    int spos = src.position();
	    int slim = src.limit();
	    assert (spos <= slim);
	    int srem = (spos <= slim ? slim - spos : 0);

	    put(src.hb, src.offset + spos, srem);
	    src.position(spos + srem);

	} else {
	    super.put(src);
	}
	return this;



    }

    public FloatBuffer put(float[] src, int offset, int length) {

	if ((length << 2) > Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {
	    checkBounds(offset, length, src.length);
	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);
	    if (length > rem)
		throw new BufferOverflowException();

	    if (order() != ByteOrder.nativeOrder()) 
		Bits.copyFromIntArray(src, offset << 2,
					    ix(pos), length << 2);
	    else
		Bits.copyFromByteArray(src, offset << 2,
				       ix(pos), length << 2);
	    position(pos + length);
	} else {
	    super.put(src, offset, length);
	}
	return this;



    }
    
    public FloatBuffer compact() {

	int pos = position();
	int lim = limit();
	assert (pos <= lim);
	int rem = (pos <= lim ? lim - pos : 0);

 	unsafe.copyMemory(ix(pos), ix(0), rem << 2);
 	position(rem);
	limit(capacity());
	return this;



    }

    public boolean isDirect() {
	return true;
    }

    public boolean isReadOnly() {
	return false;
    }











































    public ByteOrder order() {





	return ((ByteOrder.nativeOrder() != ByteOrder.BIG_ENDIAN)
=====================================================================
Found a 132 line (455 tokens) duplication in the following files: 
Starting at line 265 of /usr/local/java/src/java/nio/DirectShortBufferU.java
Starting at line 265 of /usr/local/java/src/java/nio/DirectShortBufferS.java
	    DirectShortBufferS sb = (DirectShortBufferS)src;

	    int spos = sb.position();
	    int slim = sb.limit();
	    assert (spos <= slim);
	    int srem = (spos <= slim ? slim - spos : 0);

	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);

	    if (srem > rem)
		throw new BufferOverflowException();
 	    unsafe.copyMemory(sb.ix(spos), ix(pos), srem << 1);
 	    sb.position(spos + srem);
 	    position(pos + srem);
	} else if (!src.isDirect()) {

	    int spos = src.position();
	    int slim = src.limit();
	    assert (spos <= slim);
	    int srem = (spos <= slim ? slim - spos : 0);

	    put(src.hb, src.offset + spos, srem);
	    src.position(spos + srem);

	} else {
	    super.put(src);
	}
	return this;



    }

    public ShortBuffer put(short[] src, int offset, int length) {

	if ((length << 1) > Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {
	    checkBounds(offset, length, src.length);
	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);
	    if (length > rem)
		throw new BufferOverflowException();

	    if (order() != ByteOrder.nativeOrder()) 
		Bits.copyFromShortArray(src, offset << 1,
					    ix(pos), length << 1);
	    else
		Bits.copyFromByteArray(src, offset << 1,
				       ix(pos), length << 1);
	    position(pos + length);
	} else {
	    super.put(src, offset, length);
	}
	return this;



    }
    
    public ShortBuffer compact() {

	int pos = position();
	int lim = limit();
	assert (pos <= lim);
	int rem = (pos <= lim ? lim - pos : 0);

 	unsafe.copyMemory(ix(pos), ix(0), rem << 1);
 	position(rem);
	limit(capacity());
	return this;



    }

    public boolean isDirect() {
	return true;
    }

    public boolean isReadOnly() {
	return false;
    }











































    public ByteOrder order() {

	return ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN)
=====================================================================
Found a 132 line (455 tokens) duplication in the following files: 
Starting at line 265 of /usr/local/java/src/java/nio/DirectLongBufferU.java
Starting at line 265 of /usr/local/java/src/java/nio/DirectLongBufferS.java
	    DirectLongBufferS sb = (DirectLongBufferS)src;

	    int spos = sb.position();
	    int slim = sb.limit();
	    assert (spos <= slim);
	    int srem = (spos <= slim ? slim - spos : 0);

	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);

	    if (srem > rem)
		throw new BufferOverflowException();
 	    unsafe.copyMemory(sb.ix(spos), ix(pos), srem << 3);
 	    sb.position(spos + srem);
 	    position(pos + srem);
	} else if (!src.isDirect()) {

	    int spos = src.position();
	    int slim = src.limit();
	    assert (spos <= slim);
	    int srem = (spos <= slim ? slim - spos : 0);

	    put(src.hb, src.offset + spos, srem);
	    src.position(spos + srem);

	} else {
	    super.put(src);
	}
	return this;



    }

    public LongBuffer put(long[] src, int offset, int length) {

	if ((length << 3) > Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {
	    checkBounds(offset, length, src.length);
	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);
	    if (length > rem)
		throw new BufferOverflowException();

	    if (order() != ByteOrder.nativeOrder()) 
		Bits.copyFromLongArray(src, offset << 3,
					    ix(pos), length << 3);
	    else
		Bits.copyFromByteArray(src, offset << 3,
				       ix(pos), length << 3);
	    position(pos + length);
	} else {
	    super.put(src, offset, length);
	}
	return this;



    }
    
    public LongBuffer compact() {

	int pos = position();
	int lim = limit();
	assert (pos <= lim);
	int rem = (pos <= lim ? lim - pos : 0);

 	unsafe.copyMemory(ix(pos), ix(0), rem << 3);
 	position(rem);
	limit(capacity());
	return this;



    }

    public boolean isDirect() {
	return true;
    }

    public boolean isReadOnly() {
	return false;
    }











































    public ByteOrder order() {

	return ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN)
=====================================================================
Found a 136 line (455 tokens) duplication in the following files: 
Starting at line 265 of /usr/local/java/src/java/nio/DirectIntBufferS.java
Starting at line 265 of /usr/local/java/src/java/nio/DirectIntBufferU.java
	    DirectIntBufferU sb = (DirectIntBufferU)src;

	    int spos = sb.position();
	    int slim = sb.limit();
	    assert (spos <= slim);
	    int srem = (spos <= slim ? slim - spos : 0);

	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);

	    if (srem > rem)
		throw new BufferOverflowException();
 	    unsafe.copyMemory(sb.ix(spos), ix(pos), srem << 2);
 	    sb.position(spos + srem);
 	    position(pos + srem);
	} else if (!src.isDirect()) {

	    int spos = src.position();
	    int slim = src.limit();
	    assert (spos <= slim);
	    int srem = (spos <= slim ? slim - spos : 0);

	    put(src.hb, src.offset + spos, srem);
	    src.position(spos + srem);

	} else {
	    super.put(src);
	}
	return this;



    }

    public IntBuffer put(int[] src, int offset, int length) {

	if ((length << 2) > Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {
	    checkBounds(offset, length, src.length);
	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);
	    if (length > rem)
		throw new BufferOverflowException();

	    if (order() != ByteOrder.nativeOrder()) 
		Bits.copyFromIntArray(src, offset << 2,
					    ix(pos), length << 2);
	    else
		Bits.copyFromByteArray(src, offset << 2,
				       ix(pos), length << 2);
	    position(pos + length);
	} else {
	    super.put(src, offset, length);
	}
	return this;



    }
    
    public IntBuffer compact() {

	int pos = position();
	int lim = limit();
	assert (pos <= lim);
	int rem = (pos <= lim ? lim - pos : 0);

 	unsafe.copyMemory(ix(pos), ix(0), rem << 2);
 	position(rem);
	limit(capacity());
	return this;



    }

    public boolean isDirect() {
	return true;
    }

    public boolean isReadOnly() {
	return false;
    }











































    public ByteOrder order() {





	return ((ByteOrder.nativeOrder() != ByteOrder.BIG_ENDIAN)
=====================================================================
Found a 136 line (455 tokens) duplication in the following files: 
Starting at line 265 of /usr/local/java/src/java/nio/DirectDoubleBufferS.java
Starting at line 265 of /usr/local/java/src/java/nio/DirectDoubleBufferU.java
	    DirectDoubleBufferU sb = (DirectDoubleBufferU)src;

	    int spos = sb.position();
	    int slim = sb.limit();
	    assert (spos <= slim);
	    int srem = (spos <= slim ? slim - spos : 0);

	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);

	    if (srem > rem)
		throw new BufferOverflowException();
 	    unsafe.copyMemory(sb.ix(spos), ix(pos), srem << 3);
 	    sb.position(spos + srem);
 	    position(pos + srem);
	} else if (!src.isDirect()) {

	    int spos = src.position();
	    int slim = src.limit();
	    assert (spos <= slim);
	    int srem = (spos <= slim ? slim - spos : 0);

	    put(src.hb, src.offset + spos, srem);
	    src.position(spos + srem);

	} else {
	    super.put(src);
	}
	return this;



    }

    public DoubleBuffer put(double[] src, int offset, int length) {

	if ((length << 3) > Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {
	    checkBounds(offset, length, src.length);
	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);
	    if (length > rem)
		throw new BufferOverflowException();

	    if (order() != ByteOrder.nativeOrder()) 
		Bits.copyFromLongArray(src, offset << 3,
					    ix(pos), length << 3);
	    else
		Bits.copyFromByteArray(src, offset << 3,
				       ix(pos), length << 3);
	    position(pos + length);
	} else {
	    super.put(src, offset, length);
	}
	return this;



    }
    
    public DoubleBuffer compact() {

	int pos = position();
	int lim = limit();
	assert (pos <= lim);
	int rem = (pos <= lim ? lim - pos : 0);

 	unsafe.copyMemory(ix(pos), ix(0), rem << 3);
 	position(rem);
	limit(capacity());
	return this;



    }

    public boolean isDirect() {
	return true;
    }

    public boolean isReadOnly() {
	return false;
    }











































    public ByteOrder order() {





	return ((ByteOrder.nativeOrder() != ByteOrder.BIG_ENDIAN)
=====================================================================
Found a 64 line (436 tokens) duplication in the following files: 
Starting at line 2356 of /usr/local/java/src/java/awt/geom/AffineTransform.java
Starting at line 2450 of /usr/local/java/src/java/awt/geom/AffineTransform.java
	switch (state) {
	default:
	    stateError();
	    /* NOTREACHED */
	case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
	    M00 = m00; M01 = m01; M02 = m02;
	    M10 = m10; M11 = m11; M12 = m12;
	    while (--numPts >= 0) {
		double x = srcPts[srcOff++];
		double y = srcPts[srcOff++];
		dstPts[dstOff++] = M00 * x + M01 * y + M02;
		dstPts[dstOff++] = M10 * x + M11 * y + M12;
	    }
	    return;
	case (APPLY_SHEAR | APPLY_SCALE):
	    M00 = m00; M01 = m01;
	    M10 = m10; M11 = m11;
	    while (--numPts >= 0) {
		double x = srcPts[srcOff++];
		double y = srcPts[srcOff++];
		dstPts[dstOff++] = M00 * x + M01 * y;
		dstPts[dstOff++] = M10 * x + M11 * y;
	    }
	    return;
	case (APPLY_SHEAR | APPLY_TRANSLATE):
	    M01 = m01; M02 = m02;
	    M10 = m10; M12 = m12;
	    while (--numPts >= 0) {
		double x = srcPts[srcOff++];
		dstPts[dstOff++] = M01 * srcPts[srcOff++] + M02;
		dstPts[dstOff++] = M10 * x + M12;
	    }
	    return;
	case (APPLY_SHEAR):
	    M01 = m01; M10 = m10;
	    while (--numPts >= 0) {
		double x = srcPts[srcOff++];
		dstPts[dstOff++] = M01 * srcPts[srcOff++];
		dstPts[dstOff++] = M10 * x;
	    }
	    return;
	case (APPLY_SCALE | APPLY_TRANSLATE):
	    M00 = m00; M02 = m02;
	    M11 = m11; M12 = m12;
	    while (--numPts >= 0) {
		dstPts[dstOff++] = M00 * srcPts[srcOff++] + M02;
		dstPts[dstOff++] = M11 * srcPts[srcOff++] + M12;
	    }
	    return;
	case (APPLY_SCALE):
	    M00 = m00; M11 = m11;
	    while (--numPts >= 0) {
		dstPts[dstOff++] = M00 * srcPts[srcOff++];
		dstPts[dstOff++] = M11 * srcPts[srcOff++];
	    }
	    return;
	case (APPLY_TRANSLATE):
	    M02 = m02; M12 = m12;
	    while (--numPts >= 0) {
		dstPts[dstOff++] = srcPts[srcOff++] + M02;
		dstPts[dstOff++] = srcPts[srcOff++] + M12;
	    }
	    return;
	case (APPLY_IDENTITY):
=====================================================================
Found a 60 line (352 tokens) duplication in the following files: 
Starting at line 72 of /usr/local/java/src/java/lang/CharacterData.java
Starting at line 73 of /usr/local/java/src/java/lang/CharacterDataLatin1.java
    }

    static boolean isDigit(char ch) {
        return getType(ch) == Character.DECIMAL_DIGIT_NUMBER;
    }

    static boolean isDefined(char ch) {
        return getType(ch) != Character.UNASSIGNED;
    }

    static boolean isLetter(char ch) {
        return (((((1 << Character.UPPERCASE_LETTER) |
            (1 << Character.LOWERCASE_LETTER) |
            (1 << Character.TITLECASE_LETTER) |
            (1 << Character.MODIFIER_LETTER) |
            (1 << Character.OTHER_LETTER)) >> getType(ch)) & 1) != 0);
    }

    static boolean isLetterOrDigit(char ch) {
        return (((((1 << Character.UPPERCASE_LETTER) |
            (1 << Character.LOWERCASE_LETTER) |
            (1 << Character.TITLECASE_LETTER) |
            (1 << Character.MODIFIER_LETTER) |
            (1 << Character.OTHER_LETTER) |
            (1 << Character.DECIMAL_DIGIT_NUMBER)) >> getType(ch)) & 1) != 0);
    }

    static boolean isSpaceChar(char ch) {
        return (((((1 << Character.SPACE_SEPARATOR) |
                   (1 << Character.LINE_SEPARATOR) |
                   (1 << Character.PARAGRAPH_SEPARATOR))
                >> getType(ch)) & 1) != 0);
    }


    static boolean isJavaIdentifierStart(char ch) {
        return (getProperties(ch) & 0x00007000) >= 0x00005000;
    }

    static boolean isJavaIdentifierPart(char ch) {
        return (getProperties(ch) & 0x00003000) != 0;
    }

    static boolean isUnicodeIdentifierStart(char ch) {
        return (getProperties(ch) & 0x00007000) == 0x00007000;
    }

    static boolean isUnicodeIdentifierPart(char ch) {
        return (getProperties(ch)& 0x00001000) != 0;
    }

    static boolean isIdentifierIgnorable(char ch) {
        return (getProperties(ch) & 0x00007000) == 0x00001000;
    }

    static char toLowerCase(char ch) {
        char mapChar = ch;
        int val = getProperties(ch);

        if (((val & 0x00020000) != 0) && 
=====================================================================
Found a 19 line (329 tokens) duplication in the following files: 
Starting at line 685 of /usr/local/java/src/java/util/BitSet.java
Starting at line 2270 of /usr/local/java/src/java/math/BigInteger.java
    static int bitLen(int w) {
        // Binary search - decision tree (5 tests, rarely 6)
        return
         (w < 1<<15 ?
          (w < 1<<7 ?
           (w < 1<<3 ?
            (w < 1<<1 ? (w < 1<<0 ? (w<0 ? 32 : 0) : 1) : (w < 1<<2 ? 2 : 3)) :
            (w < 1<<5 ? (w < 1<<4 ? 4 : 5) : (w < 1<<6 ? 6 : 7))) :
           (w < 1<<11 ?
            (w < 1<<9 ? (w < 1<<8 ? 8 : 9) : (w < 1<<10 ? 10 : 11)) :
            (w < 1<<13 ? (w < 1<<12 ? 12 : 13) : (w < 1<<14 ? 14 : 15)))) :
          (w < 1<<23 ?
           (w < 1<<19 ?
            (w < 1<<17 ? (w < 1<<16 ? 16 : 17) : (w < 1<<18 ? 18 : 19)) :
            (w < 1<<21 ? (w < 1<<20 ? 20 : 21) : (w < 1<<22 ? 22 : 23))) :
           (w < 1<<27 ?
            (w < 1<<25 ? (w < 1<<24 ? 24 : 25) : (w < 1<<26 ? 26 : 27)) :
            (w < 1<<29 ? (w < 1<<28 ? 28 : 29) : (w < 1<<30 ? 30 : 31)))));
    }
=====================================================================
Found a 69 line (328 tokens) duplication in the following files: 
Starting at line 112 of /usr/local/java/src/java/nio/ByteBufferAsCharBufferB.java
Starting at line 112 of /usr/local/java/src/java/nio/ByteBufferAsCharBufferL.java
	Bits.putCharL(bb, ix(checkIndex(i)), x);
	return this;



    }

    public CharBuffer compact() {

	int pos = position();
	int lim = limit();
	assert (pos <= lim);
	int rem = (pos <= lim ? lim - pos : 0);

	ByteBuffer db = bb.duplicate();
 	db.limit(ix(lim));
	db.position(ix(0));
	ByteBuffer sb = db.slice();
	sb.position(pos << 1);
	sb.compact();
 	position(rem);
	limit(capacity());
	return this;



    }

    public boolean isDirect() {
	return bb.isDirect();
    }

    public boolean isReadOnly() {
	return false;
    }



    public String toString(int start, int end) {
	if ((end > limit()) || (start > end))
	    throw new IndexOutOfBoundsException();
	try {
	    int len = end - start;
	    char[] ca = new char[len];
	    CharBuffer cb = CharBuffer.wrap(ca);
	    CharBuffer db = this.duplicate();
	    db.position(start);
	    db.limit(end);
	    cb.put(db);
	    return new String(ca);
	} catch (StringIndexOutOfBoundsException x) {
	    throw new IndexOutOfBoundsException();
	}
    }


    // --- Methods to support CharSequence ---

    public CharSequence subSequence(int start, int end) {
	int len = length();
	int pos = position();
	assert (pos <= len);
	pos = (pos <= len ? pos : len);

	if ((start < 0) || (end > len) || (start > end))
	    throw new IndexOutOfBoundsException();
	int sublen = end - start;
 	int off = offset + ((pos + start) << 1);
	return new ByteBufferAsCharBufferL(bb, -1, 0, sublen, sublen, off);
=====================================================================
Found a 214 line (326 tokens) duplication in the following files: 
Starting at line 172 of /usr/local/java/src/java/nio/DirectCharBufferRS.java
Starting at line 172 of /usr/local/java/src/java/nio/DirectCharBufferRU.java
	return new DirectCharBufferRU(this,
					      this.markValue(),
					      this.position(),
					      this.limit(),
					      this.capacity(),
					      0);
    }

    public CharBuffer asReadOnlyBuffer() {








	return duplicate();

    }


















































    public CharBuffer put(char x) {




	throw new ReadOnlyBufferException();

    }

    public CharBuffer put(int i, char x) {




	throw new ReadOnlyBufferException();

    }

    public CharBuffer put(CharBuffer src) {




































	throw new ReadOnlyBufferException();

    }

    public CharBuffer put(char[] src, int offset, int length) {






















	throw new ReadOnlyBufferException();

    }
    
    public CharBuffer compact() {











	throw new ReadOnlyBufferException();

    }

    public boolean isDirect() {
	return true;
    }

    public boolean isReadOnly() {
	return true;
    }




    public String toString(int start, int end) {
	if ((end > limit()) || (start > end))
	    throw new IndexOutOfBoundsException();
	try {
	    int len = end - start;
	    char[] ca = new char[len];
	    CharBuffer cb = CharBuffer.wrap(ca);
	    CharBuffer db = this.duplicate();
	    db.position(start);
	    db.limit(end);
	    cb.put(db);
	    return new String(ca);
	} catch (StringIndexOutOfBoundsException x) {
	    throw new IndexOutOfBoundsException();
	}
    }


    // --- Methods to support CharSequence ---

    public CharSequence subSequence(int start, int end) {
	int len = length();
	int pos = position();
	assert (pos <= len);
	pos = (pos <= len ? pos : len);

	if ((start < 0) || (end > len) || (start > end))
	    throw new IndexOutOfBoundsException();
	int sublen = end - start;
 	int off = (pos + start) << 1;
	return new DirectCharBufferRU(this, -1, 0, sublen, sublen, off);
=====================================================================
Found a 87 line (299 tokens) duplication in the following files: 
Starting at line 1259 of /usr/local/java/src/java/awt/geom/CubicCurve2D.java
Starting at line 929 of /usr/local/java/src/java/awt/geom/QuadCurve2D.java
		vals[j++] = c1*u*u + 2*ctrl*t*u + c2*t*t;
	    }
	}
	return j;
    }

    private static final int BELOW = -2;
    private static final int LOWEDGE = -1;
    private static final int INSIDE = 0;
    private static final int HIGHEDGE = 1;
    private static final int ABOVE = 2;

    /*
     * Determine where coord lies with respect to the range from
     * low to high.  It is assumed that low <= high.  The return
     * value is one of the 5 values BELOW, LOWEDGE, INSIDE, HIGHEDGE,
     * or ABOVE.
     */
    private static int getTag(double coord, double low, double high) {
	if (coord <= low) {
	    return (coord < low ? BELOW : LOWEDGE);
	}
	if (coord >= high) {
	    return (coord > high ? ABOVE : HIGHEDGE);
	}
	return INSIDE;
    }

    /*
     * Determine if the pttag represents a coordinate that is already
     * in its test range, or is on the border with either of the two
     * opttags representing another coordinate that is "towards the
     * inside" of that test range.  In other words, are either of the
     * two "opt" points "drawing the pt inward"?
     */
    private static boolean inwards(int pttag, int opt1tag, int opt2tag) {
	switch (pttag) {
	case BELOW:
	case ABOVE:
	default:
	    return false;
	case LOWEDGE:
	    return (opt1tag >= INSIDE || opt2tag >= INSIDE);
	case INSIDE:
	    return true;
	case HIGHEDGE:
	    return (opt1tag <= INSIDE || opt2tag <= INSIDE);
	}
    }

    /**
     * Tests if the shape of this <code>QuadCurve2D</code> intersects the
     * interior of a specified set of rectangular coordinates.
     * @param x,&nbsp;y the coordinates of the upper-left corner of the
     *		specified rectangular area
     * @param w the width of the specified rectangular area
     * @param h the height of the specified rectangular area
     * @return <code>true</code> if the shape of this
     * 		<code>QuadCurve2D</code> intersects the interior of the
     *		specified set of rectangular coordinates;
     *		<code>false</code> otherwise.
     */
    public boolean intersects(double x, double y, double w, double h) {
	// Trivially reject non-existant rectangles
	if (w < 0 || h < 0) {
	    return false;
	}

	// Trivially accept if either endpoint is inside the rectangle
	// (not on its border since it may end there and not go inside)
	// Record where they lie with respect to the rectangle.
	//     -1 => left, 0 => inside, 1 => right
	double x1 = getX1();
	double y1 = getY1();
	int x1tag = getTag(x1, x, x+w);
	int y1tag = getTag(y1, y, y+h);
	if (x1tag == INSIDE && y1tag == INSIDE) {
	    return true;
	}
	double x2 = getX2();
	double y2 = getY2();
	int x2tag = getTag(x2, x, x+w);
	int y2tag = getTag(y2, y, y+h);
	if (x2tag == INSIDE && y2tag == INSIDE) {
	    return true;
	}
	double ctrlx = getCtrlX();
=====================================================================
Found a 117 line (298 tokens) duplication in the following files: 
Starting at line 64 of /usr/local/java/src/java/nio/ByteBufferAsCharBufferRB.java
Starting at line 64 of /usr/local/java/src/java/nio/ByteBufferAsCharBufferRL.java
	return new ByteBufferAsCharBufferRL(bb,
						    this.markValue(),
						    this.position(),
						    this.limit(),
						    this.capacity(),
						    offset);
    }

    public CharBuffer asReadOnlyBuffer() {








	return duplicate();

    }

















    public CharBuffer put(char x) {




	throw new ReadOnlyBufferException();

    }

    public CharBuffer put(int i, char x) {




	throw new ReadOnlyBufferException();

    }

    public CharBuffer compact() {
















	throw new ReadOnlyBufferException();

    }

    public boolean isDirect() {
	return bb.isDirect();
    }

    public boolean isReadOnly() {
	return true;
    }



    public String toString(int start, int end) {
	if ((end > limit()) || (start > end))
	    throw new IndexOutOfBoundsException();
	try {
	    int len = end - start;
	    char[] ca = new char[len];
	    CharBuffer cb = CharBuffer.wrap(ca);
	    CharBuffer db = this.duplicate();
	    db.position(start);
	    db.limit(end);
	    cb.put(db);
	    return new String(ca);
	} catch (StringIndexOutOfBoundsException x) {
	    throw new IndexOutOfBoundsException();
	}
    }


    // --- Methods to support CharSequence ---

    public CharSequence subSequence(int start, int end) {
	int len = length();
	int pos = position();
	assert (pos <= len);
	pos = (pos <= len ? pos : len);

	if ((start < 0) || (end > len) || (start > end))
	    throw new IndexOutOfBoundsException();
	int sublen = end - start;
 	int off = offset + ((pos + start) << 1);
	return new ByteBufferAsCharBufferRL(bb, -1, 0, sublen, sublen, off);
=====================================================================
Found a 40 line (281 tokens) duplication in the following files: 
Starting at line 420 of /usr/local/java/src/java/io/FilePermission.java
Starting at line 235 of /usr/local/java/src/java/util/PropertyPermission.java
	}

	char[] a = actions.toCharArray();

	int i = a.length - 1;
	if (i < 0)
	    return mask;

	while (i != -1) {
	    char c;

	    // skip whitespace
	    while ((i!=-1) && ((c = a[i]) == ' ' ||
			       c == '\r' ||
			       c == '\n' ||
			       c == '\f' ||
			       c == '\t'))
		i--;

	    // check for the known strings
	    int matchlen;

	    if (i >= 3 && (a[i-3] == 'r' || a[i-3] == 'R') &&
			  (a[i-2] == 'e' || a[i-2] == 'E') &&
			  (a[i-1] == 'a' || a[i-1] == 'A') &&
			  (a[i] == 'd' || a[i] == 'D'))
	    {
		matchlen = 4;
		mask |= READ;

	    } else if (i >= 4 && (a[i-4] == 'w' || a[i-4] == 'W') &&
				 (a[i-3] == 'r' || a[i-3] == 'R') &&
				 (a[i-2] == 'i' || a[i-2] == 'I') &&
				 (a[i-1] == 't' || a[i-1] == 'T') &&
				 (a[i] == 'e' || a[i] == 'E'))
	    {
		matchlen = 5;
		mask |= WRITE;

	    } else {
=====================================================================
Found a 156 line (272 tokens) duplication in the following files: 
Starting at line 939 of /usr/local/java/src/java/net/Socket.java
Starting at line 800 of /usr/local/java/src/java/net/DatagramSocket.java
	Object o = getImpl().getOption(SocketOptions.SO_TIMEOUT);
	/* extra type safety */
	if (o instanceof Integer) {
	    return ((Integer) o).intValue();
	} else {
	    return 0;
	}
    }

    /**
     * Sets the SO_SNDBUF option to the specified value for this
     * <tt>DatagramSocket</tt>. The SO_SNDBUF option is used by the 
     * network implementation as a hint to size the underlying
     * network I/O buffers. The SO_SNDBUF setting may also be used 
     * by the network implementation to determine the maximum size
     * of the packet that can be sent on this socket.
     * <p>
     * As SO_SNDBUF is a hint, applications that want to verify
     * what size the buffer is should call {@link #getSendBufferSize()}.
     * <p>
     * Increasing the buffer size may allow multiple outgoing packets 
     * to be queued by the network implementation when the send rate
     * is high. 
     * <p>
     * Note: If {@link #send()} is used to send a 
     * <code>DatagramPacket</code> that is larger than the setting
     * of SO_SNDBUF then it is implementation specific if the
     * packet is sent or discarded.
     *
     * @param size the size to which to set the send buffer
     * size. This value must be greater than 0.
     *
     * @exception SocketException if there is an error 
     * in the underlying protocol, such as an UDP error.
     * @exception IllegalArgumentException if the value is 0 or is
     * negative.
     * @see #getSendBufferSize()
     */
    public synchronized void setSendBufferSize(int size)
    throws SocketException{
	if (!(size > 0)) {
	    throw new IllegalArgumentException("negative send size");
	}
	if (isClosed())
	    throw new SocketException("Socket is closed");
	getImpl().setOption(SocketOptions.SO_SNDBUF, new Integer(size));
    }

    /**
     * Get value of the SO_SNDBUF option for this <tt>DatagramSocket</tt>, that is the
     * buffer size used by the platform for output on this <tt>DatagramSocket</tt>.
     *
     * @return the value of the SO_SNDBUF option for this <tt>DatagramSocket</tt>
     * @exception SocketException if there is an error in 
     * the underlying protocol, such as an UDP error.
     * @see #setSendBufferSize
     */
    public synchronized int getSendBufferSize() throws SocketException {
	if (isClosed())
	    throw new SocketException("Socket is closed");
	int result = 0;
	Object o = getImpl().getOption(SocketOptions.SO_SNDBUF);
	if (o instanceof Integer) {
	    result = ((Integer)o).intValue();
	}
	return result;
    }

    /**
     * Sets the SO_RCVBUF option to the specified value for this
     * <tt>DatagramSocket</tt>. The SO_RCVBUF option is used by the
     * the network implementation as a hint to size the underlying
     * network I/O buffers. The SO_RCVBUF setting may also be used
     * by the network implementation to determine the maximum size
     * of the packet that can be received on this socket.
     * <p>
     * Because SO_RCVBUF is a hint, applications that want to
     * verify what size the buffers were set to should call
     * {@link #getReceiveBufferSize()}.
     * <p>
     * Increasing SO_RCVBUF may allow the network implementation
     * to buffer multiple packets when packets arrive faster than
     * are being received using {@link #receive()}.
     * <p>
     * Note: It is implementation specific if a packet larger
     * than SO_RCVBUF can be received.
     *
     * @param size the size to which to set the receive buffer
     * size. This value must be greater than 0.
     *
     * @exception SocketException if there is an error in 
     * the underlying protocol, such as an UDP error.
     * @exception IllegalArgumentException if the value is 0 or is
     * negative.
     * @see #getReceiveBufferSize()
     */
    public synchronized void setReceiveBufferSize(int size)
    throws SocketException{
	if (size <= 0) {
	    throw new IllegalArgumentException("invalid receive size");
	}
	if (isClosed())
	    throw new SocketException("Socket is closed");
	getImpl().setOption(SocketOptions.SO_RCVBUF, new Integer(size));
    }

    /**
     * Get value of the SO_RCVBUF option for this <tt>DatagramSocket</tt>, that is the
     * buffer size used by the platform for input on this <tt>DatagramSocket</tt>.
     *
     * @return the value of the SO_RCVBUF option for this <tt>DatagramSocket</tt>
     * @exception SocketException if there is an error in the underlying protocol, such as an UDP error.
     * @see #setReceiveBufferSize(int)
     */
    public synchronized int getReceiveBufferSize()
    throws SocketException{
	if (isClosed())
	    throw new SocketException("Socket is closed");
	int result = 0;
	Object o = getImpl().getOption(SocketOptions.SO_RCVBUF);
	if (o instanceof Integer) {
	    result = ((Integer)o).intValue();
	}
	return result;
    }

    /**
     * Enable/disable the SO_REUSEADDR socket option.
     * <p>
     * For UDP sockets it may be necessary to bind more than one
     * socket to the same socket address. This is typically for the
     * purpose of receiving multicast packets
     * (See {@link #java.net.MulticastSocket}). The
     * <tt>SO_REUSEADDR</tt> socket option allows multiple
     * sockets to be bound to the same socket address if the
     * <tt>SO_REUSEADDR</tt> socket option is enabled prior
     * to binding the socket using {@link #bind(SocketAddress)}.
     * <p>
     * When a <tt>DatagramSocket</tt> is created the initial setting
     * of <tt>SO_REUSEADDR</tt> is disabled.
     * <p>
     * The behaviour when <tt>SO_REUSEADDR</tt> is enabled or
     * disabled after a socket is bound (See {@link #isBound()})
     * is not defined.
     * 
     * @param on  whether to enable or disable the 
     * @exception SocketException if an error occurs enabling or
     *            disabling the <tt>SO_RESUEADDR</tt> socket option,
     *	   	  or the socket is closed.
     * @since 1.4
     * @see #getReuseAddress()     
     * @see #bind(SocketAddress)     
     * @see #isBound()
     * @see #isClosed()
     */
    public synchronized void setReuseAddress(boolean on) throws SocketException {
=====================================================================
Found a 8 line (254 tokens) duplication in the following files: 
Starting at line 611 of /usr/local/java/src/java/util/BitSet.java
Starting at line 619 of /usr/local/java/src/java/util/BitSet.java
	7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
	5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
	6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
	5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0};
=====================================================================
Found a 181 line (248 tokens) duplication in the following files: 
Starting at line 456 of /usr/local/java/src/java/awt/Choice.java
Starting at line 388 of /usr/local/java/src/java/awt/Checkbox.java
            oldGroup.setSelectedCheckbox(null);
        }
    }

    /**
     * Adds the specified item listener to receive item events from
     * this check box.  Item events are sent to listeners in response
     * to user input, but not in response to calls to setState().
     * If l is null, no exception is thrown and no action is performed.
     *
     * @param         l    the item listener
     * @see           #removeItemListener
     * @see           #getItemListeners
     * @see           #setState
     * @see           java.awt.event.ItemEvent
     * @see           java.awt.event.ItemListener
     * @since         JDK1.1
     */
    public synchronized void addItemListener(ItemListener l) {
	if (l == null) {
	    return;
	}
        itemListener = AWTEventMulticaster.add(itemListener, l);
        newEventsOnly = true;
    }

    /**
     * Removes the specified item listener so that the item listener
     * no longer receives item events from this check box.
     * If l is null, no exception is thrown and no action is performed.
     *
     * @param         l    the item listener
     * @see           #addItemListener
     * @see           #getItemListeners
     * @see           java.awt.event.ItemEvent
     * @see           java.awt.event.ItemListener
     * @since         JDK1.1
     */
    public synchronized void removeItemListener(ItemListener l) {
	if (l == null) {
	    return;
	}
        itemListener = AWTEventMulticaster.remove(itemListener, l);
    }

    /**
     * Returns an array of all the item listeners
     * registered on this checkbox.
     *
     * @return all of this checkbox's <code>ItemListener</code>s
     *         or an empty array if no item 
     *         listeners are currently registered
     *
     * @see           #addItemListener
     * @see           #removeItemListener
     * @see           java.awt.event.ItemEvent
     * @see           java.awt.event.ItemListener
     * @since 1.4
     */
    public synchronized ItemListener[] getItemListeners() {
        return (ItemListener[]) (getListeners(ItemListener.class));
    }

    /**
     * Returns an array of all the objects currently registered
     * as <code><em>Foo</em>Listener</code>s
     * upon this <code>Checkbox</code>.
     * <code><em>Foo</em>Listener</code>s are registered using the
     * <code>add<em>Foo</em>Listener</code> method.
     *
     * <p>
     * You can specify the <code>listenerType</code> argument
     * with a class literal, such as
     * <code><em>Foo</em>Listener.class</code>.
     * For example, you can query a
     * <code>Checkbox</code> <code>c</code>
     * for its item listeners with the following code:
     *
     * <pre>ItemListener[] ils = (ItemListener[])(c.getListeners(ItemListener.class));</pre>
     *
     * If no such listeners exist, this method returns an empty array.
     *
     * @param listenerType the type of listeners requested; this parameter
     *          should specify an interface that descends from
     *          <code>java.util.EventListener</code>
     * @return an array of all objects registered as
     *          <code><em>Foo</em>Listener</code>s on this checkbox,
     *          or an empty array if no such
     *          listeners have been added
     * @exception ClassCastException if <code>listenerType</code>
     *          doesn't specify a class or interface that implements
     *          <code>java.util.EventListener</code>
     *
     * @see #getItemListeners
     * @since 1.3
     */
    public EventListener[] getListeners(Class listenerType) { 
	EventListener l = null; 
	if  (listenerType == ItemListener.class) { 
	    l = itemListener;
	} else {
	    return super.getListeners(listenerType);
	}
	return AWTEventMulticaster.getListeners(l, listenerType);
    }

    // REMIND: remove when filtering is done at lower level
    boolean eventEnabled(AWTEvent e) {
        if (e.id == ItemEvent.ITEM_STATE_CHANGED) {
            if ((eventMask & AWTEvent.ITEM_EVENT_MASK) != 0 ||
                itemListener != null) {
                return true;
            }
            return false;
        }
        return super.eventEnabled(e);
    }

    /**
     * Processes events on this check box.
     * If the event is an instance of <code>ItemEvent</code>,
     * this method invokes the <code>processItemEvent</code> method.
     * Otherwise, it calls its superclass's <code>processEvent</code> method.
     * <p>Note that if the event parameter is <code>null</code>
     * the behavior is unspecified and may result in an
     * exception.
     *
     * @param         e the event
     * @see           java.awt.event.ItemEvent
     * @see           #processItemEvent
     * @since         JDK1.1
     */
    protected void processEvent(AWTEvent e) {
        if (e instanceof ItemEvent) {
            processItemEvent((ItemEvent)e);
            return;
        }
	super.processEvent(e);
    }

    /**
     * Processes item events occurring on this check box by
     * dispatching them to any registered
     * <code>ItemListener</code> objects.
     * <p>
     * This method is not called unless item events are
     * enabled for this component. Item events are enabled
     * when one of the following occurs:
     * <p><ul>
     * <li>An <code>ItemListener</code> object is registered
     * via <code>addItemListener</code>.
     * <li>Item events are enabled via <code>enableEvents</code>.
     * </ul>
     * <p>Note that if the event parameter is <code>null</code>
     * the behavior is unspecified and may result in an
     * exception.
     *
     * @param       e the item event
     * @see         java.awt.event.ItemEvent
     * @see         java.awt.event.ItemListener
     * @see         #addItemListener
     * @see         java.awt.Component#enableEvents
     * @since       JDK1.1
     */
    protected void processItemEvent(ItemEvent e) {
        ItemListener listener = itemListener;
        if (listener != null) {
            listener.itemStateChanged(e);
        }
    }

    /**
     * Returns a string representing the state of this <code>Checkbox</code>.
     * This method is intended to be used only for debugging purposes, and the 
     * content and format of the returned string may vary between 
     * implementations. The returned string may be empty but may not be 
     * <code>null</code>.
     *
     * @return    the parameter string of this check box
     */
    protected String paramString() {
=====================================================================
Found a 175 line (246 tokens) duplication in the following files: 
Starting at line 413 of /usr/local/java/src/java/awt/TextField.java
Starting at line 221 of /usr/local/java/src/java/awt/Button.java
    }

    /**
     * Adds the specified action listener to receive action events from
     * this button. Action events occur when a user presses or releases
     * the mouse over this button.
     * If l is null, no exception is thrown and no action is performed.
     *
     * @param         l the action listener
     * @see           #removeActionListener
     * @see           #getActionListeners
     * @see           java.awt.event.ActionListener
     * @since         JDK1.1
     */
    public synchronized void addActionListener(ActionListener l) {
	if (l == null) {
	    return;
	}
	actionListener = AWTEventMulticaster.add(actionListener, l);
        newEventsOnly = true;
    }

    /**
     * Removes the specified action listener so that it no longer
     * receives action events from this button. Action events occur
     * when a user presses or releases the mouse over this button.
     * If l is null, no exception is thrown and no action is performed.
     *
     * @param         	l     the action listener
     * @see           	#addActionListener
     * @see           	#getActionListeners
     * @see           	java.awt.event.ActionListener
     * @since         	JDK1.1
     */
    public synchronized void removeActionListener(ActionListener l) {
	if (l == null) {
	    return;
	}
	actionListener = AWTEventMulticaster.remove(actionListener, l);
    }

    /**
     * Returns an array of all the action listeners
     * registered on this button.
     *
     * @return all of this button's <code>ActionListener</code>s
     *         or an empty array if no action 
     *         listeners are currently registered
     *
     * @see	        #addActionListener
     * @see           	#removeActionListener
     * @see           	java.awt.event.ActionListener
     * @since 1.4
     */
    public synchronized ActionListener[] getActionListeners() {
        return (ActionListener[]) (getListeners(ActionListener.class));
    }

    /**
     * Returns an array of all the objects currently registered
     * as <code><em>Foo</em>Listener</code>s
     * upon this <code>Button</code>.
     * <code><em>Foo</em>Listener</code>s are registered using the
     * <code>add<em>Foo</em>Listener</code> method.
     *
     * <p>
     * You can specify the <code>listenerType</code> argument
     * with a class literal, such as
     * <code><em>Foo</em>Listener.class</code>.
     * For example, you can query a
     * <code>Button</code> <code>b</code>
     * for its action listeners with the following code:
     *
     * <pre>ActionListener[] als = (ActionListener[])(b.getListeners(ActionListener.class));</pre>
     *
     * If no such listeners exist, this method returns an empty array.
     *
     * @param listenerType the type of listeners requested; this parameter
     *          should specify an interface that descends from
     *          <code>java.util.EventListener</code>
     * @return an array of all objects registered as
     *          <code><em>Foo</em>Listener</code>s on this button,
     *          or an empty array if no such
     *          listeners have been added
     * @exception ClassCastException if <code>listenerType</code>
     *          doesn't specify a class or interface that implements
     *          <code>java.util.EventListener</code>
     *
     * @see #getActionListeners
     * @since 1.3
     */
    public EventListener[] getListeners(Class listenerType) { 
	EventListener l = null; 
	if  (listenerType == ActionListener.class) { 
	    l = actionListener;
	} else {
	    return super.getListeners(listenerType);
	}
	return AWTEventMulticaster.getListeners(l, listenerType);
    }

    // REMIND: remove when filtering is done at lower level
    boolean eventEnabled(AWTEvent e) {
        if (e.id == ActionEvent.ACTION_PERFORMED) {
            if ((eventMask & AWTEvent.ACTION_EVENT_MASK) != 0 ||
                actionListener != null) {
                return true;
            }
            return false;
        }
        return super.eventEnabled(e);
    }

    /**
     * Processes events on this button. If an event is
     * an instance of <code>ActionEvent</code>, this method invokes
     * the <code>processActionEvent</code> method. Otherwise,
     * it invokes <code>processEvent</code> on the superclass.
     * <p>Note that if the event parameter is <code>null</code>
     * the behavior is unspecified and may result in an
     * exception.
     *
     * @param        e the event
     * @see          java.awt.event.ActionEvent
     * @see          java.awt.Button#processActionEvent
     * @since        JDK1.1
     */
    protected void processEvent(AWTEvent e) {
        if (e instanceof ActionEvent) {
            processActionEvent((ActionEvent)e);
            return;
        }
	super.processEvent(e);
    }

    /**
     * Processes action events occurring on this button
     * by dispatching them to any registered
     * <code>ActionListener</code> objects.
     * <p>
     * This method is not called unless action events are
     * enabled for this button. Action events are enabled
     * when one of the following occurs:
     * <p><ul>
     * <li>An <code>ActionListener</code> object is registered
     * via <code>addActionListener</code>.
     * <li>Action events are enabled via <code>enableEvents</code>.
     * </ul>
     * <p>Note that if the event parameter is <code>null</code>
     * the behavior is unspecified and may result in an
     * exception.
     *
     * @param       e the action event
     * @see         java.awt.event.ActionListener
     * @see         java.awt.Button#addActionListener
     * @see         java.awt.Component#enableEvents
     * @since       JDK1.1
     */
    protected void processActionEvent(ActionEvent e) {
        ActionListener listener = actionListener;
        if (listener != null) {
            listener.actionPerformed(e);
        }
    }

    /**
     * Returns a string representing the state of this <code>Button</code>.
     * This method is intended to be used only for debugging purposes, and the 
     * content and format of the returned string may vary between 
     * implementations. The returned string may be empty but may not be 
     * <code>null</code>.
     *
     * @return     the parameter string of this button
     */
    protected String paramString() {
=====================================================================
Found a 39 line (244 tokens) duplication in the following files: 
Starting at line 381 of /usr/local/java/src/java/lang/Package.java
Starting at line 276 of /usr/local/java/src/java/net/URLClassLoader.java
	URL sealBase = null;

	Attributes attr = man.getAttributes(path);
	if (attr != null) {
	    specTitle   = attr.getValue(Name.SPECIFICATION_TITLE);
	    specVersion = attr.getValue(Name.SPECIFICATION_VERSION);
	    specVendor  = attr.getValue(Name.SPECIFICATION_VENDOR);
	    implTitle   = attr.getValue(Name.IMPLEMENTATION_TITLE);
	    implVersion = attr.getValue(Name.IMPLEMENTATION_VERSION);
	    implVendor  = attr.getValue(Name.IMPLEMENTATION_VENDOR);
	    sealed      = attr.getValue(Name.SEALED);
	}
	attr = man.getMainAttributes();
	if (attr != null) {
	    if (specTitle == null) {
		specTitle = attr.getValue(Name.SPECIFICATION_TITLE);
	    }
	    if (specVersion == null) {
		specVersion = attr.getValue(Name.SPECIFICATION_VERSION);
	    }
	    if (specVendor == null) {
		specVendor = attr.getValue(Name.SPECIFICATION_VENDOR);
	    }
	    if (implTitle == null) {
		implTitle = attr.getValue(Name.IMPLEMENTATION_TITLE);
	    }
	    if (implVersion == null) {
		implVersion = attr.getValue(Name.IMPLEMENTATION_VERSION);
	    }
	    if (implVendor == null) {
		implVendor = attr.getValue(Name.IMPLEMENTATION_VENDOR);
	    }
	    if (sealed == null) {
		sealed = attr.getValue(Name.SEALED);
	    }
	}
	if ("true".equalsIgnoreCase(sealed)) {
	    sealBase = url;
	}
=====================================================================
Found a 31 line (242 tokens) duplication in the following files: 
Starting at line 257 of /usr/local/java/src/java/text/CharacterBreakData.java
Starting at line 287 of /usr/local/java/src/java/text/CharacterBreakData.java
            baseForm, baseForm, baseForm, baseForm, baseForm, baseForm, baseForm, baseForm,
        //  ctrl      ctrl      ctrl      ctrl      ctrl      ctrl      ctrl      ctrl
            baseForm, baseForm, baseForm, baseForm, baseForm, baseForm, baseForm, baseForm,
        //  ctrl      ctrl      ctrl      ctrl      ctrl      ctrl      ctrl      ctrl
            baseForm, baseForm, baseForm, baseForm, baseForm, baseForm, baseForm, baseForm,
        //  ctrl      ctrl      ctrl      ctrl      ctrl      ctrl      ctrl      ctrl
            baseForm, baseForm, baseForm, baseForm, baseForm, baseForm, baseForm, baseForm,
        //  nbsp      inv-!     cents     pounds    currency  yen       broken-bar  section
            baseForm, baseForm, baseForm, baseForm, baseForm, baseForm, baseForm, baseForm,
        //  umlaut    copyright super-a   gui-left  not       soft-hyph registered  macron
            baseForm, baseForm, baseForm, baseForm, baseForm, baseForm, baseForm, baseForm,
        //  degree    +/-       super-2   super-3   acute     micro     paragraph  bullet
            baseForm, baseForm, baseForm, baseForm, baseForm, baseForm, baseForm, baseForm,
        //  cedilla   super-1   super-o   gui-right 1/4       1/2       3/4      inv-?
            baseForm, baseForm, baseForm, baseForm, baseForm, baseForm, baseForm, baseForm,
        //  A-grave   A-acute   A-hat     A-tilde   A-umlaut A-ring    AE        C-cedilla
            baseForm, baseForm, baseForm, baseForm, baseForm, baseForm, baseForm, baseForm,
        //  E-grave   E-acute   E-hat     E-umlaut  I-grave   I-acute   I-hat    I-umlaut
            baseForm, baseForm, baseForm, baseForm, baseForm, baseForm, baseForm, baseForm,
        //  Edh       N-tilde   O-grave   O-acute   O-hat     O-tilde   O-umlaut times
            baseForm, baseForm, baseForm, baseForm, baseForm, baseForm, baseForm, baseForm,
        //  O-slash   U-grave   U-acute   U-hat     U-umlaut  Y-acute   Thorn    ess-zed
            baseForm, baseForm, baseForm, baseForm, baseForm, baseForm, baseForm, baseForm,
        //  a-grave   a-acute   a-hat     a-tilde   a-umlaut  a-ring    ae       c-cedilla
            baseForm, baseForm, baseForm, baseForm, baseForm, baseForm, baseForm, baseForm,
        //  e-grave   e-acute   e-hat     e-umlaut  i-grave   i-acute   i-hat    i-umlaut
            baseForm, baseForm, baseForm, baseForm, baseForm, baseForm, baseForm, baseForm,
        //  edh       n-tilde   o-grave   o-acute   o-hat     o-tilde   o-umlaut  over
            baseForm, baseForm, baseForm, baseForm, baseForm, baseForm, baseForm, baseForm,
        //  o-slash   u-grave   u-acute   u-hat     u-umlaut  y-acute   thorn    y-umlaut
            baseForm, baseForm, baseForm, baseForm, baseForm, baseForm, baseForm, baseForm
=====================================================================
Found a 170 line (240 tokens) duplication in the following files: 
Starting at line 458 of /usr/local/java/src/java/awt/Choice.java
Starting at line 193 of /usr/local/java/src/java/awt/CheckboxMenuItem.java
    }

    /**
     * Adds the specified item listener to receive item events from
     * this check box menu item.  Item events are sent in response to user
     * actions, but not in response to calls to setState().
     * If l is null, no exception is thrown and no action is performed.
     *
     * @param         l the item listener
     * @see           #removeItemListener
     * @see           #getItemListeners
     * @see           #setState
     * @see           java.awt.event.ItemEvent
     * @see           java.awt.event.ItemListener
     * @since         JDK1.1
     */
    public synchronized void addItemListener(ItemListener l) {
	if (l == null) {
	    return;
	}
        itemListener = AWTEventMulticaster.add(itemListener, l);
        newEventsOnly = true;
    }

    /**
     * Removes the specified item listener so that it no longer receives
     * item events from this check box menu item.
     * If l is null, no exception is thrown and no action is performed.
     *
     * @param         l the item listener
     * @see           #addItemListener
     * @see           #getItemListeners
     * @see           java.awt.event.ItemEvent
     * @see           java.awt.event.ItemListener
     * @since         JDK1.1
     */
    public synchronized void removeItemListener(ItemListener l) {
	if (l == null) {
	    return;
	}
        itemListener = AWTEventMulticaster.remove(itemListener, l);
    }

    /**
     * Returns an array of all the item listeners
     * registered on this checkbox menuitem.
     *
     * @return all of this checkbox menuitem's <code>ItemListener</code>s
     *         or an empty array if no item 
     *         listeners are currently registered
     *
     * @see           #addItemListener
     * @see           #removeItemListener
     * @see           java.awt.event.ItemEvent
     * @see           java.awt.event.ItemListener
     * @since 1.4
     */
    public synchronized ItemListener[] getItemListeners() {
        return (ItemListener[])(getListeners(ItemListener.class));
    }

    /**
     * Returns an array of all the objects currently registered
     * as <code><em>Foo</em>Listener</code>s
     * upon this <code>CheckboxMenuItem</code>.
     * <code><em>Foo</em>Listener</code>s are registered using the
     * <code>add<em>Foo</em>Listener</code> method.
     *
     * <p>
     * You can specify the <code>listenerType</code> argument
     * with a class literal, such as
     * <code><em>Foo</em>Listener.class</code>.
     * For example, you can query a
     * <code>CheckboxMenuItem</code> <code>c</code>
     * for its item listeners with the following code:
     *
     * <pre>ItemListener[] ils = (ItemListener[])(c.getListeners(ItemListener.class));</pre>
     *
     * If no such listeners exist, this method returns an empty array.
     *
     * @param listenerType the type of listeners requested; this parameter
     *          should specify an interface that descends from
     *          <code>java.util.EventListener</code>
     * @return an array of all objects registered as
     *          <code><em>Foo</em>Listener</code>s on this checkbox menuitem,
     *          or an empty array if no such
     *          listeners have been added
     * @exception ClassCastException if <code>listenerType</code>
     *          doesn't specify a class or interface that implements
     *          <code>java.util.EventListener</code>
     *
     * @see #getItemListeners
     * @since 1.3
     */
    public EventListener[] getListeners(Class listenerType) { 
	EventListener l = null; 
	if  (listenerType == ItemListener.class) { 
	    l = itemListener;
	} else {
	    return super.getListeners(listenerType);
	}
	return AWTEventMulticaster.getListeners(l, listenerType);
    }

    // REMIND: remove when filtering is done at lower level
    boolean eventEnabled(AWTEvent e) {
        if (e.id == ItemEvent.ITEM_STATE_CHANGED) {
            if ((eventMask & AWTEvent.ITEM_EVENT_MASK) != 0 ||
                itemListener != null) {
                return true;
            }
            return false;
        }
        return super.eventEnabled(e);
    }

    /**
     * Processes events on this check box menu item.
     * If the event is an instance of <code>ItemEvent</code>,
     * this method invokes the <code>processItemEvent</code> method.
     * If the event is not an item event,
     * it invokes <code>processEvent</code> on the superclass.
     * <p>
     * Check box menu items currently support only item events.
     * <p>Note that if the event parameter is <code>null</code>
     * the behavior is unspecified and may result in an
     * exception.
     *
     * @param        e the event
     * @see          java.awt.event.ItemEvent
     * @see          #processItemEvent
     * @since        JDK1.1
     */
    protected void processEvent(AWTEvent e) {
        if (e instanceof ItemEvent) {
            processItemEvent((ItemEvent)e);
	    return;
        }
	super.processEvent(e);
    }

    /**
     * Processes item events occurring on this check box menu item by
     * dispatching them to any registered <code>ItemListener</code> objects.
     * <p>
     * This method is not called unless item events are
     * enabled for this menu item. Item events are enabled
     * when one of the following occurs:
     * <p><ul>
     * <li>An <code>ItemListener</code> object is registered
     * via <code>addItemListener</code>.
     * <li>Item events are enabled via <code>enableEvents</code>.
     * </ul>
     * <p>Note that if the event parameter is <code>null</code>
     * the behavior is unspecified and may result in an
     * exception.
     *
     * @param       e the item event
     * @see         java.awt.event.ItemEvent
     * @see         java.awt.event.ItemListener
     * @see         #addItemListener
     * @see         java.awt.MenuItem#enableEvents
     * @since       JDK1.1
     */
    protected void processItemEvent(ItemEvent e) {
        ItemListener listener = itemListener;
        if (listener != null) {
            listener.itemStateChanged(e);
        }
    }
=====================================================================
Found a 36 line (229 tokens) duplication in the following files: 
Starting at line 495 of /usr/local/java/src/java/util/Arrays.java
Starting at line 578 of /usr/local/java/src/java/util/Arrays.java
Starting at line 661 of /usr/local/java/src/java/util/Arrays.java
Starting at line 745 of /usr/local/java/src/java/util/Arrays.java
Starting at line 829 of /usr/local/java/src/java/util/Arrays.java
Starting at line 913 of /usr/local/java/src/java/util/Arrays.java
Starting at line 997 of /usr/local/java/src/java/util/Arrays.java
	float v = x[m];

	// Establish Invariant: v* (<v)* (>v)* v*
	int a = off, b = a, c = off + len - 1, d = c;
	while(true) {
	    while (b <= c && x[b] <= v) {
		if (x[b] == v)
		    swap(x, a++, b);
		b++;
	    }
	    while (c >= b && x[c] >= v) {
		if (x[c] == v)
		    swap(x, c, d--);
		c--;
	    }
	    if (b > c)
		break;
	    swap(x, b++, c--);
	}

	// Swap partition elements back to middle
	int s, n = off + len;
	s = Math.min(a-off, b-a  );  vecswap(x, off, b-s, s);
	s = Math.min(d-c,   n-d-1);  vecswap(x, b,   n-s, s);

	// Recursively sort non-partition-elements
	if ((s = b-a) > 1)
	    sort1(x, off, s);
	if ((s = d-c) > 1)
	    sort1(x, n-s, s);
    }

    /**
     * Swaps x[a] with x[b].
     */
    private static void swap(float x[], int a, int b) {
=====================================================================
Found a 52 line (224 tokens) duplication in the following files: 
Starting at line 925 of /usr/local/java/src/java/awt/image/ComponentSampleModel.java
Starting at line 593 of /usr/local/java/src/java/awt/image/BandedSampleModel.java
			     sarray[i] & 0xffff);
	    }
	    break;

	case DataBuffer.TYPE_INT:

	    int[] iarray = (int[])obj;

	    for (int i=0; i<numDataElems; i++) {
		data.setElem(bankIndices[i], pixelOffset + bandOffsets[i],
                             iarray[i]);
	    }
	    break;

	case DataBuffer.TYPE_FLOAT:

	    float[] farray = (float[])obj;

	    for (int i=0; i<numDataElems; i++) {
		data.setElemFloat(bankIndices[i], pixelOffset + bandOffsets[i],
                                  farray[i]);
	    }
	    break;

	case DataBuffer.TYPE_DOUBLE:

	    double[] darray = (double[])obj;

	    for (int i=0; i<numDataElems; i++) {
		data.setElemDouble(bankIndices[i], pixelOffset + bandOffsets[i],
                                   darray[i]);
	    }
	    break;

	}
    }

    /**
     * Sets a pixel in the DataBuffer using an int array of samples for input.
     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * @param x,&nbsp;y The coordinates of the pixel location
     * @param iArray    The input samples in an int array
     * @param data      The DataBuffer containing the image data
     * @see #getPixel(int, int, int[], DataBuffer)
     */
    public void setPixel(int x, int y, int iArray[], DataBuffer data) {
        if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {
            throw new ArrayIndexOutOfBoundsException
                ("Coordinate out of bounds!");
        }
       int pixelOffset = y*scanlineStride + x;
=====================================================================
Found a 47 line (209 tokens) duplication in the following files: 
Starting at line 473 of /usr/local/java/src/java/security/UnresolvedPermission.java
Starting at line 431 of /usr/local/java/src/java/security/CodeSource.java
	ois.defaultReadObject();

	// process any new-style certs in the stream (if present)
	int size = ois.readInt();
	if (size > 0) {
	    // we know of 3 different cert types: X.509, PGP, SDSI, which
	    // could all be present in the stream at the same time
	    cfs = new Hashtable(3);
	    this.certs = new java.security.cert.Certificate[size];
	}

	for (int i=0; i<size; i++) {
	    // read the certificate type, and instantiate a certificate
	    // factory of that type (reuse existing factory if possible)
	    String certType = ois.readUTF();
	    if (cfs.containsKey(certType)) {
		// reuse certificate factory
		cf = (CertificateFactory)cfs.get(certType);
	    } else {
		// create new certificate factory
		try {
		    cf = CertificateFactory.getInstance(certType);
		} catch (CertificateException ce) {
		    throw new ClassNotFoundException
			("Certificate factory for "+certType+" not found");
		}
		// store the certificate factory so we can reuse it later
		cfs.put(certType, cf);
	    }
	    // parse the certificate
	    byte[] encoded=null;
	    try {
		encoded = new byte[ois.readInt()];
	    } catch (OutOfMemoryError oome) {
		throw new IOException("Certificate too big");
	    }
	    ois.readFully(encoded);
	    ByteArrayInputStream bais = new ByteArrayInputStream(encoded);
	    try {
		this.certs[i] = cf.generateCertificate(bais);
	    } catch (CertificateException ce) {
		throw new IOException(ce.getMessage());
	    }
	    bais.close();
	}
    }
}
=====================================================================
Found a 37 line (199 tokens) duplication in the following files: 
Starting at line 265 of /usr/local/java/src/java/nio/DirectIntBufferU.java
Starting at line 265 of /usr/local/java/src/java/nio/DirectFloatBufferS.java
	    DirectFloatBufferS sb = (DirectFloatBufferS)src;

	    int spos = sb.position();
	    int slim = sb.limit();
	    assert (spos <= slim);
	    int srem = (spos <= slim ? slim - spos : 0);

	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);

	    if (srem > rem)
		throw new BufferOverflowException();
 	    unsafe.copyMemory(sb.ix(spos), ix(pos), srem << 2);
 	    sb.position(spos + srem);
 	    position(pos + srem);
	} else if (!src.isDirect()) {

	    int spos = src.position();
	    int slim = src.limit();
	    assert (spos <= slim);
	    int srem = (spos <= slim ? slim - spos : 0);

	    put(src.hb, src.offset + spos, srem);
	    src.position(spos + srem);

	} else {
	    super.put(src);
	}
	return this;



    }

    public FloatBuffer put(float[] src, int offset, int length) {
=====================================================================
Found a 37 line (199 tokens) duplication in the following files: 
Starting at line 265 of /usr/local/java/src/java/nio/DirectLongBufferU.java
Starting at line 265 of /usr/local/java/src/java/nio/DirectDoubleBufferU.java
	    DirectDoubleBufferU sb = (DirectDoubleBufferU)src;

	    int spos = sb.position();
	    int slim = sb.limit();
	    assert (spos <= slim);
	    int srem = (spos <= slim ? slim - spos : 0);

	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);

	    if (srem > rem)
		throw new BufferOverflowException();
 	    unsafe.copyMemory(sb.ix(spos), ix(pos), srem << 3);
 	    sb.position(spos + srem);
 	    position(pos + srem);
	} else if (!src.isDirect()) {

	    int spos = src.position();
	    int slim = src.limit();
	    assert (spos <= slim);
	    int srem = (spos <= slim ? slim - spos : 0);

	    put(src.hb, src.offset + spos, srem);
	    src.position(spos + srem);

	} else {
	    super.put(src);
	}
	return this;



    }

    public DoubleBuffer put(double[] src, int offset, int length) {
=====================================================================
Found a 37 line (199 tokens) duplication in the following files: 
Starting at line 265 of /usr/local/java/src/java/nio/DirectIntBufferS.java
Starting at line 265 of /usr/local/java/src/java/nio/DirectFloatBufferS.java
	    DirectFloatBufferS sb = (DirectFloatBufferS)src;

	    int spos = sb.position();
	    int slim = sb.limit();
	    assert (spos <= slim);
	    int srem = (spos <= slim ? slim - spos : 0);

	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);

	    if (srem > rem)
		throw new BufferOverflowException();
 	    unsafe.copyMemory(sb.ix(spos), ix(pos), srem << 2);
 	    sb.position(spos + srem);
 	    position(pos + srem);
	} else if (!src.isDirect()) {

	    int spos = src.position();
	    int slim = src.limit();
	    assert (spos <= slim);
	    int srem = (spos <= slim ? slim - spos : 0);

	    put(src.hb, src.offset + spos, srem);
	    src.position(spos + srem);

	} else {
	    super.put(src);
	}
	return this;



    }

    public FloatBuffer put(float[] src, int offset, int length) {
=====================================================================
Found a 37 line (199 tokens) duplication in the following files: 
Starting at line 265 of /usr/local/java/src/java/nio/DirectDoubleBufferS.java
Starting at line 265 of /usr/local/java/src/java/nio/DirectLongBufferU.java
	    DirectLongBufferU sb = (DirectLongBufferU)src;

	    int spos = sb.position();
	    int slim = sb.limit();
	    assert (spos <= slim);
	    int srem = (spos <= slim ? slim - spos : 0);

	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);

	    if (srem > rem)
		throw new BufferOverflowException();
 	    unsafe.copyMemory(sb.ix(spos), ix(pos), srem << 3);
 	    sb.position(spos + srem);
 	    position(pos + srem);
	} else if (!src.isDirect()) {

	    int spos = src.position();
	    int slim = src.limit();
	    assert (spos <= slim);
	    int srem = (spos <= slim ? slim - spos : 0);

	    put(src.hb, src.offset + spos, srem);
	    src.position(spos + srem);

	} else {
	    super.put(src);
	}
	return this;



    }

    public LongBuffer put(long[] src, int offset, int length) {
=====================================================================
Found a 37 line (199 tokens) duplication in the following files: 
Starting at line 265 of /usr/local/java/src/java/nio/DirectCharBufferU.java
Starting at line 265 of /usr/local/java/src/java/nio/DirectShortBufferU.java
	    DirectShortBufferU sb = (DirectShortBufferU)src;

	    int spos = sb.position();
	    int slim = sb.limit();
	    assert (spos <= slim);
	    int srem = (spos <= slim ? slim - spos : 0);

	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);

	    if (srem > rem)
		throw new BufferOverflowException();
 	    unsafe.copyMemory(sb.ix(spos), ix(pos), srem << 1);
 	    sb.position(spos + srem);
 	    position(pos + srem);
	} else if (!src.isDirect()) {

	    int spos = src.position();
	    int slim = src.limit();
	    assert (spos <= slim);
	    int srem = (spos <= slim ? slim - spos : 0);

	    put(src.hb, src.offset + spos, srem);
	    src.position(spos + srem);

	} else {
	    super.put(src);
	}
	return this;



    }

    public ShortBuffer put(short[] src, int offset, int length) {
=====================================================================
Found a 40 line (198 tokens) duplication in the following files: 
Starting at line 863 of /usr/local/java/src/java/awt/image/Raster.java
Starting at line 951 of /usr/local/java/src/java/awt/image/Raster.java
    public static WritableRaster createWritableRaster(SampleModel sm,
                                                      DataBuffer db,
                                                      Point location) {
        if ((sm == null) || (db == null)) {
            throw new NullPointerException("SampleModel and DataBuffer cannot be null");
        }
        if (location == null) {
           location = new Point(0,0);
        }

        int dataType = sm.getDataType();

        if (sm instanceof PixelInterleavedSampleModel) {
            switch(dataType) {
                case DataBuffer.TYPE_BYTE:
                    return new ByteInterleavedRaster(sm, db, location);

                case DataBuffer.TYPE_USHORT:
                    return new ShortInterleavedRaster(sm, db, location);
            }
        } else if (sm instanceof SinglePixelPackedSampleModel) {
            switch(dataType) {
                case DataBuffer.TYPE_BYTE:
                    return new ByteInterleavedRaster(sm, db, location);

                case DataBuffer.TYPE_USHORT:
                    return new ShortInterleavedRaster(sm, db, location);

                case DataBuffer.TYPE_INT:
                    return new IntegerInterleavedRaster(sm, db, location);
            }
        } else if (sm instanceof MultiPixelPackedSampleModel &&
                   dataType == DataBuffer.TYPE_BYTE &&
                   sm.getSampleSize(0) < 8) {
            return new BytePackedRaster(sm, db, location);
        }

        // we couldn't do anything special - do the generic thing

        return new SunWritableRaster(sm,db,location);
=====================================================================
Found a 38 line (195 tokens) duplication in the following files: 
Starting at line 437 of /usr/local/java/src/java/awt/Container.java
Starting at line 627 of /usr/local/java/src/java/awt/Container.java
                    if (index > ncomponents) {
                        throw new IllegalArgumentException("illegal component position");
                    }
            }

	    /* Add component to list; allocate new array if necessary. */
	    if (ncomponents == component.length) {
		Component newcomponents[] = new Component[ncomponents * 2 + 1];
		System.arraycopy(component, 0, newcomponents, 0, ncomponents);
		component = newcomponents;
	    }
	    if (index == -1 || index == ncomponents) {
		component[ncomponents++] = comp;
	    } else {
		System.arraycopy(component, index, component,
				 index + 1, ncomponents - index);
		component[index] = comp;
		ncomponents++;
	    }
	    comp.parent = this;

	    adjustListeningChildren(AWTEvent.HIERARCHY_EVENT_MASK, 
	        comp.numListening(AWTEvent.HIERARCHY_EVENT_MASK));
	    adjustListeningChildren(AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK,
		comp.numListening(AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK));
            adjustDescendants(comp.countHierarchyMembers());

	    if (valid) {
		invalidate();
	    }
	    if (peer != null) {
		comp.addNotify();
	    }
	    
	    /* Notify the layout manager of the added component. */
	    if (layoutMgr != null) {
		if (layoutMgr instanceof LayoutManager2) {
		    ((LayoutManager2)layoutMgr).addLayoutComponent(comp, constraints);
=====================================================================
Found a 69 line (193 tokens) duplication in the following files: 
Starting at line 90 of /usr/local/java/src/java/io/InputStream.java
Starting at line 92 of /usr/local/java/src/java/io/LineNumberInputStream.java
    }

    /**
     * Reads up to <code>len</code> bytes of data from this input stream 
     * into an array of bytes. This method blocks until some input is available.
     * <p>
     * The <code>read</code> method of 
     * <code>LineNumberInputStream</code> repeatedly calls the 
     * <code>read</code> method of zero arguments to fill in the byte array.
     *
     * @param      b     the buffer into which the data is read.
     * @param      off   the start offset of the data.
     * @param      len   the maximum number of bytes read.
     * @return     the total number of bytes read into the buffer, or
     *             <code>-1</code> if there is no more data because the end of
     *             this stream has been reached.
     * @exception  IOException  if an I/O error occurs.
     * @see        java.io.LineNumberInputStream#read()
     */
    public int read(byte b[], int off, int len) throws IOException {
	if (b == null) {
	    throw new NullPointerException();
	} else if ((off < 0) || (off > b.length) || (len < 0) ||
		   ((off + len) > b.length) || ((off + len) < 0)) {
	    throw new IndexOutOfBoundsException();
	} else if (len == 0) {
	    return 0;
	}

	int c = read();
	if (c == -1) {
	    return -1;
	}
	b[off] = (byte)c;

	int i = 1;
	try {
	    for (; i < len ; i++) {
		c = read();
		if (c == -1) {
		    break;
		}
		if (b != null) {
		    b[off + i] = (byte)c;
		}
	    }
	} catch (IOException ee) {
	}
	return i;
    }

    /**
     * Skips over and discards <code>n</code> bytes of data from this 
     * input stream. The <code>skip</code> method may, for a variety of 
     * reasons, end up skipping over some smaller number of bytes, 
     * possibly <code>0</code>. The actual number of bytes skipped is 
     * returned.  If <code>n</code> is negative, no bytes are skipped.
     * <p>
     * The <code>skip</code> method of <code>LineNumberInputStream</code> creates 
     * a byte array and then repeatedly reads into it until 
     * <code>n</code> bytes have been read or the end of the stream has 
     * been reached. 
     *
     * @param      n   the number of bytes to be skipped.
     * @return     the actual number of bytes skipped.
     * @exception  IOException  if an I/O error occurs.
     * @see        java.io.FilterInputStream#in
     */
    public long skip(long n) throws IOException {
=====================================================================
Found a 61 line (193 tokens) duplication in the following files: 
Starting at line 1444 of /usr/local/java/src/java/awt/geom/CubicCurve2D.java
Starting at line 1094 of /usr/local/java/src/java/awt/geom/QuadCurve2D.java
				  y1, ctrly, y2) == 2 &&
		    getTag(res[0], y, y+h) * getTag(res[1], y, y+h) <= 0);
	}

	// The X and Y ranges of the endpoints overlap the X and Y
	// ranges of the rectangle, now find out how the endpoint
	// line segment intersects the Y range of the rectangle
	double dx = x2 - x1;
	double dy = y2 - y1;
	double k = y2 * x1 - x2 * y1;
	int c1tag, c2tag;
	if (y1tag == INSIDE) {
	    c1tag = x1tag;
	} else {
	    c1tag = getTag((k + dx * (y1tag < INSIDE ? y : y+h)) / dy, x, x+w);
	}
	if (y2tag == INSIDE) {
	    c2tag = x2tag;
	} else {
	    c2tag = getTag((k + dx * (y2tag < INSIDE ? y : y+h)) / dy, x, x+w);
	}
	// If the part of the line segment that intersects the Y range
	// of the rectangle crosses it horizontally - trivially accept
	if (c1tag * c2tag <= 0) {
	    return true;
	}

	// Now we know that both the X and Y ranges intersect and that
	// the endpoint line segment does not directly cross the rectangle.
	//
	// We can almost treat this case like one of the cases above
	// where both endpoints are to one side, except that we will
	// only get one intersection of the curve with the vertical
	// side of the rectangle.  This is because the endpoint segment
	// accounts for the other intersection.
	//
	// (Remember there is overlap in both the X and Y ranges which
	//  means that the segment must cross at least one vertical edge
	//  of the rectangle - in particular, the "near vertical side" -
	//  leaving only one intersection for the curve.)
	//
	// Now we calculate the y tags of the two intersections on the
	// "near vertical side" of the rectangle.  We will have one with
	// the endpoint segment, and one with the curve.  If those two
	// vertical intersections overlap the Y range of the rectangle,
	// we have an intersection.  Otherwise, we don't.

	// c1tag = vertical intersection class of the endpoint segment
	//
	// Choose the y tag of the endpoint that was not on the same
	// side of the rectangle as the subsegment calculated above.
	// Note that we can "steal" the existing Y tag of that endpoint
	// since it will be provably the same as the vertical intersection.
	c1tag = ((c1tag * x1tag <= 0) ? y1tag : y2tag);

	// c2tag = vertical intersection class of the curve
	//
	// We have to calculate this one the straightforward way.
	// Note that the c2tag can still tell us which vertical edge
	// to test against.
	fillEqn(eqn, (c2tag < INSIDE ? x : x+w), x1, ctrlx, x2);
=====================================================================
Found a 35 line (193 tokens) duplication in the following files: 
Starting at line 146 of /usr/local/java/src/java/nio/ByteBufferAsCharBufferB.java
Starting at line 146 of /usr/local/java/src/java/nio/ByteBufferAsCharBufferRB.java
    }



    public String toString(int start, int end) {
	if ((end > limit()) || (start > end))
	    throw new IndexOutOfBoundsException();
	try {
	    int len = end - start;
	    char[] ca = new char[len];
	    CharBuffer cb = CharBuffer.wrap(ca);
	    CharBuffer db = this.duplicate();
	    db.position(start);
	    db.limit(end);
	    cb.put(db);
	    return new String(ca);
	} catch (StringIndexOutOfBoundsException x) {
	    throw new IndexOutOfBoundsException();
	}
    }


    // --- Methods to support CharSequence ---

    public CharSequence subSequence(int start, int end) {
	int len = length();
	int pos = position();
	assert (pos <= len);
	pos = (pos <= len ? pos : len);

	if ((start < 0) || (end > len) || (start > end))
	    throw new IndexOutOfBoundsException();
	int sublen = end - start;
 	int off = offset + ((pos + start) << 1);
	return new ByteBufferAsCharBufferRB(bb, -1, 0, sublen, sublen, off);
=====================================================================
Found a 44 line (191 tokens) duplication in the following files: 
Starting at line 132 of /usr/local/java/src/java/awt/image/LookupOp.java
Starting at line 336 of /usr/local/java/src/java/awt/image/RescaleOp.java
        int width = src.getWidth();
        int height = src.getHeight();

        if (dst == null) {
            dst = createCompatibleDestImage(src, null);
            dstCM = srcCM;
        }
        else {
            if (width != dst.getWidth()) {
                throw new
                    IllegalArgumentException("Src width ("+width+
                                             ") not equal to dst width ("+
                                             dst.getWidth()+")");
            }
            if (height != dst.getHeight()) {
                throw new
                    IllegalArgumentException("Src height ("+height+
                                             ") not equal to dst height ("+
                                             dst.getHeight()+")");
            }

            dstCM = dst.getColorModel();
            if(srcCM.getColorSpace().getType() !=
               dstCM.getColorSpace().getType()) {
                needToConvert = true;
                dst = createCompatibleDestImage(src, null);
            }

        }
        
        BufferedImage origDst = dst;

        //
        // Try to use a native BI rescale operation first
        //
        if (ImagingLib.filter(this, src, dst) == null) {
            //
            // Native BI rescale failed - convert to rasters
            //
            WritableRaster srcRaster = src.getRaster();
            WritableRaster dstRaster = dst.getRaster();

            if (srcCM.hasAlpha()) {
                if (numBands-1 == length || length == 1) {
=====================================================================
Found a 37 line (191 tokens) duplication in the following files: 
Starting at line 208 of /usr/local/java/src/java/nio/DirectShortBufferU.java
Starting at line 208 of /usr/local/java/src/java/nio/DirectShortBufferS.java
	return (Bits.swap(unsafe.getShort(ix(checkIndex(i)))));
    }

    public ShortBuffer get(short[] dst, int offset, int length) {

	if ((length << 1) > Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {
	    checkBounds(offset, length, dst.length);
	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);
	    if (length > rem)
		throw new BufferUnderflowException();

	    if (order() != ByteOrder.nativeOrder())
		Bits.copyToShortArray(ix(pos), dst,
					  offset << 1,
					  length << 1);
	    else
		Bits.copyToByteArray(ix(pos), dst,
				     offset << 1,
				     length << 1);
	    position(pos + length);
	} else {
	    super.get(dst, offset, length);
	}
	return this;



    }



    public ShortBuffer put(short x) {

	unsafe.putShort(ix(nextPutIndex()), Bits.swap((x)));
=====================================================================
Found a 37 line (191 tokens) duplication in the following files: 
Starting at line 208 of /usr/local/java/src/java/nio/DirectLongBufferU.java
Starting at line 208 of /usr/local/java/src/java/nio/DirectLongBufferS.java
	return (Bits.swap(unsafe.getLong(ix(checkIndex(i)))));
    }

    public LongBuffer get(long[] dst, int offset, int length) {

	if ((length << 3) > Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {
	    checkBounds(offset, length, dst.length);
	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);
	    if (length > rem)
		throw new BufferUnderflowException();

	    if (order() != ByteOrder.nativeOrder())
		Bits.copyToLongArray(ix(pos), dst,
					  offset << 3,
					  length << 3);
	    else
		Bits.copyToByteArray(ix(pos), dst,
				     offset << 3,
				     length << 3);
	    position(pos + length);
	} else {
	    super.get(dst, offset, length);
	}
	return this;



    }



    public LongBuffer put(long x) {

	unsafe.putLong(ix(nextPutIndex()), Bits.swap((x)));
=====================================================================
Found a 37 line (191 tokens) duplication in the following files: 
Starting at line 208 of /usr/local/java/src/java/nio/DirectIntBufferS.java
Starting at line 208 of /usr/local/java/src/java/nio/DirectIntBufferU.java
	return ((unsafe.getInt(ix(checkIndex(i)))));
    }

    public IntBuffer get(int[] dst, int offset, int length) {

	if ((length << 2) > Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {
	    checkBounds(offset, length, dst.length);
	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);
	    if (length > rem)
		throw new BufferUnderflowException();

	    if (order() != ByteOrder.nativeOrder())
		Bits.copyToIntArray(ix(pos), dst,
					  offset << 2,
					  length << 2);
	    else
		Bits.copyToByteArray(ix(pos), dst,
				     offset << 2,
				     length << 2);
	    position(pos + length);
	} else {
	    super.get(dst, offset, length);
	}
	return this;



    }



    public IntBuffer put(int x) {

	unsafe.putInt(ix(nextPutIndex()), ((x)));
=====================================================================
Found a 37 line (191 tokens) duplication in the following files: 
Starting at line 208 of /usr/local/java/src/java/nio/DirectCharBufferU.java
Starting at line 208 of /usr/local/java/src/java/nio/DirectCharBufferS.java
	return (Bits.swap(unsafe.getChar(ix(checkIndex(i)))));
    }

    public CharBuffer get(char[] dst, int offset, int length) {

	if ((length << 1) > Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {
	    checkBounds(offset, length, dst.length);
	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);
	    if (length > rem)
		throw new BufferUnderflowException();

	    if (order() != ByteOrder.nativeOrder())
		Bits.copyToCharArray(ix(pos), dst,
					  offset << 1,
					  length << 1);
	    else
		Bits.copyToByteArray(ix(pos), dst,
				     offset << 1,
				     length << 1);
	    position(pos + length);
	} else {
	    super.get(dst, offset, length);
	}
	return this;



    }



    public CharBuffer put(char x) {

	unsafe.putChar(ix(nextPutIndex()), Bits.swap((x)));
=====================================================================
Found a 38 line (189 tokens) duplication in the following files: 
Starting at line 346 of /usr/local/java/src/java/nio/DirectCharBufferRU.java
Starting at line 142 of /usr/local/java/src/java/nio/ByteBufferAsCharBufferRB.java
    }

    public boolean isReadOnly() {
	return true;
    }



    public String toString(int start, int end) {
	if ((end > limit()) || (start > end))
	    throw new IndexOutOfBoundsException();
	try {
	    int len = end - start;
	    char[] ca = new char[len];
	    CharBuffer cb = CharBuffer.wrap(ca);
	    CharBuffer db = this.duplicate();
	    db.position(start);
	    db.limit(end);
	    cb.put(db);
	    return new String(ca);
	} catch (StringIndexOutOfBoundsException x) {
	    throw new IndexOutOfBoundsException();
	}
    }


    // --- Methods to support CharSequence ---

    public CharSequence subSequence(int start, int end) {
	int len = length();
	int pos = position();
	assert (pos <= len);
	pos = (pos <= len ? pos : len);

	if ((start < 0) || (end > len) || (start > end))
	    throw new IndexOutOfBoundsException();
	int sublen = end - start;
 	int off = offset + ((pos + start) << 1);
=====================================================================
Found a 36 line (189 tokens) duplication in the following files: 
Starting at line 350 of /usr/local/java/src/java/nio/DirectCharBufferS.java
Starting at line 350 of /usr/local/java/src/java/nio/DirectCharBufferRU.java
    }




    public String toString(int start, int end) {
	if ((end > limit()) || (start > end))
	    throw new IndexOutOfBoundsException();
	try {
	    int len = end - start;
	    char[] ca = new char[len];
	    CharBuffer cb = CharBuffer.wrap(ca);
	    CharBuffer db = this.duplicate();
	    db.position(start);
	    db.limit(end);
	    cb.put(db);
	    return new String(ca);
	} catch (StringIndexOutOfBoundsException x) {
	    throw new IndexOutOfBoundsException();
	}
    }


    // --- Methods to support CharSequence ---

    public CharSequence subSequence(int start, int end) {
	int len = length();
	int pos = position();
	assert (pos <= len);
	pos = (pos <= len ? pos : len);

	if ((start < 0) || (end > len) || (start > end))
	    throw new IndexOutOfBoundsException();
	int sublen = end - start;
 	int off = (pos + start) << 1;
	return new DirectCharBufferRU(this, -1, 0, sublen, sublen, off);
=====================================================================
Found a 38 line (189 tokens) duplication in the following files: 
Starting at line 346 of /usr/local/java/src/java/nio/DirectCharBufferS.java
Starting at line 142 of /usr/local/java/src/java/nio/ByteBufferAsCharBufferB.java
    }

    public boolean isReadOnly() {
	return false;
    }



    public String toString(int start, int end) {
	if ((end > limit()) || (start > end))
	    throw new IndexOutOfBoundsException();
	try {
	    int len = end - start;
	    char[] ca = new char[len];
	    CharBuffer cb = CharBuffer.wrap(ca);
	    CharBuffer db = this.duplicate();
	    db.position(start);
	    db.limit(end);
	    cb.put(db);
	    return new String(ca);
	} catch (StringIndexOutOfBoundsException x) {
	    throw new IndexOutOfBoundsException();
	}
    }


    // --- Methods to support CharSequence ---

    public CharSequence subSequence(int start, int end) {
	int len = length();
	int pos = position();
	assert (pos <= len);
	pos = (pos <= len ? pos : len);

	if ((start < 0) || (end > len) || (start > end))
	    throw new IndexOutOfBoundsException();
	int sublen = end - start;
 	int off = offset + ((pos + start) << 1);
=====================================================================
Found a 36 line (189 tokens) duplication in the following files: 
Starting at line 350 of /usr/local/java/src/java/nio/DirectCharBufferU.java
Starting at line 350 of /usr/local/java/src/java/nio/DirectCharBufferRU.java
    }




    public String toString(int start, int end) {
	if ((end > limit()) || (start > end))
	    throw new IndexOutOfBoundsException();
	try {
	    int len = end - start;
	    char[] ca = new char[len];
	    CharBuffer cb = CharBuffer.wrap(ca);
	    CharBuffer db = this.duplicate();
	    db.position(start);
	    db.limit(end);
	    cb.put(db);
	    return new String(ca);
	} catch (StringIndexOutOfBoundsException x) {
	    throw new IndexOutOfBoundsException();
	}
    }


    // --- Methods to support CharSequence ---

    public CharSequence subSequence(int start, int end) {
	int len = length();
	int pos = position();
	assert (pos <= len);
	pos = (pos <= len ? pos : len);

	if ((start < 0) || (end > len) || (start > end))
	    throw new IndexOutOfBoundsException();
	int sublen = end - start;
 	int off = (pos + start) << 1;
	return new DirectCharBufferRU(this, -1, 0, sublen, sublen, off);
=====================================================================
Found a 38 line (189 tokens) duplication in the following files: 
Starting at line 346 of /usr/local/java/src/java/nio/DirectCharBufferU.java
Starting at line 142 of /usr/local/java/src/java/nio/ByteBufferAsCharBufferB.java
    }

    public boolean isReadOnly() {
	return false;
    }



    public String toString(int start, int end) {
	if ((end > limit()) || (start > end))
	    throw new IndexOutOfBoundsException();
	try {
	    int len = end - start;
	    char[] ca = new char[len];
	    CharBuffer cb = CharBuffer.wrap(ca);
	    CharBuffer db = this.duplicate();
	    db.position(start);
	    db.limit(end);
	    cb.put(db);
	    return new String(ca);
	} catch (StringIndexOutOfBoundsException x) {
	    throw new IndexOutOfBoundsException();
	}
    }


    // --- Methods to support CharSequence ---

    public CharSequence subSequence(int start, int end) {
	int len = length();
	int pos = position();
	assert (pos <= len);
	pos = (pos <= len ? pos : len);

	if ((start < 0) || (end > len) || (start > end))
	    throw new IndexOutOfBoundsException();
	int sublen = end - start;
 	int off = offset + ((pos + start) << 1);
=====================================================================
Found a 36 line (189 tokens) duplication in the following files: 
Starting at line 350 of /usr/local/java/src/java/nio/DirectCharBufferRS.java
Starting at line 350 of /usr/local/java/src/java/nio/DirectCharBufferU.java
    }




    public String toString(int start, int end) {
	if ((end > limit()) || (start > end))
	    throw new IndexOutOfBoundsException();
	try {
	    int len = end - start;
	    char[] ca = new char[len];
	    CharBuffer cb = CharBuffer.wrap(ca);
	    CharBuffer db = this.duplicate();
	    db.position(start);
	    db.limit(end);
	    cb.put(db);
	    return new String(ca);
	} catch (StringIndexOutOfBoundsException x) {
	    throw new IndexOutOfBoundsException();
	}
    }


    // --- Methods to support CharSequence ---

    public CharSequence subSequence(int start, int end) {
	int len = length();
	int pos = position();
	assert (pos <= len);
	pos = (pos <= len ? pos : len);

	if ((start < 0) || (end > len) || (start > end))
	    throw new IndexOutOfBoundsException();
	int sublen = end - start;
 	int off = (pos + start) << 1;
	return new DirectCharBufferU(this, -1, 0, sublen, sublen, off);
=====================================================================
Found a 38 line (189 tokens) duplication in the following files: 
Starting at line 346 of /usr/local/java/src/java/nio/DirectCharBufferRS.java
Starting at line 142 of /usr/local/java/src/java/nio/ByteBufferAsCharBufferRB.java
    }

    public boolean isReadOnly() {
	return true;
    }



    public String toString(int start, int end) {
	if ((end > limit()) || (start > end))
	    throw new IndexOutOfBoundsException();
	try {
	    int len = end - start;
	    char[] ca = new char[len];
	    CharBuffer cb = CharBuffer.wrap(ca);
	    CharBuffer db = this.duplicate();
	    db.position(start);
	    db.limit(end);
	    cb.put(db);
	    return new String(ca);
	} catch (StringIndexOutOfBoundsException x) {
	    throw new IndexOutOfBoundsException();
	}
    }


    // --- Methods to support CharSequence ---

    public CharSequence subSequence(int start, int end) {
	int len = length();
	int pos = position();
	assert (pos <= len);
	pos = (pos <= len ? pos : len);

	if ((start < 0) || (end > len) || (start > end))
	    throw new IndexOutOfBoundsException();
	int sublen = end - start;
 	int off = offset + ((pos + start) << 1);
=====================================================================
Found a 31 line (183 tokens) duplication in the following files: 
Starting at line 262 of /usr/local/java/src/java/lang/CharacterData.java
Starting at line 157 of /usr/local/java/src/java/lang/CharacterDataLatin1.java
    }

    static int digit(char ch, int radix) {
        int value = -1;
        if (radix >= Character.MIN_RADIX && radix <= Character.MAX_RADIX) {
            int val = getProperties(ch);
            int kind = val & 0x1F;
            if (kind == Character.DECIMAL_DIGIT_NUMBER) {
                value = ch + ((val & 0x3E0) >> 5) & 0x1F;
            }
            else if ((val & 0xC00) == 0x00000C00) {
                // Java supradecimal digit
                value = (ch + ((val & 0x3E0) >> 5) & 0x1F) + 10;
            }
        }
        return (value < radix) ? value : -1;
    }

    static int getNumericValue(char ch) {
        int val = getProperties(ch);
        int retval = -1;

        switch (val & 0xC00) {
            default: // cannot occur
            case (0x00000000):         // not numeric
                retval = -1;
                break;
            case (0x00000400):              // simple numeric
                retval = ch + ((val & 0x3E0) >> 5) & 0x1F;
                break;
            case (0x00000800)      :       // "strange" numeric
=====================================================================
Found a 59 line (180 tokens) duplication in the following files: 
Starting at line 150 of /usr/local/java/src/java/io/PipedReader.java
Starting at line 176 of /usr/local/java/src/java/io/PipedInputStream.java
	    receive(b[off++]);
	}
    }

    /**
     * Notifies all waiting threads that the last byte of data has been
     * received.
     */
    synchronized void receivedLast() {
	closedByWriter = true;
	notifyAll();
    }

    /**
     * Reads the next byte of data from this piped input stream. The
     * value byte is returned as an <code>int</code> in the range
     * <code>0</code> to <code>255</code>. If no byte is available
     * because the end of the stream has been reached, the value
     * <code>-1</code> is returned. This method blocks until input data
     * is available, the end of the stream is detected, or an exception
     * is thrown.
     * If a thread was providing data bytes
     * to the connected piped output stream, but
     * the  thread is no longer alive, then an
     * <code>IOException</code> is thrown.
     *
     * @return     the next byte of data, or <code>-1</code> if the end of the
     *             stream is reached.
     * @exception  IOException  if the pipe is broken.
     */
    public synchronized int read()  throws IOException {
        if (!connected) {
            throw new IOException("Pipe not connected");
        } else if (closedByReader) {
	    throw new IOException("Pipe closed");
	} else if (writeSide != null && !writeSide.isAlive()
                   && !closedByWriter && (in < 0)) {
            throw new IOException("Write end dead");
        }

        readSide = Thread.currentThread();
	int trials = 2;
	while (in < 0) {
	    if (closedByWriter) {
		/* closed by writer, return EOF */
		return -1;
	    }
	    if ((writeSide != null) && (!writeSide.isAlive()) && (--trials < 0)) {
		throw new IOException("Pipe broken");
	    }
            /* might be a writer waiting */
	    notifyAll();
	    try {
	        wait(1000);
	    } catch (InterruptedException ex) {
		throw new java.io.InterruptedIOException();
	    }
 	}
	int ret = buffer[out++] & 0xFF;
=====================================================================
Found a 34 line (180 tokens) duplication in the following files: 
Starting at line 350 of /usr/local/java/src/java/nio/DirectCharBufferRS.java
Starting at line 146 of /usr/local/java/src/java/nio/ByteBufferAsCharBufferL.java
    }



    public String toString(int start, int end) {
	if ((end > limit()) || (start > end))
	    throw new IndexOutOfBoundsException();
	try {
	    int len = end - start;
	    char[] ca = new char[len];
	    CharBuffer cb = CharBuffer.wrap(ca);
	    CharBuffer db = this.duplicate();
	    db.position(start);
	    db.limit(end);
	    cb.put(db);
	    return new String(ca);
	} catch (StringIndexOutOfBoundsException x) {
	    throw new IndexOutOfBoundsException();
	}
    }


    // --- Methods to support CharSequence ---

    public CharSequence subSequence(int start, int end) {
	int len = length();
	int pos = position();
	assert (pos <= len);
	pos = (pos <= len ? pos : len);

	if ((start < 0) || (end > len) || (start > end))
	    throw new IndexOutOfBoundsException();
	int sublen = end - start;
 	int off = offset + ((pos + start) << 1);
=====================================================================
Found a 37 line (178 tokens) duplication in the following files: 
Starting at line 208 of /usr/local/java/src/java/nio/DirectFloatBufferS.java
Starting at line 208 of /usr/local/java/src/java/nio/DirectFloatBufferU.java
	return ((unsafe.getFloat(ix(checkIndex(i)))));
    }

    public FloatBuffer get(float[] dst, int offset, int length) {

	if ((length << 2) > Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {
	    checkBounds(offset, length, dst.length);
	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);
	    if (length > rem)
		throw new BufferUnderflowException();

	    if (order() != ByteOrder.nativeOrder())
		Bits.copyToIntArray(ix(pos), dst,
					  offset << 2,
					  length << 2);
	    else
		Bits.copyToByteArray(ix(pos), dst,
				     offset << 2,
				     length << 2);
	    position(pos + length);
	} else {
	    super.get(dst, offset, length);
	}
	return this;



    }



    public FloatBuffer put(float x) {

	unsafe.putFloat(ix(nextPutIndex()), ((x)));
=====================================================================
Found a 37 line (178 tokens) duplication in the following files: 
Starting at line 208 of /usr/local/java/src/java/nio/DirectDoubleBufferS.java
Starting at line 208 of /usr/local/java/src/java/nio/DirectDoubleBufferU.java
	return ((unsafe.getDouble(ix(checkIndex(i)))));
    }

    public DoubleBuffer get(double[] dst, int offset, int length) {

	if ((length << 3) > Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {
	    checkBounds(offset, length, dst.length);
	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);
	    if (length > rem)
		throw new BufferUnderflowException();

	    if (order() != ByteOrder.nativeOrder())
		Bits.copyToLongArray(ix(pos), dst,
					  offset << 3,
					  length << 3);
	    else
		Bits.copyToByteArray(ix(pos), dst,
				     offset << 3,
				     length << 3);
	    position(pos + length);
	} else {
	    super.get(dst, offset, length);
	}
	return this;



    }



    public DoubleBuffer put(double x) {

	unsafe.putDouble(ix(nextPutIndex()), ((x)));
=====================================================================
Found a 56 line (177 tokens) duplication in the following files: 
Starting at line 388 of /usr/local/java/src/java/lang/Long.java
Starting at line 462 of /usr/local/java/src/java/lang/Integer.java
		limit = -Integer.MAX_VALUE;
	    }
	    multmin = limit / radix;
	    if (i < max) {
		digit = Character.digit(s.charAt(i++),radix);
		if (digit < 0) {
		    throw NumberFormatException.forInputString(s);
		} else {
		    result = -digit;
		}
	    }
	    while (i < max) {
		// Accumulating negatively avoids surprises near MAX_VALUE
		digit = Character.digit(s.charAt(i++),radix);
		if (digit < 0) {
		    throw NumberFormatException.forInputString(s);
		}
		if (result < multmin) {
		    throw NumberFormatException.forInputString(s);
		}
		result *= radix;
		if (result < limit + digit) {
		    throw NumberFormatException.forInputString(s);
		}
		result -= digit;
	    }
	} else {
	    throw NumberFormatException.forInputString(s);
	}
	if (negative) {
	    if (i > 1) {
		return result;
	    } else {	/* Only got "-" */
		throw NumberFormatException.forInputString(s);
	    }
	} else {
	    return -result;
	}
    }

    /**
     * Parses the string argument as a signed decimal integer. The 
     * characters in the string must all be decimal digits, except that 
     * the first character may be an ASCII minus sign <code>'-'</code> 
     * (<code>'&#92;u002D'</code>) to indicate a negative value. The resulting 
     * integer value is returned, exactly as if the argument and the radix 
     * 10 were given as arguments to the 
     * {@link #parseInt(java.lang.String, int)} method.
     *
     * @param s	   a <code>String</code> containing the <code>int</code>
     *             representation to be parsed
     * @return     the integer value represented by the argument in decimal.
     * @exception  NumberFormatException  if the string does not contain a
     *               parsable integer.
     */
    public static int parseInt(String s) throws NumberFormatException {
=====================================================================
Found a 22 line (177 tokens) duplication in the following files: 
Starting at line 473 of /usr/local/java/src/java/util/Arrays.java
Starting at line 556 of /usr/local/java/src/java/util/Arrays.java
Starting at line 639 of /usr/local/java/src/java/util/Arrays.java
Starting at line 723 of /usr/local/java/src/java/util/Arrays.java
Starting at line 807 of /usr/local/java/src/java/util/Arrays.java
Starting at line 891 of /usr/local/java/src/java/util/Arrays.java
Starting at line 975 of /usr/local/java/src/java/util/Arrays.java
    private static void sort1(float x[], int off, int len) {
	// Insertion sort on smallest arrays
	if (len < 7) {
	    for (int i=off; i<len+off; i++)
		for (int j=i; j>off && x[j-1]>x[j]; j--)
		    swap(x, j, j-1);
	    return;
	}

	// Choose a partition element, v
	int m = off + (len >> 1);       // Small arrays, middle element
	if (len > 7) {
	    int l = off;
	    int n = off + len - 1;
	    if (len > 40) {        // Big arrays, pseudomedian of 9
		int s = len/8;
		l = med3(x, l,     l+s, l+2*s);
		m = med3(x, m-s,   m,   m+s);
		n = med3(x, n-2*s, n-s, n);
	    }
	    m = med3(x, l, m, n); // Mid-size, med of 3
	}
=====================================================================
Found a 31 line (174 tokens) duplication in the following files: 
Starting at line 405 of /usr/local/java/src/java/awt/TexturePaintContext.java
Starting at line 541 of /usr/local/java/src/java/awt/TexturePaintContext.java
	    for (int j = 0; j < h; j++) {
		if (normalx) {
		    int in = inOff + rowy * inSpan + bWidth;
		    x = bWidth - rowx;
		    out += w;
		    if (bWidth >= 32) {
			int i = w;
			while (i > 0) {
			    int copyw = (i < x) ? i : x;
			    System.arraycopy(inData, in - x,
					     outData, out - i,
					     copyw);
			    i -= copyw;
			    if ((x -= copyw) == 0) {
				x = bWidth;
			    }
			}
		    } else {
			for (int i = w; i > 0; i--) {
			    outData[out - i] = inData[in - x];
			    if (--x == 0) {
				x = bWidth;
			    }
			}
		    }
		} else {
		    x = rowx;
		    y = rowy;
		    xerr = rowxerr;
		    yerr = rowyerr;
		    for (int i = 0; i < w; i++) {
=====================================================================
Found a 39 line (167 tokens) duplication in the following files: 
Starting at line 694 of /usr/local/java/src/java/lang/FloatingDecimal.java
Starting at line 747 of /usr/local/java/src/java/lang/FloatingDecimal.java
		low  = (b <  m );
		high = (b+m > tens );
                assert q < 10 : q; // excessively large digit
                if ( (q == 0) && ! high ){
		    // oops. Usually ignore leading zero.
		    decExp--;
		} else {
		    digits[ndigit++] = (char)('0' + q);
		}
		/*
		 * HACK! Java spec sez that we always have at least
		 * one digit after the . in either F- or E-form output.
		 * Thus we will need more than one digit if we're using
		 * E-form
		 */
		if ( decExp <= -3 || decExp >= 8 ){
		    high = low = false;
		}
		while( ! low && ! high ){
		    q = (int) ( b / s );
		    b = 10 * ( b % s );
		    m *= 10;
                    assert q < 10 : q;  // excessively large digit
		    if ( m > 0L ){
			low  = (b <  m );
			high = (b+m > tens );
		    } else {
			// hack -- m might overflow!
			// in this case, it is certainly > b,
			// which won't
			// and b+m > tens, too, since that has overflowed
			// either!
			low = true;
			high = true;
		    }
		    digits[ndigit++] = (char)('0' + q);
		}
		lowDigitDifference = (b<<1) - tens;
	    }
=====================================================================
Found a 51 line (166 tokens) duplication in the following files: 
Starting at line 417 of /usr/local/java/src/java/security/UnresolvedPermission.java
Starting at line 381 of /usr/local/java/src/java/security/CodeSource.java
	return sb.toString();
    }

    /**
     * Writes this object out to a stream (i.e., serializes it).
     *
     * @serialData An initial <code>URL</code> is followed by an
     * <code>int</code> indicating the number of certificates to follow 
     * (a value of "zero" denotes that there are no certificates associated
     * with this object).
     * Each certificate is written out starting with a <code>String</code>
     * denoting the certificate type, followed by an
     * <code>int</code> specifying the length of the certificate encoding,
     * followed by the certificate encoding itself which is written out as an
     * array of bytes.
     */
    private synchronized void writeObject(java.io.ObjectOutputStream oos)
        throws IOException
    {
	oos.defaultWriteObject();

	if (certs==null || certs.length==0) {
	    oos.writeInt(0);
	} else {
	    // write out the total number of certs
	    oos.writeInt(certs.length);
	    // write out each cert, including its type
	    for (int i=0; i < certs.length; i++) {
		java.security.cert.Certificate cert = certs[i];
		try {
		    oos.writeUTF(cert.getType());
		    byte[] encoded = cert.getEncoded();
		    oos.writeInt(encoded.length);
		    oos.write(encoded);
		} catch (CertificateEncodingException cee) {
		    throw new IOException(cee.getMessage());
		}
	    }
	}
    }

    /**
     * Restores this object from a stream (i.e., deserializes it).
     */
    private synchronized void readObject(java.io.ObjectInputStream ois)
	throws IOException, ClassNotFoundException
    {
	CertificateFactory cf;
	Hashtable cfs=null;

	ois.defaultReadObject();
=====================================================================
Found a 54 line (164 tokens) duplication in the following files: 
Starting at line 138 of /usr/local/java/src/java/util/zip/Deflater.java
Starting at line 86 of /usr/local/java/src/java/util/zip/Inflater.java
	this(false);
    }

    /**
     * Sets input data for decompression. Should be called whenever
     * needsInput() returns true indicating that more input data is
     * required.
     * @param b the input data bytes
     * @param off the start offset of the input data
     * @param len the length of the input data
     * @see Inflater#needsInput
     */
    public synchronized void setInput(byte[] b, int off, int len) {
	if (b == null) {
	    throw new NullPointerException();
	}
	if (off < 0 || len < 0 || off > b.length - len) {
	    throw new ArrayIndexOutOfBoundsException();
	}
	this.buf = b;
	this.off = off;
	this.len = len;
    }

    /**
     * Sets input data for decompression. Should be called whenever
     * needsInput() returns true indicating that more input data is
     * required.
     * @param b the input data bytes
     * @see Inflater#needsInput
     */
    public void setInput(byte[] b) {
	setInput(b, 0, b.length);
    }

    /**
     * Sets the preset dictionary to the given array of bytes. Should be
     * called when inflate() returns 0 and needsDictionary() returns true
     * indicating that a preset dictionary is required. The method getAdler()
     * can be used to get the Adler-32 value of the dictionary needed.
     * @param b the dictionary data bytes
     * @param off the start offset of the data
     * @param len the length of the data
     * @see Inflater#needsDictionary
     * @see Inflater#getAdler
     */
    public synchronized void setDictionary(byte[] b, int off, int len) {
	if (strm == 0 || b == null) {
	    throw new NullPointerException();
	}
	if (off < 0 || len < 0 || off > b.length - len) {
	    throw new ArrayIndexOutOfBoundsException();
	}
	setDictionary(strm, b, off, len);
=====================================================================
Found a 42 line (162 tokens) duplication in the following files: 
Starting at line 145 of /usr/local/java/src/java/awt/image/BufferedImageFilter.java
Starting at line 232 of /usr/local/java/src/java/awt/image/BufferedImageFilter.java
			  ColorModel model, int pixels[], int off,
			  int scansize) {
        // Fix 4184230
        if (w < 0 || h < 0) {
            throw new IllegalArgumentException("Width ("+w+
                                                ") and height ("+h+
                                                ") must be > 0");
        }
        // Nothing to do
        if (w == 0 || h == 0) {
            return;
        }
	if (y < 0) {
	    int diff = -y;
	    if (diff >= h) {
		return;
	    }
	    off += scansize * diff;
	    y += diff;
	    h -= diff;
	}
	if (y + h > height) {
	    h = height - y;
	    if (h <= 0) {
		return;
	    }
	}
	if (x < 0) {
	    int diff = -x;
	    if (diff >= w) {
		return;
	    }
	    off += diff;
	    x += diff;
	    w -= diff;
	}
	if (x + w > width) {
	    w = width - x;
	    if (w <= 0) {
		return;
	    }
	}
=====================================================================
Found a 78 line (154 tokens) duplication in the following files: 
Starting at line 195 of /usr/local/java/src/java/lang/reflect/Constructor.java
Starting at line 228 of /usr/local/java/src/java/lang/reflect/Method.java
	    sb.append(getName() + "(");
	    Class[] params = parameterTypes; // avoid clone
	    for (int j = 0; j < params.length; j++) {
		sb.append(Field.getTypeName(params[j]));
		if (j < (params.length - 1))
		    sb.append(",");
	    }
	    sb.append(")");
	    Class[] exceptions = exceptionTypes; // avoid clone
	    if (exceptions.length > 0) {
		sb.append(" throws ");
		for (int k = 0; k < exceptions.length; k++) {
		    sb.append(exceptions[k].getName());
		    if (k < (exceptions.length - 1))
			sb.append(",");
		}
	    }
	    return sb.toString();
	} catch (Exception e) {
	    return "<" + e + ">";
	}
    }

    /**
     * Invokes the underlying method represented by this <code>Method</code> 
     * object, on the specified object with the specified parameters.
     * Individual parameters are automatically unwrapped to match
     * primitive formal parameters, and both primitive and reference
     * parameters are subject to method invocation conversions as
     * necessary.
     *
     * <p>If the underlying method is static, then the specified <code>obj</code> 
     * argument is ignored. It may be null.
     *
     * <p>If the number of formal parameters required by the underlying method is
     * 0, the supplied <code>args</code> array may be of length 0 or null.
     *
     * <p>If the underlying method is an instance method, it is invoked
     * using dynamic method lookup as documented in The Java Language
     * Specification, Second Edition, section 15.12.4.4; in particular,
     * overriding based on the runtime type of the target object will occur.
     *
     * <p>If the underlying method is static, the class that declared
     * the method is initialized if it has not already been initialized.
     *
     * <p>If the method completes normally, the value it returns is
     * returned to the caller of invoke; if the value has a primitive
     * type, it is first appropriately wrapped in an object. If the
     * underlying method return type is void, the invocation returns
     * null.
     *
     * @param obj  the object the underlying method is invoked from
     * @param args the arguments used for the method call
     * @return the result of dispatching the method represented by
     * this object on <code>obj</code> with parameters
     * <code>args</code>
     *
     * @exception IllegalAccessException    if this <code>Method</code> object
     *              enforces Java language access control and the underlying
     *              method is inaccessible.
     * @exception IllegalArgumentException  if the method is an
     *              instance method and the specified object argument
     *              is not an instance of the class or interface
     *              declaring the underlying method (or of a subclass
     *              or implementor thereof); if the number of actual
     *              and formal parameters differ; if an unwrapping
     *              conversion for primitive arguments fails; or if,
     *              after possible unwrapping, a parameter value
     *              cannot be converted to the corresponding formal
     *              parameter type by a method invocation conversion.
     * @exception InvocationTargetException if the underlying method
     *              throws an exception.
     * @exception NullPointerException      if the specified object is null
     *              and the method is an instance method.
     * @exception ExceptionInInitializerError if the initialization
     * provoked by this method fails.
     */
    public Object invoke(Object obj, Object[] args)
=====================================================================
Found a 24 line (154 tokens) duplication in the following files: 
Starting at line 1183 of /usr/local/java/src/java/awt/image/DirectColorModel.java
Starting at line 1206 of /usr/local/java/src/java/awt/image/DirectColorModel.java
                case DataBuffer.TYPE_USHORT: {
                    for (int y = 0; y < h; y++, rY++) {
                        rX = rminX;
                        for (int x = 0; x < w; x++, rX++) {
                            pixel = raster.getPixel(rX, rY, pixel);
                            normAlpha = pixel[aIdx] * alphaScale;
                            if (normAlpha != 0.f) {
                                for (int c=0; c < aIdx; c++) {
                                    pixel[c] = (int) (pixel[c] * normAlpha +
                                                      0.5f);
                                }
                                raster.setPixel(rX, rY, pixel);
                            } else {
                                if (zpixel == null) {
                                    zpixel = new int[numComponents];
                                    java.util.Arrays.fill(zpixel, 0);
                                }
                                raster.setPixel(rX, rY, zpixel);
                            }
                        }
                    }
                } 
                break; 
                case DataBuffer.TYPE_INT: {
=====================================================================
Found a 28 line (152 tokens) duplication in the following files: 
Starting at line 301 of /usr/local/java/src/java/nio/DirectIntBufferU.java
Starting at line 301 of /usr/local/java/src/java/nio/DirectFloatBufferS.java
    public FloatBuffer put(float[] src, int offset, int length) {

	if ((length << 2) > Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {
	    checkBounds(offset, length, src.length);
	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);
	    if (length > rem)
		throw new BufferOverflowException();

	    if (order() != ByteOrder.nativeOrder()) 
		Bits.copyFromIntArray(src, offset << 2,
					    ix(pos), length << 2);
	    else
		Bits.copyFromByteArray(src, offset << 2,
				       ix(pos), length << 2);
	    position(pos + length);
	} else {
	    super.put(src, offset, length);
	}
	return this;



    }
    
    public FloatBuffer compact() {
=====================================================================
Found a 32 line (152 tokens) duplication in the following files: 
Starting at line 211 of /usr/local/java/src/java/nio/DirectIntBufferU.java
Starting at line 211 of /usr/local/java/src/java/nio/DirectFloatBufferS.java
    public FloatBuffer get(float[] dst, int offset, int length) {

	if ((length << 2) > Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {
	    checkBounds(offset, length, dst.length);
	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);
	    if (length > rem)
		throw new BufferUnderflowException();

	    if (order() != ByteOrder.nativeOrder())
		Bits.copyToIntArray(ix(pos), dst,
					  offset << 2,
					  length << 2);
	    else
		Bits.copyToByteArray(ix(pos), dst,
				     offset << 2,
				     length << 2);
	    position(pos + length);
	} else {
	    super.get(dst, offset, length);
	}
	return this;



    }



    public FloatBuffer put(float x) {
=====================================================================
Found a 28 line (152 tokens) duplication in the following files: 
Starting at line 301 of /usr/local/java/src/java/nio/DirectDoubleBufferU.java
Starting at line 301 of /usr/local/java/src/java/nio/DirectLongBufferS.java
    public LongBuffer put(long[] src, int offset, int length) {

	if ((length << 3) > Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {
	    checkBounds(offset, length, src.length);
	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);
	    if (length > rem)
		throw new BufferOverflowException();

	    if (order() != ByteOrder.nativeOrder()) 
		Bits.copyFromLongArray(src, offset << 3,
					    ix(pos), length << 3);
	    else
		Bits.copyFromByteArray(src, offset << 3,
				       ix(pos), length << 3);
	    position(pos + length);
	} else {
	    super.put(src, offset, length);
	}
	return this;



    }
    
    public LongBuffer compact() {
=====================================================================
Found a 32 line (152 tokens) duplication in the following files: 
Starting at line 211 of /usr/local/java/src/java/nio/DirectDoubleBufferU.java
Starting at line 211 of /usr/local/java/src/java/nio/DirectLongBufferS.java
    public LongBuffer get(long[] dst, int offset, int length) {

	if ((length << 3) > Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {
	    checkBounds(offset, length, dst.length);
	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);
	    if (length > rem)
		throw new BufferUnderflowException();

	    if (order() != ByteOrder.nativeOrder())
		Bits.copyToLongArray(ix(pos), dst,
					  offset << 3,
					  length << 3);
	    else
		Bits.copyToByteArray(ix(pos), dst,
				     offset << 3,
				     length << 3);
	    position(pos + length);
	} else {
	    super.get(dst, offset, length);
	}
	return this;



    }



    public LongBuffer put(long x) {
=====================================================================
Found a 28 line (152 tokens) duplication in the following files: 
Starting at line 301 of /usr/local/java/src/java/nio/DirectLongBufferU.java
Starting at line 301 of /usr/local/java/src/java/nio/DirectDoubleBufferU.java
    public DoubleBuffer put(double[] src, int offset, int length) {

	if ((length << 3) > Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {
	    checkBounds(offset, length, src.length);
	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);
	    if (length > rem)
		throw new BufferOverflowException();

	    if (order() != ByteOrder.nativeOrder()) 
		Bits.copyFromLongArray(src, offset << 3,
					    ix(pos), length << 3);
	    else
		Bits.copyFromByteArray(src, offset << 3,
				       ix(pos), length << 3);
	    position(pos + length);
	} else {
	    super.put(src, offset, length);
	}
	return this;



    }
    
    public DoubleBuffer compact() {
=====================================================================
Found a 32 line (152 tokens) duplication in the following files: 
Starting at line 211 of /usr/local/java/src/java/nio/DirectLongBufferU.java
Starting at line 211 of /usr/local/java/src/java/nio/DirectDoubleBufferU.java
    public DoubleBuffer get(double[] dst, int offset, int length) {

	if ((length << 3) > Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {
	    checkBounds(offset, length, dst.length);
	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);
	    if (length > rem)
		throw new BufferUnderflowException();

	    if (order() != ByteOrder.nativeOrder())
		Bits.copyToLongArray(ix(pos), dst,
					  offset << 3,
					  length << 3);
	    else
		Bits.copyToByteArray(ix(pos), dst,
				     offset << 3,
				     length << 3);
	    position(pos + length);
	} else {
	    super.get(dst, offset, length);
	}
	return this;



    }



    public DoubleBuffer put(double x) {
=====================================================================
Found a 225 line (152 tokens) duplication in the following files: 
Starting at line 172 of /usr/local/java/src/java/nio/DirectFloatBufferRU.java
Starting at line 172 of /usr/local/java/src/java/nio/DirectFloatBufferRS.java
	return new DirectFloatBufferRS(this,
					      this.markValue(),
					      this.position(),
					      this.limit(),
					      this.capacity(),
					      0);
    }

    public FloatBuffer asReadOnlyBuffer() {








	return duplicate();

    }


















































    public FloatBuffer put(float x) {




	throw new ReadOnlyBufferException();

    }

    public FloatBuffer put(int i, float x) {




	throw new ReadOnlyBufferException();

    }

    public FloatBuffer put(FloatBuffer src) {




































	throw new ReadOnlyBufferException();

    }

    public FloatBuffer put(float[] src, int offset, int length) {






















	throw new ReadOnlyBufferException();

    }
    
    public FloatBuffer compact() {











	throw new ReadOnlyBufferException();

    }

    public boolean isDirect() {
	return true;
    }

    public boolean isReadOnly() {
	return true;
    }











































    public ByteOrder order() {

	return ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN)
=====================================================================
Found a 28 line (152 tokens) duplication in the following files: 
Starting at line 301 of /usr/local/java/src/java/nio/DirectIntBufferS.java
Starting at line 301 of /usr/local/java/src/java/nio/DirectFloatBufferS.java
    public FloatBuffer put(float[] src, int offset, int length) {

	if ((length << 2) > Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {
	    checkBounds(offset, length, src.length);
	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);
	    if (length > rem)
		throw new BufferOverflowException();

	    if (order() != ByteOrder.nativeOrder()) 
		Bits.copyFromIntArray(src, offset << 2,
					    ix(pos), length << 2);
	    else
		Bits.copyFromByteArray(src, offset << 2,
				       ix(pos), length << 2);
	    position(pos + length);
	} else {
	    super.put(src, offset, length);
	}
	return this;



    }
    
    public FloatBuffer compact() {
=====================================================================
Found a 32 line (152 tokens) duplication in the following files: 
Starting at line 211 of /usr/local/java/src/java/nio/DirectIntBufferS.java
Starting at line 211 of /usr/local/java/src/java/nio/DirectFloatBufferS.java
    public FloatBuffer get(float[] dst, int offset, int length) {

	if ((length << 2) > Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {
	    checkBounds(offset, length, dst.length);
	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);
	    if (length > rem)
		throw new BufferUnderflowException();

	    if (order() != ByteOrder.nativeOrder())
		Bits.copyToIntArray(ix(pos), dst,
					  offset << 2,
					  length << 2);
	    else
		Bits.copyToByteArray(ix(pos), dst,
				     offset << 2,
				     length << 2);
	    position(pos + length);
	} else {
	    super.get(dst, offset, length);
	}
	return this;



    }



    public FloatBuffer put(float x) {
=====================================================================
Found a 28 line (152 tokens) duplication in the following files: 
Starting at line 301 of /usr/local/java/src/java/nio/DirectDoubleBufferS.java
Starting at line 301 of /usr/local/java/src/java/nio/DirectLongBufferU.java
    public LongBuffer put(long[] src, int offset, int length) {

	if ((length << 3) > Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {
	    checkBounds(offset, length, src.length);
	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);
	    if (length > rem)
		throw new BufferOverflowException();

	    if (order() != ByteOrder.nativeOrder()) 
		Bits.copyFromLongArray(src, offset << 3,
					    ix(pos), length << 3);
	    else
		Bits.copyFromByteArray(src, offset << 3,
				       ix(pos), length << 3);
	    position(pos + length);
	} else {
	    super.put(src, offset, length);
	}
	return this;



    }
    
    public LongBuffer compact() {
=====================================================================
Found a 32 line (152 tokens) duplication in the following files: 
Starting at line 211 of /usr/local/java/src/java/nio/DirectDoubleBufferS.java
Starting at line 211 of /usr/local/java/src/java/nio/DirectLongBufferU.java
    public LongBuffer get(long[] dst, int offset, int length) {

	if ((length << 3) > Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {
	    checkBounds(offset, length, dst.length);
	    int pos = position();
	    int lim = limit();
	    assert (pos <= lim);
	    int rem = (pos <= lim ? lim - pos : 0);
	    if (length > rem)
		throw new BufferUnderflowException();

	    if (order() != ByteOrder.nativeOrder())
		Bits.copyToLongArray(ix(pos), dst,
					  offset << 3,
					  length << 3);
	    else
		Bits.copyToByteArray(ix(pos), dst,
				     offset << 3,
				     length << 3);
	    position(pos + length);
	} else {
	    super.get(dst, offset, length);
	}
	return this;



    }



    public LongBuffer put(long x) {
=====================================================================
Found a 225 line (152 tokens) duplication in the following files: 
Starting at line 172 of /usr/local/java/src/java/nio/DirectDoubleBufferRU.java
Starting at line 172 of /usr/local/java/src/java/nio/DirectDoubleBufferRS.java
	return new DirectDoubleBufferRS(this,
					      this.markValue(),
					      this.position(),
					      this.limit(),
					      this.capacity(),
					      0);
    }

    public DoubleBuffer asReadOnlyBuffer() {








	return duplicate();

    }


















































    public DoubleBuffer put(double x) {




	throw new ReadOnlyBufferException();

    }

    public DoubleBuffer put(int i, double x) {




	throw new ReadOnlyBufferException();

    }

    public DoubleBuffer put(DoubleBuffer src) {




































	throw new ReadOnlyBufferException();

    }

    public DoubleBuffer put(double[] src, int offset, int length) {






















	throw new ReadOnlyBufferException();

    }
    
    public DoubleBuffer compact() {











	throw new ReadOnlyBufferException();

    }

    public boolean isDirect() {
	return true;
    }

    public boolean isReadOnly() {
	return true;
    }











































    public ByteOrder order() {

	return ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN)
=====================================================================
Found a 225 line (152 tokens) duplication in the following files: 
Starting at line 172 of /usr/local/java/src/java/nio/DirectLongBufferRU.java
Starting at line 172 of /usr/local/java/src/java/nio/DirectLongBufferRS.java
	return new DirectLongBufferRS(this,
					      this.markValue(),
					      this.position(),
					      this.limit(),
					      this.capacity(),
					      0);
    }

    public LongBuffer asReadOnlyBuffer() {








	return duplicate();

    }


















































    public LongBuffer put(long x) {




	throw new ReadOnlyBufferException();

    }

    public LongBuffer put(int i, long x) {




	throw new ReadOnlyBufferException();

    }

    public LongBuffer put(LongBuffer src) {




































	throw new ReadOnlyBufferException();

    }

    public LongBuffer put(long[] src, int offset, int length) {






















	throw new ReadOnlyBufferException();

    }
    
    public LongBuffer compact() {











	throw new ReadOnlyBufferException();

    }

    public boolean isDirect() {
	return true;
    }

    public boolean isReadOnly() {
	return true;
    }











































    public ByteOrder order() {

	return ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN)
=====================================================================
Found a 225 line (152 tokens) duplication in the following files: 
Starting at line 172 of /usr/local/java/src/java/nio/DirectIntBufferRU.java
Starting at line 172 of /usr/local/java/src/java/nio/DirectIntBufferRS.java
	return new DirectIntBufferRS(this,
					      this.markValue(),
					      this.position(),
					      this.limit(),
					      this.capacity(),
					      0);
    }

    public IntBuffer asReadOnlyBuffer() {








	return duplicate();

    }


















































    public IntBuffer put(int x) {




	throw new ReadOnlyBufferException();

    }

    public IntBuffer put(int i, int x) {




	throw new ReadOnlyBufferException();

    }

    public IntBuffer put(IntBuffer src) {




































	throw new ReadOnlyBufferException();

    }

    public IntBuffer put(int[] src, int offset, int length) {






















	throw new ReadOnlyBufferException();

    }
    
    public IntBuffer compact() {











	throw new ReadOnlyBufferException();

    }

    public boolean isDirect() {
	return true;
    }

    public boolean isReadOnly() {
	return true;
    }











































    public ByteOrder order() {

	return ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN)
=====================================================================
Found a 229 line (152 tokens) duplication in the following files: 
Starting at line 172 of /usr/local/java/src/java/nio/DirectShortBufferRS.java
Starting at line 172 of /usr/local/java/src/java/nio/DirectShortBufferRU.java
	return new DirectShortBufferRU(this,
					      this.markValue(),
					      this.position(),
					      this.limit(),
					      this.capacity(),
					      0);
    }

    public ShortBuffer asReadOnlyBuffer() {








	return duplicate();

    }


















































    public ShortBuffer put(short x) {




	throw new ReadOnlyBufferException();

    }

    public ShortBuffer put(int i, short x) {




	throw new ReadOnlyBufferException();

    }

    public ShortBuffer put(ShortBuffer src) {




































	throw new ReadOnlyBufferException();

    }

    public ShortBuffer put(short[] src, int offset, int length) {






















	throw new ReadOnlyBufferException();

    }
    
    public ShortBuffer compact() {











	throw new ReadOnlyBufferException();

    }

    public boolean isDirect() {
	return true;
    }

    public boolean isReadOnly() {
	return true;
    }











































    public ByteOrder order() {





	return ((ByteOrder.nativeOrder() != ByteOrder.BIG_ENDIAN)
=====================================================================
Found a 125 line (151 tokens) duplication in the following files: 
Starting at line 362 of /usr/local/java/src/java/io/PrintStream.java
Starting at line 292 of /usr/local/java/src/java/io/PrintWriter.java
	write(c);
    }

    /**
     * Print an integer.  The string produced by <code>{@link
     * java.lang.String#valueOf(int)}</code> is translated into bytes according
     * to the platform's default character encoding, and these bytes are
     * written in exactly the manner of the <code>{@link #write(int)}</code>
     * method.
     *
     * @param      i   The <code>int</code> to be printed
     * @see        java.lang.Integer#toString(int)
     */
    public void print(int i) {
	write(String.valueOf(i));
    }

    /**
     * Print a long integer.  The string produced by <code>{@link
     * java.lang.String#valueOf(long)}</code> is translated into bytes
     * according to the platform's default character encoding, and these bytes
     * are written in exactly the manner of the <code>{@link #write(int)}</code>
     * method.
     *
     * @param      l   The <code>long</code> to be printed
     * @see        java.lang.Long#toString(long)
     */
    public void print(long l) {
	write(String.valueOf(l));
    }

    /**
     * Print a floating-point number.  The string produced by <code>{@link
     * java.lang.String#valueOf(float)}</code> is translated into bytes
     * according to the platform's default character encoding, and these bytes
     * are written in exactly the manner of the <code>{@link #write(int)}</code>
     * method.
     *
     * @param      f   The <code>float</code> to be printed
     * @see        java.lang.Float#toString(float)
     */
    public void print(float f) {
	write(String.valueOf(f));
    }

    /**
     * Print a double-precision floating-point number.  The string produced by
     * <code>{@link java.lang.String#valueOf(double)}</code> is translated into
     * bytes according to the platform's default character encoding, and these
     * bytes are written in exactly the manner of the <code>{@link
     * #write(int)}</code> method.
     *
     * @param      d   The <code>double</code> to be printed
     * @see        java.lang.Double#toString(double)
     */
    public void print(double d) {
	write(String.valueOf(d));
    }

    /**
     * Print an array of characters.  The characters are converted into bytes
     * according to the platform's default character encoding, and these bytes
     * are written in exactly the manner of the <code>{@link #write(int)}</code>
     * method.
     *
     * @param      s   The array of chars to be printed
     *
     * @throws  NullPointerException  If <code>s</code> is <code>null</code>
     */
    public void print(char s[]) {
	write(s);
    }

    /**
     * Print a string.  If the argument is <code>null</code> then the string
     * <code>"null"</code> is printed.  Otherwise, the string's characters are
     * converted into bytes according to the platform's default character
     * encoding, and these bytes are written in exactly the manner of the
     * <code>{@link #write(int)}</code> method.
     *
     * @param      s   The <code>String</code> to be printed
     */
    public void print(String s) {
	if (s == null) {
	    s = "null";
	}
	write(s);
    }

    /**
     * Print an object.  The string produced by the <code>{@link
     * java.lang.String#valueOf(Object)}</code> method is translated into bytes
     * according to the platform's default character encoding, and these bytes
     * are written in exactly the manner of the <code>{@link #write(int)}</code>
     * method.
     *
     * @param      obj   The <code>Object</code> to be printed
     * @see        java.lang.Object#toString()
     */
    public void print(Object obj) {
	write(String.valueOf(obj));
    }


    /* Methods that do terminate lines */

    /**
     * Terminate the current line by writing the line separator string.  The
     * line separator string is defined by the system property
     * <code>line.separator</code>, and is not necessarily a single newline
     * character (<code>'\n'</code>).
     */
    public void println() {
	newLine();
    }

    /**
     * Print a boolean value and then terminate the line.  This method behaves
     * as though it invokes <code>{@link #print(boolean)}</code> and then
     * <code>{@link #println()}</code>.
     *
     * @param x the <code>boolean</code> value to be printed
     */
    public void println(boolean x) {
	synchronized (lock) {
=====================================================================
Found a 23 line (151 tokens) duplication in the following files: 
Starting at line 1183 of /usr/local/java/src/java/awt/image/DirectColorModel.java
Starting at line 1229 of /usr/local/java/src/java/awt/image/DirectColorModel.java
                case DataBuffer.TYPE_INT: {
                    for (int y = 0; y < h; y++, rY++) {
                        rX = rminX;
                        for (int x = 0; x < w; x++, rX++) {
                            pixel = raster.getPixel(rX, rY, pixel);
                            normAlpha = pixel[aIdx] * alphaScale;
                            if (normAlpha != 0.f) {
                                for (int c=0; c < aIdx; c++) {
                                    pixel[c] = (int) (pixel[c] * normAlpha +
                                                      0.5f);
                                }
                                raster.setPixel(rX, rY, pixel);
                            } else {
                                if (zpixel == null) {
                                    zpixel = new int[numComponents];
                                    java.util.Arrays.fill(zpixel, 0);
                                }
                                raster.setPixel(rX, rY, zpixel);
                            }
                        }
                    }
                }
                break; 
=====================================================================
Found a 45 line (151 tokens) duplication in the following files: 
Starting at line 685 of /usr/local/java/src/java/awt/ScrollPane.java
Starting at line 762 of /usr/local/java/src/java/awt/ScrollPane.java
}

/*
 * In JDK 1.1.1, the pkg private class java.awt.PeerFixer was moved to 
 * become an inner class of ScrollPane, which broke serialization 
 * for ScrollPane objects using JDK 1.1.
 * Instead of moving it back out here, which would break all JDK 1.1.x
 * releases, we keep PeerFixer in both places. Because of the scoping rules,
 * the PeerFixer that is used in ScrollPane will be the one that is the
 * inner class. This pkg private PeerFixer class below will only be used
 * if the Java 2 platform is used to deserialize ScrollPane objects that were serialized
 * using JDK1.1
 */
class PeerFixer implements AdjustmentListener, java.io.Serializable {

    PeerFixer(ScrollPane scroller) {
	this.scroller = scroller;
    }

    /**
     * Invoked when the value of the adjustable has changed.
     */   
    public void adjustmentValueChanged(AdjustmentEvent e) {
	Adjustable adj = e.getAdjustable();
	int value = e.getValue();
	ScrollPanePeer peer = (ScrollPanePeer) scroller.peer;
	if (peer != null) {
	    peer.setValue(adj, value);
	}

	Component c = scroller.getComponent(0);
        switch(adj.getOrientation()) {
	case Adjustable.VERTICAL:
	    c.move(c.getLocation().x, -(value));
	    break;
	case Adjustable.HORIZONTAL:
	    c.move(-(value), c.getLocation().y);
	    break;
	default:
	    throw new IllegalArgumentException("Illegal adjustable orientation");
	}
    }

    private ScrollPane scroller;
}
=====================================================================
Found a 82 line (151 tokens) duplication in the following files: 
Starting at line 978 of /usr/local/java/src/java/nio/DoubleBuffer.java
Starting at line 978 of /usr/local/java/src/java/nio/ByteBuffer.java
Starting at line 978 of /usr/local/java/src/java/nio/FloatBuffer.java
Starting at line 978 of /usr/local/java/src/java/nio/IntBuffer.java
Starting at line 978 of /usr/local/java/src/java/nio/ShortBuffer.java
Starting at line 978 of /usr/local/java/src/java/nio/LongBuffer.java
    public abstract LongBuffer compact();

    /**
     * Tells whether or not this long buffer is direct. </p>
     *
     * @return  <tt>true</tt> if, and only if, this buffer is direct
     */
    public abstract boolean isDirect();



    /**
     * Returns a string summarizing the state of this buffer.  </p>
     *
     * @return  A summary string
     */
    public String toString() {
	StringBuffer sb = new StringBuffer();
	sb.append(getClass().getName());
	sb.append("[pos=");
	sb.append(position());
	sb.append(" lim=");
	sb.append(limit());
	sb.append(" cap=");
	sb.append(capacity());
	sb.append("]");
	return sb.toString();
    }




    

    /**
     * Returns the current hash code of this buffer.
     *
     * <p> The hash code of a long buffer depends only upon its remaining
     * elements; that is, upon the elements from <tt>position()</tt> up to, and
     * including, the element at <tt>limit()</tt>&nbsp;-&nbsp;<tt>1</tt>.
     *
     * <p> Because buffer hash codes are content-dependent, it is inadvisable
     * to use buffers as keys in hash maps or similar data structures unless it
     * is known that their contents will not change.  </p>
     *
     * @return  The current hash code of this buffer
     */
    public int hashCode() {
	int h = 1;
	int p = position();
	for (int i = limit() - 1; i >= p; i--)
	    h = 31 * h + (int)get(i);
	return h;
    }

    /**
     * Tells whether or not this buffer is equal to another object.
     *
     * <p> Two long buffers are equal if, and only if,
     *
     * <p><ol>
     *
     *   <li><p> They have the same element type,  </p></li>
     *
     *   <li><p> They have the same number of remaining elements, and
     *   </p></li>
     *
     *   <li><p> The two sequences of remaining elements, considered
     *   independently of their starting positions, are pointwise equal.
     *   </p></li>
     *
     * </ol>
     *
     * <p> A long buffer is not equal to any other type of object.  </p>
     *
     * @param  ob  The object to which this buffer is to be compared
     *
     * @return  <tt>true</tt> if, and only if, this buffer is equal to the
     *           given object
     */
    public boolean equals(Object ob) {
	if (!(ob instanceof LongBuffer))
=====================================================================
Found a 38 line (150 tokens) duplication in the following files: 
Starting at line 458 of /usr/local/java/src/java/rmi/activation/Activatable.java
Starting at line 229 of /usr/local/java/src/java/rmi/server/UnicastRemoteObject.java
	throws java.rmi.NoSuchObjectException
    {
	return sun.rmi.transport.ObjectTable.unexportObject(obj, force);
    }

    /*
     * Creates an instance of given server ref type with constructor chosen
     * by indicated paramters and supplied with given arguements, and
     * export remote object with it.
     */
    private static Remote exportObject(Remote obj, String refType,
				       Class[] params, Object[] args)
	throws RemoteException
    {
	// compose name of server ref class and find it
	String refClassName = RemoteRef.packagePrefix + "." + refType;
	Class refClass;
	try {
	    refClass = Class.forName(refClassName);
	} catch (ClassNotFoundException e) {
	    throw new ExportException(
		"No class found for server ref type: " + refType);
	}

	if (!ServerRef.class.isAssignableFrom(refClass)) {
	    throw new ExportException(
		"Server ref class not instance of " +
		ServerRef.class.getName() + ": " + refClass.getName());
	}

	// create server ref instance using given constructor and arguments
	ServerRef serverRef;
	try {
	    java.lang.reflect.Constructor cons =
		refClass.getConstructor(params);
	    serverRef = (ServerRef) cons.newInstance(args);
	    // if impl does extends UnicastRemoteObject, set its ref
	    if (obj instanceof UnicastRemoteObject)
=====================================================================
Found a 32 line (147 tokens) duplication in the following files: 
Starting at line 536 of /usr/local/java/src/java/nio/charset/CharsetEncoder.java
Starting at line 536 of /usr/local/java/src/java/nio/charset/CharsetDecoder.java
		cr = decodeLoop(in, out);
	    } catch (BufferUnderflowException x) {
		throw new CoderMalfunctionError(x);
	    } catch (BufferOverflowException x) {
		throw new CoderMalfunctionError(x);
	    }

	    if (cr.isOverflow())
		return cr;

	    if (cr.isUnderflow()) {
		if (endOfInput && in.hasRemaining()) {
		    cr = CoderResult.malformedForLength(in.remaining());
		    // Fall through to malformed-input case
		} else {
		    return cr;
		}
	    }

	    CodingErrorAction action = null;
	    if (cr.isMalformed())
		action = malformedInputAction;
	    else if (cr.isUnmappable())
		action = unmappableCharacterAction;
	    else
		assert false : cr.toString();

	    if (action == CodingErrorAction.REPORT)
		return cr;

	    if (action == CodingErrorAction.REPLACE) {
		if (out.remaining() < replacement.length())
=====================================================================
Found a 36 line (146 tokens) duplication in the following files: 
Starting at line 453 of /usr/local/java/src/java/awt/TexturePaintContext.java
Starting at line 573 of /usr/local/java/src/java/awt/TexturePaintContext.java
			if ((xerr += colincxerr) < 0) {
			    xerr &= Integer.MAX_VALUE;
			    x++;
			}
			if ((x += colincx) >= bWidth) {
			    x -= bWidth;
			}
			if ((yerr += colincyerr) < 0) {
			    yerr &= Integer.MAX_VALUE;
			    y++;
			}
			if ((y += colincy) >= bHeight) {
			    y -= bHeight;
			}
		    }
		}
		if ((rowxerr += rowincxerr) < 0) {
		    rowxerr &= Integer.MAX_VALUE;
		    rowx++;
		}
		if ((rowx += rowincx) >= bWidth) {
		    rowx -= bWidth;
		}
		if ((rowyerr += rowincyerr) < 0) {
		    rowyerr &= Integer.MAX_VALUE;
		    rowy++;
		}
		if ((rowy += rowincy) >= bHeight) {
		    rowy -= bHeight;
		}
		out += outSpan;
	    }
	}
    }

    static class ByteFilter extends TexturePaintContext {
=====================================================================
Found a 77 line (145 tokens) duplication in the following files: 
Starting at line 112 of /usr/local/java/src/java/nio/ByteBufferAsIntBufferL.java
Starting at line 112 of /usr/local/java/src/java/nio/ByteBufferAsIntBufferB.java
	Bits.putIntB(bb, ix(checkIndex(i)), x);
	return this;



    }

    public IntBuffer compact() {

	int pos = position();
	int lim = limit();
	assert (pos <= lim);
	int rem = (pos <= lim ? lim - pos : 0);

	ByteBuffer db = bb.duplicate();
 	db.limit(ix(lim));
	db.position(ix(0));
	ByteBuffer sb = db.slice();
	sb.position(pos << 2);
	sb.compact();
 	position(rem);
	limit(capacity());
	return this;



    }

    public boolean isDirect() {
	return bb.isDirect();
    }

    public boolean isReadOnly() {
	return false;
    }







































    public ByteOrder order() {

	return ByteOrder.BIG_ENDIAN;
=====================================================================
Found a 77 line (145 tokens) duplication in the following files: 
Starting at line 112 of /usr/local/java/src/java/nio/ByteBufferAsLongBufferL.java
Starting at line 112 of /usr/local/java/src/java/nio/ByteBufferAsLongBufferB.java
	Bits.putLongB(bb, ix(checkIndex(i)), x);
	return this;



    }

    public LongBuffer compact() {

	int pos = position();
	int lim = limit();
	assert (pos <= lim);
	int rem = (pos <= lim ? lim - pos : 0);

	ByteBuffer db = bb.duplicate();
 	db.limit(ix(lim));
	db.position(ix(0));
	ByteBuffer sb = db.slice();
	sb.position(pos << 3);
	sb.compact();
 	position(rem);
	limit(capacity());
	return this;



    }

    public boolean isDirect() {
	return bb.isDirect();
    }

    public boolean isReadOnly() {
	return false;
    }







































    public ByteOrder order() {

	return ByteOrder.BIG_ENDIAN;
=====================================================================
Found a 77 line (145 tokens) duplication in the following files: 
Starting at line 112 of /usr/local/java/src/java/nio/ByteBufferAsShortBufferL.java
Starting at line 112 of /usr/local/java/src/java/nio/ByteBufferAsShortBufferB.java
	Bits.putShortB(bb, ix(checkIndex(i)), x);
	return this;



    }

    public ShortBuffer compact() {

	int pos = position();
	int lim = limit();
	assert (pos <= lim);
	int rem = (pos <= lim ? lim - pos : 0);

	ByteBuffer db = bb.duplicate();
 	db.limit(ix(lim));
	db.position(ix(0));
	ByteBuffer sb = db.slice();
	sb.position(pos << 1);
	sb.compact();
 	position(rem);
	limit(capacity());
	return this;



    }

    public boolean isDirect() {
	return bb.isDirect();
    }

    public boolean isReadOnly() {
	return false;
    }







































    public ByteOrder order() {

	return ByteOrder.BIG_ENDIAN;
=====================================================================
Found a 77 line (145 tokens) duplication in the following files: 
Starting at line 112 of /usr/local/java/src/java/nio/ByteBufferAsFloatBufferL.java
Starting at line 112 of /usr/local/java/src/java/nio/ByteBufferAsFloatBufferB.java
	Bits.putFloatB(bb, ix(checkIndex(i)), x);
	return this;



    }

    public FloatBuffer compact() {

	int pos = position();
	int lim = limit();
	assert (pos <= lim);
	int rem = (pos <= lim ? lim - pos : 0);

	ByteBuffer db = bb.duplicate();
 	db.limit(ix(lim));
	db.position(ix(0));
	ByteBuffer sb = db.slice();
	sb.position(pos << 2);
	sb.compact();
 	position(rem);
	limit(capacity());
	return this;



    }

    public boolean isDirect() {
	return bb.isDirect();
    }

    public boolean isReadOnly() {
	return false;
    }







































    public ByteOrder order() {

	return ByteOrder.BIG_ENDIAN;
=====================================================================
Found a 80 line (145 tokens) duplication in the following files: 
Starting at line 112 of /usr/local/java/src/java/nio/ByteBufferAsDoubleBufferB.java
Starting at line 112 of /usr/local/java/src/java/nio/ByteBufferAsDoubleBufferL.java
	Bits.putDoubleL(bb, ix(checkIndex(i)), x);
	return this;



    }

    public DoubleBuffer compact() {

	int pos = position();
	int lim = limit();
	assert (pos <= lim);
	int rem = (pos <= lim ? lim - pos : 0);

	ByteBuffer db = bb.duplicate();
 	db.limit(ix(lim));
	db.position(ix(0));
	ByteBuffer sb = db.slice();
	sb.position(pos << 3);
	sb.compact();
 	position(rem);
	limit(capacity());
	return this;



    }

    public boolean isDirect() {
	return bb.isDirect();
    }

    public boolean isReadOnly() {
	return false;
    }







































    public ByteOrder order() {




	return ByteOrder.LITTLE_ENDIAN;
=====================================================================
Found a 43 line (144 tokens) duplication in the following files: 
Starting at line 70 of /usr/local/java/src/java/security/cert/CertPathBuilder.java
Starting at line 70 of /usr/local/java/src/java/security/cert/CertPathValidator.java
    private Provider provider;
    private String algorithm;

    // for use with the reflection API
    private static final Class cl = java.security.Security.class;
    private static final Class[] GET_IMPL_PARAMS = { String.class,
						     String.class,
						     String.class };
    private static final Class[] GET_IMPL_PARAMS2 = { String.class,
						      String.class,
						      Provider.class };
    // Get the implMethod via the name of a provider. Note: the name could
    // be null. 
    private static Method implMethod;
    // Get the implMethod2 via a Provider object. 
    private static Method implMethod2;
    private static Boolean implMethod2Set = new Boolean(false);

    static {
	implMethod = (Method)
	    AccessController.doPrivileged(new PrivilegedAction() {
	    public Object run() {
		Method m = null;
		try {
		    m = cl.getDeclaredMethod("getImpl", GET_IMPL_PARAMS);
		    if (m != null)
			m.setAccessible(true);
		} catch (NoSuchMethodException nsme) {
		}
		return m;
	    }
	});
    }

    /**
     * Creates a <code>CertPathValidator</code> object of the given algorithm, 
     * and encapsulates the given provider implementation (SPI object) in it.
     *
     * @param validatorSpi the provider implementation
     * @param provider the provider
     * @param algorithm the algorithm name
     */
    protected CertPathValidator(CertPathValidatorSpi validatorSpi, 
=====================================================================
Found a 53 line (143 tokens) duplication in the following files: 
Starting at line 474 of /usr/local/java/src/java/util/HashMap.java
Starting at line 470 of /usr/local/java/src/java/util/WeakHashMap.java
            }
        }
    }

    /**
     * Copies all of the mappings from the specified map to this map These
     * mappings will replace any mappings that this map had for any of the
     * keys currently in the specified map.<p>
     *
     * @param m mappings to be stored in this map.
     * @throws  NullPointerException if the specified map is null.
     */
    public void putAll(Map m) {
        int numKeysToBeAdded = m.size();
        if (numKeysToBeAdded == 0)
            return;

        /*
         * Expand the map if the map if the number of mappings to be added
         * is greater than or equal to threshold.  This is conservative; the
         * obvious condition is (m.size() + size) >= threshold, but this
         * condition could result in a map with twice the appropriate capacity,
         * if the keys to be added overlap with the keys already in this map.
         * By using the conservative calculation, we subject ourself
         * to at most one extra resize.
         */
        if (numKeysToBeAdded > threshold) {
            int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1);
            if (targetCapacity > MAXIMUM_CAPACITY)
                targetCapacity = MAXIMUM_CAPACITY;
            int newCapacity = table.length;
            while (newCapacity < targetCapacity)
                newCapacity <<= 1;
            if (newCapacity > table.length)
                resize(newCapacity);
        }

        for (Iterator i = m.entrySet().iterator(); i.hasNext(); ) {
            Map.Entry e = (Map.Entry) i.next();
            put(e.getKey(), e.getValue());
        }
    }
  
    /**
     * Removes the mapping for this key from this map if present.
     *
     * @param key key whose mapping is to be removed from the map.
     * @return previous value associated with specified key, or <tt>null</tt>
     *	       if there was no mapping for key.  A <tt>null</tt> return can
     *	       also indicate that the map previously associated <tt>null</tt>
     *	       with the specified key.
     */
    public Object remove(Object key) {
=====================================================================
Found a 25 line (143 tokens) duplication in the following files: 
Starting at line 97 of /usr/local/java/src/java/awt/image/CropImageFilter.java
Starting at line 136 of /usr/local/java/src/java/awt/image/CropImageFilter.java
			  ColorModel model, int pixels[], int off,
			  int scansize) {
	int x1 = x;
	if (x1 < cropX) {
	    x1 = cropX;
	}
	int x2 = x + w;
	if (x2 > cropX + cropW) {
	    x2 = cropX + cropW;
	}
	int y1 = y;
	if (y1 < cropY) {
	    y1 = cropY;
	}
	int y2 = y + h;
	if (y2 > cropY + cropH) {
	    y2 = cropY + cropH;
	}
	if (x1 >= x2 || y1 >= y2) {
	    return;
	}
	consumer.setPixels(x1 - cropX, y1 - cropY, (x2 - x1), (y2 - y1),
			   model, pixels,
			   off + (y1 - y) * scansize + (x1 - x), scansize);
    }
=====================================================================
Found a 120 line (142 tokens) duplication in the following files: 
Starting at line 406 of /usr/local/java/src/java/awt/MenuItem.java
Starting at line 197 of /usr/local/java/src/java/awt/Button.java
    }

    /**
     * Sets the command name for the action event fired
     * by this button. By default this action command is
     * set to match the label of the button.
     * @param     command  A string used to set the button's
     *                  action command.
     *            If the string is <code>null</code> then the action command
     *            is set to match the label of the button.
     * @see       java.awt.event.ActionEvent
     * @since     JDK1.1
     */
    public void setActionCommand(String command) {
        actionCommand = command;
    }

    /**
     * Returns the command name of the action event fired by this button.
     * If the command name is <code>null</code> (default) then this method
     * returns the label of the button.
     */
    public String getActionCommand() {
        return (actionCommand == null? label : actionCommand);
    }

    /**
     * Adds the specified action listener to receive action events from
     * this button. Action events occur when a user presses or releases
     * the mouse over this button.
     * If l is null, no exception is thrown and no action is performed.
     *
     * @param         l the action listener
     * @see           #removeActionListener
     * @see           #getActionListeners
     * @see           java.awt.event.ActionListener
     * @since         JDK1.1
     */
    public synchronized void addActionListener(ActionListener l) {
	if (l == null) {
	    return;
	}
	actionListener = AWTEventMulticaster.add(actionListener, l);
        newEventsOnly = true;
    }

    /**
     * Removes the specified action listener so that it no longer
     * receives action events from this button. Action events occur
     * when a user presses or releases the mouse over this button.
     * If l is null, no exception is thrown and no action is performed.
     *
     * @param         	l     the action listener
     * @see           	#addActionListener
     * @see           	#getActionListeners
     * @see           	java.awt.event.ActionListener
     * @since         	JDK1.1
     */
    public synchronized void removeActionListener(ActionListener l) {
	if (l == null) {
	    return;
	}
	actionListener = AWTEventMulticaster.remove(actionListener, l);
    }

    /**
     * Returns an array of all the action listeners
     * registered on this button.
     *
     * @return all of this button's <code>ActionListener</code>s
     *         or an empty array if no action 
     *         listeners are currently registered
     *
     * @see	        #addActionListener
     * @see           	#removeActionListener
     * @see           	java.awt.event.ActionListener
     * @since 1.4
     */
    public synchronized ActionListener[] getActionListeners() {
        return (ActionListener[]) (getListeners(ActionListener.class));
    }

    /**
     * Returns an array of all the objects currently registered
     * as <code><em>Foo</em>Listener</code>s
     * upon this <code>Button</code>.
     * <code><em>Foo</em>Listener</code>s are registered using the
     * <code>add<em>Foo</em>Listener</code> method.
     *
     * <p>
     * You can specify the <code>listenerType</code> argument
     * with a class literal, such as
     * <code><em>Foo</em>Listener.class</code>.
     * For example, you can query a
     * <code>Button</code> <code>b</code>
     * for its action listeners with the following code:
     *
     * <pre>ActionListener[] als = (ActionListener[])(b.getListeners(ActionListener.class));</pre>
     *
     * If no such listeners exist, this method returns an empty array.
     *
     * @param listenerType the type of listeners requested; this parameter
     *          should specify an interface that descends from
     *          <code>java.util.EventListener</code>
     * @return an array of all objects registered as
     *          <code><em>Foo</em>Listener</code>s on this button,
     *          or an empty array if no such
     *          listeners have been added
     * @exception ClassCastException if <code>listenerType</code>
     *          doesn't specify a class or interface that implements
     *          <code>java.util.EventListener</code>
     *
     * @see #getActionListeners
     * @since 1.3
     */
    public EventListener[] getListeners(Class listenerType) { 
	EventListener l = null; 
	if  (listenerType == ActionListener.class) { 
	    l = actionListener;
	} else {
=====================================================================
Found a 24 line (142 tokens) duplication in the following files: 
Starting at line 179 of /usr/local/java/src/java/nio/HeapLongBuffer.java
Starting at line 179 of /usr/local/java/src/java/nio/HeapDoubleBuffer.java
Starting at line 179 of /usr/local/java/src/java/nio/HeapIntBuffer.java
Starting at line 179 of /usr/local/java/src/java/nio/HeapByteBuffer.java
Starting at line 179 of /usr/local/java/src/java/nio/HeapFloatBuffer.java
Starting at line 179 of /usr/local/java/src/java/nio/HeapShortBuffer.java
Starting at line 179 of /usr/local/java/src/java/nio/HeapCharBuffer.java
	    HeapCharBuffer sb = (HeapCharBuffer)src;
	    int n = sb.remaining();
	    if (n > remaining())
		throw new BufferOverflowException();
	    System.arraycopy(sb.hb, sb.ix(sb.position()),
			     hb, ix(position()), n);
	    sb.position(sb.position() + n);
	    position(position() + n);
	} else if (src.isDirect()) {
	    int n = src.remaining();
	    if (n > remaining())
		throw new BufferOverflowException();
	    src.get(hb, ix(position()), n);
	    position(position() + n);
	} else {
	    super.put(src);
	}
	return this;



    }

    public CharBuffer compact() {
=====================================================================
Found a 33 line (141 tokens) duplication in the following files: 
Starting at line 4430 of /usr/local/java/src/java/util/regex/Pattern.java
Starting at line 4470 of /usr/local/java/src/java/util/regex/Pattern.java
            return ((lhs.match(matcher, i, seq) && rhs.match(matcher, i, seq))
                && next.match(matcher, matcher.last, seq));
            return false;
        }
        boolean study(TreeInfo info) {
            boolean maxV = info.maxValid;
            boolean detm = info.deterministic;

            int minL = info.minLength;
            int maxL = info.maxLength;
            lhs.study(info);

            int minL2 = info.minLength;
            int maxL2 = info.maxLength;

            info.minLength = minL;
            info.maxLength = maxL;
            rhs.study(info);

            info.minLength = Math.min(minL2, info.minLength);
            info.maxLength = Math.max(maxL2, info.maxLength);
            info.maxValid = maxV;
            info.deterministic = detm;

            return next.study(info);
        }
    }

    /**
     * An object added to the tree when a character class has a range
     * or single subtracted from it.
     */
    static final class Sub extends Add  {
=====================================================================
Found a 31 line (141 tokens) duplication in the following files: 
Starting at line 3706 of /usr/local/java/src/java/util/regex/Pattern.java
Starting at line 3881 of /usr/local/java/src/java/util/regex/Pattern.java
                i = matcher.last;
            }
            return next.match(matcher, i, seq);
        }
        boolean study(TreeInfo info) {
            // Save original info
            int minL = info.minLength;
            int maxL = info.maxLength;
            boolean maxV = info.maxValid;
            boolean detm = info.deterministic;
            info.reset();

            atom.study(info);

            int temp = info.minLength * cmin + minL;
            if (temp < minL) {
                temp = 0xFFFFFFF; // Arbitrary large number
            }
            info.minLength = temp;

            if (maxV & info.maxValid) {
                temp = info.maxLength * cmax + maxL;
                info.maxLength = temp;
                if (temp < maxL) {
                    info.maxValid = false;
                }
            } else {
                info.maxValid = false;
            }

            if (info.deterministic && cmin == cmax) {
=====================================================================
Found a 34 line (140 tokens) duplication in the following files: 
Starting at line 475 of /usr/local/java/src/java/lang/Throwable.java
Starting at line 523 of /usr/local/java/src/java/lang/Throwable.java
    private void printStackTraceAsCause(PrintWriter s,
                                        StackTraceElement[] causedTrace)
    {
        // assert Thread.holdsLock(s);

        // Compute number of frames in common between this and caused
        StackTraceElement[] trace = getOurStackTrace();
        int m = trace.length-1, n = causedTrace.length-1;
        while (m >= 0 && n >=0 && trace[m].equals(causedTrace[n])) {
            m--; n--;
        }
        int framesInCommon = trace.length - 1 - m;

        s.println("Caused by: " + this);
        for (int i=0; i <= m; i++)
            s.println("\tat " + trace[i]);
        if (framesInCommon != 0)
            s.println("\t... " + framesInCommon + " more");

        // Recurse if we have a cause
        Throwable ourCause = getCause();
        if (ourCause != null)
            ourCause.printStackTraceAsCause(s, trace);
    }

    /**
     * Fills in the execution stack trace. This method records within this 
     * <code>Throwable</code> object information about the current state of 
     * the stack frames for the current thread.
     *
     * @return  a reference to this <code>Throwable</code> instance.
     * @see     java.lang.Throwable#printStackTrace()
     */
    public synchronized native Throwable fillInStackTrace();
=====================================================================
Found a 29 line (140 tokens) duplication in the following files: 
Starting at line 678 of /usr/local/java/src/java/util/HashMap.java
Starting at line 655 of /usr/local/java/src/java/util/WeakHashMap.java
            return unmaskNull(get());
        }

        public Object getValue() {
            return value;
        }
    
        public Object setValue(Object newValue) {
            Object oldValue = value;
            value = newValue;
            return oldValue;
        }
    
        public boolean equals(Object o) {
            if (!(o instanceof Map.Entry))
                return false;
            Map.Entry e = (Map.Entry)o;
            Object k1 = getKey();
            Object k2 = e.getKey();
            if (k1 == k2 || (k1 != null && k1.equals(k2))) {
                Object v1 = getValue();
                Object v2 = e.getValue();
                if (v1 == v2 || (v1 != null && v1.equals(v2))) 
                    return true;
            }
            return false;
        }
    
        public int hashCode() {
=====================================================================
Found a 27 line (139 tokens) duplication in the following files: 
Starting at line 112 of /usr/local/java/src/java/io/PipedReader.java
Starting at line 132 of /usr/local/java/src/java/io/PipedInputStream.java
    protected synchronized void receive(int b) throws IOException {
        if (!connected) {
            throw new IOException("Pipe not connected");
        } else if (closedByWriter || closedByReader) {
	    throw new IOException("Pipe closed");
	} else if (readSide != null && !readSide.isAlive()) {
            throw new IOException("Read end dead");
        }

	writeSide = Thread.currentThread();
	while (in == out) {
	    if ((readSide != null) && !readSide.isAlive()) {
		throw new IOException("Pipe broken");
	    }
	    /* full: kick any waiting readers */
	    notifyAll();
	    try {
	        wait(1000);
	    } catch (InterruptedException ex) {
		throw new java.io.InterruptedIOException();
	    }
	}
	if (in < 0) {
	    in = 0;
	    out = 0;
	}
	buffer[in++] = (byte)(b & 0xFF);
=====================================================================
Found a 24 line (139 tokens) duplication in the following files: 
Starting at line 394 of /usr/local/java/src/java/awt/datatransfer/SystemFlavorMap.java
Starting at line 352 of /usr/local/java/src/java/util/Properties.java
        return (slashCount % 2 == 1);
    }

    /*
     * Converts encoded &#92;uxxxx to unicode chars
     * and changes special saved chars to their original forms
     */
    private String loadConvert(String theString) {
        char aChar;
        int len = theString.length();
        StringBuffer outBuffer = new StringBuffer(len);

        for (int x=0; x<len; ) {
            aChar = theString.charAt(x++);
            if (aChar == '\\') {
                aChar = theString.charAt(x++);
                if (aChar == 'u') {
                    // Read the xxxx
                    int value=0;
		    for (int i=0; i<4; i++) {
		        aChar = theString.charAt(x++);
		        switch (aChar) {
		          case '0': case '1': case '2': case '3': case '4':
		          case '5': case '6': case '7': case '8': case '9':
=====================================================================
Found a 30 line (138 tokens) duplication in the following files: 
Starting at line 682 of /usr/local/java/src/java/awt/TexturePaintContext.java
Starting at line 773 of /usr/local/java/src/java/awt/TexturePaintContext.java
		    outRas.setDataElements(i, j, data);
		    if ((xerr += colincxerr) < 0) {
			xerr &= Integer.MAX_VALUE;
			x++;
		    }
		    if ((x += colincx) >= bWidth) {
			x -= bWidth;
		    }
		    if ((yerr += colincyerr) < 0) {
			yerr &= Integer.MAX_VALUE;
			y++;
		    }
		    if ((y += colincy) >= bHeight) {
			y -= bHeight;
		    }
		}
		if ((rowxerr += rowincxerr) < 0) {
		    rowxerr &= Integer.MAX_VALUE;
		    rowx++;
		}
		if ((rowx += rowincx) >= bWidth) {
		    rowx -= bWidth;
		}
		if ((rowyerr += rowincyerr) < 0) {
		    rowyerr &= Integer.MAX_VALUE;
		    rowy++;
		}
		if ((rowy += rowincy) >= bHeight) {
		    rowy -= bHeight;
		}
=====================================================================
Found a 29 line (137 tokens) duplication in the following files: 
Starting at line 74 of /usr/local/java/src/java/security/cert/CertPathBuilder.java
Starting at line 91 of /usr/local/java/src/java/security/cert/CertificateFactory.java
    private static final Class cl = java.security.Security.class;
    private static final Class[] GET_IMPL_PARAMS = { String.class,
						     String.class,
						     String.class };
    private static final Class[] GET_IMPL_PARAMS2 = { String.class,
						      String.class,
						      Provider.class };
    // Get the implMethod via the name of a provider. Note: the name could
    // be null. 
    private static Method implMethod;
    // Get the implMethod2 via a Provider object. 
    private static Method implMethod2;
    private static Boolean implMethod2Set = new Boolean(false);

    static {
	implMethod = (Method)
	    AccessController.doPrivileged(new PrivilegedAction() {
	    public Object run() {
		Method m = null;
		try {
		    m = cl.getDeclaredMethod("getImpl", GET_IMPL_PARAMS);
		    if (m != null)
			m.setAccessible(true);
		} catch (NoSuchMethodException nsme) {
		}
		return m;
	    }
	});
    }
=====================================================================
Found a 31 line (137 tokens) duplication in the following files: 
Starting at line 454 of /usr/local/java/src/java/awt/image/PixelGrabber.java
Starting at line 539 of /usr/local/java/src/java/awt/image/PixelGrabber.java
			  int pixels[], int srcOff, int srcScan) {
	if (srcY < dstY) {
	    int diff = dstY - srcY;
	    if (diff >= srcH) {
		return;
	    }
	    srcOff += srcScan * diff;
	    srcY += diff;
	    srcH -= diff;
	}
	if (srcY + srcH > dstY + dstH) {
	    srcH = (dstY + dstH) - srcY;
	    if (srcH <= 0) {
		return;
	    }
	}
	if (srcX < dstX) {
	    int diff = dstX - srcX;
	    if (diff >= srcW) {
		return;
	    }
	    srcOff += diff;
	    srcX += diff;
	    srcW -= diff;
	}
	if (srcX + srcW > dstX + dstW) {
	    srcW = (dstX + dstW) - srcX;
	    if (srcW <= 0) {
		return;
	    }
	}
=====================================================================
Found a 53 line (137 tokens) duplication in the following files: 
Starting at line 188 of /usr/local/java/src/java/awt/image/LookupOp.java
Starting at line 396 of /usr/local/java/src/java/awt/image/RescaleOp.java
                if (dstNumBands-1 == length || length == 1) {
                    int minx = dstRaster.getMinX();
                    int miny = dstRaster.getMinY();
                    int[] bands = new int[numBands-1];
                    for (int i=0; i < numBands-1; i++) {
                        bands[i] = i;
                    }
                    dstRaster =
                        dstRaster.createWritableChild(minx, miny,
                                                      dstRaster.getWidth(),
                                                      dstRaster.getHeight(),
                                                      minx, miny,
                                                      bands);
                }
            }

            //
            // Call the raster filter method
            //
            filter(srcRaster, dstRaster);
            
        }
        
        if (needToConvert) {
            // ColorModels are not the same
            ColorConvertOp ccop = new ColorConvertOp(hints);
            ccop.filter(dst, origDst);
        }

        return origDst;
    }

    /**
     * Rescales the pixel data in the source Raster.
     * If the destination Raster is null, a new Raster will be created.
     * The source and destination must have the same number of bands.
     * Otherwise, an IllegalArgumentException is thrown.
     * Note that the number of scaling factors/offsets in this object must
     * meet the restrictions stated in the class comments above.
     * Otherwise, an IllegalArgumentException is thrown.
     * @param src the <code>Raster</code> to be filtered
     * @param dst the destination for the filtering operation 
     *            or <code>null</code>
     * @return the filtered <code>WritableRaster</code>.
     * @throws IllegalArgumentException if <code>src</code> and
     *         <code>dst</code> do not have the same number of bands,  
     *         or if the number of scaling factors and offsets in this
     *         <code>RescaleOp</code> do not meet the requirements 
     *         stated in the class comments.
     */
    public final WritableRaster filter (Raster src, WritableRaster dst)  {
        int numBands = src.getNumBands();
        int width  = src.getWidth();
=====================================================================
Found a 13 line (131 tokens) duplication in the following files: 
Starting at line 1125 of /usr/local/java/src/java/awt/geom/Arc2D.java
Starting at line 1166 of /usr/local/java/src/java/awt/geom/Arc2D.java
	if (((x+w) == 0) && ((((getHeight()/2) >= (y-h)) 
                              && ((getHeight()/2) <= y)) 
                             || ((((-1) * (getHeight()/2)) >= (y-h)) 
                                 && (((-1) * (getHeight()/2) <= y))))) {
	  if (containsAngle(Math.PI/2)) {
              return true;
          }
	  if (containsAngle(Math.PI*(3/2))) {
              return true;
          }
	}
	
	yint = Math.abs(Math.sqrt((1-(((x+w)*(x+w))
=====================================================================
Found a 42 line (130 tokens) duplication in the following files: 
Starting at line 907 of /usr/local/java/src/java/io/ObjectOutputStream.java
Starting at line 1153 of /usr/local/java/src/java/io/ObjectInputStream.java
    }

    /**
     * Verifies that this (possibly subclass) instance can be constructed
     * without violating security constraints: the subclass must not override
     * security-sensitive non-final methods, or else the
     * "enableSubclassImplementation" SerializablePermission is checked.
     */
    private void verifySubclass() {
	Class cl = getClass();
	synchronized (subclassAudits) {
	    Boolean result = (Boolean) subclassAudits.get(cl);
	    if (result == null) {
		/*
		 * Note: only new Boolean instances (i.e., not Boolean.TRUE or
		 * Boolean.FALSE) must be used as cache values, otherwise cache
		 * entry will pin associated class.
		 */
		result = new Boolean(auditSubclass(cl));
		subclassAudits.put(cl, result);
	    }
	    if (result.booleanValue()) {
		return;
	    }
	}
	SecurityManager sm = System.getSecurityManager();
	if (sm != null) {
	    sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
	}
    }

    /**
     * Performs reflective checks on given subclass to verify that it doesn't
     * override security-sensitive non-final methods.  Returns true if subclass
     * is "safe", false otherwise.
     */
    private static boolean auditSubclass(final Class subcl) {
	Boolean result = (Boolean) AccessController.doPrivileged(
	    new PrivilegedAction() {
		public Object run() {
		    for (Class cl = subcl;
			 cl != ObjectInputStream.class;
=====================================================================
Found a 77 line (130 tokens) duplication in the following files: 
Starting at line 119 of /usr/local/java/src/java/nio/ByteBufferAsFloatBufferB.java
Starting at line 119 of /usr/local/java/src/java/nio/ByteBufferAsIntBufferB.java
    public IntBuffer compact() {

	int pos = position();
	int lim = limit();
	assert (pos <= lim);
	int rem = (pos <= lim ? lim - pos : 0);

	ByteBuffer db = bb.duplicate();
 	db.limit(ix(lim));
	db.position(ix(0));
	ByteBuffer sb = db.slice();
	sb.position(pos << 2);
	sb.compact();
 	position(rem);
	limit(capacity());
	return this;



    }

    public boolean isDirect() {
	return bb.isDirect();
    }

    public boolean isReadOnly() {
	return false;
    }







































    public ByteOrder order() {

	return ByteOrder.BIG_ENDIAN;




    }

}
=====================================================================
Found a 77 line (130 tokens) duplication in the following files: 
Starting at line 119 of /usr/local/java/src/java/nio/ByteBufferAsDoubleBufferL.java
Starting at line 119 of /usr/local/java/src/java/nio/ByteBufferAsLongBufferL.java
    public LongBuffer compact() {

	int pos = position();
	int lim = limit();
	assert (pos <= lim);
	int rem = (pos <= lim ? lim - pos : 0);

	ByteBuffer db = bb.duplicate();
 	db.limit(ix(lim));
	db.position(ix(0));
	ByteBuffer sb = db.slice();
	sb.position(pos << 3);
	sb.compact();
 	position(rem);
	limit(capacity());
	return this;



    }

    public boolean isDirect() {
	return bb.isDirect();
    }

    public boolean isReadOnly() {
	return false;
    }







































    public ByteOrder order() {




	return ByteOrder.LITTLE_ENDIAN;

    }

}
=====================================================================
Found a 77 line (130 tokens) duplication in the following files: 
Starting at line 119 of /usr/local/java/src/java/nio/ByteBufferAsFloatBufferL.java
Starting at line 119 of /usr/local/java/src/java/nio/ByteBufferAsIntBufferL.java
    public IntBuffer compact() {

	int pos = position();
	int lim = limit();
	assert (pos <= lim);
	int rem = (pos <= lim ? lim - pos : 0);

	ByteBuffer db = bb.duplicate();
 	db.limit(ix(lim));
	db.position(ix(0));
	ByteBuffer sb = db.slice();
	sb.position(pos << 2);
	sb.compact();
 	position(rem);
	limit(capacity());
	return this;



    }

    public boolean isDirect() {
	return bb.isDirect();
    }

    public boolean isReadOnly() {
	return false;
    }







































    public ByteOrder order() {




	return ByteOrder.LITTLE_ENDIAN;

    }

}
=====================================================================
Found a 77 line (130 tokens) duplication in the following files: 
Starting at line 119 of /usr/local/java/src/java/nio/ByteBufferAsDoubleBufferB.java
Starting at line 119 of /usr/local/java/src/java/nio/ByteBufferAsLongBufferB.java
    public LongBuffer compact() {

	int pos = position();
	int lim = limit();
	assert (pos <= lim);
	int rem = (pos <= lim ? lim - pos : 0);

	ByteBuffer db = bb.duplicate();
 	db.limit(ix(lim));
	db.position(ix(0));
	ByteBuffer sb = db.slice();
	sb.position(pos << 3);
	sb.compact();
 	position(rem);
	limit(capacity());
	return this;



    }

    public boolean isDirect() {
	return bb.isDirect();
    }

    public boolean isReadOnly() {
	return false;
    }







































    public ByteOrder order() {

	return ByteOrder.BIG_ENDIAN;




    }

}
=====================================================================
Found a 29 line (129 tokens) duplication in the following files: 
Starting at line 2225 of /usr/local/java/src/java/awt/geom/AffineTransform.java
Starting at line 2338 of /usr/local/java/src/java/awt/geom/AffineTransform.java
			  double[] dstPts, int dstOff,
			  int numPts) {
	double M00, M01, M02, M10, M11, M12;	// For caching
	if (dstPts == srcPts &&
	    dstOff > srcOff && dstOff < srcOff + numPts * 2)
	{
	    // If the arrays overlap partially with the destination higher
	    // than the source and we transform the coordinates normally
	    // we would overwrite some of the later source coordinates
	    // with results of previous transformations.
	    // To get around this we use arraycopy to copy the points
	    // to their final destination with correct overwrite
	    // handling and then transform them in place in the new
	    // safer location.
	    System.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
	    // srcPts = dstPts;		// They are known to be equal.
	    srcOff = dstOff;
	}
	switch (state) {
	default:
	    stateError();
	    /* NOTREACHED */
	case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
	    M00 = m00; M01 = m01; M02 = m02;
	    M10 = m10; M11 = m11; M12 = m12;
	    while (--numPts >= 0) {
		double x = srcPts[srcOff++];
		double y = srcPts[srcOff++];
		dstPts[dstOff++] = M00 * x + M01 * y + M02;
=====================================================================
Found a 4 line (127 tokens) duplication in the following files: 
Starting at line 611 of /usr/local/java/src/java/util/BitSet.java
Starting at line 615 of /usr/local/java/src/java/util/BitSet.java
	6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
	5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
=====================================================================
Found a 16 line (127 tokens) duplication in the following files: 
Starting at line 1098 of /usr/local/java/src/java/util/IdentityHashMap.java
Starting at line 935 of /usr/local/java/src/java/util/WeakHashMap.java
        }

        public Object[] toArray() {
            Collection c = new ArrayList(size());
            for (Iterator i = iterator(); i.hasNext(); )
                c.add(new AbstractMap.SimpleEntry((Map.Entry) i.next()));
            return c.toArray();
        }

        public Object[] toArray(Object a[]) {
            Collection c = new ArrayList(size());
            for (Iterator i = iterator(); i.hasNext(); )
                c.add(new AbstractMap.SimpleEntry((Map.Entry) i.next()));
            return c.toArray(a);
        }
    }
=====================================================================
Found a 39 line (127 tokens) duplication in the following files: 
Starting at line 767 of /usr/local/java/src/java/io/FilePermission.java
Starting at line 1166 of /usr/local/java/src/java/net/SocketPermission.java
    private static final ObjectStreamField[] serialPersistentFields = {
        new ObjectStreamField("permissions", Vector.class),
    };

    /**
     * @serialData "permissions" field (a Vector containing the SocketPermissions).
     */
    /*
     * Writes the contents of the perms field out as a Vector for
     * serialization compatibility with earlier releases.
     */
    private void writeObject(ObjectOutputStream out) throws IOException {
	// Don't call out.defaultWriteObject()

	// Write out Vector
	Vector permissions = new Vector(perms.size());
	permissions.addAll(perms);

        ObjectOutputStream.PutField pfields = out.putFields();
        pfields.put("permissions", permissions);
        out.writeFields();
    }

    /*
     * Reads in a Vector of SocketPermissions and saves them in the perms field.
     */
    private void readObject(ObjectInputStream in) throws IOException, 
    ClassNotFoundException {
	// Don't call in.defaultReadObject()

	// Read in serialized fields
	ObjectInputStream.GetField gfields = in.readFields();

	// Get the one we want
	Vector permissions = (Vector)gfields.get("permissions", null);
	perms = new ArrayList(permissions.size());
	perms.addAll(permissions);
    }
}
=====================================================================
Found a 16 line (127 tokens) duplication in the following files: 
Starting at line 1057 of /usr/local/java/src/java/awt/Color.java
Starting at line 1101 of /usr/local/java/src/java/awt/Color.java
    public float[] getColorComponents(ColorSpace cspace, float[] compArray) {
        if (cs == null) {
            cs = ColorSpace.getInstance(ColorSpace.CS_sRGB);
        }
        float f[];
        if (fvalue == null) {
            f = new float[3];
            f[0] = ((float)getRed())/255f;
            f[1] = ((float)getGreen())/255f;
            f[2] = ((float)getBlue())/255f;
        } else {
            f = fvalue;
        }
        float tmp[] = cs.toCIEXYZ(f);
        float tmpout[] = cspace.fromCIEXYZ(tmp);
        if (compArray == null) {
=====================================================================
Found a 24 line (127 tokens) duplication in the following files: 
Starting at line 613 of /usr/local/java/src/java/awt/image/ColorModel.java
Starting at line 680 of /usr/local/java/src/java/awt/image/ColorModel.java
Starting at line 747 of /usr/local/java/src/java/awt/image/ColorModel.java
Starting at line 810 of /usr/local/java/src/java/awt/image/ColorModel.java
    public int getAlpha(Object inData) {
        int pixel=0,length=0;
        switch (transferType) {
            case DataBuffer.TYPE_BYTE:
               byte bdata[] = (byte[])inData;
               pixel = bdata[0] & 0xff;
               length = bdata.length;
            break;
            case DataBuffer.TYPE_USHORT:
               short sdata[] = (short[])inData;
               pixel = sdata[0] & 0xffff;
               length = sdata.length;
            break;
            case DataBuffer.TYPE_INT:
               int idata[] = (int[])inData;
               pixel = idata[0];
               length = idata.length;
            break;
            default:
               throw new UnsupportedOperationException("This method has not been "+
                   "implemented for transferType " + transferType);
        }
        if (length == 1) {
            return getAlpha(pixel);
=====================================================================
Found a 70 line (127 tokens) duplication in the following files: 
Starting at line 119 of /usr/local/java/src/java/nio/ByteBufferAsIntBufferL.java
Starting at line 119 of /usr/local/java/src/java/nio/ByteBufferAsFloatBufferB.java
    public FloatBuffer compact() {

	int pos = position();
	int lim = limit();
	assert (pos <= lim);
	int rem = (pos <= lim ? lim - pos : 0);

	ByteBuffer db = bb.duplicate();
 	db.limit(ix(lim));
	db.position(ix(0));
	ByteBuffer sb = db.slice();
	sb.position(pos << 2);
	sb.compact();
 	position(rem);
	limit(capacity());
	return this;



    }

    public boolean isDirect() {
	return bb.isDirect();
    }

    public boolean isReadOnly() {
	return false;
    }







































    public ByteOrder order() {

	return ByteOrder.BIG_ENDIAN;
=====================================================================
Found a 70 line (127 tokens) duplication in the following files: 
Starting at line 119 of /usr/local/java/src/java/nio/ByteBufferAsDoubleBufferL.java
Starting at line 119 of /usr/local/java/src/java/nio/ByteBufferAsLongBufferB.java
    public LongBuffer compact() {

	int pos = position();
	int lim = limit();
	assert (pos <= lim);
	int rem = (pos <= lim ? lim - pos : 0);

	ByteBuffer db = bb.duplicate();
 	db.limit(ix(lim));
	db.position(ix(0));
	ByteBuffer sb = db.slice();
	sb.position(pos << 3);
	sb.compact();
 	position(rem);
	limit(capacity());
	return this;



    }

    public boolean isDirect() {
	return bb.isDirect();
    }

    public boolean isReadOnly() {
	return false;
    }







































    public ByteOrder order() {

	return ByteOrder.BIG_ENDIAN;
=====================================================================
Found a 70 line (127 tokens) duplication in the following files: 
Starting at line 119 of /usr/local/java/src/java/nio/ByteBufferAsFloatBufferL.java
Starting at line 119 of /usr/local/java/src/java/nio/ByteBufferAsIntBufferB.java
    public IntBuffer compact() {

	int pos = position();
	int lim = limit();
	assert (pos <= lim);
	int rem = (pos <= lim ? lim - pos : 0);

	ByteBuffer db = bb.duplicate();
 	db.limit(ix(lim));
	db.position(ix(0));
	ByteBuffer sb = db.slice();
	sb.position(pos << 2);
	sb.compact();
 	position(rem);
	limit(capacity());
	return this;



    }

    public boolean isDirect() {
	return bb.isDirect();
    }

    public boolean isReadOnly() {
	return false;
    }







































    public ByteOrder order() {

	return ByteOrder.BIG_ENDIAN;
=====================================================================
Found a 73 line (127 tokens) duplication in the following files: 
Starting at line 119 of /usr/local/java/src/java/nio/ByteBufferAsDoubleBufferB.java
Starting at line 119 of /usr/local/java/src/java/nio/ByteBufferAsLongBufferL.java
    public LongBuffer compact() {

	int pos = position();
	int lim = limit();
	assert (pos <= lim);
	int rem = (pos <= lim ? lim - pos : 0);

	ByteBuffer db = bb.duplicate();
 	db.limit(ix(lim));
	db.position(ix(0));
	ByteBuffer sb = db.slice();
	sb.position(pos << 3);
	sb.compact();
 	position(rem);
	limit(capacity());
	return this;



    }

    public boolean isDirect() {
	return bb.isDirect();
    }

    public boolean isReadOnly() {
	return false;
    }







































    public ByteOrder order() {




	return ByteOrder.LITTLE_ENDIAN;
=====================================================================
Found a 4 line (126 tokens) duplication in the following files: 
Starting at line 619 of /usr/local/java/src/java/util/BitSet.java
Starting at line 623 of /usr/local/java/src/java/util/BitSet.java
	6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
	5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0};
=====================================================================
Found a 25 line (125 tokens) duplication in the following files: 
Starting at line 180 of /usr/local/java/src/java/util/BitSet.java
Starting at line 295 of /usr/local/java/src/java/util/BitSet.java
    public void set(int fromIndex, int toIndex) {
	if (fromIndex < 0)
	    throw new IndexOutOfBoundsException("fromIndex < 0: " + fromIndex);
        if (toIndex < 0)
	    throw new IndexOutOfBoundsException("toIndex < 0: " + toIndex);
        if (fromIndex > toIndex)
	    throw new IndexOutOfBoundsException("fromIndex: " + fromIndex +
                                                " > toIndex: " + toIndex);

        // Increase capacity if necessary
        int endUnitIndex = unitIndex(toIndex);
        int unitsRequired = endUnitIndex + 1;

        if (unitsInUse < unitsRequired) {
            ensureCapacity(unitsRequired);
            unitsInUse = unitsRequired;
        }

        int startUnitIndex = unitIndex(fromIndex);
        long bitMask = 0;
        if (startUnitIndex == endUnitIndex) {
            // Case 1: One word
            bitMask = (1L << (toIndex & BIT_INDEX_MASK)) -
                      (1L << (fromIndex & BIT_INDEX_MASK));
            bits[startUnitIndex] |= bitMask;
=====================================================================
Found a 13 line (125 tokens) duplication in the following files: 
Starting at line 1210 of /usr/local/java/src/java/awt/geom/Arc2D.java
Starting at line 1253 of /usr/local/java/src/java/awt/geom/Arc2D.java
	if (((y-h) == 0) && ((((getWidth()/2) >= x) 
                              && ((getWidth()/2) <= (x+w))) 
                             || ((((-1) * (getWidth()/2)) >= x) 
                                 && (((-1) * (getWidth()/2)) <= (x+w))))) {
	  if (containsAngle(Math.PI)) {
              return true;
          }
	  if (containsAngle(Math.PI*2)) {
              return true;
          }
	}
	
	xint = Math.abs(Math.sqrt((1-(((y-h)*(y-h))
=====================================================================
Found a 44 line (123 tokens) duplication in the following files: 
Starting at line 74 of /usr/local/java/src/java/io/StringBufferInputStream.java
Starting at line 127 of /usr/local/java/src/java/io/ByteArrayInputStream.java
	return (pos < count) ? (buf[pos++] & 0xff) : -1;
    }

    /**
     * Reads up to <code>len</code> bytes of data into an array of bytes 
     * from this input stream. 
     * If <code>pos</code> equals <code>count</code>,
     * then <code>-1</code> is returned to indicate
     * end of file. Otherwise, the  number <code>k</code>
     * of bytes read is equal to the smaller of
     * <code>len</code> and <code>count-pos</code>.
     * If <code>k</code> is positive, then bytes
     * <code>buf[pos]</code> through <code>buf[pos+k-1]</code>
     * are copied into <code>b[off]</code>  through
     * <code>b[off+k-1]</code> in the manner performed
     * by <code>System.arraycopy</code>. The
     * value <code>k</code> is added into <code>pos</code>
     * and <code>k</code> is returned.
     * <p>
     * This <code>read</code> method cannot block. 
     *
     * @param   b     the buffer into which the data is read.
     * @param   off   the start offset of the data.
     * @param   len   the maximum number of bytes read.
     * @return  the total number of bytes read into the buffer, or
     *          <code>-1</code> if there is no more data because the end of
     *          the stream has been reached.
     */
    public synchronized int read(byte b[], int off, int len) {
	if (b == null) {
	    throw new NullPointerException();
	} else if ((off < 0) || (off > b.length) || (len < 0) ||
		   ((off + len) > b.length) || ((off + len) < 0)) {
	    throw new IndexOutOfBoundsException();
	}
	if (pos >= count) {
	    return -1;
	}
	if (pos + len > count) {
	    len = count - pos;
	}
	if (len <= 0) {
	    return 0;
	}
=====================================================================
Found a 54 line (122 tokens) duplication in the following files: 
Starting at line 780 of /usr/local/java/src/java/awt/Rectangle.java
Starting at line 205 of /usr/local/java/src/java/awt/geom/Rectangle2D.java
	    this.height = (float) r.getHeight();
	}

	/**
	 * Determines where the specified float coordinates lie with respect
	 * to this <code>Rectangle2D</code>.
	 * This method computes a binary OR of the appropriate mask values
	 * indicating, for each side of this <code>Rectangle2D</code>, 
         * whether or not the specified coordinates are on the same side
         * of the edge as the rest of this <code>Rectangle2D</code>.
         * @param x,&nbsp;y the specified coordinates
         * @return the logical OR of all appropriate out codes.
	 * @see Rectangle2D#OUT_LEFT
	 * @see Rectangle2D#OUT_TOP
	 * @see Rectangle2D#OUT_RIGHT
	 * @see Rectangle2D#OUT_BOTTOM
	 * @since 1.2
	 */
	public int outcode(double x, double y) {
	    /*
	     * Note on casts to double below.  If the arithmetic of
	     * x+w or y+h is done in float, then some bits may be
	     * lost if the binary exponents of x/y and w/h are not
	     * similar.  By converting to double before the addition
	     * we force the addition to be carried out in double to
	     * avoid rounding error in the comparison.
	     *
	     * See bug 4320890 for problems that this inaccuracy causes.
	     */
	    int out = 0;
	    if (this.width <= 0) {
		out |= OUT_LEFT | OUT_RIGHT;
	    } else if (x < this.x) {
		out |= OUT_LEFT;
	    } else if (x > this.x + (double) this.width) {
		out |= OUT_RIGHT;
	    }
	    if (this.height <= 0) {
		out |= OUT_TOP | OUT_BOTTOM;
	    } else if (y < this.y) {
		out |= OUT_TOP;
	    } else if (y > this.y + (double) this.height) {
		out |= OUT_BOTTOM;
	    }
	    return out;
	}

	/**
	 * Returns the high precision bounding box of this
         * <code>Rectangle2D</code>.
         * @return the bounding box of this <code>Rectangle2D</code>.
	 * @since 1.2
	 */
	public Rectangle2D getBounds2D() {
=====================================================================
Found a 17 line (120 tokens) duplication in the following files: 
Starting at line 230 of /usr/local/java/src/java/net/SocksSocketImpl.java
Starting at line 454 of /usr/local/java/src/java/net/SocksSocketImpl.java
	out.write(addr1);
	String userName = (String) java.security.AccessController.doPrivileged(
               new sun.security.action.GetPropertyAction("user.name"));
	out.write(userName.getBytes());
	out.write(0);
	out.flush();
	byte[] data = new byte[8];
	int n = readSocksReply(in, data);
	if (n != 8)
	    throw new SocketException("Reply from SOCKS server has bad length: " + n);
	if (data[0] != 0 && data[0] != 4)
	    throw new SocketException("Reply from SOCKS server has bad version");
	SocketException ex = null;
	switch (data[1]) {
	case 90:
	    // Success!
	    external_address = new InetSocketAddress(baddr, lport);
=====================================================================
Found a 29 line (120 tokens) duplication in the following files: 
Starting at line 275 of /usr/local/java/src/java/security/cert/CertificateFactory.java
Starting at line 357 of /usr/local/java/src/java/security/cert/CertStore.java
    {
	if (provider == null)
	    throw new IllegalArgumentException("missing provider");

	if (implMethod2Set.booleanValue() == false) {
	    synchronized (implMethod2Set) {
		if (implMethod2Set.booleanValue() == false) {
		    implMethod2 = (Method)
			AccessController.doPrivileged(
					   new PrivilegedAction() {
			    public Object run() {
				Method m = null;
				try {
				    m = cl.getDeclaredMethod("getImpl",
							     GET_IMPL_PARAMS2);
				    if (m != null)
					m.setAccessible(true);
				} catch (NoSuchMethodException nsme) {
				}
				return m;
			    }
			});
		    implMethod2Set = new Boolean(true);
		}		
	    }
	}

	if (implMethod2 == null) {
	    throw new NoSuchAlgorithmException(type + " not found");
=====================================================================
Found a 35 line (120 tokens) duplication in the following files: 
Starting at line 824 of /usr/local/java/src/java/util/WeakHashMap.java
Starting at line 872 of /usr/local/java/src/java/util/WeakHashMap.java
        }

        public void clear() {
            WeakHashMap.this.clear();
        }

        public Object[] toArray() {
            Collection c = new ArrayList(size());
            for (Iterator i = iterator(); i.hasNext(); )
                c.add(i.next());
            return c.toArray();
        }

        public Object[] toArray(Object a[]) {
            Collection c = new ArrayList(size());
            for (Iterator i = iterator(); i.hasNext(); )
                c.add(i.next());
            return c.toArray(a);
        }
    }

    /**
     * Returns a collection view of the mappings contained in this map.  Each
     * element in the returned collection is a <tt>Map.Entry</tt>.  The
     * collection is backed by the map, so changes to the map are reflected in
     * the collection, and vice-versa.  The collection supports element
     * removal, which removes the corresponding mapping from the map, via the
     * <tt>Iterator.remove</tt>, <tt>Collection.remove</tt>,
     * <tt>removeAll</tt>, <tt>retainAll</tt>, and <tt>clear</tt> operations.
     * It does not support the <tt>add</tt> or <tt>addAll</tt> operations.
     *
     * @return a collection view of the mappings contained in this map.
     * @see Map.Entry
     */
    public Set entrySet() {
=====================================================================
Found a 34 line (119 tokens) duplication in the following files: 
Starting at line 234 of /usr/local/java/src/java/security/cert/CertStore.java
Starting at line 395 of /usr/local/java/src/java/security/cert/CertStore.java
						 provider,
						 params
					       } );
	    return new CertStore((CertStoreSpi)objs[0],
				 (Provider)objs[1], type, params);
	} catch (IllegalAccessException iae) {
	    NoSuchAlgorithmException nsae = new
	                   NoSuchAlgorithmException(type + " not found");
	    nsae.initCause(iae);
	    throw nsae;
	} catch (InvocationTargetException ite) {
            Throwable t = ite.getCause();
            if (t != null) {
	        if (t instanceof InvalidAlgorithmParameterException)
	            throw (InvalidAlgorithmParameterException)t;
	        if (t instanceof NoSuchAlgorithmException)
	            throw (NoSuchAlgorithmException)t;
            }
	    NoSuchAlgorithmException nsae = new
	        NoSuchAlgorithmException(type + " not found");
	    nsae.initCause(ite);
	    throw nsae;
	}
    }

    /**
     * Returns the parameters used to initialize this <code>CertStore</code>.
     * Note that the <code>CertStoreParameters</code> object is cloned before 
     * it is returned.
     *
     * @return the parameters used to initialize this <code>CertStore</code>
     * (may be <code>null</code>)
     */
    public final CertStoreParameters getCertStoreParameters() {
=====================================================================
Found a 8 line (119 tokens) duplication in the following files: 
Starting at line 51 of /usr/local/java/src/java/io/Bits.java
Starting at line 62 of /usr/local/java/src/java/io/Bits.java
	long j = ((b[off + 7] & 0xFFL) << 0) +
		 ((b[off + 6] & 0xFFL) << 8) +
		 ((b[off + 5] & 0xFFL) << 16) +
		 ((b[off + 4] & 0xFFL) << 24) +
		 ((b[off + 3] & 0xFFL) << 32) +
		 ((b[off + 2] & 0xFFL) << 40) +
		 ((b[off + 1] & 0xFFL) << 48) +
		 ((b[off + 0] & 0xFFL) << 56);
=====================================================================
Found a 63 line (119 tokens) duplication in the following files: 
Starting at line 648 of /usr/local/java/src/java/awt/Choice.java
Starting at line 585 of /usr/local/java/src/java/awt/Checkbox.java
    private int checkboxSerializedDataVersion = 1;

    /**
     * Writes default serializable fields to stream.  Writes
     * a list of serializable <code>ItemListeners</code>
     * as optional data.  The non-serializable
     * <code>ItemListeners</code> are detected and
     * no attempt is made to serialize them.
     *
     * @param s the <code>ObjectOutputStream</code> to write
     * @serialData <code>null</code> terminated sequence of 0 
     *   or more pairs; the pair consists of a <code>String</code>
     *   and an <code>Object</code>; the <code>String</code> indicates
     *   the type of object and is one of the following:
     *   <code>itemListenerK</code> indicating an
     *     <code>ItemListener</code> object
     *
     * @see AWTEventMulticaster#save(ObjectOutputStream, String, EventListener)
     * @see java.awt.Component#itemListenerK
     * @see #readObject(ObjectInputStream)
     */
    private void writeObject(ObjectOutputStream s)
      throws java.io.IOException
    {
      s.defaultWriteObject();

      AWTEventMulticaster.save(s, itemListenerK, itemListener);
      s.writeObject(null);
    }

    /**
     * Reads the <code>ObjectInputStream</code> and if it
     * isn't <code>null</code> adds a listener to receive
     * item events fired by the <code>Checkbox</code>.
     * Unrecognized keys or values will be ignored.
     *
     * @param s the <code>ObjectInputStream</code> to read
     * @exception HeadlessException if
     *   <code>GraphicsEnvironment.isHeadless</code> returns
     *   <code>true</code>
     * @serial
     * @see #removeItemListener(ItemListener)
     * @see #addItemListener(ItemListener)
     * @see java.awt.GraphicsEnvironment#isHeadless
     * @see #writeObject(ObjectOutputStream)
     */
    private void readObject(ObjectInputStream s)
      throws ClassNotFoundException, IOException, HeadlessException
    {
      GraphicsEnvironment.checkHeadless();
      s.defaultReadObject();

      Object keyOrNull;
      while(null != (keyOrNull = s.readObject())) {
	String key = ((String)keyOrNull).intern();

	if (itemListenerK == key)
	  addItemListener((ItemListener)(s.readObject()));

	else // skip value for unrecognized key
	  s.readObject();
      }
    }
=====================================================================
Found a 32 line (119 tokens) duplication in the following files: 
Starting at line 119 of /usr/local/java/src/java/nio/ByteBufferAsShortBufferL.java
Starting at line 119 of /usr/local/java/src/java/nio/ByteBufferAsCharBufferB.java
    public CharBuffer compact() {

	int pos = position();
	int lim = limit();
	assert (pos <= lim);
	int rem = (pos <= lim ? lim - pos : 0);

	ByteBuffer db = bb.duplicate();
 	db.limit(ix(lim));
	db.position(ix(0));
	ByteBuffer sb = db.slice();
	sb.position(pos << 1);
	sb.compact();
 	position(rem);
	limit(capacity());
	return this;



    }

    public boolean isDirect() {
	return bb.isDirect();
    }

    public boolean isReadOnly() {
	return false;
    }



    public String toString(int start, int end) {
=====================================================================
Found a 57 line (117 tokens) duplication in the following files: 
Starting at line 291 of /usr/local/java/src/java/security/cert/CertPathBuilder.java
Starting at line 293 of /usr/local/java/src/java/security/cert/CertPathValidator.java
	    return new CertPathValidator((CertPathValidatorSpi)objs[0],
				       (Provider)objs[1], algorithm);
	} catch (IllegalAccessException iae) {
	    NoSuchAlgorithmException nsae = new
	                   NoSuchAlgorithmException(algorithm + " not found");
	    nsae.initCause(iae);
	    throw nsae;
	} catch (InvocationTargetException ite) {
            Throwable t = ite.getCause();
            if (t != null && t instanceof NoSuchAlgorithmException)
                throw (NoSuchAlgorithmException)t;
	    NoSuchAlgorithmException nsae = new
	        NoSuchAlgorithmException(algorithm + " not found");
	    nsae.initCause(ite);
	    throw nsae;
	} 
    }

    /**
     * Returns the <code>Provider</code> of this
     * <code>CertPathValidator</code>.
     *
     * @return the <code>Provider</code> of this <code>CertPathValidator</code>
     */
    public final Provider getProvider() {
	return this.provider;
    }

    /**
     * Returns the algorithm name of this <code>CertPathValidator</code>.
     *
     * @return the algorithm name of this <code>CertPathValidator</code>
     */
    public final String getAlgorithm() {
	return this.algorithm;
    }

    /**
     * Validates the specified certification path using the specified 
     * algorithm parameter set. 
     * <p>
     * The <code>CertPath</code> specified must be of a type that is 
     * supported by the validation algorithm, otherwise an
     * <code>InvalidAlgorithmParameterException</code> will be thrown. For 
     * example, a <code>CertPathValidator</code> that implements the PKIX
     * algorithm validates <code>CertPath</code> objects of type X.509.
     *
     * @param certPath the <code>CertPath</code> to be validated
     * @param params the algorithm parameters
     * @return the result of the validation algorithm
     * @exception CertPathValidatorException if the <code>CertPath</code>
     * does not validate
     * @exception InvalidAlgorithmParameterException if the specified 
     * parameters or the type of the specified <code>CertPath</code> are 
     * inappropriate for this <code>CertPathValidator</code>
     */ 
    public final CertPathValidatorResult validate(CertPath certPath, 
=====================================================================
Found a 18 line (117 tokens) duplication in the following files: 
Starting at line 1278 of /usr/local/java/src/java/awt/image/DirectColorModel.java
Starting at line 1296 of /usr/local/java/src/java/awt/image/DirectColorModel.java
                case DataBuffer.TYPE_INT: {
                    for (int y = 0; y < h; y++, rY++) {
                        rX = rminX;
                        for (int x = 0; x < w; x++, rX++) {
                            pixel = raster.getPixel(rX, rY, pixel);
                            normAlpha = pixel[aIdx] * alphaScale;
                            if (normAlpha != 0) {
                                float invAlpha = 1.0f / normAlpha;
                                for (int c=0; c < aIdx; c++) {
                                    pixel[c] = (int) (pixel[c] * invAlpha +
                                                      0.5f);
                                }
                                raster.setPixel(rX, rY, pixel);
                            }
                        }
                    }
                }
                break;
=====================================================================
Found a 15 line (116 tokens) duplication in the following files: 
Starting at line 1514 of /usr/local/java/src/java/awt/image/ComponentColorModel.java
Starting at line 1536 of /usr/local/java/src/java/awt/image/ComponentColorModel.java
                          0xffff) / 65535.0f;
            if (supportsAlpha) {
                alp = (rgb>>24) & 0xff;
                if (nBits[1] == 8) {
                    intpixel[1] = alp;
                } else {
                    intpixel[1] = (int) (alp * (1.0f / 255.0f) *
                                         ((1 << nBits[1]) - 1) + 0.5f);
                }
                if (isAlphaPremultiplied) {
                    gray *= (alp * (1.0f / 255.0f));
                }
            }
            intpixel[0] = (int) (gray * ((1 << nBits[0]) - 1) + 0.5f);
        } else {
=====================================================================
Found a 23 line (115 tokens) duplication in the following files: 
Starting at line 242 of /usr/local/java/src/java/security/cert/CertPathBuilder.java
Starting at line 244 of /usr/local/java/src/java/security/cert/CertPathValidator.java
    public static CertPathValidator getInstance(String algorithm, 
						Provider provider) 
	throws NoSuchAlgorithmException
    {
	if (provider == null)
	    throw new IllegalArgumentException("missing provider");

	if (implMethod2Set.booleanValue() == false) {
	    synchronized (implMethod2Set) {
		if (implMethod2Set.booleanValue() == false) {
		    implMethod2 = (Method)
			AccessController.doPrivileged(
					   new PrivilegedAction() {
			    public Object run() {
				Method m = null;
				try {
				    m = cl.getDeclaredMethod("getImpl",
							     GET_IMPL_PARAMS2);
				    if (m != null)
					m.setAccessible(true);
				} catch (NoSuchMethodException nsme) {
				    if (debug != null)
					debug.println("CertPathValidator." +
=====================================================================
Found a 97 line (115 tokens) duplication in the following files: 
Starting at line 852 of /usr/local/java/src/java/awt/List.java
Starting at line 220 of /usr/local/java/src/java/awt/Button.java
        return (actionCommand == null? label : actionCommand);
    }

    /**
     * Adds the specified action listener to receive action events from
     * this button. Action events occur when a user presses or releases
     * the mouse over this button.
     * If l is null, no exception is thrown and no action is performed.
     *
     * @param         l the action listener
     * @see           #removeActionListener
     * @see           #getActionListeners
     * @see           java.awt.event.ActionListener
     * @since         JDK1.1
     */
    public synchronized void addActionListener(ActionListener l) {
	if (l == null) {
	    return;
	}
	actionListener = AWTEventMulticaster.add(actionListener, l);
        newEventsOnly = true;
    }

    /**
     * Removes the specified action listener so that it no longer
     * receives action events from this button. Action events occur
     * when a user presses or releases the mouse over this button.
     * If l is null, no exception is thrown and no action is performed.
     *
     * @param         	l     the action listener
     * @see           	#addActionListener
     * @see           	#getActionListeners
     * @see           	java.awt.event.ActionListener
     * @since         	JDK1.1
     */
    public synchronized void removeActionListener(ActionListener l) {
	if (l == null) {
	    return;
	}
	actionListener = AWTEventMulticaster.remove(actionListener, l);
    }

    /**
     * Returns an array of all the action listeners
     * registered on this button.
     *
     * @return all of this button's <code>ActionListener</code>s
     *         or an empty array if no action 
     *         listeners are currently registered
     *
     * @see	        #addActionListener
     * @see           	#removeActionListener
     * @see           	java.awt.event.ActionListener
     * @since 1.4
     */
    public synchronized ActionListener[] getActionListeners() {
        return (ActionListener[]) (getListeners(ActionListener.class));
    }

    /**
     * Returns an array of all the objects currently registered
     * as <code><em>Foo</em>Listener</code>s
     * upon this <code>Button</code>.
     * <code><em>Foo</em>Listener</code>s are registered using the
     * <code>add<em>Foo</em>Listener</code> method.
     *
     * <p>
     * You can specify the <code>listenerType</code> argument
     * with a class literal, such as
     * <code><em>Foo</em>Listener.class</code>.
     * For example, you can query a
     * <code>Button</code> <code>b</code>
     * for its action listeners with the following code:
     *
     * <pre>ActionListener[] als = (ActionListener[])(b.getListeners(ActionListener.class));</pre>
     *
     * If no such listeners exist, this method returns an empty array.
     *
     * @param listenerType the type of listeners requested; this parameter
     *          should specify an interface that descends from
     *          <code>java.util.EventListener</code>
     * @return an array of all objects registered as
     *          <code><em>Foo</em>Listener</code>s on this button,
     *          or an empty array if no such
     *          listeners have been added
     * @exception ClassCastException if <code>listenerType</code>
     *          doesn't specify a class or interface that implements
     *          <code>java.util.EventListener</code>
     *
     * @see #getActionListeners
     * @since 1.3
     */
    public EventListener[] getListeners(Class listenerType) { 
	EventListener l = null; 
	if  (listenerType == ActionListener.class) { 
	    l = actionListener;
	} else {
=====================================================================
Found a 14 line (115 tokens) duplication in the following files: 
Starting at line 1152 of /usr/local/java/src/java/awt/geom/Arc2D.java
Starting at line 1195 of /usr/local/java/src/java/awt/geom/Arc2D.java
	if (((x+w) < 0) && (((yint >= (y-h)) && (yint <= y)) 
                            || ((((-1) * yint) >= (y-h)) 
                                && (((-1) * yint) <= y)))) {
            if (containsAngle((((Math.PI) - intersect_angle)/Math.PI) * 180)) {
              return true;
            }
            if (containsAngle(((Math.PI + intersect_angle)/Math.PI) * 180)) {
                return true;
            }
	}
      
      }

      if (((y*y)/((getHeight()/2)*(getHeight()/2)) < 1)) {
=====================================================================
Found a 103 line (115 tokens) duplication in the following files: 
Starting at line 328 of /usr/local/java/src/java/nio/DirectIntBufferU.java
Starting at line 328 of /usr/local/java/src/java/nio/DirectFloatBufferU.java
    public FloatBuffer compact() {

	int pos = position();
	int lim = limit();
	assert (pos <= lim);
	int rem = (pos <= lim ? lim - pos : 0);

 	unsafe.copyMemory(ix(pos), ix(0), rem << 2);
 	position(rem);
	limit(capacity());
	return this;



    }

    public boolean isDirect() {
	return true;
    }

    public boolean isReadOnly() {
	return false;
    }











































    public ByteOrder order() {





	return ((ByteOrder.nativeOrder() != ByteOrder.BIG_ENDIAN)
		? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN);

    }


























}
=====================================================================
Found a 125 line (115 tokens) duplication in the following files: 
Starting at line 64 of /usr/local/java/src/java/nio/ByteBufferAsFloatBufferRL.java
Starting at line 64 of /usr/local/java/src/java/nio/ByteBufferAsFloatBufferRB.java
	return new ByteBufferAsFloatBufferRB(bb,
						    this.markValue(),
						    this.position(),
						    this.limit(),
						    this.capacity(),
						    offset);
    }

    public FloatBuffer asReadOnlyBuffer() {








	return duplicate();

    }

















    public FloatBuffer put(float x) {




	throw new ReadOnlyBufferException();

    }

    public FloatBuffer put(int i, float x) {




	throw new ReadOnlyBufferException();

    }

    public FloatBuffer compact() {
















	throw new ReadOnlyBufferException();

    }

    public boolean isDirect() {
	return bb.isDirect();
    }

    public boolean isReadOnly() {
	return true;
    }







































    public ByteOrder order() {

	return ByteOrder.BIG_ENDIAN;
=====================================================================
Found a 103 line (115 tokens) duplication in the following files: 
Starting at line 328 of /usr/local/java/src/java/nio/DirectLongBufferU.java
Starting at line 328 of /usr/local/java/src/java/nio/DirectDoubleBufferU.java
    public DoubleBuffer compact() {

	int pos = position();
	int lim = limit();
	assert (pos <= lim);
	int rem = (pos <= lim ? lim - pos : 0);

 	unsafe.copyMemory(ix(pos), ix(0), rem << 3);
 	position(rem);
	limit(capacity());
	return this;



    }

    public boolean isDirect() {
	return true;
    }

    public boolean isReadOnly() {
	return false;
    }











































    public ByteOrder order() {





	return ((ByteOrder.nativeOrder() != ByteOrder.BIG_ENDIAN)
		? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN);

    }


























}
=====================================================================
Found a 103 line (115 tokens) duplication in the following files: 
Starting at line 328 of /usr/local/java/src/java/nio/DirectIntBufferS.java
Starting at line 328 of /usr/local/java/src/java/nio/DirectFloatBufferS.java
    public FloatBuffer compact() {

	int pos = position();
	int lim = limit();
	assert (pos <= lim);
	int rem = (pos <= lim ? lim - pos : 0);

 	unsafe.copyMemory(ix(pos), ix(0), rem << 2);
 	position(rem);
	limit(capacity());
	return this;



    }

    public boolean isDirect() {
	return true;
    }

    public boolean isReadOnly() {
	return false;
    }











































    public ByteOrder order() {

	return ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN)
		? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN);





    }


























}
=====================================================================
Found a 103 line (115 tokens) duplication in the following files: 
Starting at line 328 of /usr/local/java/src/java/nio/DirectDoubleBufferS.java
Starting at line 328 of /usr/local/java/src/java/nio/DirectLongBufferS.java
    public LongBuffer compact() {

	int pos = position();
	int lim = limit();
	assert (pos <= lim);
	int rem = (pos <= lim ? lim - pos : 0);

 	unsafe.copyMemory(ix(pos), ix(0), rem << 3);
 	position(rem);
	limit(capacity());
	return this;



    }

    public boolean isDirect() {
	return true;
    }

    public boolean isReadOnly() {
	return false;
    }











































    public ByteOrder order() {

	return ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN)
		? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN);





    }


























}
=====================================================================
Found a 125 line (115 tokens) duplication in the following files: 
Starting at line 64 of /usr/local/java/src/java/nio/ByteBufferAsShortBufferRL.java
Starting at line 64 of /usr/local/java/src/java/nio/ByteBufferAsShortBufferRB.java
	return new ByteBufferAsShortBufferRB(bb,
						    this.markValue(),
						    this.position(),
						    this.limit(),
						    this.capacity(),
						    offset);
    }

    public ShortBuffer asReadOnlyBuffer() {








	return duplicate();

    }

















    public ShortBuffer put(short x) {




	throw new ReadOnlyBufferException();

    }

    public ShortBuffer put(int i, short x) {




	throw new ReadOnlyBufferException();

    }

    public ShortBuffer compact() {
















	throw new ReadOnlyBufferException();

    }

    public boolean isDirect() {
	return bb.isDirect();
    }

    public boolean isReadOnly() {
	return true;
    }







































    public ByteOrder order() {

	return ByteOrder.BIG_ENDIAN;
=====================================================================
Found a 128 line (115 tokens) duplication in the following files: 
Starting at line 64 of /usr/local/java/src/java/nio/ByteBufferAsIntBufferRB.java
Starting at line 64 of /usr/local/java/src/java/nio/ByteBufferAsIntBufferRL.java
	return new ByteBufferAsIntBufferRL(bb,
						    this.markValue(),
						    this.position(),
						    this.limit(),
						    this.capacity(),
						    offset);
    }

    public IntBuffer asReadOnlyBuffer() {








	return duplicate();

    }

















    public IntBuffer put(int x) {




	throw new ReadOnlyBufferException();

    }

    public IntBuffer put(int i, int x) {




	throw new ReadOnlyBufferException();

    }

    public IntBuffer compact() {
















	throw new ReadOnlyBufferException();

    }

    public boolean isDirect() {
	return bb.isDirect();
    }

    public boolean isReadOnly() {
	return true;
    }







































    public ByteOrder order() {




	return ByteOrder.LITTLE_ENDIAN;
=====================================================================
Found a 128 line (115 tokens) duplication in the following files: 
Starting at line 64 of /usr/local/java/src/java/nio/ByteBufferAsDoubleBufferRB.java
Starting at line 64 of /usr/local/java/src/java/nio/ByteBufferAsDoubleBufferRL.java
	return new ByteBufferAsDoubleBufferRL(bb,
						    this.markValue(),
						    this.position(),
						    this.limit(),
						    this.capacity(),
						    offset);
    }

    public DoubleBuffer asReadOnlyBuffer() {








	return duplicate();

    }

















    public DoubleBuffer put(double x) {




	throw new ReadOnlyBufferException();

    }

    public DoubleBuffer put(int i, double x) {




	throw new ReadOnlyBufferException();

    }

    public DoubleBuffer compact() {
















	throw new ReadOnlyBufferException();

    }

    public boolean isDirect() {
	return bb.isDirect();
    }

    public boolean isReadOnly() {
	return true;
    }







































    public ByteOrder order() {




	return ByteOrder.LITTLE_ENDIAN;
=====================================================================
Found a 125 line (115 tokens) duplication in the following files: 
Starting at line 64 of /usr/local/java/src/java/nio/ByteBufferAsLongBufferRL.java
Starting at line 64 of /usr/local/java/src/java/nio/ByteBufferAsLongBufferRB.java
	return new ByteBufferAsLongBufferRB(bb,
						    this.markValue(),
						    this.position(),
						    this.limit(),
						    this.capacity(),
						    offset);
    }

    public LongBuffer asReadOnlyBuffer() {








	return duplicate();

    }

















    public LongBuffer put(long x) {




	throw new ReadOnlyBufferException();

    }

    public LongBuffer put(int i, long x) {




	throw new ReadOnlyBufferException();

    }

    public LongBuffer compact() {
















	throw new ReadOnlyBufferException();

    }

    public boolean isDirect() {
	return bb.isDirect();
    }

    public boolean isReadOnly() {
	return true;
    }







































    public ByteOrder order() {

	return ByteOrder.BIG_ENDIAN;
=====================================================================
Found a 24 line (114 tokens) duplication in the following files: 
Starting at line 227 of /usr/local/java/src/java/lang/Short.java
Starting at line 559 of /usr/local/java/src/java/lang/Long.java
Starting at line 874 of /usr/local/java/src/java/lang/Integer.java
Starting at line 228 of /usr/local/java/src/java/lang/Byte.java
        Byte result;

        // Handle minus sign, if present
        if (nm.startsWith("-")) {
            negative = true;
            index++;
        }

	if (nm.startsWith("0x", index) || nm.startsWith("0X", index)) {
            index += 2;
            radix = 16;
	} else if (nm.startsWith("#", index)) {
	    index++;
            radix = 16;
	} else if (nm.startsWith("0", index) && nm.length() > 1 + index) {
	    index++;
            radix = 8;
	}

        if (nm.startsWith("-", index))
            throw new NumberFormatException("Negative sign in wrong position");

        try {
            result = Byte.valueOf(nm.substring(index), radix);
=====================================================================
Found a 94 line (114 tokens) duplication in the following files: 
Starting at line 853 of /usr/local/java/src/java/awt/List.java
Starting at line 413 of /usr/local/java/src/java/awt/TextField.java
    }

    /**
     * Adds the specified action listener to receive
     * action events from this text field.  
     * If l is null, no exception is thrown and no action is performed.
     *
     * @param      l the action listener.
     * @see        #removeActionListener
     * @see        #getActionListeners
     * @see        java.awt.event.ActionListener
     * @since      JDK1.1
     */
    public synchronized void addActionListener(ActionListener l) {
	if (l == null) {
	    return;
	}
	actionListener = AWTEventMulticaster.add(actionListener, l);
        newEventsOnly = true;
    }

    /**
     * Removes the specified action listener so that it no longer
     * receives action events from this text field.
     * If l is null, no exception is thrown and no action is performed.
     *
     * @param      	l the action listener.
     * @see        	#addActionListener
     * @see        	#getActionListeners
     * @see        	java.awt.event.ActionListener
     * @since      	JDK1.1
     */
    public synchronized void removeActionListener(ActionListener l) {
	if (l == null) {
	    return;
	}
	actionListener = AWTEventMulticaster.remove(actionListener, l);
    }

    /**
     * Returns an array of all the action listeners
     * registered on this textfield.
     *
     * @return all of this textfield's <code>ActionListener</code>s
     *         or an empty array if no action 
     *         listeners are currently registered
     *
     * @see #addActionListener
     * @see #removeActionListener
     * @see	java.awt.event#ActionListener
     * @since 1.4
     */
    public synchronized ActionListener[] getActionListeners() {
        return (ActionListener[])(getListeners(ActionListener.class));
    }

    /**
     * Returns an array of all the objects currently registered
     * as <code><em>Foo</em>Listener</code>s
     * upon this <code>TextField</code>.
     * <code><em>Foo</em>Listener</code>s are registered using the
     * <code>add<em>Foo</em>Listener</code> method.
     *
     * <p>
     * You can specify the <code>listenerType</code> argument
     * with a class literal, such as
     * <code><em>Foo</em>Listener.class</code>.
     * For example, you can query a
     * <code>TextField</code> <code>t</code>
     * for its action listeners with the following code:
     *
     * <pre>ActionListener[] als = (ActionListener[])(t.getListeners(ActionListener.class));</pre>
     *
     * If no such listeners exist, this method returns an empty array.
     *
     * @param listenerType the type of listeners requested; this parameter
     *          should specify an interface that descends from
     *          <code>java.util.EventListener</code>
     * @return an array of all objects registered as
     *          <code><em>Foo</em>Listener</code>s on this textfield,
     *          or an empty array if no such
     *          listeners have been added
     * @exception ClassCastException if <code>listenerType</code>
     *          doesn't specify a class or interface that implements
     *          <code>java.util.EventListener</code>
     *
     * @see #getActionListeners
     * @since 1.3
     */
    public EventListener[] getListeners(Class listenerType) { 
	EventListener l = null; 
	if  (listenerType == ActionListener.class) { 
	    l = actionListener;
	} else {
=====================================================================
Found a 98 line (114 tokens) duplication in the following files: 
Starting at line 852 of /usr/local/java/src/java/awt/List.java
Starting at line 430 of /usr/local/java/src/java/awt/MenuItem.java
        return (actionCommand == null? label : actionCommand);
    }

    /**
     * Adds the specified action listener to receive action events
     * from this menu item.
     * If l is null, no exception is thrown and no action is performed.
     *
     * @param      l the action listener.
     * @see        #removeActionListener
     * @see        #getActionListeners
     * @see        java.awt.event.ActionEvent
     * @see        java.awt.event.ActionListener
     * @since      JDK1.1
     */
    public synchronized void addActionListener(ActionListener l) {
	if (l == null) {
	    return;
	}
	actionListener = AWTEventMulticaster.add(actionListener, l);
        newEventsOnly = true;
    }

    /**
     * Removes the specified action listener so it no longer receives
     * action events from this menu item.
     * If l is null, no exception is thrown and no action is performed.
     *
     * @param      l the action listener.
     * @see        #addActionListener
     * @see        #getActionListeners
     * @see        java.awt.event.ActionEvent
     * @see        java.awt.event.ActionListener
     * @since      JDK1.1
     */
    public synchronized void removeActionListener(ActionListener l) {
	if (l == null) {
	    return;
	}
	actionListener = AWTEventMulticaster.remove(actionListener, l);
    }

    /**
     * Returns an array of all the action listeners
     * registered on this menu item.
     *
     * @return all of this menu item's <code>ActionListener</code>s
     *         or an empty array if no action
     *         listeners are currently registered
     *
     * @see        #addActionListener
     * @see        #removeActionListener
     * @see        java.awt.event.ActionEvent
     * @see        java.awt.event.ActionListener
     * @since 1.4
     */
    public synchronized ActionListener[] getActionListeners() {
        return (ActionListener[])(getListeners(ActionListener.class));
    }

    /**
     * Returns an array of all the objects currently registered
     * as <code><em>Foo</em>Listener</code>s
     * upon this <code>MenuItem</code>.
     * <code><em>Foo</em>Listener</code>s are registered using the
     * <code>add<em>Foo</em>Listener</code> method.
     *
     * <p>
     * You can specify the <code>listenerType</code> argument
     * with a class literal, such as
     * <code><em>Foo</em>Listener.class</code>.
     * For example, you can query a
     * <code>MenuItem</code> <code>m</code>
     * for its action listeners with the following code:
     *
     * <pre>ActionListener[] als = (ActionListener[])(m.getListeners(ActionListener.class));</pre>
     *
     * If no such listeners exist, this method returns an empty array.
     *
     * @param listenerType the type of listeners requested; this parameter
     *          should specify an interface that descends from
     *          <code>java.util.EventListener</code>
     * @return an array of all objects registered as
     *          <code><em>Foo</em>Listener</code>s on this menu item,
     *          or an empty array if no such
     *          listeners have been added
     * @exception ClassCastException if <code>listenerType</code>
     *          doesn't specify a class or interface that implements
     *          <code>java.util.EventListener</code>
     *
     * @see #getActionListeners
     * @since 1.3
     */
    public EventListener[] getListeners(Class listenerType) { 
	EventListener l = null; 
	if  (listenerType == ActionListener.class) { 
	    l = actionListener;
	}
=====================================================================
Found a 97 line (113 tokens) duplication in the following files: 
Starting at line 413 of /usr/local/java/src/java/awt/TextField.java
Starting at line 431 of /usr/local/java/src/java/awt/MenuItem.java
    }

    /**
     * Adds the specified action listener to receive action events
     * from this menu item.
     * If l is null, no exception is thrown and no action is performed.
     *
     * @param      l the action listener.
     * @see        #removeActionListener
     * @see        #getActionListeners
     * @see        java.awt.event.ActionEvent
     * @see        java.awt.event.ActionListener
     * @since      JDK1.1
     */
    public synchronized void addActionListener(ActionListener l) {
	if (l == null) {
	    return;
	}
	actionListener = AWTEventMulticaster.add(actionListener, l);
        newEventsOnly = true;
    }

    /**
     * Removes the specified action listener so it no longer receives
     * action events from this menu item.
     * If l is null, no exception is thrown and no action is performed.
     *
     * @param      l the action listener.
     * @see        #addActionListener
     * @see        #getActionListeners
     * @see        java.awt.event.ActionEvent
     * @see        java.awt.event.ActionListener
     * @since      JDK1.1
     */
    public synchronized void removeActionListener(ActionListener l) {
	if (l == null) {
	    return;
	}
	actionListener = AWTEventMulticaster.remove(actionListener, l);
    }

    /**
     * Returns an array of all the action listeners
     * registered on this menu item.
     *
     * @return all of this menu item's <code>ActionListener</code>s
     *         or an empty array if no action
     *         listeners are currently registered
     *
     * @see        #addActionListener
     * @see        #removeActionListener
     * @see        java.awt.event.ActionEvent
     * @see        java.awt.event.ActionListener
     * @since 1.4
     */
    public synchronized ActionListener[] getActionListeners() {
        return (ActionListener[])(getListeners(ActionListener.class));
    }

    /**
     * Returns an array of all the objects currently registered
     * as <code><em>Foo</em>Listener</code>s
     * upon this <code>MenuItem</code>.
     * <code><em>Foo</em>Listener</code>s are registered using the
     * <code>add<em>Foo</em>Listener</code> method.
     *
     * <p>
     * You can specify the <code>listenerType</code> argument
     * with a class literal, such as
     * <code><em>Foo</em>Listener.class</code>.
     * For example, you can query a
     * <code>MenuItem</code> <code>m</code>
     * for its action listeners with the following code:
     *
     * <pre>ActionListener[] als = (ActionListener[])(m.getListeners(ActionListener.class));</pre>
     *
     * If no such listeners exist, this method returns an empty array.
     *
     * @param listenerType the type of listeners requested; this parameter
     *          should specify an interface that descends from
     *          <code>java.util.EventListener</code>
     * @return an array of all objects registered as
     *          <code><em>Foo</em>Listener</code>s on this menu item,
     *          or an empty array if no such
     *          listeners have been added
     * @exception ClassCastException if <code>listenerType</code>
     *          doesn't specify a class or interface that implements
     *          <code>java.util.EventListener</code>
     *
     * @see #getActionListeners
     * @since 1.3
     */
    public EventListener[] getListeners(Class listenerType) { 
	EventListener l = null; 
	if  (listenerType == ActionListener.class) { 
	    l = actionListener;
	}
=====================================================================
Found a 44 line (112 tokens) duplication in the following files: 
Starting at line 300 of /usr/local/java/src/java/util/zip/Deflater.java
Starting at line 236 of /usr/local/java/src/java/util/zip/Inflater.java
	return inflate(b, 0, b.length);
    }

    /**
     * Returns the ADLER-32 value of the uncompressed data.
     * @return the ADLER-32 value of the uncompressed data
     */
    public synchronized int getAdler() {
	if (strm == 0) {
	    throw new NullPointerException();
	}
	return getAdler(strm);
    }

    /**
     * Returns the total number of bytes input so far.
     * @return the total number of bytes input so far
     */
    public synchronized int getTotalIn() {
	if (strm == 0) {
	    throw new NullPointerException();
	}
	return getTotalIn(strm);
    }

    /**
     * Returns the total number of bytes output so far.
     * @return the total number of bytes output so far
     */
    public synchronized int getTotalOut() {
	if (strm == 0) {
	    throw new NullPointerException();
	}
	return getTotalOut(strm);
    }

    /**
     * Resets inflater so that a new set of input data can be processed.
     */
    public synchronized void reset() {
	if (strm == 0) {
	    throw new NullPointerException();
	}
	reset(strm);
=====================================================================
Found a 34 line (112 tokens) duplication in the following files: 
Starting at line 812 of /usr/local/java/src/java/awt/image/ComponentSampleModel.java
Starting at line 484 of /usr/local/java/src/java/awt/image/BandedSampleModel.java
                                       y*scanlineStride + x + bandOffsets[b]);
	return sample;
    }

    /**
     * Returns the samples in a specified band for the specified rectangle
     * of pixels in an int array, one sample per data array element.
     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * @param x,&nbsp;y The coordinates of the upper left pixel location
     * @param w         The width of the pixel rectangle
     * @param h         The height of the pixel rectangle
     * @param b         The band to return
     * @param iArray    If non-null, returns the samples in this array
     * @param data      The DataBuffer containing the image data
     * @return the samples in the specified band for the pixels within
     * the specified region.
     * @see #setSamples(int, int, int, int, int, int[], DataBuffer)
     */
    public int[] getSamples(int x, int y, int w, int h, int b,
                            int iArray[], DataBuffer data) {
        // Bounds check for 'b' will be performed automatically
        if ((x < 0) || (y < 0) || (x + w > width) || (y + h > height)) {
            throw new ArrayIndexOutOfBoundsException
                ("Coordinate out of bounds!");
        }
        int samples[];
        if (iArray != null) {
           samples = iArray;
        } else {
           samples = new int [w*h];
        }

        int lineOffset = y*scanlineStride + x + bandOffsets[b];
=====================================================================
Found a 21 line (111 tokens) duplication in the following files: 
Starting at line 335 of /usr/local/java/src/java/net/MulticastSocket.java
Starting at line 381 of /usr/local/java/src/java/net/MulticastSocket.java
    public void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf)
	throws IOException {
	if (isClosed())
	    throw new SocketException("Socket is closed");

	if (mcastaddr == null || !(mcastaddr instanceof InetSocketAddress))
	    throw new IllegalArgumentException("Unsupported address type");

	if (oldImpl)
	    throw new UnsupportedOperationException();

	SecurityManager security = System.getSecurityManager();
	if (security != null) {
	    security.checkMulticast(((InetSocketAddress)mcastaddr).getAddress());
	}

	if (!((InetSocketAddress)mcastaddr).getAddress().isMulticastAddress()) {
	    throw new SocketException("Not a multicast address");
	}

	getImpl().leaveGroup(mcastaddr, netIf);
=====================================================================
Found a 14 line (111 tokens) duplication in the following files: 
Starting at line 1826 of /usr/local/java/src/java/awt/image/ColorModel.java
Starting at line 1913 of /usr/local/java/src/java/awt/image/ColorModel.java
            }
        }
        short[] tmp = new short[65536];
        for (int i = 0; i <= 65535; i++) {
            tmp[i] = (short) i;
        }
        ICC_Transform[] transformList = new ICC_Transform[2];
        ICC_ColorSpace lgCS =
            (ICC_ColorSpace) ColorSpace.getInstance(ColorSpace.CS_GRAY);
        transformList[0] = new ICC_Transform (
            lgCS.getProfile(), ICC_Transform.Any, ICC_Transform.In);
        transformList[1] = new ICC_Transform (
            grayCS.getProfile(), ICC_Transform.Any, ICC_Transform.Out);
        ICC_Transform t = new ICC_Transform(transformList);
=====================================================================
Found a 19 line (111 tokens) duplication in the following files: 
Starting at line 1563 of /usr/local/java/src/java/awt/geom/AffineTransform.java
Starting at line 1770 of /usr/local/java/src/java/awt/geom/AffineTransform.java
    public void preConcatenate(AffineTransform Tx) {
	double M0, M1;
	double T00, T01, T10, T11;
	double T02, T12;
	int mystate = state;
	int txstate = Tx.state;
	switch ((txstate << HI_SHIFT) | mystate) {
	case (HI_IDENTITY | APPLY_IDENTITY):
	case (HI_IDENTITY | APPLY_TRANSLATE):
	case (HI_IDENTITY | APPLY_SCALE):
	case (HI_IDENTITY | APPLY_SCALE | APPLY_TRANSLATE):
	case (HI_IDENTITY | APPLY_SHEAR):
	case (HI_IDENTITY | APPLY_SHEAR | APPLY_TRANSLATE):
	case (HI_IDENTITY | APPLY_SHEAR | APPLY_SCALE):
	case (HI_IDENTITY | APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
	    // Tx is IDENTITY...
	    return;

	case (HI_TRANSLATE | APPLY_IDENTITY):
=====================================================================
Found a 19 line (110 tokens) duplication in the following files: 
Starting at line 1993 of /usr/local/java/src/java/lang/String.java
Starting at line 2018 of /usr/local/java/src/java/lang/String.java
                upperChar = Character.toUpperCaseEx(ch);
                if (upperChar == Character.CHAR_ERROR) {
                    upperCharArray = Character.toUpperCaseCharArray(ch);
                    /* Grow result. */
                    int mapLen = upperCharArray.length;
                    char[] result2 = new char[result.length + mapLen - 1];
                    System.arraycopy(result, 0, result2, 0,
                        i + 1 + resultOffset);
                    for (int x=0; x<mapLen; ++x) {
                        result2[i+resultOffset++] = upperCharArray[x];
                    }
                    --resultOffset;
                    result = result2;
                }
                else {
                    result[i+resultOffset] = upperChar;
                }
            }
        }
=====================================================================
Found a 7 line (110 tokens) duplication in the following files: 
Starting at line 237 of /usr/local/java/src/java/text/SentenceBreakData.java
Starting at line 243 of /usr/local/java/src/java/text/SentenceBreakData.java
        (byte)(SI+1),  STOP,

        // 2
        (byte)(SI+2),  (byte)(SI+2),  (byte)(SI+2),  (byte)(SI+2),
        (byte)(SI+2),  (byte)(SI+2),  (byte)(SI+3),  STOP,
        (byte)(SI+2),  (byte)(SI+3),  (byte)(SI+2),  (byte)(SI+2),
        (byte)(SI+2),  STOP,
=====================================================================
Found a 16 line (110 tokens) duplication in the following files: 
Starting at line 1212 of /usr/local/java/src/java/awt/event/KeyEvent.java
Starting at line 503 of /usr/local/java/src/java/awt/event/MouseEvent.java
            buf.append(Toolkit.getProperty("AWT.control", "Ctrl"));
            buf.append("+");
        }
        if ((modifiers & InputEvent.SHIFT_MASK) != 0) {
            buf.append(Toolkit.getProperty("AWT.shift", "Shift"));
            buf.append("+");
        }
        if ((modifiers & InputEvent.ALT_GRAPH_MASK) != 0) {
            buf.append(Toolkit.getProperty("AWT.altGraph", "Alt Graph"));
            buf.append("+");
        }
        if ((modifiers & InputEvent.BUTTON1_MASK) != 0) {
            buf.append(Toolkit.getProperty("AWT.button1", "Button1"));
            buf.append("+");
        }
        if ((modifiers & InputEvent.BUTTON2_MASK) != 0) {
=====================================================================
Found a 15 line (110 tokens) duplication in the following files: 
Starting at line 180 of /usr/local/java/src/java/awt/image/ReplicateScaleFilter.java
Starting at line 221 of /usr/local/java/src/java/awt/image/ReplicateScaleFilter.java
	    outpix = new int[destWidth];
	    outpixbuf = outpix;
	}
	for (int dy = dy1; (sy = srcrows[dy]) < y + h; dy++) {
	    int srcoff = off + scansize * (sy - y);
	    int dx;
	    for (dx = dx1; (sx = srccols[dx]) < x + w; dx++) {
		outpix[dx] = pixels[srcoff + sx - x];
	    }
	    if (dx > dx1) {
		consumer.setPixels(dx1, dy, dx - dx1, 1,
				   model, outpix, dx1, destWidth);
	    }
	}
    }
=====================================================================
Found a 48 line (110 tokens) duplication in the following files: 
Starting at line 313 of /usr/local/java/src/java/nio/channels/DatagramChannel.java
Starting at line 316 of /usr/local/java/src/java/nio/channels/SocketChannel.java
    public abstract boolean finishConnect() throws IOException;


    // -- ByteChannel operations --

    /**
     * @throws  NotYetConnectedException
     *          If this channel is not yet connected
     */
    public abstract int read(ByteBuffer dst) throws IOException;

    /**
     * @throws  NotYetConnectedException
     *          If this channel is not yet connected
     */
    public abstract long read(ByteBuffer[] dsts, int offset, int length)
	throws IOException;

    /**
     * @throws  NotYetConnectedException
     *          If this channel is not yet connected
     */
    public final long read(ByteBuffer[] dsts) throws IOException {
	return read(dsts, 0, dsts.length);
    }

    /**
     * @throws  NotYetConnectedException
     *          If this channel is not yet connected
     */
    public abstract int write(ByteBuffer src) throws IOException;

    /**
     * @throws  NotYetConnectedException
     *          If this channel is not yet connected
     */
    public abstract long write(ByteBuffer[] srcs, int offset, int length)
	throws IOException;

    /**
     * @throws  NotYetConnectedException
     *          If this channel is not yet connected
     */
    public final long write(ByteBuffer[] srcs) throws IOException {
	return write(srcs, 0, srcs.length);
    }

}
=====================================================================
Found a 12 line (109 tokens) duplication in the following files: 
Starting at line 1239 of /usr/local/java/src/java/awt/geom/Arc2D.java
Starting at line 1281 of /usr/local/java/src/java/awt/geom/Arc2D.java
	if (((y-h) < 0) && (((xint >= x) && (xint <= (x+w))) 
                            || ((((-1) * xint) >= x) 
                                && (((-1) * xint) <= (x+w))))) {
	  if (containsAngle(((Math.PI*2) - intersect_angle)/Math.PI * 180)) {
              return true;
          }
	  if (containsAngle((Math.PI + intersect_angle)/Math.PI * 180)) {
              return true;
          }
	}
      
      }
=====================================================================
Found a 28 line (109 tokens) duplication in the following files: 
Starting at line 350 of /usr/local/java/src/java/beans/PropertyChangeSupport.java
Starting at line 337 of /usr/local/java/src/java/beans/VetoableChangeSupport.java
	    VetoableChangeSupport child = (VetoableChangeSupport)children.get(propertyName);
	    if (child != null && child.listeners != null) {
		return !child.listeners.isEmpty();
	    }
	}
	return false;
    }

    /**
     * @serialData Null terminated list of <code>VetoableChangeListeners</code>.
     * <p>
     * At serialization time we skip non-serializable listeners and
     * only serialize the serializable listeners.
     *
     */

    private void writeObject(ObjectOutputStream s) throws IOException {
        s.defaultWriteObject();

	java.util.Vector v = null;
	synchronized (this) {
	    if (listeners != null) {
	        v = (java.util.Vector) listeners.clone();
            }
	}

	if (v != null) {
	    for(int i = 0; i < v.size(); i++) {
=====================================================================
Found a 38 line (108 tokens) duplication in the following files: 
Starting at line 205 of /usr/local/java/src/java/security/cert/CertPathBuilder.java
Starting at line 207 of /usr/local/java/src/java/security/cert/CertPathValidator.java
	    return new CertPathValidator((CertPathValidatorSpi)objs[0],
				       (Provider)objs[1], algorithm);
	} catch (IllegalAccessException iae) {
	    NoSuchAlgorithmException nsae = new
		  NoSuchAlgorithmException(algorithm + " not found");
	    nsae.initCause(iae);
	    throw nsae;
	} catch (InvocationTargetException ite) {
	    Throwable t = ite.getTargetException();
	    if (t != null) {
		if (t instanceof NoSuchProviderException)
		    throw (NoSuchProviderException)t;
                if (t instanceof NoSuchAlgorithmException)
                    throw (NoSuchAlgorithmException)t;
            }
	    NoSuchAlgorithmException nsae = new
	        NoSuchAlgorithmException(algorithm + " not found");
	    nsae.initCause(ite);
	    throw nsae;
	} 
    }

    /**
     * Returns a <code>CertPathValidator</code> object that implements the
     * specified algorithm, as supplied by the specified provider.
     * Note: the <code>provider</code> doesn't have to be registered.
     *
     * @param algorithm the name of the requested 
     * <code>CertPathValidator</code> algorithm
     * @param provider the provider
     * @return a <code>CertPathValidator</code> object that implements the
     * specified algorithm, as supplied by the specified provider
     * @exception NoSuchAlgorithmException if the requested algorithm
     * is not available from the specified provider
     * @exception IllegalArgumentException if the <code>provider</code> is
     * null
     */
    public static CertPathValidator getInstance(String algorithm, 
=====================================================================
Found a 18 line (107 tokens) duplication in the following files: 
Starting at line 1246 of /usr/local/java/src/java/awt/image/ComponentColorModel.java
Starting at line 1554 of /usr/local/java/src/java/awt/image/ComponentColorModel.java
            norm[0] = red * factor;
            norm[1] = grn * factor;
            norm[2] = blu * factor;
            norm = colorSpace.fromRGB(norm);
            if (nonStdScale) {
                for (int i = 0; i < numColorComponents; i++) {
                    norm[i] = (norm[i] - compOffset[i]) *
                              compScale[i];
                    // REMIND: need to analyze whether this
                    // clamping is necessary
                    if (norm[i] < 0.0f) {
                        norm[i] = 0.0f;
                    }
                    if (norm[i] > 1.0f) {
                        norm[i] = 1.0f;
                    }
                }
            }
=====================================================================
Found a 18 line (107 tokens) duplication in the following files: 
Starting at line 171 of /usr/local/java/src/java/awt/image/LookupOp.java
Starting at line 379 of /usr/local/java/src/java/awt/image/RescaleOp.java
                if (numBands-1 == length || length == 1) {
                    int minx = srcRaster.getMinX();
                    int miny = srcRaster.getMinY();
                    int[] bands = new int[numBands-1];
                    for (int i=0; i < numBands-1; i++) {
                        bands[i] = i;
                    }
                    srcRaster =
                        srcRaster.createWritableChild(minx, miny,
                                                      srcRaster.getWidth(),
                                                      srcRaster.getHeight(),
                                                      minx, miny,
                                                      bands);
                }
            }
            if (dstCM.hasAlpha()) {
                int dstNumBands = dstRaster.getNumBands();
                if (dstNumBands-1 == length || length == 1) {
=====================================================================
Found a 31 line (106 tokens) duplication in the following files: 
Starting at line 700 of /usr/local/java/src/java/awt/image/ComponentSampleModel.java
Starting at line 439 of /usr/local/java/src/java/awt/image/SinglePixelPackedSampleModel.java
	}
	return pixels;
    }

    /**
     * Returns all samples for the specified rectangle of pixels in
     * an int array, one sample per array element.
     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * @param x 	The X coordinate of the upper left pixel location.
     * @param y 	The Y coordinate of the upper left pixel location.
     * @param w 	The width of the pixel rectangle.
     * @param h 	The height of the pixel rectangle.
     * @param iArray    If non-null, returns the samples in this array.
     * @param data 	The DataBuffer containing the image data.
     * @return all samples for the specified region of pixels.
     * @see #setPixels(int, int, int, int, int[], DataBuffer)
     */
    public int[] getPixels(int x, int y, int w, int h,
                           int iArray[], DataBuffer data) {
        if ((x < 0) || (y < 0) || (x + w > width) || (y + h > height)) {
            throw new ArrayIndexOutOfBoundsException
                ("Coordinate out of bounds!");
        }
        int pixels[];
        if (iArray != null) {
           pixels = iArray;
        } else {
           pixels = new int [w*h*numBands];
        }
        int lineOffset = y*scanlineStride + x;
=====================================================================
Found a 17 line (106 tokens) duplication in the following files: 
Starting at line 303 of /usr/local/java/src/java/awt/GridLayout.java
Starting at line 352 of /usr/local/java/src/java/awt/GridLayout.java
    public Dimension minimumLayoutSize(Container parent) {
      synchronized (parent.getTreeLock()) {
        Insets insets = parent.getInsets();
	int ncomponents = parent.getComponentCount();
	int nrows = rows;
	int ncols = cols;

	if (nrows > 0) {
	    ncols = (ncomponents + nrows - 1) / nrows;
	} else {
	    nrows = (ncomponents + ncols - 1) / ncols;
	}
	int w = 0;
	int h = 0;
	for (int i = 0 ; i < ncomponents ; i++) {
	    Component comp = parent.getComponent(i);
	    Dimension d = comp.getMinimumSize();
=====================================================================
Found a 68 line (106 tokens) duplication in the following files: 
Starting at line 332 of /usr/local/java/src/java/nio/channels/DatagramChannel.java
Starting at line 156 of /usr/local/java/src/java/nio/channels/FileChannel.java
    public abstract int read(ByteBuffer dst) throws IOException;

    /**
     * Reads a sequence of bytes from this channel into a subsequence of the
     * given buffers.
     *
     * <p> Bytes are read starting at this channel's current file position, and
     * then the file position is updated with the number of bytes actually
     * read.  Otherwise this method behaves exactly as specified in the {@link
     * ScatteringByteChannel} interface.  </p>
     */
    public abstract long read(ByteBuffer[] dsts, int offset, int length)
	throws IOException;

    /**
     * Reads a sequence of bytes from this channel into the given buffers.
     *
     * <p> Bytes are read starting at this channel's current file position, and
     * then the file position is updated with the number of bytes actually
     * read.  Otherwise this method behaves exactly as specified in the {@link
     * ScatteringByteChannel} interface.  </p>
     */
    public final long read(ByteBuffer[] dsts) throws IOException {
	return read(dsts, 0, dsts.length);
    }

    /**
     * Writes a sequence of bytes to this channel from the given buffer.
     *
     * <p> Bytes are written starting at this channel's current file position
     * unless the channel is in append mode, in which case the position is
     * first advanced to the end of the file.  The file is grown, if necessary,
     * to accomodate the written bytes, and then the file position is updated
     * with the number of bytes actually written.  Otherwise this method
     * behaves exactly as specified by the {@link WritableByteChannel}
     * interface. </p>
     */ 
    public abstract int write(ByteBuffer src) throws IOException;

    /**
     * Writes a sequence of bytes to this channel from a subsequence of the
     * given buffers.
     *
     * <p> Bytes are written starting at this channel's current file position
     * unless the channel is in append mode, in which case the position is
     * first advanced to the end of the file.  The file is grown, if necessary,
     * to accomodate the written bytes, and then the file position is updated
     * with the number of bytes actually written.  Otherwise this method
     * behaves exactly as specified in the {@link GatheringByteChannel}
     * interface.  </p>
     */ 
    public abstract long write(ByteBuffer[] srcs, int offset, int length)
	throws IOException;

    /**
     * Writes a sequence of bytes to this channel from the given buffers.
     *
     * <p> Bytes are written starting at this channel's current file position
     * unless the channel is in append mode, in which case the position is
     * first advanced to the end of the file.  The file is grown, if necessary,
     * to accomodate the written bytes, and then the file position is updated
     * with the number of bytes actually written.  Otherwise this method
     * behaves exactly as specified in the {@link GatheringByteChannel}
     * interface.  </p>
     */ 
    public final long write(ByteBuffer[] srcs) throws IOException {
	return write(srcs, 0, srcs.length);
    }
=====================================================================
Found a 16 line (105 tokens) duplication in the following files: 
Starting at line 1798 of /usr/local/java/src/java/net/URI.java
Starting at line 1894 of /usr/local/java/src/java/net/URI.java
                    sb.append(userInfo);
                    sb.append('@');
                }
                boolean needBrackets = ((host.indexOf(':') >= 0)
                                    && !host.startsWith("[")
                                    && !host.endsWith("]"));
                if (needBrackets) sb.append('[');
                sb.append(host);
                if (needBrackets) sb.append(']');
                if (port != -1) {
                    sb.append(':');
                    sb.append(port);
                }
            } else if (authority != null) {
                sb.append("//");
                sb.append(authority);
=====================================================================
Found a 26 line (105 tokens) duplication in the following files: 
Starting at line 909 of /usr/local/java/src/java/awt/Container.java
Starting at line 946 of /usr/local/java/src/java/awt/Container.java
        synchronized (getTreeLock()) {
	    int listeners = 0;
	    switch (id) {
	      case HierarchyEvent.HIERARCHY_CHANGED:
		listeners = listeningChildren;
	        break;
	      case HierarchyEvent.ANCESTOR_MOVED:
	      case HierarchyEvent.ANCESTOR_RESIZED:
		if (dbg.on) {
		    dbg.assertion(changeFlags == 0);
		}
		listeners = listeningBoundsChildren;
	        break;
	      default:
		if (dbg.on) {
		    dbg.assertion(false);
		}
	        break;
	    }

            if (enabledOnToolkit) {
                listeners = descendantsCount;
            }
	  
	    for (int count = listeners, i = 0; count > 0; i++) {
	        count -= component[i].createHierarchyEvents(id, this, parent,
=====================================================================
Found a 19 line (105 tokens) duplication in the following files: 
Starting at line 124 of /usr/local/java/src/java/awt/geom/ArcIterator.java
Starting at line 193 of /usr/local/java/src/java/awt/geom/ArcIterator.java
	    coords[1] = y;
	    if (affine != null) {
		affine.transform(coords, 0, coords, 0, 1);
	    }
	    return SEG_LINETO;
	}
	double increment = angExtDeg;
	if (increment > 360.0) {
	    increment = 360.0;
	} else if (increment < -360.0) {
	    increment = -360.0;
	}
	increment /= arcSegs;
	increment = Math.toRadians(increment);
	angle += increment * (index - 1);
	double relx = Math.cos(angle);
	double rely = Math.sin(angle);
	double z = btan(increment);
	coords[0] = x + (relx - z * rely) * w;
=====================================================================
Found a 32 line (104 tokens) duplication in the following files: 
Starting at line 815 of /usr/local/java/src/java/awt/image/ComponentSampleModel.java
Starting at line 506 of /usr/local/java/src/java/awt/image/SinglePixelPackedSampleModel.java
    }

    /**
     * Returns the samples for a specified band for the specified rectangle
     * of pixels in an int array, one sample per array element.
     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * @param x 	The X coordinate of the upper left pixel location.
     * @param y 	The Y coordinate of the upper left pixel location.
     * @param w 	The width of the pixel rectangle.
     * @param h 	The height of the pixel rectangle.
     * @param b 	The band to return.
     * @param iArray    If non-null, returns the samples in this array.
     * @param data 	The DataBuffer containing the image data.
     * @return the samples for the specified band for the specified
     *         region of pixels.
     * @see #setSamples(int, int, int, int, int, int[], DataBuffer)
     */
    public int[] getSamples(int x, int y, int w, int h, int b,
			   int iArray[], DataBuffer data) {
        // Bounds check for 'b' will be performed automatically
        if ((x < 0) || (y < 0) || (x + w > width) || (y + h > height)) {
            throw new ArrayIndexOutOfBoundsException
                ("Coordinate out of bounds!");
        }
        int samples[];
        if (iArray != null) {
           samples = iArray;
        } else {
           samples = new int [w*h];
        }
        int lineOffset = y*scanlineStride + x;
=====================================================================
Found a 27 line (104 tokens) duplication in the following files: 
Starting at line 697 of /usr/local/java/src/java/awt/image/ComponentSampleModel.java
Starting at line 368 of /usr/local/java/src/java/awt/image/BandedSampleModel.java
        for (int i=0; i<numBands; i++) {
            pixels[i] = data.getElem(bankIndices[i],
                                     pixelOffset + bandOffsets[i]);
        }
        return pixels;
    }

    /**
     * Returns all samples for the specified rectangle of pixels in
     * an int array, one sample per data array element.
     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * @param x,&nbsp;y The coordinates of the upper left pixel location
     * @param w         The width of the pixel rectangle
     * @param h         The height of the pixel rectangle
     * @param iArray    If non-null, returns the samples in this array
     * @param data      The DataBuffer containing the image data
     * @return the samples for the pixels within the specified region.
     * @see #setPixels(int, int, int, int, int[], DataBuffer)
     */
    public int[] getPixels(int x, int y, int w, int h,
                           int iArray[], DataBuffer data) {
        if ((x < 0) || (y < 0) || (x + w > width) || (y + h > height)) {
            throw new ArrayIndexOutOfBoundsException
                ("Coordinate out of bounds!");
        }
        int[] pixels;
=====================================================================
Found a 21 line (103 tokens) duplication in the following files: 
Starting at line 359 of /usr/local/java/src/java/lang/CharacterData.java
Starting at line 207 of /usr/local/java/src/java/lang/CharacterDataLatin1.java
        }
        return directionality;
    }

    static boolean isMirrored(char ch) {
        return (getProperties(ch) & 0x80000000) != 0;
    }

    static char toUpperCaseEx(char ch) {
        char mapChar = ch;
        int val = getProperties(ch);

        if ((val & 0x00010000) != 0) {
            if ((val & 0x07FC0000) != 0x07FC0000) {
                int offset = val  << 5 >> (5+18);
                mapChar =  (char)(ch - offset);
            }
            else {
                switch(ch) {
                    // map overflow characters
                    case '\u00B5' : mapChar = '\u039C'; break;
=====================================================================
Found a 3 line (103 tokens) duplication in the following files: 
Starting at line 197 of /usr/local/java/src/java/util/prefs/Base64.java
Starting at line 211 of /usr/local/java/src/java/util/prefs/Base64.java
    private static final byte altBase64ToInt[] = {
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1,
=====================================================================
Found a 13 line (102 tokens) duplication in the following files: 
Starting at line 154 of /usr/local/java/src/java/io/InputStream.java
Starting at line 263 of /usr/local/java/src/java/io/PipedInputStream.java
    public synchronized int read(byte b[], int off, int len)  throws IOException {
	if (b == null) {
	    throw new NullPointerException();
	} else if ((off < 0) || (off > b.length) || (len < 0) ||
		   ((off + len) > b.length) || ((off + len) < 0)) {
	    throw new IndexOutOfBoundsException();
	} else if (len == 0) {
	    return 0;
	}

        /* possibly wait on the first character */
	int c = read();
	if (c < 0) {
=====================================================================
Found a 29 line (102 tokens) duplication in the following files: 
Starting at line 658 of /usr/local/java/src/java/awt/image/ComponentSampleModel.java
Starting at line 331 of /usr/local/java/src/java/awt/image/BandedSampleModel.java
	    for (int i=0; i<numDataElems; i++) {
		ddata[i] = data.getElemDouble(bankIndices[i],
                                              pixelOffset + bandOffsets[i]);
	    }

	    obj = (Object)ddata;
	    break;
	}

	return obj;
    }

    /**
     * Returns all samples for the specified pixel in an int array.
     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * @param x,&nbsp;y The coordinates of the pixel location
     * @param iArray    If non-null, returns the samples in this array
     * @param data      The DataBuffer containing the image data 
     * @return the samples for the specified pixel.
     * @see #setPixel(int, int, int[], DataBuffer)
     */
    public int[] getPixel(int x, int y, int iArray[], DataBuffer data) {
        if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {
            throw new ArrayIndexOutOfBoundsException
                ("Coordinate out of bounds!");
        }

        int[] pixels;
=====================================================================
Found a 20 line (101 tokens) duplication in the following files: 
Starting at line 481 of /usr/local/java/src/java/awt/image/DirectColorModel.java
Starting at line 534 of /usr/local/java/src/java/awt/image/DirectColorModel.java
Starting at line 587 of /usr/local/java/src/java/awt/image/DirectColorModel.java
Starting at line 637 of /usr/local/java/src/java/awt/image/DirectColorModel.java
Starting at line 685 of /usr/local/java/src/java/awt/image/DirectColorModel.java
    public int getRGB(Object inData) {
        int pixel=0;
        switch (transferType) {
            case DataBuffer.TYPE_BYTE:
               byte bdata[] = (byte[])inData;
               pixel = bdata[0] & 0xff;
            break;
            case DataBuffer.TYPE_USHORT:
               short sdata[] = (short[])inData;
               pixel = sdata[0] & 0xffff;
            break;
            case DataBuffer.TYPE_INT:
               int idata[] = (int[])inData;
               pixel = idata[0];
            break;
            default:
               throw new UnsupportedOperationException("This method has not been "+
                   "implemented for transferType " + transferType);
        }
        return getRGB(pixel);
=====================================================================
Found a 19 line (101 tokens) duplication in the following files: 
Starting at line 1014 of /usr/local/java/src/java/awt/image/IndexColorModel.java
Starting at line 963 of /usr/local/java/src/java/awt/image/DirectColorModel.java
        switch (transferType) {
     	    case DataBuffer.TYPE_BYTE:
               byte bdata[] = (byte[])pixel;
               intpixel = bdata[0] & 0xff;
            break;
            case DataBuffer.TYPE_USHORT:
               short sdata[] = (short[])pixel;
               intpixel = sdata[0] & 0xffff;
            break;
            case DataBuffer.TYPE_INT:
               int idata[] = (int[])pixel;
               intpixel = idata[0];
            break;
            default:
               throw new UnsupportedOperationException("This method has not been "+
                   "implemented for transferType " + transferType);
        }
        return getComponents(intpixel, components, offset);
    }
=====================================================================
Found a 44 line (101 tokens) duplication in the following files: 
Starting at line 333 of /usr/local/java/src/java/awt/image/PackedColorModel.java
Starting at line 2874 of /usr/local/java/src/java/awt/image/ComponentColorModel.java
        }
        
        return true;
    }
    
    /**
     * Returns a <CODE>Raster</CODE> representing the alpha channel of an image,
     * extracted from the input <CODE>Raster</CODE>.
     * This method assumes that <CODE>Raster</CODE> objects associated with 
     * this <CODE>ColorModel</CODE> store the alpha band, if present, as 
     * the last band of image data. Returns null if there is no separate spatial 
     * alpha channel associated with this <CODE>ColorModel</CODE>.
     * This method creates a new <CODE>Raster</CODE>, but will share the data
     * array.
     *
     * @param raster The <CODE>WritableRaster</CODE> from which to extract the 
     * alpha  channel.
     *
     * @return A <CODE>WritableRaster</CODE> containing the image's alpha channel.
     *
     */
    public WritableRaster getAlphaRaster(WritableRaster raster) {
        if (hasAlpha() == false) {
            return null;
        }
        
        int x = raster.getMinX();
        int y = raster.getMinY();
        int[] band = new int[1];
        band[0] = raster.getNumBands() - 1;
        return raster.createWritableChild(x, y, raster.getWidth(),
                                          raster.getHeight(), x, y,
                                          band);
    }
    
    /**
     * Compares this color model with another for equality.  
     *
     * @param obj The object to compare with this color model.
     * @return <CODE>true</CODE> if the color model objects are equal, 
     * <CODE>false</CODE> if they are not.
     */
    public boolean equals(Object obj) {
        if (!super.equals(obj)) {
=====================================================================
Found a 5 line (100 tokens) duplication in the following files: 
Starting at line 254 of /usr/local/java/src/java/lang/Integer.java
Starting at line 259 of /usr/local/java/src/java/lang/Integer.java
	'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
	'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
	'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
	'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
	'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
=====================================================================
Found a 26 line (100 tokens) duplication in the following files: 
Starting at line 153 of /usr/local/java/src/java/security/cert/CertPathValidator.java
Starting at line 292 of /usr/local/java/src/java/security/cert/CertPathValidator.java
					       } );
	    return new CertPathValidator((CertPathValidatorSpi)objs[0],
				       (Provider)objs[1], algorithm);
	} catch (IllegalAccessException iae) {
	    NoSuchAlgorithmException nsae = new
	                   NoSuchAlgorithmException(algorithm + " not found");
	    nsae.initCause(iae);
	    throw nsae;
	} catch (InvocationTargetException ite) {
            Throwable t = ite.getCause();
            if (t != null && t instanceof NoSuchAlgorithmException)
                throw (NoSuchAlgorithmException)t;
	    NoSuchAlgorithmException nsae = new
	        NoSuchAlgorithmException(algorithm + " not found");
	    nsae.initCause(ite);
	    throw nsae;
	} 
    }

    /**
     * Returns the <code>Provider</code> of this
     * <code>CertPathValidator</code>.
     *
     * @return the <code>Provider</code> of this <code>CertPathValidator</code>
     */
    public final Provider getProvider() {
=====================================================================
Found a 25 line (100 tokens) duplication in the following files: 
Starting at line 153 of /usr/local/java/src/java/security/cert/CertPathBuilder.java
Starting at line 290 of /usr/local/java/src/java/security/cert/CertPathBuilder.java
					       } );
	    return new CertPathBuilder((CertPathBuilderSpi)objs[0],
				       (Provider)objs[1], algorithm);
	} catch (IllegalAccessException iae) {
	    NoSuchAlgorithmException nsae = new 
                           NoSuchAlgorithmException(algorithm + " not found");
	    nsae.initCause(iae);
	    throw nsae;
	} catch (InvocationTargetException ite) {
            Throwable t = ite.getCause();
            if (t != null && t instanceof NoSuchAlgorithmException)
                throw (NoSuchAlgorithmException)t;
	    NoSuchAlgorithmException nsae = new
                NoSuchAlgorithmException(algorithm + " not found");
	    nsae.initCause(ite);
	    throw nsae;
	}
    }

    /**
     * Returns the provider of this <code>CertPathBuilder</code>.
     *
     * @return the provider of this <code>CertPathBuilder</code>
     */
    public final Provider getProvider() {
=====================================================================
Found a 28 line (100 tokens) duplication in the following files: 
Starting at line 350 of /usr/local/java/src/java/awt/Container.java
Starting at line 593 of /usr/local/java/src/java/awt/Container.java
    protected void addImpl(Component comp, Object constraints, int index) {
	synchronized (getTreeLock()) {
	    /* Check for correct arguments:  index in bounds,
	     * comp cannot be one of this container's parents,
	     * and comp cannot be a window.
	     * comp and container must be on the same GraphicsDevice.
	     * if comp is container, all sub-components must be on
	     * same GraphicsDevice.
	     */
	    GraphicsConfiguration thisGC = this.getGraphicsConfiguration();

	    if (index > ncomponents || (index < 0 && index != -1)) {
		throw new IllegalArgumentException(
			  "illegal component position");
	    }
        if (comp instanceof Container) {
            for (Container cn = this; cn != null; cn=cn.parent) {
                if (cn == comp) {
                throw new IllegalArgumentException(
                      "adding container's parent to itself");
                }
            }
            if (comp instanceof Window) {
                throw new IllegalArgumentException(
                       "adding a window to a container");
            }
        }
        if (thisGC != null) {

